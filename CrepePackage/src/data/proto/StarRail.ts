/* eslint-disable */
import Long from "long";
import * as _m0 from "protobufjs/minimal";

export const protobufPackage = "CrepeSR.Proto";

export enum AccountType {
  ACCOUNT_MIHOYO_GUEST = 0,
  ACCOUNT_MIHOYO = 1,
  ACCOUNT_XIAOMI = 11,
  ACCOUNT_COOLPAD = 12,
  ACCOUNT_YYB = 13,
  ACCOUNT_BILI = 14,
  ACCOUNT_HUAWEI = 15,
  ACCOUNT_MEIZU = 16,
  ACCOUNT_360 = 17,
  ACCOUNT_OPPO = 18,
  ACCOUNT_VIVO = 19,
  ACCOUNT_UC = 20,
  ACCOUNT_WANDOJIA = 21,
  ACCOUNT_LENOVO = 22,
  ACCOUNT_JINLI = 23,
  ACCOUNT_BAIDU = 25,
  ACCOUNT_DANGLE = 26,
  ACCOUNT_WEGAME = 27,
  ACCOUNT_RPG_CUSTOM = 10000,
  UNRECOGNIZED = -1,
}

export function accountTypeFromJSON(object: any): AccountType {
  switch (object) {
    case 0:
    case "ACCOUNT_MIHOYO_GUEST":
      return AccountType.ACCOUNT_MIHOYO_GUEST;
    case 1:
    case "ACCOUNT_MIHOYO":
      return AccountType.ACCOUNT_MIHOYO;
    case 11:
    case "ACCOUNT_XIAOMI":
      return AccountType.ACCOUNT_XIAOMI;
    case 12:
    case "ACCOUNT_COOLPAD":
      return AccountType.ACCOUNT_COOLPAD;
    case 13:
    case "ACCOUNT_YYB":
      return AccountType.ACCOUNT_YYB;
    case 14:
    case "ACCOUNT_BILI":
      return AccountType.ACCOUNT_BILI;
    case 15:
    case "ACCOUNT_HUAWEI":
      return AccountType.ACCOUNT_HUAWEI;
    case 16:
    case "ACCOUNT_MEIZU":
      return AccountType.ACCOUNT_MEIZU;
    case 17:
    case "ACCOUNT_360":
      return AccountType.ACCOUNT_360;
    case 18:
    case "ACCOUNT_OPPO":
      return AccountType.ACCOUNT_OPPO;
    case 19:
    case "ACCOUNT_VIVO":
      return AccountType.ACCOUNT_VIVO;
    case 20:
    case "ACCOUNT_UC":
      return AccountType.ACCOUNT_UC;
    case 21:
    case "ACCOUNT_WANDOJIA":
      return AccountType.ACCOUNT_WANDOJIA;
    case 22:
    case "ACCOUNT_LENOVO":
      return AccountType.ACCOUNT_LENOVO;
    case 23:
    case "ACCOUNT_JINLI":
      return AccountType.ACCOUNT_JINLI;
    case 25:
    case "ACCOUNT_BAIDU":
      return AccountType.ACCOUNT_BAIDU;
    case 26:
    case "ACCOUNT_DANGLE":
      return AccountType.ACCOUNT_DANGLE;
    case 27:
    case "ACCOUNT_WEGAME":
      return AccountType.ACCOUNT_WEGAME;
    case 10000:
    case "ACCOUNT_RPG_CUSTOM":
      return AccountType.ACCOUNT_RPG_CUSTOM;
    case -1:
    case "UNRECOGNIZED":
    default:
      return AccountType.UNRECOGNIZED;
  }
}

export function accountTypeToJSON(object: AccountType): string {
  switch (object) {
    case AccountType.ACCOUNT_MIHOYO_GUEST:
      return "ACCOUNT_MIHOYO_GUEST";
    case AccountType.ACCOUNT_MIHOYO:
      return "ACCOUNT_MIHOYO";
    case AccountType.ACCOUNT_XIAOMI:
      return "ACCOUNT_XIAOMI";
    case AccountType.ACCOUNT_COOLPAD:
      return "ACCOUNT_COOLPAD";
    case AccountType.ACCOUNT_YYB:
      return "ACCOUNT_YYB";
    case AccountType.ACCOUNT_BILI:
      return "ACCOUNT_BILI";
    case AccountType.ACCOUNT_HUAWEI:
      return "ACCOUNT_HUAWEI";
    case AccountType.ACCOUNT_MEIZU:
      return "ACCOUNT_MEIZU";
    case AccountType.ACCOUNT_360:
      return "ACCOUNT_360";
    case AccountType.ACCOUNT_OPPO:
      return "ACCOUNT_OPPO";
    case AccountType.ACCOUNT_VIVO:
      return "ACCOUNT_VIVO";
    case AccountType.ACCOUNT_UC:
      return "ACCOUNT_UC";
    case AccountType.ACCOUNT_WANDOJIA:
      return "ACCOUNT_WANDOJIA";
    case AccountType.ACCOUNT_LENOVO:
      return "ACCOUNT_LENOVO";
    case AccountType.ACCOUNT_JINLI:
      return "ACCOUNT_JINLI";
    case AccountType.ACCOUNT_BAIDU:
      return "ACCOUNT_BAIDU";
    case AccountType.ACCOUNT_DANGLE:
      return "ACCOUNT_DANGLE";
    case AccountType.ACCOUNT_WEGAME:
      return "ACCOUNT_WEGAME";
    case AccountType.ACCOUNT_RPG_CUSTOM:
      return "ACCOUNT_RPG_CUSTOM";
    case AccountType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum ChannelIdType {
  CHANNEL_ID_NONE = 0,
  CHANNEL_ID_MIHOYO = 1,
  CHANNEL_ID_XIAOMI = 11,
  CHANNEL_ID_COOLPAD = 12,
  CHANNEL_ID_YYB = 13,
  CHANNEL_ID_BILI = 14,
  CHANNEL_ID_HUAWEI = 15,
  CHANNEL_ID_MEIZU = 16,
  CHANNEL_ID_360 = 17,
  CHANNEL_ID_OPPO = 18,
  CHANNEL_ID_VIVO = 19,
  CHANNEL_ID_UC = 20,
  CHANNEL_ID_WANDOJIA = 21,
  CHANNEL_ID_LENOVO = 22,
  CHANNEL_ID_JINLI = 23,
  CHANNEL_ID_BAIDU = 25,
  CHANNEL_ID_DANGLE = 26,
  CHANNEL_ID_WEGAME = 27,
  UNRECOGNIZED = -1,
}

export function channelIdTypeFromJSON(object: any): ChannelIdType {
  switch (object) {
    case 0:
    case "CHANNEL_ID_NONE":
      return ChannelIdType.CHANNEL_ID_NONE;
    case 1:
    case "CHANNEL_ID_MIHOYO":
      return ChannelIdType.CHANNEL_ID_MIHOYO;
    case 11:
    case "CHANNEL_ID_XIAOMI":
      return ChannelIdType.CHANNEL_ID_XIAOMI;
    case 12:
    case "CHANNEL_ID_COOLPAD":
      return ChannelIdType.CHANNEL_ID_COOLPAD;
    case 13:
    case "CHANNEL_ID_YYB":
      return ChannelIdType.CHANNEL_ID_YYB;
    case 14:
    case "CHANNEL_ID_BILI":
      return ChannelIdType.CHANNEL_ID_BILI;
    case 15:
    case "CHANNEL_ID_HUAWEI":
      return ChannelIdType.CHANNEL_ID_HUAWEI;
    case 16:
    case "CHANNEL_ID_MEIZU":
      return ChannelIdType.CHANNEL_ID_MEIZU;
    case 17:
    case "CHANNEL_ID_360":
      return ChannelIdType.CHANNEL_ID_360;
    case 18:
    case "CHANNEL_ID_OPPO":
      return ChannelIdType.CHANNEL_ID_OPPO;
    case 19:
    case "CHANNEL_ID_VIVO":
      return ChannelIdType.CHANNEL_ID_VIVO;
    case 20:
    case "CHANNEL_ID_UC":
      return ChannelIdType.CHANNEL_ID_UC;
    case 21:
    case "CHANNEL_ID_WANDOJIA":
      return ChannelIdType.CHANNEL_ID_WANDOJIA;
    case 22:
    case "CHANNEL_ID_LENOVO":
      return ChannelIdType.CHANNEL_ID_LENOVO;
    case 23:
    case "CHANNEL_ID_JINLI":
      return ChannelIdType.CHANNEL_ID_JINLI;
    case 25:
    case "CHANNEL_ID_BAIDU":
      return ChannelIdType.CHANNEL_ID_BAIDU;
    case 26:
    case "CHANNEL_ID_DANGLE":
      return ChannelIdType.CHANNEL_ID_DANGLE;
    case 27:
    case "CHANNEL_ID_WEGAME":
      return ChannelIdType.CHANNEL_ID_WEGAME;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ChannelIdType.UNRECOGNIZED;
  }
}

export function channelIdTypeToJSON(object: ChannelIdType): string {
  switch (object) {
    case ChannelIdType.CHANNEL_ID_NONE:
      return "CHANNEL_ID_NONE";
    case ChannelIdType.CHANNEL_ID_MIHOYO:
      return "CHANNEL_ID_MIHOYO";
    case ChannelIdType.CHANNEL_ID_XIAOMI:
      return "CHANNEL_ID_XIAOMI";
    case ChannelIdType.CHANNEL_ID_COOLPAD:
      return "CHANNEL_ID_COOLPAD";
    case ChannelIdType.CHANNEL_ID_YYB:
      return "CHANNEL_ID_YYB";
    case ChannelIdType.CHANNEL_ID_BILI:
      return "CHANNEL_ID_BILI";
    case ChannelIdType.CHANNEL_ID_HUAWEI:
      return "CHANNEL_ID_HUAWEI";
    case ChannelIdType.CHANNEL_ID_MEIZU:
      return "CHANNEL_ID_MEIZU";
    case ChannelIdType.CHANNEL_ID_360:
      return "CHANNEL_ID_360";
    case ChannelIdType.CHANNEL_ID_OPPO:
      return "CHANNEL_ID_OPPO";
    case ChannelIdType.CHANNEL_ID_VIVO:
      return "CHANNEL_ID_VIVO";
    case ChannelIdType.CHANNEL_ID_UC:
      return "CHANNEL_ID_UC";
    case ChannelIdType.CHANNEL_ID_WANDOJIA:
      return "CHANNEL_ID_WANDOJIA";
    case ChannelIdType.CHANNEL_ID_LENOVO:
      return "CHANNEL_ID_LENOVO";
    case ChannelIdType.CHANNEL_ID_JINLI:
      return "CHANNEL_ID_JINLI";
    case ChannelIdType.CHANNEL_ID_BAIDU:
      return "CHANNEL_ID_BAIDU";
    case ChannelIdType.CHANNEL_ID_DANGLE:
      return "CHANNEL_ID_DANGLE";
    case ChannelIdType.CHANNEL_ID_WEGAME:
      return "CHANNEL_ID_WEGAME";
    case ChannelIdType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum AvatarSlotType {
  AVATAR_SLOT_1 = 0,
  AVATAR_SLOT_2 = 1,
  AVATAR_SLOT_3 = 2,
  UNRECOGNIZED = -1,
}

export function avatarSlotTypeFromJSON(object: any): AvatarSlotType {
  switch (object) {
    case 0:
    case "AVATAR_SLOT_1":
      return AvatarSlotType.AVATAR_SLOT_1;
    case 1:
    case "AVATAR_SLOT_2":
      return AvatarSlotType.AVATAR_SLOT_2;
    case 2:
    case "AVATAR_SLOT_3":
      return AvatarSlotType.AVATAR_SLOT_3;
    case -1:
    case "UNRECOGNIZED":
    default:
      return AvatarSlotType.UNRECOGNIZED;
  }
}

export function avatarSlotTypeToJSON(object: AvatarSlotType): string {
  switch (object) {
    case AvatarSlotType.AVATAR_SLOT_1:
      return "AVATAR_SLOT_1";
    case AvatarSlotType.AVATAR_SLOT_2:
      return "AVATAR_SLOT_2";
    case AvatarSlotType.AVATAR_SLOT_3:
      return "AVATAR_SLOT_3";
    case AvatarSlotType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum ItemType {
  ITEM_TYPE_NONE = 0,
  ITEM_AVATAR_CARD = 1,
  ITEM_EQUIPMENT = 2,
  ITEM_MATERIAL = 3,
  ITEM_AVATAR_EXP = 4,
  ITEM_RELIC = 5,
  UNRECOGNIZED = -1,
}

export function itemTypeFromJSON(object: any): ItemType {
  switch (object) {
    case 0:
    case "ITEM_TYPE_NONE":
      return ItemType.ITEM_TYPE_NONE;
    case 1:
    case "ITEM_AVATAR_CARD":
      return ItemType.ITEM_AVATAR_CARD;
    case 2:
    case "ITEM_EQUIPMENT":
      return ItemType.ITEM_EQUIPMENT;
    case 3:
    case "ITEM_MATERIAL":
      return ItemType.ITEM_MATERIAL;
    case 4:
    case "ITEM_AVATAR_EXP":
      return ItemType.ITEM_AVATAR_EXP;
    case 5:
    case "ITEM_RELIC":
      return ItemType.ITEM_RELIC;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ItemType.UNRECOGNIZED;
  }
}

export function itemTypeToJSON(object: ItemType): string {
  switch (object) {
    case ItemType.ITEM_TYPE_NONE:
      return "ITEM_TYPE_NONE";
    case ItemType.ITEM_AVATAR_CARD:
      return "ITEM_AVATAR_CARD";
    case ItemType.ITEM_EQUIPMENT:
      return "ITEM_EQUIPMENT";
    case ItemType.ITEM_MATERIAL:
      return "ITEM_MATERIAL";
    case ItemType.ITEM_AVATAR_EXP:
      return "ITEM_AVATAR_EXP";
    case ItemType.ITEM_RELIC:
      return "ITEM_RELIC";
    case ItemType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum VirtualItemType {
  VIRTUAL_ITEM_NONE = 0,
  VIRTUAL_ITEM_HCOIN = 1,
  VIRTUAL_ITEM_SCOIN = 2,
  VIRTUAL_ITEM_MCOIN = 3,
  VIRTUAL_ITEM_STAMINA = 11,
  VIRTUAL_ITEM_EXP = 22,
  VIRTUAL_ITEM_ROGUE_COIN = 31,
  VIRTUAL_ITEM_ROGUE_STAMINA = 32,
  VIRTUAL_ITEM_ROGUE_EXPLORE_EXP = 33,
  VIRTUAL_ITEM_ACHIEVEMENT_EXP = 41,
  VIRTUAL_ITEM_WARRIOR_EXP = 190,
  VIRTUAL_ITEM_ROGUE_EXP = 191,
  VIRTUAL_ITEM_MAGE_EXP = 192,
  VIRTUAL_ITEM_SHAMAN_EXP = 193,
  VIRTUAL_ITEM_WARLOCK_EXP = 194,
  VIRTUAL_ITEM_KNIGHT_EXP = 195,
  VIRTUAL_ITEM_PRIEST_EXP = 196,
  UNRECOGNIZED = -1,
}

export function virtualItemTypeFromJSON(object: any): VirtualItemType {
  switch (object) {
    case 0:
    case "VIRTUAL_ITEM_NONE":
      return VirtualItemType.VIRTUAL_ITEM_NONE;
    case 1:
    case "VIRTUAL_ITEM_HCOIN":
      return VirtualItemType.VIRTUAL_ITEM_HCOIN;
    case 2:
    case "VIRTUAL_ITEM_SCOIN":
      return VirtualItemType.VIRTUAL_ITEM_SCOIN;
    case 3:
    case "VIRTUAL_ITEM_MCOIN":
      return VirtualItemType.VIRTUAL_ITEM_MCOIN;
    case 11:
    case "VIRTUAL_ITEM_STAMINA":
      return VirtualItemType.VIRTUAL_ITEM_STAMINA;
    case 22:
    case "VIRTUAL_ITEM_EXP":
      return VirtualItemType.VIRTUAL_ITEM_EXP;
    case 31:
    case "VIRTUAL_ITEM_ROGUE_COIN":
      return VirtualItemType.VIRTUAL_ITEM_ROGUE_COIN;
    case 32:
    case "VIRTUAL_ITEM_ROGUE_STAMINA":
      return VirtualItemType.VIRTUAL_ITEM_ROGUE_STAMINA;
    case 33:
    case "VIRTUAL_ITEM_ROGUE_EXPLORE_EXP":
      return VirtualItemType.VIRTUAL_ITEM_ROGUE_EXPLORE_EXP;
    case 41:
    case "VIRTUAL_ITEM_ACHIEVEMENT_EXP":
      return VirtualItemType.VIRTUAL_ITEM_ACHIEVEMENT_EXP;
    case 190:
    case "VIRTUAL_ITEM_WARRIOR_EXP":
      return VirtualItemType.VIRTUAL_ITEM_WARRIOR_EXP;
    case 191:
    case "VIRTUAL_ITEM_ROGUE_EXP":
      return VirtualItemType.VIRTUAL_ITEM_ROGUE_EXP;
    case 192:
    case "VIRTUAL_ITEM_MAGE_EXP":
      return VirtualItemType.VIRTUAL_ITEM_MAGE_EXP;
    case 193:
    case "VIRTUAL_ITEM_SHAMAN_EXP":
      return VirtualItemType.VIRTUAL_ITEM_SHAMAN_EXP;
    case 194:
    case "VIRTUAL_ITEM_WARLOCK_EXP":
      return VirtualItemType.VIRTUAL_ITEM_WARLOCK_EXP;
    case 195:
    case "VIRTUAL_ITEM_KNIGHT_EXP":
      return VirtualItemType.VIRTUAL_ITEM_KNIGHT_EXP;
    case 196:
    case "VIRTUAL_ITEM_PRIEST_EXP":
      return VirtualItemType.VIRTUAL_ITEM_PRIEST_EXP;
    case -1:
    case "UNRECOGNIZED":
    default:
      return VirtualItemType.UNRECOGNIZED;
  }
}

export function virtualItemTypeToJSON(object: VirtualItemType): string {
  switch (object) {
    case VirtualItemType.VIRTUAL_ITEM_NONE:
      return "VIRTUAL_ITEM_NONE";
    case VirtualItemType.VIRTUAL_ITEM_HCOIN:
      return "VIRTUAL_ITEM_HCOIN";
    case VirtualItemType.VIRTUAL_ITEM_SCOIN:
      return "VIRTUAL_ITEM_SCOIN";
    case VirtualItemType.VIRTUAL_ITEM_MCOIN:
      return "VIRTUAL_ITEM_MCOIN";
    case VirtualItemType.VIRTUAL_ITEM_STAMINA:
      return "VIRTUAL_ITEM_STAMINA";
    case VirtualItemType.VIRTUAL_ITEM_EXP:
      return "VIRTUAL_ITEM_EXP";
    case VirtualItemType.VIRTUAL_ITEM_ROGUE_COIN:
      return "VIRTUAL_ITEM_ROGUE_COIN";
    case VirtualItemType.VIRTUAL_ITEM_ROGUE_STAMINA:
      return "VIRTUAL_ITEM_ROGUE_STAMINA";
    case VirtualItemType.VIRTUAL_ITEM_ROGUE_EXPLORE_EXP:
      return "VIRTUAL_ITEM_ROGUE_EXPLORE_EXP";
    case VirtualItemType.VIRTUAL_ITEM_ACHIEVEMENT_EXP:
      return "VIRTUAL_ITEM_ACHIEVEMENT_EXP";
    case VirtualItemType.VIRTUAL_ITEM_WARRIOR_EXP:
      return "VIRTUAL_ITEM_WARRIOR_EXP";
    case VirtualItemType.VIRTUAL_ITEM_ROGUE_EXP:
      return "VIRTUAL_ITEM_ROGUE_EXP";
    case VirtualItemType.VIRTUAL_ITEM_MAGE_EXP:
      return "VIRTUAL_ITEM_MAGE_EXP";
    case VirtualItemType.VIRTUAL_ITEM_SHAMAN_EXP:
      return "VIRTUAL_ITEM_SHAMAN_EXP";
    case VirtualItemType.VIRTUAL_ITEM_WARLOCK_EXP:
      return "VIRTUAL_ITEM_WARLOCK_EXP";
    case VirtualItemType.VIRTUAL_ITEM_KNIGHT_EXP:
      return "VIRTUAL_ITEM_KNIGHT_EXP";
    case VirtualItemType.VIRTUAL_ITEM_PRIEST_EXP:
      return "VIRTUAL_ITEM_PRIEST_EXP";
    case VirtualItemType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum BlackLimitLevel {
  BLACK_LIMIT_LEVEL_ALL = 0,
  UNRECOGNIZED = -1,
}

export function blackLimitLevelFromJSON(object: any): BlackLimitLevel {
  switch (object) {
    case 0:
    case "BLACK_LIMIT_LEVEL_ALL":
      return BlackLimitLevel.BLACK_LIMIT_LEVEL_ALL;
    case -1:
    case "UNRECOGNIZED":
    default:
      return BlackLimitLevel.UNRECOGNIZED;
  }
}

export function blackLimitLevelToJSON(object: BlackLimitLevel): string {
  switch (object) {
    case BlackLimitLevel.BLACK_LIMIT_LEVEL_ALL:
      return "BLACK_LIMIT_LEVEL_ALL";
    case BlackLimitLevel.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum AreaType {
  AREA_NONE = 0,
  AREA_CN = 1,
  AREA_JP = 2,
  AREA_ASIA = 3,
  AREA_WEST = 4,
  AREA_KR = 5,
  AREA_OVERSEAS = 6,
  UNRECOGNIZED = -1,
}

export function areaTypeFromJSON(object: any): AreaType {
  switch (object) {
    case 0:
    case "AREA_NONE":
      return AreaType.AREA_NONE;
    case 1:
    case "AREA_CN":
      return AreaType.AREA_CN;
    case 2:
    case "AREA_JP":
      return AreaType.AREA_JP;
    case 3:
    case "AREA_ASIA":
      return AreaType.AREA_ASIA;
    case 4:
    case "AREA_WEST":
      return AreaType.AREA_WEST;
    case 5:
    case "AREA_KR":
      return AreaType.AREA_KR;
    case 6:
    case "AREA_OVERSEAS":
      return AreaType.AREA_OVERSEAS;
    case -1:
    case "UNRECOGNIZED":
    default:
      return AreaType.UNRECOGNIZED;
  }
}

export function areaTypeToJSON(object: AreaType): string {
  switch (object) {
    case AreaType.AREA_NONE:
      return "AREA_NONE";
    case AreaType.AREA_CN:
      return "AREA_CN";
    case AreaType.AREA_JP:
      return "AREA_JP";
    case AreaType.AREA_ASIA:
      return "AREA_ASIA";
    case AreaType.AREA_WEST:
      return "AREA_WEST";
    case AreaType.AREA_KR:
      return "AREA_KR";
    case AreaType.AREA_OVERSEAS:
      return "AREA_OVERSEAS";
    case AreaType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum EntityType {
  ENTITY_NONE = 0,
  ENTITY_AVATAR = 1,
  ENTITY_MONSTER = 2,
  ENTITY_NPC = 3,
  ENTITY_PROP = 4,
  ENTITY_TRIGGER = 5,
  ENTITY_ENV = 6,
  UNRECOGNIZED = -1,
}

export function entityTypeFromJSON(object: any): EntityType {
  switch (object) {
    case 0:
    case "ENTITY_NONE":
      return EntityType.ENTITY_NONE;
    case 1:
    case "ENTITY_AVATAR":
      return EntityType.ENTITY_AVATAR;
    case 2:
    case "ENTITY_MONSTER":
      return EntityType.ENTITY_MONSTER;
    case 3:
    case "ENTITY_NPC":
      return EntityType.ENTITY_NPC;
    case 4:
    case "ENTITY_PROP":
      return EntityType.ENTITY_PROP;
    case 5:
    case "ENTITY_TRIGGER":
      return EntityType.ENTITY_TRIGGER;
    case 6:
    case "ENTITY_ENV":
      return EntityType.ENTITY_ENV;
    case -1:
    case "UNRECOGNIZED":
    default:
      return EntityType.UNRECOGNIZED;
  }
}

export function entityTypeToJSON(object: EntityType): string {
  switch (object) {
    case EntityType.ENTITY_NONE:
      return "ENTITY_NONE";
    case EntityType.ENTITY_AVATAR:
      return "ENTITY_AVATAR";
    case EntityType.ENTITY_MONSTER:
      return "ENTITY_MONSTER";
    case EntityType.ENTITY_NPC:
      return "ENTITY_NPC";
    case EntityType.ENTITY_PROP:
      return "ENTITY_PROP";
    case EntityType.ENTITY_TRIGGER:
      return "ENTITY_TRIGGER";
    case EntityType.ENTITY_ENV:
      return "ENTITY_ENV";
    case EntityType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum LanguageType {
  LANGUAGE_NONE = 0,
  LANGUAGE_SC = 1,
  LANGUAGE_TC = 2,
  LANGUAGE_EN = 3,
  LANGUAGE_KR = 4,
  LANGUAGE_JP = 5,
  LANGUAGE_FR = 6,
  LANGUAGE_DE = 7,
  LANGUAGE_ES = 8,
  LANGUAGE_PT = 9,
  LANGUAGE_RU = 10,
  LANGUAGE_TH = 11,
  LANGUAGE_VI = 12,
  LANGUAGE_ID = 13,
  UNRECOGNIZED = -1,
}

export function languageTypeFromJSON(object: any): LanguageType {
  switch (object) {
    case 0:
    case "LANGUAGE_NONE":
      return LanguageType.LANGUAGE_NONE;
    case 1:
    case "LANGUAGE_SC":
      return LanguageType.LANGUAGE_SC;
    case 2:
    case "LANGUAGE_TC":
      return LanguageType.LANGUAGE_TC;
    case 3:
    case "LANGUAGE_EN":
      return LanguageType.LANGUAGE_EN;
    case 4:
    case "LANGUAGE_KR":
      return LanguageType.LANGUAGE_KR;
    case 5:
    case "LANGUAGE_JP":
      return LanguageType.LANGUAGE_JP;
    case 6:
    case "LANGUAGE_FR":
      return LanguageType.LANGUAGE_FR;
    case 7:
    case "LANGUAGE_DE":
      return LanguageType.LANGUAGE_DE;
    case 8:
    case "LANGUAGE_ES":
      return LanguageType.LANGUAGE_ES;
    case 9:
    case "LANGUAGE_PT":
      return LanguageType.LANGUAGE_PT;
    case 10:
    case "LANGUAGE_RU":
      return LanguageType.LANGUAGE_RU;
    case 11:
    case "LANGUAGE_TH":
      return LanguageType.LANGUAGE_TH;
    case 12:
    case "LANGUAGE_VI":
      return LanguageType.LANGUAGE_VI;
    case 13:
    case "LANGUAGE_ID":
      return LanguageType.LANGUAGE_ID;
    case -1:
    case "UNRECOGNIZED":
    default:
      return LanguageType.UNRECOGNIZED;
  }
}

export function languageTypeToJSON(object: LanguageType): string {
  switch (object) {
    case LanguageType.LANGUAGE_NONE:
      return "LANGUAGE_NONE";
    case LanguageType.LANGUAGE_SC:
      return "LANGUAGE_SC";
    case LanguageType.LANGUAGE_TC:
      return "LANGUAGE_TC";
    case LanguageType.LANGUAGE_EN:
      return "LANGUAGE_EN";
    case LanguageType.LANGUAGE_KR:
      return "LANGUAGE_KR";
    case LanguageType.LANGUAGE_JP:
      return "LANGUAGE_JP";
    case LanguageType.LANGUAGE_FR:
      return "LANGUAGE_FR";
    case LanguageType.LANGUAGE_DE:
      return "LANGUAGE_DE";
    case LanguageType.LANGUAGE_ES:
      return "LANGUAGE_ES";
    case LanguageType.LANGUAGE_PT:
      return "LANGUAGE_PT";
    case LanguageType.LANGUAGE_RU:
      return "LANGUAGE_RU";
    case LanguageType.LANGUAGE_TH:
      return "LANGUAGE_TH";
    case LanguageType.LANGUAGE_VI:
      return "LANGUAGE_VI";
    case LanguageType.LANGUAGE_ID:
      return "LANGUAGE_ID";
    case LanguageType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum PlatformType {
  EDITOR = 0,
  IOS = 1,
  ANDROID = 2,
  PC = 3,
  UNRECOGNIZED = -1,
}

export function platformTypeFromJSON(object: any): PlatformType {
  switch (object) {
    case 0:
    case "EDITOR":
      return PlatformType.EDITOR;
    case 1:
    case "IOS":
      return PlatformType.IOS;
    case 2:
    case "ANDROID":
      return PlatformType.ANDROID;
    case 3:
    case "PC":
      return PlatformType.PC;
    case -1:
    case "UNRECOGNIZED":
    default:
      return PlatformType.UNRECOGNIZED;
  }
}

export function platformTypeToJSON(object: PlatformType): string {
  switch (object) {
    case PlatformType.EDITOR:
      return "EDITOR";
    case PlatformType.IOS:
      return "IOS";
    case PlatformType.ANDROID:
      return "ANDROID";
    case PlatformType.PC:
      return "PC";
    case PlatformType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum ReloginType {
  NO_KICK = 0,
  FORCE_KICK = 1,
  IDLE_KICK = 2,
  UNRECOGNIZED = -1,
}

export function reloginTypeFromJSON(object: any): ReloginType {
  switch (object) {
    case 0:
    case "NO_KICK":
      return ReloginType.NO_KICK;
    case 1:
    case "FORCE_KICK":
      return ReloginType.FORCE_KICK;
    case 2:
    case "IDLE_KICK":
      return ReloginType.IDLE_KICK;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ReloginType.UNRECOGNIZED;
  }
}

export function reloginTypeToJSON(object: ReloginType): string {
  switch (object) {
    case ReloginType.NO_KICK:
      return "NO_KICK";
    case ReloginType.FORCE_KICK:
      return "FORCE_KICK";
    case ReloginType.IDLE_KICK:
      return "IDLE_KICK";
    case ReloginType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum AvatarType {
  AVATAR_TYPE_NONE = 0,
  AVATAR_TRIAL_TYPE = 1,
  AVATAR_LIMIT_TYPE = 2,
  AVATAR_FORMAL_TYPE = 3,
  UNRECOGNIZED = -1,
}

export function avatarTypeFromJSON(object: any): AvatarType {
  switch (object) {
    case 0:
    case "AVATAR_TYPE_NONE":
      return AvatarType.AVATAR_TYPE_NONE;
    case 1:
    case "AVATAR_TRIAL_TYPE":
      return AvatarType.AVATAR_TRIAL_TYPE;
    case 2:
    case "AVATAR_LIMIT_TYPE":
      return AvatarType.AVATAR_LIMIT_TYPE;
    case 3:
    case "AVATAR_FORMAL_TYPE":
      return AvatarType.AVATAR_FORMAL_TYPE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return AvatarType.UNRECOGNIZED;
  }
}

export function avatarTypeToJSON(object: AvatarType): string {
  switch (object) {
    case AvatarType.AVATAR_TYPE_NONE:
      return "AVATAR_TYPE_NONE";
    case AvatarType.AVATAR_TRIAL_TYPE:
      return "AVATAR_TRIAL_TYPE";
    case AvatarType.AVATAR_LIMIT_TYPE:
      return "AVATAR_LIMIT_TYPE";
    case AvatarType.AVATAR_FORMAL_TYPE:
      return "AVATAR_FORMAL_TYPE";
    case AvatarType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum HeroBasicType {
  None = 0,
  BoyWarrior = 8001,
  GirlWarrior = 8002,
  BoyKnight = 8003,
  GirlKnight = 8004,
  BoyRogue = 8005,
  GirlRogue = 8006,
  BoyMage = 8007,
  GirlMage = 8008,
  BoyShaman = 8009,
  GirlShaman = 8010,
  BoyWarlock = 8011,
  GirlWarlock = 8012,
  BoyPriest = 8013,
  GirlPriest = 8014,
  UNRECOGNIZED = -1,
}

export function heroBasicTypeFromJSON(object: any): HeroBasicType {
  switch (object) {
    case 0:
    case "None":
      return HeroBasicType.None;
    case 8001:
    case "BoyWarrior":
      return HeroBasicType.BoyWarrior;
    case 8002:
    case "GirlWarrior":
      return HeroBasicType.GirlWarrior;
    case 8003:
    case "BoyKnight":
      return HeroBasicType.BoyKnight;
    case 8004:
    case "GirlKnight":
      return HeroBasicType.GirlKnight;
    case 8005:
    case "BoyRogue":
      return HeroBasicType.BoyRogue;
    case 8006:
    case "GirlRogue":
      return HeroBasicType.GirlRogue;
    case 8007:
    case "BoyMage":
      return HeroBasicType.BoyMage;
    case 8008:
    case "GirlMage":
      return HeroBasicType.GirlMage;
    case 8009:
    case "BoyShaman":
      return HeroBasicType.BoyShaman;
    case 8010:
    case "GirlShaman":
      return HeroBasicType.GirlShaman;
    case 8011:
    case "BoyWarlock":
      return HeroBasicType.BoyWarlock;
    case 8012:
    case "GirlWarlock":
      return HeroBasicType.GirlWarlock;
    case 8013:
    case "BoyPriest":
      return HeroBasicType.BoyPriest;
    case 8014:
    case "GirlPriest":
      return HeroBasicType.GirlPriest;
    case -1:
    case "UNRECOGNIZED":
    default:
      return HeroBasicType.UNRECOGNIZED;
  }
}

export function heroBasicTypeToJSON(object: HeroBasicType): string {
  switch (object) {
    case HeroBasicType.None:
      return "None";
    case HeroBasicType.BoyWarrior:
      return "BoyWarrior";
    case HeroBasicType.GirlWarrior:
      return "GirlWarrior";
    case HeroBasicType.BoyKnight:
      return "BoyKnight";
    case HeroBasicType.GirlKnight:
      return "GirlKnight";
    case HeroBasicType.BoyRogue:
      return "BoyRogue";
    case HeroBasicType.GirlRogue:
      return "GirlRogue";
    case HeroBasicType.BoyMage:
      return "BoyMage";
    case HeroBasicType.GirlMage:
      return "GirlMage";
    case HeroBasicType.BoyShaman:
      return "BoyShaman";
    case HeroBasicType.GirlShaman:
      return "GirlShaman";
    case HeroBasicType.BoyWarlock:
      return "BoyWarlock";
    case HeroBasicType.GirlWarlock:
      return "GirlWarlock";
    case HeroBasicType.BoyPriest:
      return "BoyPriest";
    case HeroBasicType.GirlPriest:
      return "GirlPriest";
    case HeroBasicType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum Gender {
  GenderNone = 0,
  GenderMan = 1,
  GenderWoman = 2,
  UNRECOGNIZED = -1,
}

export function genderFromJSON(object: any): Gender {
  switch (object) {
    case 0:
    case "GenderNone":
      return Gender.GenderNone;
    case 1:
    case "GenderMan":
      return Gender.GenderMan;
    case 2:
    case "GenderWoman":
      return Gender.GenderWoman;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Gender.UNRECOGNIZED;
  }
}

export function genderToJSON(object: Gender): string {
  switch (object) {
    case Gender.GenderNone:
      return "GenderNone";
    case Gender.GenderMan:
      return "GenderMan";
    case Gender.GenderWoman:
      return "GenderWoman";
    case Gender.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum ProductType {
  PRODUCT_NONE = 0,
  PRODUCT_NORMAL = 1,
  PRODUCT_LIMIT = 2,
  UNRECOGNIZED = -1,
}

export function productTypeFromJSON(object: any): ProductType {
  switch (object) {
    case 0:
    case "PRODUCT_NONE":
      return ProductType.PRODUCT_NONE;
    case 1:
    case "PRODUCT_NORMAL":
      return ProductType.PRODUCT_NORMAL;
    case 2:
    case "PRODUCT_LIMIT":
      return ProductType.PRODUCT_LIMIT;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ProductType.UNRECOGNIZED;
  }
}

export function productTypeToJSON(object: ProductType): string {
  switch (object) {
    case ProductType.PRODUCT_NONE:
      return "PRODUCT_NONE";
    case ProductType.PRODUCT_NORMAL:
      return "PRODUCT_NORMAL";
    case ProductType.PRODUCT_LIMIT:
      return "PRODUCT_LIMIT";
    case ProductType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum ProductGiftType {
  PRODUCT_GIFT_NONE = 0,
  PRODUCT_GIFT_HCOIN = 1,
  PRODUCT_GIFT_SUBSCRIPTION = 2,
  UNRECOGNIZED = -1,
}

export function productGiftTypeFromJSON(object: any): ProductGiftType {
  switch (object) {
    case 0:
    case "PRODUCT_GIFT_NONE":
      return ProductGiftType.PRODUCT_GIFT_NONE;
    case 1:
    case "PRODUCT_GIFT_HCOIN":
      return ProductGiftType.PRODUCT_GIFT_HCOIN;
    case 2:
    case "PRODUCT_GIFT_SUBSCRIPTION":
      return ProductGiftType.PRODUCT_GIFT_SUBSCRIPTION;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ProductGiftType.UNRECOGNIZED;
  }
}

export function productGiftTypeToJSON(object: ProductGiftType): string {
  switch (object) {
    case ProductGiftType.PRODUCT_GIFT_NONE:
      return "PRODUCT_GIFT_NONE";
    case ProductGiftType.PRODUCT_GIFT_HCOIN:
      return "PRODUCT_GIFT_HCOIN";
    case ProductGiftType.PRODUCT_GIFT_SUBSCRIPTION:
      return "PRODUCT_GIFT_SUBSCRIPTION";
    case ProductGiftType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum FeatureSwitchType {
  FEATURE_SWITCH_NONE = 0,
  FEATURE_SWITCH_SHOP = 1,
  FEATURE_SWITCH_LINEUP_NAME = 2,
  UNRECOGNIZED = -1,
}

export function featureSwitchTypeFromJSON(object: any): FeatureSwitchType {
  switch (object) {
    case 0:
    case "FEATURE_SWITCH_NONE":
      return FeatureSwitchType.FEATURE_SWITCH_NONE;
    case 1:
    case "FEATURE_SWITCH_SHOP":
      return FeatureSwitchType.FEATURE_SWITCH_SHOP;
    case 2:
    case "FEATURE_SWITCH_LINEUP_NAME":
      return FeatureSwitchType.FEATURE_SWITCH_LINEUP_NAME;
    case -1:
    case "UNRECOGNIZED":
    default:
      return FeatureSwitchType.UNRECOGNIZED;
  }
}

export function featureSwitchTypeToJSON(object: FeatureSwitchType): string {
  switch (object) {
    case FeatureSwitchType.FEATURE_SWITCH_NONE:
      return "FEATURE_SWITCH_NONE";
    case FeatureSwitchType.FEATURE_SWITCH_SHOP:
      return "FEATURE_SWITCH_SHOP";
    case FeatureSwitchType.FEATURE_SWITCH_LINEUP_NAME:
      return "FEATURE_SWITCH_LINEUP_NAME";
    case FeatureSwitchType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum BattleCheckStrategyType {
  BATTLE_CHECK_STRATEGY_IDENTICAL = 0,
  BATTLE_CHECK_STRATEGY_SERVER = 1,
  BATTLE_CHECK_STRATEGY_CLIENT = 2,
  UNRECOGNIZED = -1,
}

export function battleCheckStrategyTypeFromJSON(
  object: any
): BattleCheckStrategyType {
  switch (object) {
    case 0:
    case "BATTLE_CHECK_STRATEGY_IDENTICAL":
      return BattleCheckStrategyType.BATTLE_CHECK_STRATEGY_IDENTICAL;
    case 1:
    case "BATTLE_CHECK_STRATEGY_SERVER":
      return BattleCheckStrategyType.BATTLE_CHECK_STRATEGY_SERVER;
    case 2:
    case "BATTLE_CHECK_STRATEGY_CLIENT":
      return BattleCheckStrategyType.BATTLE_CHECK_STRATEGY_CLIENT;
    case -1:
    case "UNRECOGNIZED":
    default:
      return BattleCheckStrategyType.UNRECOGNIZED;
  }
}

export function battleCheckStrategyTypeToJSON(
  object: BattleCheckStrategyType
): string {
  switch (object) {
    case BattleCheckStrategyType.BATTLE_CHECK_STRATEGY_IDENTICAL:
      return "BATTLE_CHECK_STRATEGY_IDENTICAL";
    case BattleCheckStrategyType.BATTLE_CHECK_STRATEGY_SERVER:
      return "BATTLE_CHECK_STRATEGY_SERVER";
    case BattleCheckStrategyType.BATTLE_CHECK_STRATEGY_CLIENT:
      return "BATTLE_CHECK_STRATEGY_CLIENT";
    case BattleCheckStrategyType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum BattleCheckResultType {
  BATTLE_CHECK_RESULT_SUCC = 0,
  BATTLE_CHECK_RESULT_FAIL = 1,
  BATTLE_CHECK_RESULT_PASS = 2,
  UNRECOGNIZED = -1,
}

export function battleCheckResultTypeFromJSON(
  object: any
): BattleCheckResultType {
  switch (object) {
    case 0:
    case "BATTLE_CHECK_RESULT_SUCC":
      return BattleCheckResultType.BATTLE_CHECK_RESULT_SUCC;
    case 1:
    case "BATTLE_CHECK_RESULT_FAIL":
      return BattleCheckResultType.BATTLE_CHECK_RESULT_FAIL;
    case 2:
    case "BATTLE_CHECK_RESULT_PASS":
      return BattleCheckResultType.BATTLE_CHECK_RESULT_PASS;
    case -1:
    case "UNRECOGNIZED":
    default:
      return BattleCheckResultType.UNRECOGNIZED;
  }
}

export function battleCheckResultTypeToJSON(
  object: BattleCheckResultType
): string {
  switch (object) {
    case BattleCheckResultType.BATTLE_CHECK_RESULT_SUCC:
      return "BATTLE_CHECK_RESULT_SUCC";
    case BattleCheckResultType.BATTLE_CHECK_RESULT_FAIL:
      return "BATTLE_CHECK_RESULT_FAIL";
    case BattleCheckResultType.BATTLE_CHECK_RESULT_PASS:
      return "BATTLE_CHECK_RESULT_PASS";
    case BattleCheckResultType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum BattleModuleType {
  BATTLE_MODULE_MAZE = 0,
  BATTLE_MODULE_CHALLENGE = 1,
  BATTLE_MODULE_COCOON = 2,
  BATTLE_MODULE_ROGUE = 3,
  BATTLE_MODULE_CHALLENGE_ACTIVITY = 4,
  UNRECOGNIZED = -1,
}

export function battleModuleTypeFromJSON(object: any): BattleModuleType {
  switch (object) {
    case 0:
    case "BATTLE_MODULE_MAZE":
      return BattleModuleType.BATTLE_MODULE_MAZE;
    case 1:
    case "BATTLE_MODULE_CHALLENGE":
      return BattleModuleType.BATTLE_MODULE_CHALLENGE;
    case 2:
    case "BATTLE_MODULE_COCOON":
      return BattleModuleType.BATTLE_MODULE_COCOON;
    case 3:
    case "BATTLE_MODULE_ROGUE":
      return BattleModuleType.BATTLE_MODULE_ROGUE;
    case 4:
    case "BATTLE_MODULE_CHALLENGE_ACTIVITY":
      return BattleModuleType.BATTLE_MODULE_CHALLENGE_ACTIVITY;
    case -1:
    case "UNRECOGNIZED":
    default:
      return BattleModuleType.UNRECOGNIZED;
  }
}

export function battleModuleTypeToJSON(object: BattleModuleType): string {
  switch (object) {
    case BattleModuleType.BATTLE_MODULE_MAZE:
      return "BATTLE_MODULE_MAZE";
    case BattleModuleType.BATTLE_MODULE_CHALLENGE:
      return "BATTLE_MODULE_CHALLENGE";
    case BattleModuleType.BATTLE_MODULE_COCOON:
      return "BATTLE_MODULE_COCOON";
    case BattleModuleType.BATTLE_MODULE_ROGUE:
      return "BATTLE_MODULE_ROGUE";
    case BattleModuleType.BATTLE_MODULE_CHALLENGE_ACTIVITY:
      return "BATTLE_MODULE_CHALLENGE_ACTIVITY";
    case BattleModuleType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum DeathSource {
  UNKNOWN = 0,
  KILLED_BY_OTHERS = 1,
  KILLED_BY_SELF = 2,
  ESCAPE = 3,
  UNRECOGNIZED = -1,
}

export function deathSourceFromJSON(object: any): DeathSource {
  switch (object) {
    case 0:
    case "UNKNOWN":
      return DeathSource.UNKNOWN;
    case 1:
    case "KILLED_BY_OTHERS":
      return DeathSource.KILLED_BY_OTHERS;
    case 2:
    case "KILLED_BY_SELF":
      return DeathSource.KILLED_BY_SELF;
    case 3:
    case "ESCAPE":
      return DeathSource.ESCAPE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return DeathSource.UNRECOGNIZED;
  }
}

export function deathSourceToJSON(object: DeathSource): string {
  switch (object) {
    case DeathSource.UNKNOWN:
      return "UNKNOWN";
    case DeathSource.KILLED_BY_OTHERS:
      return "KILLED_BY_OTHERS";
    case DeathSource.KILLED_BY_SELF:
      return "KILLED_BY_SELF";
    case DeathSource.ESCAPE:
      return "ESCAPE";
    case DeathSource.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum BattleTag {
  TAG_NONE = 0,
  TAG_HIDE_NPC_MONSTER = 1,
  UNRECOGNIZED = -1,
}

export function battleTagFromJSON(object: any): BattleTag {
  switch (object) {
    case 0:
    case "TAG_NONE":
      return BattleTag.TAG_NONE;
    case 1:
    case "TAG_HIDE_NPC_MONSTER":
      return BattleTag.TAG_HIDE_NPC_MONSTER;
    case -1:
    case "UNRECOGNIZED":
    default:
      return BattleTag.UNRECOGNIZED;
  }
}

export function battleTagToJSON(object: BattleTag): string {
  switch (object) {
    case BattleTag.TAG_NONE:
      return "TAG_NONE";
    case BattleTag.TAG_HIDE_NPC_MONSTER:
      return "TAG_HIDE_NPC_MONSTER";
    case BattleTag.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum BattleEndStatus {
  BATTLE_END_NONE = 0,
  BATTLE_END_WIN = 1,
  BATTLE_END_LOSE = 2,
  BATTLE_END_QUIT = 3,
  UNRECOGNIZED = -1,
}

export function battleEndStatusFromJSON(object: any): BattleEndStatus {
  switch (object) {
    case 0:
    case "BATTLE_END_NONE":
      return BattleEndStatus.BATTLE_END_NONE;
    case 1:
    case "BATTLE_END_WIN":
      return BattleEndStatus.BATTLE_END_WIN;
    case 2:
    case "BATTLE_END_LOSE":
      return BattleEndStatus.BATTLE_END_LOSE;
    case 3:
    case "BATTLE_END_QUIT":
      return BattleEndStatus.BATTLE_END_QUIT;
    case -1:
    case "UNRECOGNIZED":
    default:
      return BattleEndStatus.UNRECOGNIZED;
  }
}

export function battleEndStatusToJSON(object: BattleEndStatus): string {
  switch (object) {
    case BattleEndStatus.BATTLE_END_NONE:
      return "BATTLE_END_NONE";
    case BattleEndStatus.BATTLE_END_WIN:
      return "BATTLE_END_WIN";
    case BattleEndStatus.BATTLE_END_LOSE:
      return "BATTLE_END_LOSE";
    case BattleEndStatus.BATTLE_END_QUIT:
      return "BATTLE_END_QUIT";
    case BattleEndStatus.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum Retcode {
  RET_SUCC = 0,
  RET_FAIL = 1,
  RET_SERVER_INTERNAL_ERROR = 2,
  RET_TIMEOUT = 3,
  RET_REPEATED_REQ = 4,
  RET_REQ_PARA_INVALID = 5,
  RET_PLAYER_DATA_ERROR = 6,
  RET_PLAYER_CLIENT_PAUSED = 7,
  RET_FUNC_CHECK_FAILED = 8,
  RET_FEATURE_SWITCH_CLOSED = 9,
  RET_REPEATE_LOGIN = 1000,
  RET_RETRY_LOGIN = 1001,
  RET_WAIT_LOGIN = 1002,
  RET_NOT_IN_WHITE_LIST = 1003,
  RET_IN_BLACK_LIST = 1004,
  RET_ACCOUNT_VERIFY_ERROR = 1005,
  RET_ACCOUNT_PARA_ERROR = 1006,
  RET_ANTI_ADDICT_LOGIN = 1007,
  RET_CHECK_SUM_ERROR = 1008,
  RET_REACH_MAX_PLAYER_NUM = 1009,
  RET_ALREADY_REGISTERED = 1010,
  RET_GENDER_ERROR = 1011,
  SET_NICKNAME_RET_CALLBACK_PROCESSING = 1012,
  RET_IN_GM_BIND_ACCESS = 1013,
  RET_QUEST_REWARD_ALREADY_TAKEN = 1100,
  RET_QUEST_NOT_ACCEPT = 1101,
  RET_QUEST_NOT_FINISH = 1102,
  RET_QUEST_STATUS_ERROR = 1103,
  RET_ACHIEVEMENT_LEVEL_NOT_REACH = 1104,
  RET_ACHIEVEMENT_LEVEL_ALREADY_TAKEN = 1105,
  RET_AVATAR_NOT_EXIST = 1200,
  RET_AVATAR_RES_EXP_NOT_ENOUGH = 1201,
  RET_AVATAR_EXP_REACH_PROMOTION_LIMIT = 1202,
  RET_AVATAR_REACH_MAX_PROMOTION = 1203,
  RET_SKILLTREE_CONFIG_NOT_EXIST = 1204,
  RET_SKILLTREE_ALREADY_UNLOCK = 1205,
  RET_SKILLTREE_PRE_LOCKED = 1206,
  RET_SKILLTREE_LEVEL_NOT_MEET = 1207,
  RET_SKILLTREE_RANK_NOT_MEET = 1208,
  RET_AVATAR_DRESS_NO_EQUIPMENT = 1209,
  RET_AVATAR_EXP_ITEM_NOT_EXIST = 1210,
  RET_SKILLTREE_POINT_UNLOCK = 1211,
  RET_SKILLTREE_POINT_LEVEL_UPGRADE_NOT_MATCH = 1212,
  RET_SKILLTREE_POINT_LEVEL_REACH_MAX = 1213,
  RET_WORLD_LEVEL_NOT_MEET = 1214,
  RET_PLAYER_LEVEL_NOT_MEET = 1215,
  RET_AVATAR_RANK_NOT_MATCH = 1216,
  RET_AVATAR_RANK_REACH_MAX = 1217,
  RET_HERO_BASIC_TYPE_NOT_MATCH = 1218,
  RET_ITEM_NOT_EXIST = 1300,
  RET_ITEM_COST_NOT_ENOUGH = 1301,
  RET_ITEM_COST_TOO_MUCH = 1302,
  RET_ITEM_NO_COST = 1303,
  RET_ITEM_NOT_ENOUGH = 1304,
  RET_ITEM_INVALID = 1305,
  RET_ITEM_CONFIG_NOT_EXIST = 1306,
  RET_SCOIN_NOT_ENOUGH = 1307,
  RET_ITEM_REWARD_EXCEED_LIMIT = 1308,
  RET_ITEM_INVALID_USE = 1309,
  RET_ITEM_USE_CONFIG_NOT_EXIST = 1310,
  RET_REWARD_CONFIG_NOT_EXIST = 1311,
  RET_ITEM_EXCEED_LIMIT = 1312,
  RET_ITEM_COUNT_INVALID = 1313,
  RET_ITEM_USE_TARGET_TYPE_INVALID = 1314,
  RET_ITEM_USE_SATIETY_FULL = 1315,
  RET_ITEM_COMPOSE_NOT_EXIST = 1316,
  RET_RELIC_COMPOSE_NOT_EXIST = 1317,
  RET_ITEM_CAN_NOT_SELL = 1318,
  RET_ITEM_SELL_EXCEDD_LIMIT = 1319,
  RET_EQUIPMENT_ALREADY_DRESSED = 1350,
  RET_EQUIPMENT_NOT_EXIST = 1351,
  RET_EQUIPMENT_REACH_LEVEL_LIMIT = 1352,
  RET_EQUIPMENT_CONSUME_SELF = 1353,
  RET_EQUIPMENT_ALREADY_LOCKED = 1354,
  RET_EQUIPMENT_ALREADY_UNLOCKED = 1355,
  RET_EQUIPMENT_LOCKED = 1356,
  RET_EQUIPMENT_SELECT_NUM_OVER_LIMIT = 1357,
  RET_EQUIPMENT_RANK_UP_MUST_CONSUME_SAME_TID = 1358,
  RET_EQUIPMENT_PROMOTION_REACH_MAX = 1359,
  RET_EQUIPMENT_RANK_UP_REACH_MAX = 1360,
  RET_EQUIPMENT_LEVEL_REACH_MAX = 1361,
  RET_EQUIPMENT_EXCEED_LIMIT = 1362,
  RET_RELIC_NOT_EXIST = 1363,
  RET_RELIC_REACH_LEVEL_LIMIT = 1364,
  RET_RELIC_CONSUME_SELF = 1365,
  RET_RELIC_ALREADY_DRESSED = 1366,
  RET_RELIC_LOCKED = 1367,
  RET_RELIC_ALREADY_LOCKED = 1368,
  RET_RELIC_ALREADY_UNLOCKED = 1369,
  RET_RELIC_LEVEL_IS_NOT_ZERO = 1370,
  RET_LINEUP_INVALID_INDEX = 1400,
  RET_LINEUP_INVALID_MEMBER_POS = 1401,
  RET_LINEUP_SWAP_NOT_EXIST = 1402,
  RET_LINEUP_AVATAR_ALREADY_IN = 1403,
  RET_LINEUP_CREATE_AVATAR_ERROR = 1404,
  RET_LINEUP_AVATAR_INIT_ERROR = 1405,
  RET_LINEUP_NOT_EXIST = 1406,
  RET_LINEUP_ONLY_ONE_MEMBER = 1407,
  RET_LINEUP_SAME_LEADER_SLOT = 1408,
  RET_LINEUP_NO_LEADER_SELECT = 1409,
  RET_LINEUP_SWAP_SAME_SLOT = 1410,
  RET_LINEUP_AVATAR_NOT_EXIST = 1411,
  RET_LINEUP_TRIAL_AVATAR_CAN_NOT_QUIT = 1412,
  RET_LINEUP_VIRTUAL_LINEUP_PLANE_NOT_MATCH = 1413,
  RET_LINEUP_NOT_VALID_LEADER = 1414,
  RET_LINEUP_SAME_INDEX = 1415,
  RET_LINEUP_IS_EMPTY = 1416,
  RET_LINEUP_NAME_FORMAT_ERROR = 1417,
  RET_LINEUP_TYPE_NOT_MATCH = 1418,
  RET_LINEUP_REPLACE_ALL_FAILED = 1419,
  RET_LINEUP_NOT_ALLOW_EDIT = 1420,
  RET_LINEUP_AVATAR_IS_ALIVE = 1421,
  RET_MAIL_NOT_EXIST = 1700,
  RET_MAIL_RANGE_INVALID = 1701,
  RET_MAIL_MAIL_ID_INVALID = 1702,
  RET_MAIL_NO_MAIL_TAKE_ATTACHMENT = 1703,
  RET_MAIL_NO_MAIL_TO_DEL = 1704,
  RET_STAGE_SETTLE_ERROR = 1800,
  RET_STAGE_CONFIG_NOT_EXIST = 1801,
  RET_STAGE_NOT_FOUND = 1802,
  RET_STAGE_COCOON_PROP_NOT_VALID = 1804,
  RET_STAGE_COCOON_WAVE_NOT_VALID = 1805,
  RET_STAGE_PROP_ID_NOT_EQUAL = 1806,
  RET_STAGE_COCOON_WAVE_OVER = 1807,
  RET_STAGE_WEEK_COCOON_OVER_CNT = 1808,
  RET_STAGE_COCOON_NOT_OPEN = 1809,
  RET_CHAPTER_LOCK = 1900,
  RET_CHAPTER_CHALLENGE_NUM_NOT_ENOUGH = 1901,
  RET_CHAPTER_REWARD_ID_NOT_EXIST = 1902,
  RET_CHAPTER_REWARD_ALREADY_TAKEN = 1903,
  RET_BATTLE_STAGE_NOT_MATCH = 2000,
  RET_IN_BATTLE_NOW = 2001,
  RET_BATTLE_CHEAT = 2002,
  RET_BATTLE_FAIL = 2003,
  RET_BATTLE_NO_LINEUP = 2004,
  RET_BATTLE_LINEUP_EMPTY = 2005,
  RET_BATTLE_VERSION_NOT_MATCH = 2006,
  RET_BATTLE_QUIT_BY_SERVER = 2007,
  RET_LACK_EXCHANGE_STAMINA_TIMES = 2100,
  RET_LACK_STAMINA = 2101,
  RET_STAMINA_FULL = 2102,
  RET_AUTHKEY_SIGN_TYPE_ERROR = 2103,
  RET_AUTHKEY_SIGN_VER_ERROR = 2104,
  RET_NICKNAME_FORMAT_ERROR = 2105,
  RET_SENSITIVE_WORDS = 2106,
  RET_LEVEL_REWARD_HAS_TAKEN = 2107,
  RET_LEVEL_REWARD_LEVEL_ERROR = 2108,
  RET_LANGUAGE_INVALID = 2109,
  RET_MAZE_NOT_FINISH = 2200,
  RET_MAZE_LACK_TICKET = 2201,
  RET_MAZE_NOT_UNLOCK = 2202,
  RET_MAZE_DIFFICULTY_LIMIT = 2203,
  RET_MAZE_NO_ABILITY = 2204,
  RET_MAZE_NO_PLANE = 2205,
  RET_MAZE_STAGE_DISMATCH = 2206,
  RET_MAZE_MAP_NOT_EXIST = 2207,
  RET_MAZE_TYPE_NOT_EXIST = 2208,
  RET_MAZE_ALREADY_FINISH = 2209,
  RET_MAZE_PROP_NOT_EXIST = 2210,
  RET_MAZE_POSITION_TOO_FAR = 2211,
  RET_MAZE_SKILL_CAST_CNT_REACH_MAX = 2212,
  RET_MAZE_MP_NOT_ENOUGH = 2213,
  RET_SPRING_NOT_ENABLE = 2214,
  RET_SPRING_REFRESH_IN_CD = 2215,
  RET_SPRING_TOO_FAR = 2216,
  RET_MAZE_NO_FLOOR = 2217,
  RET_NOT_IN_MAZE = 2218,
  RET_PLANE_ID_NOT_MATCH = 2219,
  RET_FLOOR_ID_NOT_MATCH = 2220,
  RET_SAVEPOINTS_TIMES_ZERO = 2221,
  RET_MAZE_TIME_OF_DAY_TYPE_IS_SAME = 2222,
  RET_MAZE_TIME_OF_DAY_TYPE_ERROR = 2223,
  RET_PLOT_NOT_UNLOCK = 2300,
  RET_MISSION_NOT_EXIST = 2400,
  RET_MISSION_ALREADY_DONE = 2401,
  RET_DAILY_TASK_NOT_FINISH = 2402,
  RET_DAILY_TASK_REWARD_HAS_TAKEN = 2403,
  RET_MISSION_NOT_FINISH = 2404,
  RET_MISSION_NOT_DOING = 2405,
  RET_MISSION_FINISH_WAY_NOT_MATCH = 2406,
  RET_MISSION_SCENE_NOT_MATCH = 2407,
  RET_ADVENTURE_MAP_NOT_EXIST = 2500,
  RET_SCENE_ENTITY_NOT_EXIST = 2600,
  RET_NOT_IN_SCENE = 2601,
  RET_SCENE_MONSTER_NOT_EXIST = 2602,
  RET_INTERACT_CONFIG_NOT_EXIST = 2603,
  RET_UNSUPPORTED_PROP_STATE = 2604,
  RET_SCENE_ENTRY_ID_NOT_MATCH = 2605,
  RET_ASSIST_MONSTER_COUNT_LIMIT = 2607,
  RET_SCENE_USE_SKILL_FAIL = 2608,
  RET_PROP_IS_HIDDEN = 2609,
  RET_LOADING_SUCC_ALREADY = 2610,
  RET_SCENE_ENTITY_TYPE_INVALID = 2611,
  RET_INTERACT_TYPE_INVALID = 2612,
  RET_INTERACT_NOT_IN_REGION = 2613,
  RET_INTERACT_SUB_TYPE_INVALID = 2614,
  RET_NOT_LEADER_ENTITY = 2615,
  RET_MONSTER_IS_NOT_FARM_ELEMENT = 2616,
  RET_MONSTER_CONFIG_NOT_EXIST = 2617,
  RET_AVATAR_HP_ALREADY_FULL = 2618,
  RET_BUY_TIMES_LIMIT = 2700,
  RET_BUY_LIMIT_TYPE = 2701,
  RET_SHOP_NOT_OPEN = 2702,
  RET_GOODS_NOT_OPEN = 2703,
  RET_TUTORIAL_NOT_UNLOCK = 2751,
  RET_TUTORIAL_UNLOCK_ALREADY = 2752,
  RET_TUTORIAL_FINISH_ALREADY = 2753,
  RET_TUTORIAL_PRE_NOT_UNLOCK = 2754,
  RET_TUTORIAL_PLAYER_LEVEL_NOT_MATCH = 2755,
  RET_TUTORIAL_TUTORIAL_NOT_FOUND = 2756,
  RET_CHALLENGE_NOT_EXIST = 2801,
  RET_CHALLENGE_NOT_UNLOCK = 2802,
  RET_CHALLENGE_ALREADY = 2803,
  RET_CHALLENGE_LINEUP_EDIT_FORBIDDEN = 2804,
  RET_CHALLENGE_LINEUP_EMPTY = 2805,
  RET_CHALLENGE_NOT_DOING = 2806,
  RET_CHALLENGE_NOT_FINISH = 2807,
  RET_CHALLENGE_TARGET_NOT_FINISH = 2808,
  RET_CHALLENGE_TARGET_REWARD_TAKEN = 2809,
  RET_CHALLENGE_TIME_NOT_VALID = 2810,
  RET_BASIC_TYPE_ALREADY = 2850,
  RET_NO_BASIC_TYPE = 2851,
  RET_NOT_CHOOSE_BASIC_TYPE = 2852,
  RET_NOT_FUNC_CLOSE = 2853,
  RET_ROGUE_STATUS_NOT_MATCH = 2901,
  RET_ROGUE_SELECT_BUFF_NOT_EXIST = 2902,
  RET_ROGUE_COIN_NOT_ENOUGH = 2903,
  RET_ROGUE_STAMINA_NOT_ENOUGH = 2904,
  RET_ROGUE_COUNT_INVALID = 2905,
  RET_ROGUE_PROP_ALREADY_USED = 2906,
  RET_ROGUE_RECORD_ALREADY_SAVED = 2907,
  RET_ROGUE_ROLL_BUFF_MAX_COUNT = 2908,
  RET_ROGUE_PICK_AVATAR_INVALID = 2909,
  RET_ROGUE_QUEST_EXPIRE = 2910,
  RET_ROGUE_QUEST_REWARD_ALREADY = 2911,
  RET_MISSION_EVENT_CONFIG_NOT_EXIST = 2951,
  RET_MISSION_EVENT_NOT_CLIENT = 2952,
  RET_MISSION_EVENT_FINISHED = 2953,
  RET_MISSION_EVENT_DOING = 2954,
  RET_HAS_CHALLENGE_MISSION_EVENT = 2955,
  RET_NOT_CHALLENGE_MISSION_EVENT = 2956,
  RET_GACHA_ID_NOT_EXIST = 3001,
  RET_GACHA_NUM_INVALID = 3002,
  RET_GACHA_FIRST_GACHA_MUST_ONE = 3003,
  RET_GACHA_REQ_DUPLICATED = 3004,
  RET_GACHA_NOT_IN_SCHEDULE = 3005,
  RET_GACHA_NEWBIE_CLOSE = 3006,
  RET_GACHA_TODAY_LIMITED = 3007,
  RET_PRESTIGE_ID_NOT_EXIST = 3051,
  RET_PRESTIGE_LEVEL_REWARD_LEVEL_ERROR = 3052,
  RET_PRESTIGE_LEVEL_REWARD_HAS_TAKEN = 3053,
  RET_PRESTIGE_MISSION_NOT_EXIST = 3054,
  RET_PRESTIGE_MISSION_NOT_FINISHED = 3055,
  RET_PRESTIGE_MISSION_REWARD_HAS_TAKEN = 3056,
  RET_NOT_IN_RAID = 3101,
  RET_RAID_DOING = 3102,
  RET_NOT_PROP = 3103,
  RET_RAID_ID_NOT_MATCH = 3104,
  RET_RAID_RESTART_NOT_MATCH = 3105,
  RET_RAID_LIMIT = 3106,
  RET_RAID_AVATAR_LIST_EMPTY = 3107,
  RET_RAID_AVATAR_NOT_EXIST = 3108,
  RET_CHALLENGE_RAID_REWARD_ALREADY = 3109,
  RET_CHALLENGE_RAID_SCORE_NOT_REACH = 3110,
  RET_CHALLENGE_RAID_NOT_OPEN = 3111,
  RET_RAID_FINISHED = 3112,
  RET_TALK_EVENT_ALREADY_TAKEN = 3151,
  RET_NPC_ALREADY_MEET = 3152,
  RET_NPC_NOT_IN_CONFIG = 3153,
  RET_DIALOGUE_GROUP_DISMATCH = 3154,
  RET_DIALOGUE_EVENT_INVALID = 3155,
  RET_EXPEDITION_CONFIG_NOT_EXIST = 3201,
  RET_EXPEDITION_REWARD_CONFIG_NOT_EXIST = 3202,
  RET_EXPEDITION_NOT_UNLOCKED = 3203,
  RET_EXPEDITION_ALREADY_ACCEPTED = 3204,
  RET_EXPEDITION_REPEATED_AVATAR = 3205,
  RET_AVATAR_ALREADY_DISPATCHED = 3206,
  RET_EXPEDITION_NOT_ACCEPTED = 3207,
  RET_EXPEDITION_NOT_FINISH = 3208,
  RET_EXPEDITION_ALREADY_FINISH = 3209,
  RET_LOGIN_ACTIVITY_HAS_TAKEN = 3301,
  RET_LOGIN_ACTIVITY_DAYS_LACK = 3302,
  RET_MESSAGE_CONFIG_NOT_EXIST = 3501,
  RET_MESSAGE_SECTION_NOT_TAKE = 3502,
  RET_MESSAGE_GROUP_NOT_TAKE = 3503,
  RET_MESSAGE_SECTION_ID_NOT_MATCH = 3504,
  RET_MESSAGE_SECTION_CAN_NOT_FINISH = 3505,
  RET_MESSAGE_ITEM_CAN_NOT_FINISH = 3506,
  UNRECOGNIZED = -1,
}

export function retcodeFromJSON(object: any): Retcode {
  switch (object) {
    case 0:
    case "RET_SUCC":
      return Retcode.RET_SUCC;
    case 1:
    case "RET_FAIL":
      return Retcode.RET_FAIL;
    case 2:
    case "RET_SERVER_INTERNAL_ERROR":
      return Retcode.RET_SERVER_INTERNAL_ERROR;
    case 3:
    case "RET_TIMEOUT":
      return Retcode.RET_TIMEOUT;
    case 4:
    case "RET_REPEATED_REQ":
      return Retcode.RET_REPEATED_REQ;
    case 5:
    case "RET_REQ_PARA_INVALID":
      return Retcode.RET_REQ_PARA_INVALID;
    case 6:
    case "RET_PLAYER_DATA_ERROR":
      return Retcode.RET_PLAYER_DATA_ERROR;
    case 7:
    case "RET_PLAYER_CLIENT_PAUSED":
      return Retcode.RET_PLAYER_CLIENT_PAUSED;
    case 8:
    case "RET_FUNC_CHECK_FAILED":
      return Retcode.RET_FUNC_CHECK_FAILED;
    case 9:
    case "RET_FEATURE_SWITCH_CLOSED":
      return Retcode.RET_FEATURE_SWITCH_CLOSED;
    case 1000:
    case "RET_REPEATE_LOGIN":
      return Retcode.RET_REPEATE_LOGIN;
    case 1001:
    case "RET_RETRY_LOGIN":
      return Retcode.RET_RETRY_LOGIN;
    case 1002:
    case "RET_WAIT_LOGIN":
      return Retcode.RET_WAIT_LOGIN;
    case 1003:
    case "RET_NOT_IN_WHITE_LIST":
      return Retcode.RET_NOT_IN_WHITE_LIST;
    case 1004:
    case "RET_IN_BLACK_LIST":
      return Retcode.RET_IN_BLACK_LIST;
    case 1005:
    case "RET_ACCOUNT_VERIFY_ERROR":
      return Retcode.RET_ACCOUNT_VERIFY_ERROR;
    case 1006:
    case "RET_ACCOUNT_PARA_ERROR":
      return Retcode.RET_ACCOUNT_PARA_ERROR;
    case 1007:
    case "RET_ANTI_ADDICT_LOGIN":
      return Retcode.RET_ANTI_ADDICT_LOGIN;
    case 1008:
    case "RET_CHECK_SUM_ERROR":
      return Retcode.RET_CHECK_SUM_ERROR;
    case 1009:
    case "RET_REACH_MAX_PLAYER_NUM":
      return Retcode.RET_REACH_MAX_PLAYER_NUM;
    case 1010:
    case "RET_ALREADY_REGISTERED":
      return Retcode.RET_ALREADY_REGISTERED;
    case 1011:
    case "RET_GENDER_ERROR":
      return Retcode.RET_GENDER_ERROR;
    case 1012:
    case "SET_NICKNAME_RET_CALLBACK_PROCESSING":
      return Retcode.SET_NICKNAME_RET_CALLBACK_PROCESSING;
    case 1013:
    case "RET_IN_GM_BIND_ACCESS":
      return Retcode.RET_IN_GM_BIND_ACCESS;
    case 1100:
    case "RET_QUEST_REWARD_ALREADY_TAKEN":
      return Retcode.RET_QUEST_REWARD_ALREADY_TAKEN;
    case 1101:
    case "RET_QUEST_NOT_ACCEPT":
      return Retcode.RET_QUEST_NOT_ACCEPT;
    case 1102:
    case "RET_QUEST_NOT_FINISH":
      return Retcode.RET_QUEST_NOT_FINISH;
    case 1103:
    case "RET_QUEST_STATUS_ERROR":
      return Retcode.RET_QUEST_STATUS_ERROR;
    case 1104:
    case "RET_ACHIEVEMENT_LEVEL_NOT_REACH":
      return Retcode.RET_ACHIEVEMENT_LEVEL_NOT_REACH;
    case 1105:
    case "RET_ACHIEVEMENT_LEVEL_ALREADY_TAKEN":
      return Retcode.RET_ACHIEVEMENT_LEVEL_ALREADY_TAKEN;
    case 1200:
    case "RET_AVATAR_NOT_EXIST":
      return Retcode.RET_AVATAR_NOT_EXIST;
    case 1201:
    case "RET_AVATAR_RES_EXP_NOT_ENOUGH":
      return Retcode.RET_AVATAR_RES_EXP_NOT_ENOUGH;
    case 1202:
    case "RET_AVATAR_EXP_REACH_PROMOTION_LIMIT":
      return Retcode.RET_AVATAR_EXP_REACH_PROMOTION_LIMIT;
    case 1203:
    case "RET_AVATAR_REACH_MAX_PROMOTION":
      return Retcode.RET_AVATAR_REACH_MAX_PROMOTION;
    case 1204:
    case "RET_SKILLTREE_CONFIG_NOT_EXIST":
      return Retcode.RET_SKILLTREE_CONFIG_NOT_EXIST;
    case 1205:
    case "RET_SKILLTREE_ALREADY_UNLOCK":
      return Retcode.RET_SKILLTREE_ALREADY_UNLOCK;
    case 1206:
    case "RET_SKILLTREE_PRE_LOCKED":
      return Retcode.RET_SKILLTREE_PRE_LOCKED;
    case 1207:
    case "RET_SKILLTREE_LEVEL_NOT_MEET":
      return Retcode.RET_SKILLTREE_LEVEL_NOT_MEET;
    case 1208:
    case "RET_SKILLTREE_RANK_NOT_MEET":
      return Retcode.RET_SKILLTREE_RANK_NOT_MEET;
    case 1209:
    case "RET_AVATAR_DRESS_NO_EQUIPMENT":
      return Retcode.RET_AVATAR_DRESS_NO_EQUIPMENT;
    case 1210:
    case "RET_AVATAR_EXP_ITEM_NOT_EXIST":
      return Retcode.RET_AVATAR_EXP_ITEM_NOT_EXIST;
    case 1211:
    case "RET_SKILLTREE_POINT_UNLOCK":
      return Retcode.RET_SKILLTREE_POINT_UNLOCK;
    case 1212:
    case "RET_SKILLTREE_POINT_LEVEL_UPGRADE_NOT_MATCH":
      return Retcode.RET_SKILLTREE_POINT_LEVEL_UPGRADE_NOT_MATCH;
    case 1213:
    case "RET_SKILLTREE_POINT_LEVEL_REACH_MAX":
      return Retcode.RET_SKILLTREE_POINT_LEVEL_REACH_MAX;
    case 1214:
    case "RET_WORLD_LEVEL_NOT_MEET":
      return Retcode.RET_WORLD_LEVEL_NOT_MEET;
    case 1215:
    case "RET_PLAYER_LEVEL_NOT_MEET":
      return Retcode.RET_PLAYER_LEVEL_NOT_MEET;
    case 1216:
    case "RET_AVATAR_RANK_NOT_MATCH":
      return Retcode.RET_AVATAR_RANK_NOT_MATCH;
    case 1217:
    case "RET_AVATAR_RANK_REACH_MAX":
      return Retcode.RET_AVATAR_RANK_REACH_MAX;
    case 1218:
    case "RET_HERO_BASIC_TYPE_NOT_MATCH":
      return Retcode.RET_HERO_BASIC_TYPE_NOT_MATCH;
    case 1300:
    case "RET_ITEM_NOT_EXIST":
      return Retcode.RET_ITEM_NOT_EXIST;
    case 1301:
    case "RET_ITEM_COST_NOT_ENOUGH":
      return Retcode.RET_ITEM_COST_NOT_ENOUGH;
    case 1302:
    case "RET_ITEM_COST_TOO_MUCH":
      return Retcode.RET_ITEM_COST_TOO_MUCH;
    case 1303:
    case "RET_ITEM_NO_COST":
      return Retcode.RET_ITEM_NO_COST;
    case 1304:
    case "RET_ITEM_NOT_ENOUGH":
      return Retcode.RET_ITEM_NOT_ENOUGH;
    case 1305:
    case "RET_ITEM_INVALID":
      return Retcode.RET_ITEM_INVALID;
    case 1306:
    case "RET_ITEM_CONFIG_NOT_EXIST":
      return Retcode.RET_ITEM_CONFIG_NOT_EXIST;
    case 1307:
    case "RET_SCOIN_NOT_ENOUGH":
      return Retcode.RET_SCOIN_NOT_ENOUGH;
    case 1308:
    case "RET_ITEM_REWARD_EXCEED_LIMIT":
      return Retcode.RET_ITEM_REWARD_EXCEED_LIMIT;
    case 1309:
    case "RET_ITEM_INVALID_USE":
      return Retcode.RET_ITEM_INVALID_USE;
    case 1310:
    case "RET_ITEM_USE_CONFIG_NOT_EXIST":
      return Retcode.RET_ITEM_USE_CONFIG_NOT_EXIST;
    case 1311:
    case "RET_REWARD_CONFIG_NOT_EXIST":
      return Retcode.RET_REWARD_CONFIG_NOT_EXIST;
    case 1312:
    case "RET_ITEM_EXCEED_LIMIT":
      return Retcode.RET_ITEM_EXCEED_LIMIT;
    case 1313:
    case "RET_ITEM_COUNT_INVALID":
      return Retcode.RET_ITEM_COUNT_INVALID;
    case 1314:
    case "RET_ITEM_USE_TARGET_TYPE_INVALID":
      return Retcode.RET_ITEM_USE_TARGET_TYPE_INVALID;
    case 1315:
    case "RET_ITEM_USE_SATIETY_FULL":
      return Retcode.RET_ITEM_USE_SATIETY_FULL;
    case 1316:
    case "RET_ITEM_COMPOSE_NOT_EXIST":
      return Retcode.RET_ITEM_COMPOSE_NOT_EXIST;
    case 1317:
    case "RET_RELIC_COMPOSE_NOT_EXIST":
      return Retcode.RET_RELIC_COMPOSE_NOT_EXIST;
    case 1318:
    case "RET_ITEM_CAN_NOT_SELL":
      return Retcode.RET_ITEM_CAN_NOT_SELL;
    case 1319:
    case "RET_ITEM_SELL_EXCEDD_LIMIT":
      return Retcode.RET_ITEM_SELL_EXCEDD_LIMIT;
    case 1350:
    case "RET_EQUIPMENT_ALREADY_DRESSED":
      return Retcode.RET_EQUIPMENT_ALREADY_DRESSED;
    case 1351:
    case "RET_EQUIPMENT_NOT_EXIST":
      return Retcode.RET_EQUIPMENT_NOT_EXIST;
    case 1352:
    case "RET_EQUIPMENT_REACH_LEVEL_LIMIT":
      return Retcode.RET_EQUIPMENT_REACH_LEVEL_LIMIT;
    case 1353:
    case "RET_EQUIPMENT_CONSUME_SELF":
      return Retcode.RET_EQUIPMENT_CONSUME_SELF;
    case 1354:
    case "RET_EQUIPMENT_ALREADY_LOCKED":
      return Retcode.RET_EQUIPMENT_ALREADY_LOCKED;
    case 1355:
    case "RET_EQUIPMENT_ALREADY_UNLOCKED":
      return Retcode.RET_EQUIPMENT_ALREADY_UNLOCKED;
    case 1356:
    case "RET_EQUIPMENT_LOCKED":
      return Retcode.RET_EQUIPMENT_LOCKED;
    case 1357:
    case "RET_EQUIPMENT_SELECT_NUM_OVER_LIMIT":
      return Retcode.RET_EQUIPMENT_SELECT_NUM_OVER_LIMIT;
    case 1358:
    case "RET_EQUIPMENT_RANK_UP_MUST_CONSUME_SAME_TID":
      return Retcode.RET_EQUIPMENT_RANK_UP_MUST_CONSUME_SAME_TID;
    case 1359:
    case "RET_EQUIPMENT_PROMOTION_REACH_MAX":
      return Retcode.RET_EQUIPMENT_PROMOTION_REACH_MAX;
    case 1360:
    case "RET_EQUIPMENT_RANK_UP_REACH_MAX":
      return Retcode.RET_EQUIPMENT_RANK_UP_REACH_MAX;
    case 1361:
    case "RET_EQUIPMENT_LEVEL_REACH_MAX":
      return Retcode.RET_EQUIPMENT_LEVEL_REACH_MAX;
    case 1362:
    case "RET_EQUIPMENT_EXCEED_LIMIT":
      return Retcode.RET_EQUIPMENT_EXCEED_LIMIT;
    case 1363:
    case "RET_RELIC_NOT_EXIST":
      return Retcode.RET_RELIC_NOT_EXIST;
    case 1364:
    case "RET_RELIC_REACH_LEVEL_LIMIT":
      return Retcode.RET_RELIC_REACH_LEVEL_LIMIT;
    case 1365:
    case "RET_RELIC_CONSUME_SELF":
      return Retcode.RET_RELIC_CONSUME_SELF;
    case 1366:
    case "RET_RELIC_ALREADY_DRESSED":
      return Retcode.RET_RELIC_ALREADY_DRESSED;
    case 1367:
    case "RET_RELIC_LOCKED":
      return Retcode.RET_RELIC_LOCKED;
    case 1368:
    case "RET_RELIC_ALREADY_LOCKED":
      return Retcode.RET_RELIC_ALREADY_LOCKED;
    case 1369:
    case "RET_RELIC_ALREADY_UNLOCKED":
      return Retcode.RET_RELIC_ALREADY_UNLOCKED;
    case 1370:
    case "RET_RELIC_LEVEL_IS_NOT_ZERO":
      return Retcode.RET_RELIC_LEVEL_IS_NOT_ZERO;
    case 1400:
    case "RET_LINEUP_INVALID_INDEX":
      return Retcode.RET_LINEUP_INVALID_INDEX;
    case 1401:
    case "RET_LINEUP_INVALID_MEMBER_POS":
      return Retcode.RET_LINEUP_INVALID_MEMBER_POS;
    case 1402:
    case "RET_LINEUP_SWAP_NOT_EXIST":
      return Retcode.RET_LINEUP_SWAP_NOT_EXIST;
    case 1403:
    case "RET_LINEUP_AVATAR_ALREADY_IN":
      return Retcode.RET_LINEUP_AVATAR_ALREADY_IN;
    case 1404:
    case "RET_LINEUP_CREATE_AVATAR_ERROR":
      return Retcode.RET_LINEUP_CREATE_AVATAR_ERROR;
    case 1405:
    case "RET_LINEUP_AVATAR_INIT_ERROR":
      return Retcode.RET_LINEUP_AVATAR_INIT_ERROR;
    case 1406:
    case "RET_LINEUP_NOT_EXIST":
      return Retcode.RET_LINEUP_NOT_EXIST;
    case 1407:
    case "RET_LINEUP_ONLY_ONE_MEMBER":
      return Retcode.RET_LINEUP_ONLY_ONE_MEMBER;
    case 1408:
    case "RET_LINEUP_SAME_LEADER_SLOT":
      return Retcode.RET_LINEUP_SAME_LEADER_SLOT;
    case 1409:
    case "RET_LINEUP_NO_LEADER_SELECT":
      return Retcode.RET_LINEUP_NO_LEADER_SELECT;
    case 1410:
    case "RET_LINEUP_SWAP_SAME_SLOT":
      return Retcode.RET_LINEUP_SWAP_SAME_SLOT;
    case 1411:
    case "RET_LINEUP_AVATAR_NOT_EXIST":
      return Retcode.RET_LINEUP_AVATAR_NOT_EXIST;
    case 1412:
    case "RET_LINEUP_TRIAL_AVATAR_CAN_NOT_QUIT":
      return Retcode.RET_LINEUP_TRIAL_AVATAR_CAN_NOT_QUIT;
    case 1413:
    case "RET_LINEUP_VIRTUAL_LINEUP_PLANE_NOT_MATCH":
      return Retcode.RET_LINEUP_VIRTUAL_LINEUP_PLANE_NOT_MATCH;
    case 1414:
    case "RET_LINEUP_NOT_VALID_LEADER":
      return Retcode.RET_LINEUP_NOT_VALID_LEADER;
    case 1415:
    case "RET_LINEUP_SAME_INDEX":
      return Retcode.RET_LINEUP_SAME_INDEX;
    case 1416:
    case "RET_LINEUP_IS_EMPTY":
      return Retcode.RET_LINEUP_IS_EMPTY;
    case 1417:
    case "RET_LINEUP_NAME_FORMAT_ERROR":
      return Retcode.RET_LINEUP_NAME_FORMAT_ERROR;
    case 1418:
    case "RET_LINEUP_TYPE_NOT_MATCH":
      return Retcode.RET_LINEUP_TYPE_NOT_MATCH;
    case 1419:
    case "RET_LINEUP_REPLACE_ALL_FAILED":
      return Retcode.RET_LINEUP_REPLACE_ALL_FAILED;
    case 1420:
    case "RET_LINEUP_NOT_ALLOW_EDIT":
      return Retcode.RET_LINEUP_NOT_ALLOW_EDIT;
    case 1421:
    case "RET_LINEUP_AVATAR_IS_ALIVE":
      return Retcode.RET_LINEUP_AVATAR_IS_ALIVE;
    case 1700:
    case "RET_MAIL_NOT_EXIST":
      return Retcode.RET_MAIL_NOT_EXIST;
    case 1701:
    case "RET_MAIL_RANGE_INVALID":
      return Retcode.RET_MAIL_RANGE_INVALID;
    case 1702:
    case "RET_MAIL_MAIL_ID_INVALID":
      return Retcode.RET_MAIL_MAIL_ID_INVALID;
    case 1703:
    case "RET_MAIL_NO_MAIL_TAKE_ATTACHMENT":
      return Retcode.RET_MAIL_NO_MAIL_TAKE_ATTACHMENT;
    case 1704:
    case "RET_MAIL_NO_MAIL_TO_DEL":
      return Retcode.RET_MAIL_NO_MAIL_TO_DEL;
    case 1800:
    case "RET_STAGE_SETTLE_ERROR":
      return Retcode.RET_STAGE_SETTLE_ERROR;
    case 1801:
    case "RET_STAGE_CONFIG_NOT_EXIST":
      return Retcode.RET_STAGE_CONFIG_NOT_EXIST;
    case 1802:
    case "RET_STAGE_NOT_FOUND":
      return Retcode.RET_STAGE_NOT_FOUND;
    case 1804:
    case "RET_STAGE_COCOON_PROP_NOT_VALID":
      return Retcode.RET_STAGE_COCOON_PROP_NOT_VALID;
    case 1805:
    case "RET_STAGE_COCOON_WAVE_NOT_VALID":
      return Retcode.RET_STAGE_COCOON_WAVE_NOT_VALID;
    case 1806:
    case "RET_STAGE_PROP_ID_NOT_EQUAL":
      return Retcode.RET_STAGE_PROP_ID_NOT_EQUAL;
    case 1807:
    case "RET_STAGE_COCOON_WAVE_OVER":
      return Retcode.RET_STAGE_COCOON_WAVE_OVER;
    case 1808:
    case "RET_STAGE_WEEK_COCOON_OVER_CNT":
      return Retcode.RET_STAGE_WEEK_COCOON_OVER_CNT;
    case 1809:
    case "RET_STAGE_COCOON_NOT_OPEN":
      return Retcode.RET_STAGE_COCOON_NOT_OPEN;
    case 1900:
    case "RET_CHAPTER_LOCK":
      return Retcode.RET_CHAPTER_LOCK;
    case 1901:
    case "RET_CHAPTER_CHALLENGE_NUM_NOT_ENOUGH":
      return Retcode.RET_CHAPTER_CHALLENGE_NUM_NOT_ENOUGH;
    case 1902:
    case "RET_CHAPTER_REWARD_ID_NOT_EXIST":
      return Retcode.RET_CHAPTER_REWARD_ID_NOT_EXIST;
    case 1903:
    case "RET_CHAPTER_REWARD_ALREADY_TAKEN":
      return Retcode.RET_CHAPTER_REWARD_ALREADY_TAKEN;
    case 2000:
    case "RET_BATTLE_STAGE_NOT_MATCH":
      return Retcode.RET_BATTLE_STAGE_NOT_MATCH;
    case 2001:
    case "RET_IN_BATTLE_NOW":
      return Retcode.RET_IN_BATTLE_NOW;
    case 2002:
    case "RET_BATTLE_CHEAT":
      return Retcode.RET_BATTLE_CHEAT;
    case 2003:
    case "RET_BATTLE_FAIL":
      return Retcode.RET_BATTLE_FAIL;
    case 2004:
    case "RET_BATTLE_NO_LINEUP":
      return Retcode.RET_BATTLE_NO_LINEUP;
    case 2005:
    case "RET_BATTLE_LINEUP_EMPTY":
      return Retcode.RET_BATTLE_LINEUP_EMPTY;
    case 2006:
    case "RET_BATTLE_VERSION_NOT_MATCH":
      return Retcode.RET_BATTLE_VERSION_NOT_MATCH;
    case 2007:
    case "RET_BATTLE_QUIT_BY_SERVER":
      return Retcode.RET_BATTLE_QUIT_BY_SERVER;
    case 2100:
    case "RET_LACK_EXCHANGE_STAMINA_TIMES":
      return Retcode.RET_LACK_EXCHANGE_STAMINA_TIMES;
    case 2101:
    case "RET_LACK_STAMINA":
      return Retcode.RET_LACK_STAMINA;
    case 2102:
    case "RET_STAMINA_FULL":
      return Retcode.RET_STAMINA_FULL;
    case 2103:
    case "RET_AUTHKEY_SIGN_TYPE_ERROR":
      return Retcode.RET_AUTHKEY_SIGN_TYPE_ERROR;
    case 2104:
    case "RET_AUTHKEY_SIGN_VER_ERROR":
      return Retcode.RET_AUTHKEY_SIGN_VER_ERROR;
    case 2105:
    case "RET_NICKNAME_FORMAT_ERROR":
      return Retcode.RET_NICKNAME_FORMAT_ERROR;
    case 2106:
    case "RET_SENSITIVE_WORDS":
      return Retcode.RET_SENSITIVE_WORDS;
    case 2107:
    case "RET_LEVEL_REWARD_HAS_TAKEN":
      return Retcode.RET_LEVEL_REWARD_HAS_TAKEN;
    case 2108:
    case "RET_LEVEL_REWARD_LEVEL_ERROR":
      return Retcode.RET_LEVEL_REWARD_LEVEL_ERROR;
    case 2109:
    case "RET_LANGUAGE_INVALID":
      return Retcode.RET_LANGUAGE_INVALID;
    case 2200:
    case "RET_MAZE_NOT_FINISH":
      return Retcode.RET_MAZE_NOT_FINISH;
    case 2201:
    case "RET_MAZE_LACK_TICKET":
      return Retcode.RET_MAZE_LACK_TICKET;
    case 2202:
    case "RET_MAZE_NOT_UNLOCK":
      return Retcode.RET_MAZE_NOT_UNLOCK;
    case 2203:
    case "RET_MAZE_DIFFICULTY_LIMIT":
      return Retcode.RET_MAZE_DIFFICULTY_LIMIT;
    case 2204:
    case "RET_MAZE_NO_ABILITY":
      return Retcode.RET_MAZE_NO_ABILITY;
    case 2205:
    case "RET_MAZE_NO_PLANE":
      return Retcode.RET_MAZE_NO_PLANE;
    case 2206:
    case "RET_MAZE_STAGE_DISMATCH":
      return Retcode.RET_MAZE_STAGE_DISMATCH;
    case 2207:
    case "RET_MAZE_MAP_NOT_EXIST":
      return Retcode.RET_MAZE_MAP_NOT_EXIST;
    case 2208:
    case "RET_MAZE_TYPE_NOT_EXIST":
      return Retcode.RET_MAZE_TYPE_NOT_EXIST;
    case 2209:
    case "RET_MAZE_ALREADY_FINISH":
      return Retcode.RET_MAZE_ALREADY_FINISH;
    case 2210:
    case "RET_MAZE_PROP_NOT_EXIST":
      return Retcode.RET_MAZE_PROP_NOT_EXIST;
    case 2211:
    case "RET_MAZE_POSITION_TOO_FAR":
      return Retcode.RET_MAZE_POSITION_TOO_FAR;
    case 2212:
    case "RET_MAZE_SKILL_CAST_CNT_REACH_MAX":
      return Retcode.RET_MAZE_SKILL_CAST_CNT_REACH_MAX;
    case 2213:
    case "RET_MAZE_MP_NOT_ENOUGH":
      return Retcode.RET_MAZE_MP_NOT_ENOUGH;
    case 2214:
    case "RET_SPRING_NOT_ENABLE":
      return Retcode.RET_SPRING_NOT_ENABLE;
    case 2215:
    case "RET_SPRING_REFRESH_IN_CD":
      return Retcode.RET_SPRING_REFRESH_IN_CD;
    case 2216:
    case "RET_SPRING_TOO_FAR":
      return Retcode.RET_SPRING_TOO_FAR;
    case 2217:
    case "RET_MAZE_NO_FLOOR":
      return Retcode.RET_MAZE_NO_FLOOR;
    case 2218:
    case "RET_NOT_IN_MAZE":
      return Retcode.RET_NOT_IN_MAZE;
    case 2219:
    case "RET_PLANE_ID_NOT_MATCH":
      return Retcode.RET_PLANE_ID_NOT_MATCH;
    case 2220:
    case "RET_FLOOR_ID_NOT_MATCH":
      return Retcode.RET_FLOOR_ID_NOT_MATCH;
    case 2221:
    case "RET_SAVEPOINTS_TIMES_ZERO":
      return Retcode.RET_SAVEPOINTS_TIMES_ZERO;
    case 2222:
    case "RET_MAZE_TIME_OF_DAY_TYPE_IS_SAME":
      return Retcode.RET_MAZE_TIME_OF_DAY_TYPE_IS_SAME;
    case 2223:
    case "RET_MAZE_TIME_OF_DAY_TYPE_ERROR":
      return Retcode.RET_MAZE_TIME_OF_DAY_TYPE_ERROR;
    case 2300:
    case "RET_PLOT_NOT_UNLOCK":
      return Retcode.RET_PLOT_NOT_UNLOCK;
    case 2400:
    case "RET_MISSION_NOT_EXIST":
      return Retcode.RET_MISSION_NOT_EXIST;
    case 2401:
    case "RET_MISSION_ALREADY_DONE":
      return Retcode.RET_MISSION_ALREADY_DONE;
    case 2402:
    case "RET_DAILY_TASK_NOT_FINISH":
      return Retcode.RET_DAILY_TASK_NOT_FINISH;
    case 2403:
    case "RET_DAILY_TASK_REWARD_HAS_TAKEN":
      return Retcode.RET_DAILY_TASK_REWARD_HAS_TAKEN;
    case 2404:
    case "RET_MISSION_NOT_FINISH":
      return Retcode.RET_MISSION_NOT_FINISH;
    case 2405:
    case "RET_MISSION_NOT_DOING":
      return Retcode.RET_MISSION_NOT_DOING;
    case 2406:
    case "RET_MISSION_FINISH_WAY_NOT_MATCH":
      return Retcode.RET_MISSION_FINISH_WAY_NOT_MATCH;
    case 2407:
    case "RET_MISSION_SCENE_NOT_MATCH":
      return Retcode.RET_MISSION_SCENE_NOT_MATCH;
    case 2500:
    case "RET_ADVENTURE_MAP_NOT_EXIST":
      return Retcode.RET_ADVENTURE_MAP_NOT_EXIST;
    case 2600:
    case "RET_SCENE_ENTITY_NOT_EXIST":
      return Retcode.RET_SCENE_ENTITY_NOT_EXIST;
    case 2601:
    case "RET_NOT_IN_SCENE":
      return Retcode.RET_NOT_IN_SCENE;
    case 2602:
    case "RET_SCENE_MONSTER_NOT_EXIST":
      return Retcode.RET_SCENE_MONSTER_NOT_EXIST;
    case 2603:
    case "RET_INTERACT_CONFIG_NOT_EXIST":
      return Retcode.RET_INTERACT_CONFIG_NOT_EXIST;
    case 2604:
    case "RET_UNSUPPORTED_PROP_STATE":
      return Retcode.RET_UNSUPPORTED_PROP_STATE;
    case 2605:
    case "RET_SCENE_ENTRY_ID_NOT_MATCH":
      return Retcode.RET_SCENE_ENTRY_ID_NOT_MATCH;
    case 2607:
    case "RET_ASSIST_MONSTER_COUNT_LIMIT":
      return Retcode.RET_ASSIST_MONSTER_COUNT_LIMIT;
    case 2608:
    case "RET_SCENE_USE_SKILL_FAIL":
      return Retcode.RET_SCENE_USE_SKILL_FAIL;
    case 2609:
    case "RET_PROP_IS_HIDDEN":
      return Retcode.RET_PROP_IS_HIDDEN;
    case 2610:
    case "RET_LOADING_SUCC_ALREADY":
      return Retcode.RET_LOADING_SUCC_ALREADY;
    case 2611:
    case "RET_SCENE_ENTITY_TYPE_INVALID":
      return Retcode.RET_SCENE_ENTITY_TYPE_INVALID;
    case 2612:
    case "RET_INTERACT_TYPE_INVALID":
      return Retcode.RET_INTERACT_TYPE_INVALID;
    case 2613:
    case "RET_INTERACT_NOT_IN_REGION":
      return Retcode.RET_INTERACT_NOT_IN_REGION;
    case 2614:
    case "RET_INTERACT_SUB_TYPE_INVALID":
      return Retcode.RET_INTERACT_SUB_TYPE_INVALID;
    case 2615:
    case "RET_NOT_LEADER_ENTITY":
      return Retcode.RET_NOT_LEADER_ENTITY;
    case 2616:
    case "RET_MONSTER_IS_NOT_FARM_ELEMENT":
      return Retcode.RET_MONSTER_IS_NOT_FARM_ELEMENT;
    case 2617:
    case "RET_MONSTER_CONFIG_NOT_EXIST":
      return Retcode.RET_MONSTER_CONFIG_NOT_EXIST;
    case 2618:
    case "RET_AVATAR_HP_ALREADY_FULL":
      return Retcode.RET_AVATAR_HP_ALREADY_FULL;
    case 2700:
    case "RET_BUY_TIMES_LIMIT":
      return Retcode.RET_BUY_TIMES_LIMIT;
    case 2701:
    case "RET_BUY_LIMIT_TYPE":
      return Retcode.RET_BUY_LIMIT_TYPE;
    case 2702:
    case "RET_SHOP_NOT_OPEN":
      return Retcode.RET_SHOP_NOT_OPEN;
    case 2703:
    case "RET_GOODS_NOT_OPEN":
      return Retcode.RET_GOODS_NOT_OPEN;
    case 2751:
    case "RET_TUTORIAL_NOT_UNLOCK":
      return Retcode.RET_TUTORIAL_NOT_UNLOCK;
    case 2752:
    case "RET_TUTORIAL_UNLOCK_ALREADY":
      return Retcode.RET_TUTORIAL_UNLOCK_ALREADY;
    case 2753:
    case "RET_TUTORIAL_FINISH_ALREADY":
      return Retcode.RET_TUTORIAL_FINISH_ALREADY;
    case 2754:
    case "RET_TUTORIAL_PRE_NOT_UNLOCK":
      return Retcode.RET_TUTORIAL_PRE_NOT_UNLOCK;
    case 2755:
    case "RET_TUTORIAL_PLAYER_LEVEL_NOT_MATCH":
      return Retcode.RET_TUTORIAL_PLAYER_LEVEL_NOT_MATCH;
    case 2756:
    case "RET_TUTORIAL_TUTORIAL_NOT_FOUND":
      return Retcode.RET_TUTORIAL_TUTORIAL_NOT_FOUND;
    case 2801:
    case "RET_CHALLENGE_NOT_EXIST":
      return Retcode.RET_CHALLENGE_NOT_EXIST;
    case 2802:
    case "RET_CHALLENGE_NOT_UNLOCK":
      return Retcode.RET_CHALLENGE_NOT_UNLOCK;
    case 2803:
    case "RET_CHALLENGE_ALREADY":
      return Retcode.RET_CHALLENGE_ALREADY;
    case 2804:
    case "RET_CHALLENGE_LINEUP_EDIT_FORBIDDEN":
      return Retcode.RET_CHALLENGE_LINEUP_EDIT_FORBIDDEN;
    case 2805:
    case "RET_CHALLENGE_LINEUP_EMPTY":
      return Retcode.RET_CHALLENGE_LINEUP_EMPTY;
    case 2806:
    case "RET_CHALLENGE_NOT_DOING":
      return Retcode.RET_CHALLENGE_NOT_DOING;
    case 2807:
    case "RET_CHALLENGE_NOT_FINISH":
      return Retcode.RET_CHALLENGE_NOT_FINISH;
    case 2808:
    case "RET_CHALLENGE_TARGET_NOT_FINISH":
      return Retcode.RET_CHALLENGE_TARGET_NOT_FINISH;
    case 2809:
    case "RET_CHALLENGE_TARGET_REWARD_TAKEN":
      return Retcode.RET_CHALLENGE_TARGET_REWARD_TAKEN;
    case 2810:
    case "RET_CHALLENGE_TIME_NOT_VALID":
      return Retcode.RET_CHALLENGE_TIME_NOT_VALID;
    case 2850:
    case "RET_BASIC_TYPE_ALREADY":
      return Retcode.RET_BASIC_TYPE_ALREADY;
    case 2851:
    case "RET_NO_BASIC_TYPE":
      return Retcode.RET_NO_BASIC_TYPE;
    case 2852:
    case "RET_NOT_CHOOSE_BASIC_TYPE":
      return Retcode.RET_NOT_CHOOSE_BASIC_TYPE;
    case 2853:
    case "RET_NOT_FUNC_CLOSE":
      return Retcode.RET_NOT_FUNC_CLOSE;
    case 2901:
    case "RET_ROGUE_STATUS_NOT_MATCH":
      return Retcode.RET_ROGUE_STATUS_NOT_MATCH;
    case 2902:
    case "RET_ROGUE_SELECT_BUFF_NOT_EXIST":
      return Retcode.RET_ROGUE_SELECT_BUFF_NOT_EXIST;
    case 2903:
    case "RET_ROGUE_COIN_NOT_ENOUGH":
      return Retcode.RET_ROGUE_COIN_NOT_ENOUGH;
    case 2904:
    case "RET_ROGUE_STAMINA_NOT_ENOUGH":
      return Retcode.RET_ROGUE_STAMINA_NOT_ENOUGH;
    case 2905:
    case "RET_ROGUE_COUNT_INVALID":
      return Retcode.RET_ROGUE_COUNT_INVALID;
    case 2906:
    case "RET_ROGUE_PROP_ALREADY_USED":
      return Retcode.RET_ROGUE_PROP_ALREADY_USED;
    case 2907:
    case "RET_ROGUE_RECORD_ALREADY_SAVED":
      return Retcode.RET_ROGUE_RECORD_ALREADY_SAVED;
    case 2908:
    case "RET_ROGUE_ROLL_BUFF_MAX_COUNT":
      return Retcode.RET_ROGUE_ROLL_BUFF_MAX_COUNT;
    case 2909:
    case "RET_ROGUE_PICK_AVATAR_INVALID":
      return Retcode.RET_ROGUE_PICK_AVATAR_INVALID;
    case 2910:
    case "RET_ROGUE_QUEST_EXPIRE":
      return Retcode.RET_ROGUE_QUEST_EXPIRE;
    case 2911:
    case "RET_ROGUE_QUEST_REWARD_ALREADY":
      return Retcode.RET_ROGUE_QUEST_REWARD_ALREADY;
    case 2951:
    case "RET_MISSION_EVENT_CONFIG_NOT_EXIST":
      return Retcode.RET_MISSION_EVENT_CONFIG_NOT_EXIST;
    case 2952:
    case "RET_MISSION_EVENT_NOT_CLIENT":
      return Retcode.RET_MISSION_EVENT_NOT_CLIENT;
    case 2953:
    case "RET_MISSION_EVENT_FINISHED":
      return Retcode.RET_MISSION_EVENT_FINISHED;
    case 2954:
    case "RET_MISSION_EVENT_DOING":
      return Retcode.RET_MISSION_EVENT_DOING;
    case 2955:
    case "RET_HAS_CHALLENGE_MISSION_EVENT":
      return Retcode.RET_HAS_CHALLENGE_MISSION_EVENT;
    case 2956:
    case "RET_NOT_CHALLENGE_MISSION_EVENT":
      return Retcode.RET_NOT_CHALLENGE_MISSION_EVENT;
    case 3001:
    case "RET_GACHA_ID_NOT_EXIST":
      return Retcode.RET_GACHA_ID_NOT_EXIST;
    case 3002:
    case "RET_GACHA_NUM_INVALID":
      return Retcode.RET_GACHA_NUM_INVALID;
    case 3003:
    case "RET_GACHA_FIRST_GACHA_MUST_ONE":
      return Retcode.RET_GACHA_FIRST_GACHA_MUST_ONE;
    case 3004:
    case "RET_GACHA_REQ_DUPLICATED":
      return Retcode.RET_GACHA_REQ_DUPLICATED;
    case 3005:
    case "RET_GACHA_NOT_IN_SCHEDULE":
      return Retcode.RET_GACHA_NOT_IN_SCHEDULE;
    case 3006:
    case "RET_GACHA_NEWBIE_CLOSE":
      return Retcode.RET_GACHA_NEWBIE_CLOSE;
    case 3007:
    case "RET_GACHA_TODAY_LIMITED":
      return Retcode.RET_GACHA_TODAY_LIMITED;
    case 3051:
    case "RET_PRESTIGE_ID_NOT_EXIST":
      return Retcode.RET_PRESTIGE_ID_NOT_EXIST;
    case 3052:
    case "RET_PRESTIGE_LEVEL_REWARD_LEVEL_ERROR":
      return Retcode.RET_PRESTIGE_LEVEL_REWARD_LEVEL_ERROR;
    case 3053:
    case "RET_PRESTIGE_LEVEL_REWARD_HAS_TAKEN":
      return Retcode.RET_PRESTIGE_LEVEL_REWARD_HAS_TAKEN;
    case 3054:
    case "RET_PRESTIGE_MISSION_NOT_EXIST":
      return Retcode.RET_PRESTIGE_MISSION_NOT_EXIST;
    case 3055:
    case "RET_PRESTIGE_MISSION_NOT_FINISHED":
      return Retcode.RET_PRESTIGE_MISSION_NOT_FINISHED;
    case 3056:
    case "RET_PRESTIGE_MISSION_REWARD_HAS_TAKEN":
      return Retcode.RET_PRESTIGE_MISSION_REWARD_HAS_TAKEN;
    case 3101:
    case "RET_NOT_IN_RAID":
      return Retcode.RET_NOT_IN_RAID;
    case 3102:
    case "RET_RAID_DOING":
      return Retcode.RET_RAID_DOING;
    case 3103:
    case "RET_NOT_PROP":
      return Retcode.RET_NOT_PROP;
    case 3104:
    case "RET_RAID_ID_NOT_MATCH":
      return Retcode.RET_RAID_ID_NOT_MATCH;
    case 3105:
    case "RET_RAID_RESTART_NOT_MATCH":
      return Retcode.RET_RAID_RESTART_NOT_MATCH;
    case 3106:
    case "RET_RAID_LIMIT":
      return Retcode.RET_RAID_LIMIT;
    case 3107:
    case "RET_RAID_AVATAR_LIST_EMPTY":
      return Retcode.RET_RAID_AVATAR_LIST_EMPTY;
    case 3108:
    case "RET_RAID_AVATAR_NOT_EXIST":
      return Retcode.RET_RAID_AVATAR_NOT_EXIST;
    case 3109:
    case "RET_CHALLENGE_RAID_REWARD_ALREADY":
      return Retcode.RET_CHALLENGE_RAID_REWARD_ALREADY;
    case 3110:
    case "RET_CHALLENGE_RAID_SCORE_NOT_REACH":
      return Retcode.RET_CHALLENGE_RAID_SCORE_NOT_REACH;
    case 3111:
    case "RET_CHALLENGE_RAID_NOT_OPEN":
      return Retcode.RET_CHALLENGE_RAID_NOT_OPEN;
    case 3112:
    case "RET_RAID_FINISHED":
      return Retcode.RET_RAID_FINISHED;
    case 3151:
    case "RET_TALK_EVENT_ALREADY_TAKEN":
      return Retcode.RET_TALK_EVENT_ALREADY_TAKEN;
    case 3152:
    case "RET_NPC_ALREADY_MEET":
      return Retcode.RET_NPC_ALREADY_MEET;
    case 3153:
    case "RET_NPC_NOT_IN_CONFIG":
      return Retcode.RET_NPC_NOT_IN_CONFIG;
    case 3154:
    case "RET_DIALOGUE_GROUP_DISMATCH":
      return Retcode.RET_DIALOGUE_GROUP_DISMATCH;
    case 3155:
    case "RET_DIALOGUE_EVENT_INVALID":
      return Retcode.RET_DIALOGUE_EVENT_INVALID;
    case 3201:
    case "RET_EXPEDITION_CONFIG_NOT_EXIST":
      return Retcode.RET_EXPEDITION_CONFIG_NOT_EXIST;
    case 3202:
    case "RET_EXPEDITION_REWARD_CONFIG_NOT_EXIST":
      return Retcode.RET_EXPEDITION_REWARD_CONFIG_NOT_EXIST;
    case 3203:
    case "RET_EXPEDITION_NOT_UNLOCKED":
      return Retcode.RET_EXPEDITION_NOT_UNLOCKED;
    case 3204:
    case "RET_EXPEDITION_ALREADY_ACCEPTED":
      return Retcode.RET_EXPEDITION_ALREADY_ACCEPTED;
    case 3205:
    case "RET_EXPEDITION_REPEATED_AVATAR":
      return Retcode.RET_EXPEDITION_REPEATED_AVATAR;
    case 3206:
    case "RET_AVATAR_ALREADY_DISPATCHED":
      return Retcode.RET_AVATAR_ALREADY_DISPATCHED;
    case 3207:
    case "RET_EXPEDITION_NOT_ACCEPTED":
      return Retcode.RET_EXPEDITION_NOT_ACCEPTED;
    case 3208:
    case "RET_EXPEDITION_NOT_FINISH":
      return Retcode.RET_EXPEDITION_NOT_FINISH;
    case 3209:
    case "RET_EXPEDITION_ALREADY_FINISH":
      return Retcode.RET_EXPEDITION_ALREADY_FINISH;
    case 3301:
    case "RET_LOGIN_ACTIVITY_HAS_TAKEN":
      return Retcode.RET_LOGIN_ACTIVITY_HAS_TAKEN;
    case 3302:
    case "RET_LOGIN_ACTIVITY_DAYS_LACK":
      return Retcode.RET_LOGIN_ACTIVITY_DAYS_LACK;
    case 3501:
    case "RET_MESSAGE_CONFIG_NOT_EXIST":
      return Retcode.RET_MESSAGE_CONFIG_NOT_EXIST;
    case 3502:
    case "RET_MESSAGE_SECTION_NOT_TAKE":
      return Retcode.RET_MESSAGE_SECTION_NOT_TAKE;
    case 3503:
    case "RET_MESSAGE_GROUP_NOT_TAKE":
      return Retcode.RET_MESSAGE_GROUP_NOT_TAKE;
    case 3504:
    case "RET_MESSAGE_SECTION_ID_NOT_MATCH":
      return Retcode.RET_MESSAGE_SECTION_ID_NOT_MATCH;
    case 3505:
    case "RET_MESSAGE_SECTION_CAN_NOT_FINISH":
      return Retcode.RET_MESSAGE_SECTION_CAN_NOT_FINISH;
    case 3506:
    case "RET_MESSAGE_ITEM_CAN_NOT_FINISH":
      return Retcode.RET_MESSAGE_ITEM_CAN_NOT_FINISH;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Retcode.UNRECOGNIZED;
  }
}

export function retcodeToJSON(object: Retcode): string {
  switch (object) {
    case Retcode.RET_SUCC:
      return "RET_SUCC";
    case Retcode.RET_FAIL:
      return "RET_FAIL";
    case Retcode.RET_SERVER_INTERNAL_ERROR:
      return "RET_SERVER_INTERNAL_ERROR";
    case Retcode.RET_TIMEOUT:
      return "RET_TIMEOUT";
    case Retcode.RET_REPEATED_REQ:
      return "RET_REPEATED_REQ";
    case Retcode.RET_REQ_PARA_INVALID:
      return "RET_REQ_PARA_INVALID";
    case Retcode.RET_PLAYER_DATA_ERROR:
      return "RET_PLAYER_DATA_ERROR";
    case Retcode.RET_PLAYER_CLIENT_PAUSED:
      return "RET_PLAYER_CLIENT_PAUSED";
    case Retcode.RET_FUNC_CHECK_FAILED:
      return "RET_FUNC_CHECK_FAILED";
    case Retcode.RET_FEATURE_SWITCH_CLOSED:
      return "RET_FEATURE_SWITCH_CLOSED";
    case Retcode.RET_REPEATE_LOGIN:
      return "RET_REPEATE_LOGIN";
    case Retcode.RET_RETRY_LOGIN:
      return "RET_RETRY_LOGIN";
    case Retcode.RET_WAIT_LOGIN:
      return "RET_WAIT_LOGIN";
    case Retcode.RET_NOT_IN_WHITE_LIST:
      return "RET_NOT_IN_WHITE_LIST";
    case Retcode.RET_IN_BLACK_LIST:
      return "RET_IN_BLACK_LIST";
    case Retcode.RET_ACCOUNT_VERIFY_ERROR:
      return "RET_ACCOUNT_VERIFY_ERROR";
    case Retcode.RET_ACCOUNT_PARA_ERROR:
      return "RET_ACCOUNT_PARA_ERROR";
    case Retcode.RET_ANTI_ADDICT_LOGIN:
      return "RET_ANTI_ADDICT_LOGIN";
    case Retcode.RET_CHECK_SUM_ERROR:
      return "RET_CHECK_SUM_ERROR";
    case Retcode.RET_REACH_MAX_PLAYER_NUM:
      return "RET_REACH_MAX_PLAYER_NUM";
    case Retcode.RET_ALREADY_REGISTERED:
      return "RET_ALREADY_REGISTERED";
    case Retcode.RET_GENDER_ERROR:
      return "RET_GENDER_ERROR";
    case Retcode.SET_NICKNAME_RET_CALLBACK_PROCESSING:
      return "SET_NICKNAME_RET_CALLBACK_PROCESSING";
    case Retcode.RET_IN_GM_BIND_ACCESS:
      return "RET_IN_GM_BIND_ACCESS";
    case Retcode.RET_QUEST_REWARD_ALREADY_TAKEN:
      return "RET_QUEST_REWARD_ALREADY_TAKEN";
    case Retcode.RET_QUEST_NOT_ACCEPT:
      return "RET_QUEST_NOT_ACCEPT";
    case Retcode.RET_QUEST_NOT_FINISH:
      return "RET_QUEST_NOT_FINISH";
    case Retcode.RET_QUEST_STATUS_ERROR:
      return "RET_QUEST_STATUS_ERROR";
    case Retcode.RET_ACHIEVEMENT_LEVEL_NOT_REACH:
      return "RET_ACHIEVEMENT_LEVEL_NOT_REACH";
    case Retcode.RET_ACHIEVEMENT_LEVEL_ALREADY_TAKEN:
      return "RET_ACHIEVEMENT_LEVEL_ALREADY_TAKEN";
    case Retcode.RET_AVATAR_NOT_EXIST:
      return "RET_AVATAR_NOT_EXIST";
    case Retcode.RET_AVATAR_RES_EXP_NOT_ENOUGH:
      return "RET_AVATAR_RES_EXP_NOT_ENOUGH";
    case Retcode.RET_AVATAR_EXP_REACH_PROMOTION_LIMIT:
      return "RET_AVATAR_EXP_REACH_PROMOTION_LIMIT";
    case Retcode.RET_AVATAR_REACH_MAX_PROMOTION:
      return "RET_AVATAR_REACH_MAX_PROMOTION";
    case Retcode.RET_SKILLTREE_CONFIG_NOT_EXIST:
      return "RET_SKILLTREE_CONFIG_NOT_EXIST";
    case Retcode.RET_SKILLTREE_ALREADY_UNLOCK:
      return "RET_SKILLTREE_ALREADY_UNLOCK";
    case Retcode.RET_SKILLTREE_PRE_LOCKED:
      return "RET_SKILLTREE_PRE_LOCKED";
    case Retcode.RET_SKILLTREE_LEVEL_NOT_MEET:
      return "RET_SKILLTREE_LEVEL_NOT_MEET";
    case Retcode.RET_SKILLTREE_RANK_NOT_MEET:
      return "RET_SKILLTREE_RANK_NOT_MEET";
    case Retcode.RET_AVATAR_DRESS_NO_EQUIPMENT:
      return "RET_AVATAR_DRESS_NO_EQUIPMENT";
    case Retcode.RET_AVATAR_EXP_ITEM_NOT_EXIST:
      return "RET_AVATAR_EXP_ITEM_NOT_EXIST";
    case Retcode.RET_SKILLTREE_POINT_UNLOCK:
      return "RET_SKILLTREE_POINT_UNLOCK";
    case Retcode.RET_SKILLTREE_POINT_LEVEL_UPGRADE_NOT_MATCH:
      return "RET_SKILLTREE_POINT_LEVEL_UPGRADE_NOT_MATCH";
    case Retcode.RET_SKILLTREE_POINT_LEVEL_REACH_MAX:
      return "RET_SKILLTREE_POINT_LEVEL_REACH_MAX";
    case Retcode.RET_WORLD_LEVEL_NOT_MEET:
      return "RET_WORLD_LEVEL_NOT_MEET";
    case Retcode.RET_PLAYER_LEVEL_NOT_MEET:
      return "RET_PLAYER_LEVEL_NOT_MEET";
    case Retcode.RET_AVATAR_RANK_NOT_MATCH:
      return "RET_AVATAR_RANK_NOT_MATCH";
    case Retcode.RET_AVATAR_RANK_REACH_MAX:
      return "RET_AVATAR_RANK_REACH_MAX";
    case Retcode.RET_HERO_BASIC_TYPE_NOT_MATCH:
      return "RET_HERO_BASIC_TYPE_NOT_MATCH";
    case Retcode.RET_ITEM_NOT_EXIST:
      return "RET_ITEM_NOT_EXIST";
    case Retcode.RET_ITEM_COST_NOT_ENOUGH:
      return "RET_ITEM_COST_NOT_ENOUGH";
    case Retcode.RET_ITEM_COST_TOO_MUCH:
      return "RET_ITEM_COST_TOO_MUCH";
    case Retcode.RET_ITEM_NO_COST:
      return "RET_ITEM_NO_COST";
    case Retcode.RET_ITEM_NOT_ENOUGH:
      return "RET_ITEM_NOT_ENOUGH";
    case Retcode.RET_ITEM_INVALID:
      return "RET_ITEM_INVALID";
    case Retcode.RET_ITEM_CONFIG_NOT_EXIST:
      return "RET_ITEM_CONFIG_NOT_EXIST";
    case Retcode.RET_SCOIN_NOT_ENOUGH:
      return "RET_SCOIN_NOT_ENOUGH";
    case Retcode.RET_ITEM_REWARD_EXCEED_LIMIT:
      return "RET_ITEM_REWARD_EXCEED_LIMIT";
    case Retcode.RET_ITEM_INVALID_USE:
      return "RET_ITEM_INVALID_USE";
    case Retcode.RET_ITEM_USE_CONFIG_NOT_EXIST:
      return "RET_ITEM_USE_CONFIG_NOT_EXIST";
    case Retcode.RET_REWARD_CONFIG_NOT_EXIST:
      return "RET_REWARD_CONFIG_NOT_EXIST";
    case Retcode.RET_ITEM_EXCEED_LIMIT:
      return "RET_ITEM_EXCEED_LIMIT";
    case Retcode.RET_ITEM_COUNT_INVALID:
      return "RET_ITEM_COUNT_INVALID";
    case Retcode.RET_ITEM_USE_TARGET_TYPE_INVALID:
      return "RET_ITEM_USE_TARGET_TYPE_INVALID";
    case Retcode.RET_ITEM_USE_SATIETY_FULL:
      return "RET_ITEM_USE_SATIETY_FULL";
    case Retcode.RET_ITEM_COMPOSE_NOT_EXIST:
      return "RET_ITEM_COMPOSE_NOT_EXIST";
    case Retcode.RET_RELIC_COMPOSE_NOT_EXIST:
      return "RET_RELIC_COMPOSE_NOT_EXIST";
    case Retcode.RET_ITEM_CAN_NOT_SELL:
      return "RET_ITEM_CAN_NOT_SELL";
    case Retcode.RET_ITEM_SELL_EXCEDD_LIMIT:
      return "RET_ITEM_SELL_EXCEDD_LIMIT";
    case Retcode.RET_EQUIPMENT_ALREADY_DRESSED:
      return "RET_EQUIPMENT_ALREADY_DRESSED";
    case Retcode.RET_EQUIPMENT_NOT_EXIST:
      return "RET_EQUIPMENT_NOT_EXIST";
    case Retcode.RET_EQUIPMENT_REACH_LEVEL_LIMIT:
      return "RET_EQUIPMENT_REACH_LEVEL_LIMIT";
    case Retcode.RET_EQUIPMENT_CONSUME_SELF:
      return "RET_EQUIPMENT_CONSUME_SELF";
    case Retcode.RET_EQUIPMENT_ALREADY_LOCKED:
      return "RET_EQUIPMENT_ALREADY_LOCKED";
    case Retcode.RET_EQUIPMENT_ALREADY_UNLOCKED:
      return "RET_EQUIPMENT_ALREADY_UNLOCKED";
    case Retcode.RET_EQUIPMENT_LOCKED:
      return "RET_EQUIPMENT_LOCKED";
    case Retcode.RET_EQUIPMENT_SELECT_NUM_OVER_LIMIT:
      return "RET_EQUIPMENT_SELECT_NUM_OVER_LIMIT";
    case Retcode.RET_EQUIPMENT_RANK_UP_MUST_CONSUME_SAME_TID:
      return "RET_EQUIPMENT_RANK_UP_MUST_CONSUME_SAME_TID";
    case Retcode.RET_EQUIPMENT_PROMOTION_REACH_MAX:
      return "RET_EQUIPMENT_PROMOTION_REACH_MAX";
    case Retcode.RET_EQUIPMENT_RANK_UP_REACH_MAX:
      return "RET_EQUIPMENT_RANK_UP_REACH_MAX";
    case Retcode.RET_EQUIPMENT_LEVEL_REACH_MAX:
      return "RET_EQUIPMENT_LEVEL_REACH_MAX";
    case Retcode.RET_EQUIPMENT_EXCEED_LIMIT:
      return "RET_EQUIPMENT_EXCEED_LIMIT";
    case Retcode.RET_RELIC_NOT_EXIST:
      return "RET_RELIC_NOT_EXIST";
    case Retcode.RET_RELIC_REACH_LEVEL_LIMIT:
      return "RET_RELIC_REACH_LEVEL_LIMIT";
    case Retcode.RET_RELIC_CONSUME_SELF:
      return "RET_RELIC_CONSUME_SELF";
    case Retcode.RET_RELIC_ALREADY_DRESSED:
      return "RET_RELIC_ALREADY_DRESSED";
    case Retcode.RET_RELIC_LOCKED:
      return "RET_RELIC_LOCKED";
    case Retcode.RET_RELIC_ALREADY_LOCKED:
      return "RET_RELIC_ALREADY_LOCKED";
    case Retcode.RET_RELIC_ALREADY_UNLOCKED:
      return "RET_RELIC_ALREADY_UNLOCKED";
    case Retcode.RET_RELIC_LEVEL_IS_NOT_ZERO:
      return "RET_RELIC_LEVEL_IS_NOT_ZERO";
    case Retcode.RET_LINEUP_INVALID_INDEX:
      return "RET_LINEUP_INVALID_INDEX";
    case Retcode.RET_LINEUP_INVALID_MEMBER_POS:
      return "RET_LINEUP_INVALID_MEMBER_POS";
    case Retcode.RET_LINEUP_SWAP_NOT_EXIST:
      return "RET_LINEUP_SWAP_NOT_EXIST";
    case Retcode.RET_LINEUP_AVATAR_ALREADY_IN:
      return "RET_LINEUP_AVATAR_ALREADY_IN";
    case Retcode.RET_LINEUP_CREATE_AVATAR_ERROR:
      return "RET_LINEUP_CREATE_AVATAR_ERROR";
    case Retcode.RET_LINEUP_AVATAR_INIT_ERROR:
      return "RET_LINEUP_AVATAR_INIT_ERROR";
    case Retcode.RET_LINEUP_NOT_EXIST:
      return "RET_LINEUP_NOT_EXIST";
    case Retcode.RET_LINEUP_ONLY_ONE_MEMBER:
      return "RET_LINEUP_ONLY_ONE_MEMBER";
    case Retcode.RET_LINEUP_SAME_LEADER_SLOT:
      return "RET_LINEUP_SAME_LEADER_SLOT";
    case Retcode.RET_LINEUP_NO_LEADER_SELECT:
      return "RET_LINEUP_NO_LEADER_SELECT";
    case Retcode.RET_LINEUP_SWAP_SAME_SLOT:
      return "RET_LINEUP_SWAP_SAME_SLOT";
    case Retcode.RET_LINEUP_AVATAR_NOT_EXIST:
      return "RET_LINEUP_AVATAR_NOT_EXIST";
    case Retcode.RET_LINEUP_TRIAL_AVATAR_CAN_NOT_QUIT:
      return "RET_LINEUP_TRIAL_AVATAR_CAN_NOT_QUIT";
    case Retcode.RET_LINEUP_VIRTUAL_LINEUP_PLANE_NOT_MATCH:
      return "RET_LINEUP_VIRTUAL_LINEUP_PLANE_NOT_MATCH";
    case Retcode.RET_LINEUP_NOT_VALID_LEADER:
      return "RET_LINEUP_NOT_VALID_LEADER";
    case Retcode.RET_LINEUP_SAME_INDEX:
      return "RET_LINEUP_SAME_INDEX";
    case Retcode.RET_LINEUP_IS_EMPTY:
      return "RET_LINEUP_IS_EMPTY";
    case Retcode.RET_LINEUP_NAME_FORMAT_ERROR:
      return "RET_LINEUP_NAME_FORMAT_ERROR";
    case Retcode.RET_LINEUP_TYPE_NOT_MATCH:
      return "RET_LINEUP_TYPE_NOT_MATCH";
    case Retcode.RET_LINEUP_REPLACE_ALL_FAILED:
      return "RET_LINEUP_REPLACE_ALL_FAILED";
    case Retcode.RET_LINEUP_NOT_ALLOW_EDIT:
      return "RET_LINEUP_NOT_ALLOW_EDIT";
    case Retcode.RET_LINEUP_AVATAR_IS_ALIVE:
      return "RET_LINEUP_AVATAR_IS_ALIVE";
    case Retcode.RET_MAIL_NOT_EXIST:
      return "RET_MAIL_NOT_EXIST";
    case Retcode.RET_MAIL_RANGE_INVALID:
      return "RET_MAIL_RANGE_INVALID";
    case Retcode.RET_MAIL_MAIL_ID_INVALID:
      return "RET_MAIL_MAIL_ID_INVALID";
    case Retcode.RET_MAIL_NO_MAIL_TAKE_ATTACHMENT:
      return "RET_MAIL_NO_MAIL_TAKE_ATTACHMENT";
    case Retcode.RET_MAIL_NO_MAIL_TO_DEL:
      return "RET_MAIL_NO_MAIL_TO_DEL";
    case Retcode.RET_STAGE_SETTLE_ERROR:
      return "RET_STAGE_SETTLE_ERROR";
    case Retcode.RET_STAGE_CONFIG_NOT_EXIST:
      return "RET_STAGE_CONFIG_NOT_EXIST";
    case Retcode.RET_STAGE_NOT_FOUND:
      return "RET_STAGE_NOT_FOUND";
    case Retcode.RET_STAGE_COCOON_PROP_NOT_VALID:
      return "RET_STAGE_COCOON_PROP_NOT_VALID";
    case Retcode.RET_STAGE_COCOON_WAVE_NOT_VALID:
      return "RET_STAGE_COCOON_WAVE_NOT_VALID";
    case Retcode.RET_STAGE_PROP_ID_NOT_EQUAL:
      return "RET_STAGE_PROP_ID_NOT_EQUAL";
    case Retcode.RET_STAGE_COCOON_WAVE_OVER:
      return "RET_STAGE_COCOON_WAVE_OVER";
    case Retcode.RET_STAGE_WEEK_COCOON_OVER_CNT:
      return "RET_STAGE_WEEK_COCOON_OVER_CNT";
    case Retcode.RET_STAGE_COCOON_NOT_OPEN:
      return "RET_STAGE_COCOON_NOT_OPEN";
    case Retcode.RET_CHAPTER_LOCK:
      return "RET_CHAPTER_LOCK";
    case Retcode.RET_CHAPTER_CHALLENGE_NUM_NOT_ENOUGH:
      return "RET_CHAPTER_CHALLENGE_NUM_NOT_ENOUGH";
    case Retcode.RET_CHAPTER_REWARD_ID_NOT_EXIST:
      return "RET_CHAPTER_REWARD_ID_NOT_EXIST";
    case Retcode.RET_CHAPTER_REWARD_ALREADY_TAKEN:
      return "RET_CHAPTER_REWARD_ALREADY_TAKEN";
    case Retcode.RET_BATTLE_STAGE_NOT_MATCH:
      return "RET_BATTLE_STAGE_NOT_MATCH";
    case Retcode.RET_IN_BATTLE_NOW:
      return "RET_IN_BATTLE_NOW";
    case Retcode.RET_BATTLE_CHEAT:
      return "RET_BATTLE_CHEAT";
    case Retcode.RET_BATTLE_FAIL:
      return "RET_BATTLE_FAIL";
    case Retcode.RET_BATTLE_NO_LINEUP:
      return "RET_BATTLE_NO_LINEUP";
    case Retcode.RET_BATTLE_LINEUP_EMPTY:
      return "RET_BATTLE_LINEUP_EMPTY";
    case Retcode.RET_BATTLE_VERSION_NOT_MATCH:
      return "RET_BATTLE_VERSION_NOT_MATCH";
    case Retcode.RET_BATTLE_QUIT_BY_SERVER:
      return "RET_BATTLE_QUIT_BY_SERVER";
    case Retcode.RET_LACK_EXCHANGE_STAMINA_TIMES:
      return "RET_LACK_EXCHANGE_STAMINA_TIMES";
    case Retcode.RET_LACK_STAMINA:
      return "RET_LACK_STAMINA";
    case Retcode.RET_STAMINA_FULL:
      return "RET_STAMINA_FULL";
    case Retcode.RET_AUTHKEY_SIGN_TYPE_ERROR:
      return "RET_AUTHKEY_SIGN_TYPE_ERROR";
    case Retcode.RET_AUTHKEY_SIGN_VER_ERROR:
      return "RET_AUTHKEY_SIGN_VER_ERROR";
    case Retcode.RET_NICKNAME_FORMAT_ERROR:
      return "RET_NICKNAME_FORMAT_ERROR";
    case Retcode.RET_SENSITIVE_WORDS:
      return "RET_SENSITIVE_WORDS";
    case Retcode.RET_LEVEL_REWARD_HAS_TAKEN:
      return "RET_LEVEL_REWARD_HAS_TAKEN";
    case Retcode.RET_LEVEL_REWARD_LEVEL_ERROR:
      return "RET_LEVEL_REWARD_LEVEL_ERROR";
    case Retcode.RET_LANGUAGE_INVALID:
      return "RET_LANGUAGE_INVALID";
    case Retcode.RET_MAZE_NOT_FINISH:
      return "RET_MAZE_NOT_FINISH";
    case Retcode.RET_MAZE_LACK_TICKET:
      return "RET_MAZE_LACK_TICKET";
    case Retcode.RET_MAZE_NOT_UNLOCK:
      return "RET_MAZE_NOT_UNLOCK";
    case Retcode.RET_MAZE_DIFFICULTY_LIMIT:
      return "RET_MAZE_DIFFICULTY_LIMIT";
    case Retcode.RET_MAZE_NO_ABILITY:
      return "RET_MAZE_NO_ABILITY";
    case Retcode.RET_MAZE_NO_PLANE:
      return "RET_MAZE_NO_PLANE";
    case Retcode.RET_MAZE_STAGE_DISMATCH:
      return "RET_MAZE_STAGE_DISMATCH";
    case Retcode.RET_MAZE_MAP_NOT_EXIST:
      return "RET_MAZE_MAP_NOT_EXIST";
    case Retcode.RET_MAZE_TYPE_NOT_EXIST:
      return "RET_MAZE_TYPE_NOT_EXIST";
    case Retcode.RET_MAZE_ALREADY_FINISH:
      return "RET_MAZE_ALREADY_FINISH";
    case Retcode.RET_MAZE_PROP_NOT_EXIST:
      return "RET_MAZE_PROP_NOT_EXIST";
    case Retcode.RET_MAZE_POSITION_TOO_FAR:
      return "RET_MAZE_POSITION_TOO_FAR";
    case Retcode.RET_MAZE_SKILL_CAST_CNT_REACH_MAX:
      return "RET_MAZE_SKILL_CAST_CNT_REACH_MAX";
    case Retcode.RET_MAZE_MP_NOT_ENOUGH:
      return "RET_MAZE_MP_NOT_ENOUGH";
    case Retcode.RET_SPRING_NOT_ENABLE:
      return "RET_SPRING_NOT_ENABLE";
    case Retcode.RET_SPRING_REFRESH_IN_CD:
      return "RET_SPRING_REFRESH_IN_CD";
    case Retcode.RET_SPRING_TOO_FAR:
      return "RET_SPRING_TOO_FAR";
    case Retcode.RET_MAZE_NO_FLOOR:
      return "RET_MAZE_NO_FLOOR";
    case Retcode.RET_NOT_IN_MAZE:
      return "RET_NOT_IN_MAZE";
    case Retcode.RET_PLANE_ID_NOT_MATCH:
      return "RET_PLANE_ID_NOT_MATCH";
    case Retcode.RET_FLOOR_ID_NOT_MATCH:
      return "RET_FLOOR_ID_NOT_MATCH";
    case Retcode.RET_SAVEPOINTS_TIMES_ZERO:
      return "RET_SAVEPOINTS_TIMES_ZERO";
    case Retcode.RET_MAZE_TIME_OF_DAY_TYPE_IS_SAME:
      return "RET_MAZE_TIME_OF_DAY_TYPE_IS_SAME";
    case Retcode.RET_MAZE_TIME_OF_DAY_TYPE_ERROR:
      return "RET_MAZE_TIME_OF_DAY_TYPE_ERROR";
    case Retcode.RET_PLOT_NOT_UNLOCK:
      return "RET_PLOT_NOT_UNLOCK";
    case Retcode.RET_MISSION_NOT_EXIST:
      return "RET_MISSION_NOT_EXIST";
    case Retcode.RET_MISSION_ALREADY_DONE:
      return "RET_MISSION_ALREADY_DONE";
    case Retcode.RET_DAILY_TASK_NOT_FINISH:
      return "RET_DAILY_TASK_NOT_FINISH";
    case Retcode.RET_DAILY_TASK_REWARD_HAS_TAKEN:
      return "RET_DAILY_TASK_REWARD_HAS_TAKEN";
    case Retcode.RET_MISSION_NOT_FINISH:
      return "RET_MISSION_NOT_FINISH";
    case Retcode.RET_MISSION_NOT_DOING:
      return "RET_MISSION_NOT_DOING";
    case Retcode.RET_MISSION_FINISH_WAY_NOT_MATCH:
      return "RET_MISSION_FINISH_WAY_NOT_MATCH";
    case Retcode.RET_MISSION_SCENE_NOT_MATCH:
      return "RET_MISSION_SCENE_NOT_MATCH";
    case Retcode.RET_ADVENTURE_MAP_NOT_EXIST:
      return "RET_ADVENTURE_MAP_NOT_EXIST";
    case Retcode.RET_SCENE_ENTITY_NOT_EXIST:
      return "RET_SCENE_ENTITY_NOT_EXIST";
    case Retcode.RET_NOT_IN_SCENE:
      return "RET_NOT_IN_SCENE";
    case Retcode.RET_SCENE_MONSTER_NOT_EXIST:
      return "RET_SCENE_MONSTER_NOT_EXIST";
    case Retcode.RET_INTERACT_CONFIG_NOT_EXIST:
      return "RET_INTERACT_CONFIG_NOT_EXIST";
    case Retcode.RET_UNSUPPORTED_PROP_STATE:
      return "RET_UNSUPPORTED_PROP_STATE";
    case Retcode.RET_SCENE_ENTRY_ID_NOT_MATCH:
      return "RET_SCENE_ENTRY_ID_NOT_MATCH";
    case Retcode.RET_ASSIST_MONSTER_COUNT_LIMIT:
      return "RET_ASSIST_MONSTER_COUNT_LIMIT";
    case Retcode.RET_SCENE_USE_SKILL_FAIL:
      return "RET_SCENE_USE_SKILL_FAIL";
    case Retcode.RET_PROP_IS_HIDDEN:
      return "RET_PROP_IS_HIDDEN";
    case Retcode.RET_LOADING_SUCC_ALREADY:
      return "RET_LOADING_SUCC_ALREADY";
    case Retcode.RET_SCENE_ENTITY_TYPE_INVALID:
      return "RET_SCENE_ENTITY_TYPE_INVALID";
    case Retcode.RET_INTERACT_TYPE_INVALID:
      return "RET_INTERACT_TYPE_INVALID";
    case Retcode.RET_INTERACT_NOT_IN_REGION:
      return "RET_INTERACT_NOT_IN_REGION";
    case Retcode.RET_INTERACT_SUB_TYPE_INVALID:
      return "RET_INTERACT_SUB_TYPE_INVALID";
    case Retcode.RET_NOT_LEADER_ENTITY:
      return "RET_NOT_LEADER_ENTITY";
    case Retcode.RET_MONSTER_IS_NOT_FARM_ELEMENT:
      return "RET_MONSTER_IS_NOT_FARM_ELEMENT";
    case Retcode.RET_MONSTER_CONFIG_NOT_EXIST:
      return "RET_MONSTER_CONFIG_NOT_EXIST";
    case Retcode.RET_AVATAR_HP_ALREADY_FULL:
      return "RET_AVATAR_HP_ALREADY_FULL";
    case Retcode.RET_BUY_TIMES_LIMIT:
      return "RET_BUY_TIMES_LIMIT";
    case Retcode.RET_BUY_LIMIT_TYPE:
      return "RET_BUY_LIMIT_TYPE";
    case Retcode.RET_SHOP_NOT_OPEN:
      return "RET_SHOP_NOT_OPEN";
    case Retcode.RET_GOODS_NOT_OPEN:
      return "RET_GOODS_NOT_OPEN";
    case Retcode.RET_TUTORIAL_NOT_UNLOCK:
      return "RET_TUTORIAL_NOT_UNLOCK";
    case Retcode.RET_TUTORIAL_UNLOCK_ALREADY:
      return "RET_TUTORIAL_UNLOCK_ALREADY";
    case Retcode.RET_TUTORIAL_FINISH_ALREADY:
      return "RET_TUTORIAL_FINISH_ALREADY";
    case Retcode.RET_TUTORIAL_PRE_NOT_UNLOCK:
      return "RET_TUTORIAL_PRE_NOT_UNLOCK";
    case Retcode.RET_TUTORIAL_PLAYER_LEVEL_NOT_MATCH:
      return "RET_TUTORIAL_PLAYER_LEVEL_NOT_MATCH";
    case Retcode.RET_TUTORIAL_TUTORIAL_NOT_FOUND:
      return "RET_TUTORIAL_TUTORIAL_NOT_FOUND";
    case Retcode.RET_CHALLENGE_NOT_EXIST:
      return "RET_CHALLENGE_NOT_EXIST";
    case Retcode.RET_CHALLENGE_NOT_UNLOCK:
      return "RET_CHALLENGE_NOT_UNLOCK";
    case Retcode.RET_CHALLENGE_ALREADY:
      return "RET_CHALLENGE_ALREADY";
    case Retcode.RET_CHALLENGE_LINEUP_EDIT_FORBIDDEN:
      return "RET_CHALLENGE_LINEUP_EDIT_FORBIDDEN";
    case Retcode.RET_CHALLENGE_LINEUP_EMPTY:
      return "RET_CHALLENGE_LINEUP_EMPTY";
    case Retcode.RET_CHALLENGE_NOT_DOING:
      return "RET_CHALLENGE_NOT_DOING";
    case Retcode.RET_CHALLENGE_NOT_FINISH:
      return "RET_CHALLENGE_NOT_FINISH";
    case Retcode.RET_CHALLENGE_TARGET_NOT_FINISH:
      return "RET_CHALLENGE_TARGET_NOT_FINISH";
    case Retcode.RET_CHALLENGE_TARGET_REWARD_TAKEN:
      return "RET_CHALLENGE_TARGET_REWARD_TAKEN";
    case Retcode.RET_CHALLENGE_TIME_NOT_VALID:
      return "RET_CHALLENGE_TIME_NOT_VALID";
    case Retcode.RET_BASIC_TYPE_ALREADY:
      return "RET_BASIC_TYPE_ALREADY";
    case Retcode.RET_NO_BASIC_TYPE:
      return "RET_NO_BASIC_TYPE";
    case Retcode.RET_NOT_CHOOSE_BASIC_TYPE:
      return "RET_NOT_CHOOSE_BASIC_TYPE";
    case Retcode.RET_NOT_FUNC_CLOSE:
      return "RET_NOT_FUNC_CLOSE";
    case Retcode.RET_ROGUE_STATUS_NOT_MATCH:
      return "RET_ROGUE_STATUS_NOT_MATCH";
    case Retcode.RET_ROGUE_SELECT_BUFF_NOT_EXIST:
      return "RET_ROGUE_SELECT_BUFF_NOT_EXIST";
    case Retcode.RET_ROGUE_COIN_NOT_ENOUGH:
      return "RET_ROGUE_COIN_NOT_ENOUGH";
    case Retcode.RET_ROGUE_STAMINA_NOT_ENOUGH:
      return "RET_ROGUE_STAMINA_NOT_ENOUGH";
    case Retcode.RET_ROGUE_COUNT_INVALID:
      return "RET_ROGUE_COUNT_INVALID";
    case Retcode.RET_ROGUE_PROP_ALREADY_USED:
      return "RET_ROGUE_PROP_ALREADY_USED";
    case Retcode.RET_ROGUE_RECORD_ALREADY_SAVED:
      return "RET_ROGUE_RECORD_ALREADY_SAVED";
    case Retcode.RET_ROGUE_ROLL_BUFF_MAX_COUNT:
      return "RET_ROGUE_ROLL_BUFF_MAX_COUNT";
    case Retcode.RET_ROGUE_PICK_AVATAR_INVALID:
      return "RET_ROGUE_PICK_AVATAR_INVALID";
    case Retcode.RET_ROGUE_QUEST_EXPIRE:
      return "RET_ROGUE_QUEST_EXPIRE";
    case Retcode.RET_ROGUE_QUEST_REWARD_ALREADY:
      return "RET_ROGUE_QUEST_REWARD_ALREADY";
    case Retcode.RET_MISSION_EVENT_CONFIG_NOT_EXIST:
      return "RET_MISSION_EVENT_CONFIG_NOT_EXIST";
    case Retcode.RET_MISSION_EVENT_NOT_CLIENT:
      return "RET_MISSION_EVENT_NOT_CLIENT";
    case Retcode.RET_MISSION_EVENT_FINISHED:
      return "RET_MISSION_EVENT_FINISHED";
    case Retcode.RET_MISSION_EVENT_DOING:
      return "RET_MISSION_EVENT_DOING";
    case Retcode.RET_HAS_CHALLENGE_MISSION_EVENT:
      return "RET_HAS_CHALLENGE_MISSION_EVENT";
    case Retcode.RET_NOT_CHALLENGE_MISSION_EVENT:
      return "RET_NOT_CHALLENGE_MISSION_EVENT";
    case Retcode.RET_GACHA_ID_NOT_EXIST:
      return "RET_GACHA_ID_NOT_EXIST";
    case Retcode.RET_GACHA_NUM_INVALID:
      return "RET_GACHA_NUM_INVALID";
    case Retcode.RET_GACHA_FIRST_GACHA_MUST_ONE:
      return "RET_GACHA_FIRST_GACHA_MUST_ONE";
    case Retcode.RET_GACHA_REQ_DUPLICATED:
      return "RET_GACHA_REQ_DUPLICATED";
    case Retcode.RET_GACHA_NOT_IN_SCHEDULE:
      return "RET_GACHA_NOT_IN_SCHEDULE";
    case Retcode.RET_GACHA_NEWBIE_CLOSE:
      return "RET_GACHA_NEWBIE_CLOSE";
    case Retcode.RET_GACHA_TODAY_LIMITED:
      return "RET_GACHA_TODAY_LIMITED";
    case Retcode.RET_PRESTIGE_ID_NOT_EXIST:
      return "RET_PRESTIGE_ID_NOT_EXIST";
    case Retcode.RET_PRESTIGE_LEVEL_REWARD_LEVEL_ERROR:
      return "RET_PRESTIGE_LEVEL_REWARD_LEVEL_ERROR";
    case Retcode.RET_PRESTIGE_LEVEL_REWARD_HAS_TAKEN:
      return "RET_PRESTIGE_LEVEL_REWARD_HAS_TAKEN";
    case Retcode.RET_PRESTIGE_MISSION_NOT_EXIST:
      return "RET_PRESTIGE_MISSION_NOT_EXIST";
    case Retcode.RET_PRESTIGE_MISSION_NOT_FINISHED:
      return "RET_PRESTIGE_MISSION_NOT_FINISHED";
    case Retcode.RET_PRESTIGE_MISSION_REWARD_HAS_TAKEN:
      return "RET_PRESTIGE_MISSION_REWARD_HAS_TAKEN";
    case Retcode.RET_NOT_IN_RAID:
      return "RET_NOT_IN_RAID";
    case Retcode.RET_RAID_DOING:
      return "RET_RAID_DOING";
    case Retcode.RET_NOT_PROP:
      return "RET_NOT_PROP";
    case Retcode.RET_RAID_ID_NOT_MATCH:
      return "RET_RAID_ID_NOT_MATCH";
    case Retcode.RET_RAID_RESTART_NOT_MATCH:
      return "RET_RAID_RESTART_NOT_MATCH";
    case Retcode.RET_RAID_LIMIT:
      return "RET_RAID_LIMIT";
    case Retcode.RET_RAID_AVATAR_LIST_EMPTY:
      return "RET_RAID_AVATAR_LIST_EMPTY";
    case Retcode.RET_RAID_AVATAR_NOT_EXIST:
      return "RET_RAID_AVATAR_NOT_EXIST";
    case Retcode.RET_CHALLENGE_RAID_REWARD_ALREADY:
      return "RET_CHALLENGE_RAID_REWARD_ALREADY";
    case Retcode.RET_CHALLENGE_RAID_SCORE_NOT_REACH:
      return "RET_CHALLENGE_RAID_SCORE_NOT_REACH";
    case Retcode.RET_CHALLENGE_RAID_NOT_OPEN:
      return "RET_CHALLENGE_RAID_NOT_OPEN";
    case Retcode.RET_RAID_FINISHED:
      return "RET_RAID_FINISHED";
    case Retcode.RET_TALK_EVENT_ALREADY_TAKEN:
      return "RET_TALK_EVENT_ALREADY_TAKEN";
    case Retcode.RET_NPC_ALREADY_MEET:
      return "RET_NPC_ALREADY_MEET";
    case Retcode.RET_NPC_NOT_IN_CONFIG:
      return "RET_NPC_NOT_IN_CONFIG";
    case Retcode.RET_DIALOGUE_GROUP_DISMATCH:
      return "RET_DIALOGUE_GROUP_DISMATCH";
    case Retcode.RET_DIALOGUE_EVENT_INVALID:
      return "RET_DIALOGUE_EVENT_INVALID";
    case Retcode.RET_EXPEDITION_CONFIG_NOT_EXIST:
      return "RET_EXPEDITION_CONFIG_NOT_EXIST";
    case Retcode.RET_EXPEDITION_REWARD_CONFIG_NOT_EXIST:
      return "RET_EXPEDITION_REWARD_CONFIG_NOT_EXIST";
    case Retcode.RET_EXPEDITION_NOT_UNLOCKED:
      return "RET_EXPEDITION_NOT_UNLOCKED";
    case Retcode.RET_EXPEDITION_ALREADY_ACCEPTED:
      return "RET_EXPEDITION_ALREADY_ACCEPTED";
    case Retcode.RET_EXPEDITION_REPEATED_AVATAR:
      return "RET_EXPEDITION_REPEATED_AVATAR";
    case Retcode.RET_AVATAR_ALREADY_DISPATCHED:
      return "RET_AVATAR_ALREADY_DISPATCHED";
    case Retcode.RET_EXPEDITION_NOT_ACCEPTED:
      return "RET_EXPEDITION_NOT_ACCEPTED";
    case Retcode.RET_EXPEDITION_NOT_FINISH:
      return "RET_EXPEDITION_NOT_FINISH";
    case Retcode.RET_EXPEDITION_ALREADY_FINISH:
      return "RET_EXPEDITION_ALREADY_FINISH";
    case Retcode.RET_LOGIN_ACTIVITY_HAS_TAKEN:
      return "RET_LOGIN_ACTIVITY_HAS_TAKEN";
    case Retcode.RET_LOGIN_ACTIVITY_DAYS_LACK:
      return "RET_LOGIN_ACTIVITY_DAYS_LACK";
    case Retcode.RET_MESSAGE_CONFIG_NOT_EXIST:
      return "RET_MESSAGE_CONFIG_NOT_EXIST";
    case Retcode.RET_MESSAGE_SECTION_NOT_TAKE:
      return "RET_MESSAGE_SECTION_NOT_TAKE";
    case Retcode.RET_MESSAGE_GROUP_NOT_TAKE:
      return "RET_MESSAGE_GROUP_NOT_TAKE";
    case Retcode.RET_MESSAGE_SECTION_ID_NOT_MATCH:
      return "RET_MESSAGE_SECTION_ID_NOT_MATCH";
    case Retcode.RET_MESSAGE_SECTION_CAN_NOT_FINISH:
      return "RET_MESSAGE_SECTION_CAN_NOT_FINISH";
    case Retcode.RET_MESSAGE_ITEM_CAN_NOT_FINISH:
      return "RET_MESSAGE_ITEM_CAN_NOT_FINISH";
    case Retcode.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum CmdActivityType {
  CmdActivityTypeNone = 0,
  CmdGetLoginActivityCsReq = 2601,
  CmdGetLoginActivityScRsp = 2602,
  CmdTakeLoginActivityRewardCsReq = 2603,
  CmdTakeLoginActivityRewardScRsp = 2604,
  UNRECOGNIZED = -1,
}

export function cmdActivityTypeFromJSON(object: any): CmdActivityType {
  switch (object) {
    case 0:
    case "CmdActivityTypeNone":
      return CmdActivityType.CmdActivityTypeNone;
    case 2601:
    case "CmdGetLoginActivityCsReq":
      return CmdActivityType.CmdGetLoginActivityCsReq;
    case 2602:
    case "CmdGetLoginActivityScRsp":
      return CmdActivityType.CmdGetLoginActivityScRsp;
    case 2603:
    case "CmdTakeLoginActivityRewardCsReq":
      return CmdActivityType.CmdTakeLoginActivityRewardCsReq;
    case 2604:
    case "CmdTakeLoginActivityRewardScRsp":
      return CmdActivityType.CmdTakeLoginActivityRewardScRsp;
    case -1:
    case "UNRECOGNIZED":
    default:
      return CmdActivityType.UNRECOGNIZED;
  }
}

export function cmdActivityTypeToJSON(object: CmdActivityType): string {
  switch (object) {
    case CmdActivityType.CmdActivityTypeNone:
      return "CmdActivityTypeNone";
    case CmdActivityType.CmdGetLoginActivityCsReq:
      return "CmdGetLoginActivityCsReq";
    case CmdActivityType.CmdGetLoginActivityScRsp:
      return "CmdGetLoginActivityScRsp";
    case CmdActivityType.CmdTakeLoginActivityRewardCsReq:
      return "CmdTakeLoginActivityRewardCsReq";
    case CmdActivityType.CmdTakeLoginActivityRewardScRsp:
      return "CmdTakeLoginActivityRewardScRsp";
    case CmdActivityType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum CmdAdventureType {
  CmdAdventureTypeNone = 0,
  CmdEnterAdventureCsReq = 1301,
  CmdEnterAdventureScRsp = 1302,
  UNRECOGNIZED = -1,
}

export function cmdAdventureTypeFromJSON(object: any): CmdAdventureType {
  switch (object) {
    case 0:
    case "CmdAdventureTypeNone":
      return CmdAdventureType.CmdAdventureTypeNone;
    case 1301:
    case "CmdEnterAdventureCsReq":
      return CmdAdventureType.CmdEnterAdventureCsReq;
    case 1302:
    case "CmdEnterAdventureScRsp":
      return CmdAdventureType.CmdEnterAdventureScRsp;
    case -1:
    case "UNRECOGNIZED":
    default:
      return CmdAdventureType.UNRECOGNIZED;
  }
}

export function cmdAdventureTypeToJSON(object: CmdAdventureType): string {
  switch (object) {
    case CmdAdventureType.CmdAdventureTypeNone:
      return "CmdAdventureTypeNone";
    case CmdAdventureType.CmdEnterAdventureCsReq:
      return "CmdEnterAdventureCsReq";
    case CmdAdventureType.CmdEnterAdventureScRsp:
      return "CmdEnterAdventureScRsp";
    case CmdAdventureType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum CmdArchiveType {
  CmdArchiveTypeNone = 0,
  CmdGetArchiveDataCsReq = 2301,
  CmdGetArchiveDataScRsp = 2302,
  CmdGetUpdatedArchiveDataCsReq = 2303,
  CmdGetUpdatedArchiveDataScRsp = 2304,
  UNRECOGNIZED = -1,
}

export function cmdArchiveTypeFromJSON(object: any): CmdArchiveType {
  switch (object) {
    case 0:
    case "CmdArchiveTypeNone":
      return CmdArchiveType.CmdArchiveTypeNone;
    case 2301:
    case "CmdGetArchiveDataCsReq":
      return CmdArchiveType.CmdGetArchiveDataCsReq;
    case 2302:
    case "CmdGetArchiveDataScRsp":
      return CmdArchiveType.CmdGetArchiveDataScRsp;
    case 2303:
    case "CmdGetUpdatedArchiveDataCsReq":
      return CmdArchiveType.CmdGetUpdatedArchiveDataCsReq;
    case 2304:
    case "CmdGetUpdatedArchiveDataScRsp":
      return CmdArchiveType.CmdGetUpdatedArchiveDataScRsp;
    case -1:
    case "UNRECOGNIZED":
    default:
      return CmdArchiveType.UNRECOGNIZED;
  }
}

export function cmdArchiveTypeToJSON(object: CmdArchiveType): string {
  switch (object) {
    case CmdArchiveType.CmdArchiveTypeNone:
      return "CmdArchiveTypeNone";
    case CmdArchiveType.CmdGetArchiveDataCsReq:
      return "CmdGetArchiveDataCsReq";
    case CmdArchiveType.CmdGetArchiveDataScRsp:
      return "CmdGetArchiveDataScRsp";
    case CmdArchiveType.CmdGetUpdatedArchiveDataCsReq:
      return "CmdGetUpdatedArchiveDataCsReq";
    case CmdArchiveType.CmdGetUpdatedArchiveDataScRsp:
      return "CmdGetUpdatedArchiveDataScRsp";
    case CmdArchiveType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum CmdAvatarType {
  CmdAvatarTypeNone = 0,
  CmdGetAvatarDataCsReq = 301,
  CmdGetAvatarDataScRsp = 302,
  CmdAvatarExpUpCsReq = 303,
  CmdAvatarExpUpScRsp = 304,
  CmdUnlockSkilltreeCsReq = 305,
  CmdUnlockSkilltreeScRsp = 306,
  CmdPromoteAvatarCsReq = 307,
  CmdPromoteAvatarScRsp = 308,
  CmdDressAvatarCsReq = 309,
  CmdDressAvatarScRsp = 310,
  CmdTakeOffEquipmentCsReq = 311,
  CmdTakeOffEquipmentScRsp = 312,
  CmdAddAvatarScNotify = 313,
  CmdRankUpAvatarCsReq = 314,
  CmdRankUpAvatarScRsp = 315,
  CmdDressRelicAvatarCsReq = 316,
  CmdDressRelicAvatarScRsp = 317,
  CmdTakeOffRelicCsReq = 318,
  CmdTakeOffRelicScRsp = 319,
  UNRECOGNIZED = -1,
}

export function cmdAvatarTypeFromJSON(object: any): CmdAvatarType {
  switch (object) {
    case 0:
    case "CmdAvatarTypeNone":
      return CmdAvatarType.CmdAvatarTypeNone;
    case 301:
    case "CmdGetAvatarDataCsReq":
      return CmdAvatarType.CmdGetAvatarDataCsReq;
    case 302:
    case "CmdGetAvatarDataScRsp":
      return CmdAvatarType.CmdGetAvatarDataScRsp;
    case 303:
    case "CmdAvatarExpUpCsReq":
      return CmdAvatarType.CmdAvatarExpUpCsReq;
    case 304:
    case "CmdAvatarExpUpScRsp":
      return CmdAvatarType.CmdAvatarExpUpScRsp;
    case 305:
    case "CmdUnlockSkilltreeCsReq":
      return CmdAvatarType.CmdUnlockSkilltreeCsReq;
    case 306:
    case "CmdUnlockSkilltreeScRsp":
      return CmdAvatarType.CmdUnlockSkilltreeScRsp;
    case 307:
    case "CmdPromoteAvatarCsReq":
      return CmdAvatarType.CmdPromoteAvatarCsReq;
    case 308:
    case "CmdPromoteAvatarScRsp":
      return CmdAvatarType.CmdPromoteAvatarScRsp;
    case 309:
    case "CmdDressAvatarCsReq":
      return CmdAvatarType.CmdDressAvatarCsReq;
    case 310:
    case "CmdDressAvatarScRsp":
      return CmdAvatarType.CmdDressAvatarScRsp;
    case 311:
    case "CmdTakeOffEquipmentCsReq":
      return CmdAvatarType.CmdTakeOffEquipmentCsReq;
    case 312:
    case "CmdTakeOffEquipmentScRsp":
      return CmdAvatarType.CmdTakeOffEquipmentScRsp;
    case 313:
    case "CmdAddAvatarScNotify":
      return CmdAvatarType.CmdAddAvatarScNotify;
    case 314:
    case "CmdRankUpAvatarCsReq":
      return CmdAvatarType.CmdRankUpAvatarCsReq;
    case 315:
    case "CmdRankUpAvatarScRsp":
      return CmdAvatarType.CmdRankUpAvatarScRsp;
    case 316:
    case "CmdDressRelicAvatarCsReq":
      return CmdAvatarType.CmdDressRelicAvatarCsReq;
    case 317:
    case "CmdDressRelicAvatarScRsp":
      return CmdAvatarType.CmdDressRelicAvatarScRsp;
    case 318:
    case "CmdTakeOffRelicCsReq":
      return CmdAvatarType.CmdTakeOffRelicCsReq;
    case 319:
    case "CmdTakeOffRelicScRsp":
      return CmdAvatarType.CmdTakeOffRelicScRsp;
    case -1:
    case "UNRECOGNIZED":
    default:
      return CmdAvatarType.UNRECOGNIZED;
  }
}

export function cmdAvatarTypeToJSON(object: CmdAvatarType): string {
  switch (object) {
    case CmdAvatarType.CmdAvatarTypeNone:
      return "CmdAvatarTypeNone";
    case CmdAvatarType.CmdGetAvatarDataCsReq:
      return "CmdGetAvatarDataCsReq";
    case CmdAvatarType.CmdGetAvatarDataScRsp:
      return "CmdGetAvatarDataScRsp";
    case CmdAvatarType.CmdAvatarExpUpCsReq:
      return "CmdAvatarExpUpCsReq";
    case CmdAvatarType.CmdAvatarExpUpScRsp:
      return "CmdAvatarExpUpScRsp";
    case CmdAvatarType.CmdUnlockSkilltreeCsReq:
      return "CmdUnlockSkilltreeCsReq";
    case CmdAvatarType.CmdUnlockSkilltreeScRsp:
      return "CmdUnlockSkilltreeScRsp";
    case CmdAvatarType.CmdPromoteAvatarCsReq:
      return "CmdPromoteAvatarCsReq";
    case CmdAvatarType.CmdPromoteAvatarScRsp:
      return "CmdPromoteAvatarScRsp";
    case CmdAvatarType.CmdDressAvatarCsReq:
      return "CmdDressAvatarCsReq";
    case CmdAvatarType.CmdDressAvatarScRsp:
      return "CmdDressAvatarScRsp";
    case CmdAvatarType.CmdTakeOffEquipmentCsReq:
      return "CmdTakeOffEquipmentCsReq";
    case CmdAvatarType.CmdTakeOffEquipmentScRsp:
      return "CmdTakeOffEquipmentScRsp";
    case CmdAvatarType.CmdAddAvatarScNotify:
      return "CmdAddAvatarScNotify";
    case CmdAvatarType.CmdRankUpAvatarCsReq:
      return "CmdRankUpAvatarCsReq";
    case CmdAvatarType.CmdRankUpAvatarScRsp:
      return "CmdRankUpAvatarScRsp";
    case CmdAvatarType.CmdDressRelicAvatarCsReq:
      return "CmdDressRelicAvatarCsReq";
    case CmdAvatarType.CmdDressRelicAvatarScRsp:
      return "CmdDressRelicAvatarScRsp";
    case CmdAvatarType.CmdTakeOffRelicCsReq:
      return "CmdTakeOffRelicCsReq";
    case CmdAvatarType.CmdTakeOffRelicScRsp:
      return "CmdTakeOffRelicScRsp";
    case CmdAvatarType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum AddAvatarSrc {
  ADD_AVATAR_SRC_NONE = 0,
  ADD_AVATAR_SRC_GACHA = 1,
  UNRECOGNIZED = -1,
}

export function addAvatarSrcFromJSON(object: any): AddAvatarSrc {
  switch (object) {
    case 0:
    case "ADD_AVATAR_SRC_NONE":
      return AddAvatarSrc.ADD_AVATAR_SRC_NONE;
    case 1:
    case "ADD_AVATAR_SRC_GACHA":
      return AddAvatarSrc.ADD_AVATAR_SRC_GACHA;
    case -1:
    case "UNRECOGNIZED":
    default:
      return AddAvatarSrc.UNRECOGNIZED;
  }
}

export function addAvatarSrcToJSON(object: AddAvatarSrc): string {
  switch (object) {
    case AddAvatarSrc.ADD_AVATAR_SRC_NONE:
      return "ADD_AVATAR_SRC_NONE";
    case AddAvatarSrc.ADD_AVATAR_SRC_GACHA:
      return "ADD_AVATAR_SRC_GACHA";
    case AddAvatarSrc.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum CmdBattleType {
  CmdBattleTypeNone = 0,
  CmdPVEBattleResultCsReq = 101,
  CmdPVEBattleResultScRsp = 102,
  CmdQuitBattleCsReq = 103,
  CmdQuitBattleScRsp = 104,
  CmdGetCurBattleInfoCsReq = 105,
  CmdGetCurBattleInfoScRsp = 106,
  CmdSyncClientResVersionCsReq = 107,
  CmdSyncClientResVersionScRsp = 108,
  CmdQuitBattleScNotify = 109,
  UNRECOGNIZED = -1,
}

export function cmdBattleTypeFromJSON(object: any): CmdBattleType {
  switch (object) {
    case 0:
    case "CmdBattleTypeNone":
      return CmdBattleType.CmdBattleTypeNone;
    case 101:
    case "CmdPVEBattleResultCsReq":
      return CmdBattleType.CmdPVEBattleResultCsReq;
    case 102:
    case "CmdPVEBattleResultScRsp":
      return CmdBattleType.CmdPVEBattleResultScRsp;
    case 103:
    case "CmdQuitBattleCsReq":
      return CmdBattleType.CmdQuitBattleCsReq;
    case 104:
    case "CmdQuitBattleScRsp":
      return CmdBattleType.CmdQuitBattleScRsp;
    case 105:
    case "CmdGetCurBattleInfoCsReq":
      return CmdBattleType.CmdGetCurBattleInfoCsReq;
    case 106:
    case "CmdGetCurBattleInfoScRsp":
      return CmdBattleType.CmdGetCurBattleInfoScRsp;
    case 107:
    case "CmdSyncClientResVersionCsReq":
      return CmdBattleType.CmdSyncClientResVersionCsReq;
    case 108:
    case "CmdSyncClientResVersionScRsp":
      return CmdBattleType.CmdSyncClientResVersionScRsp;
    case 109:
    case "CmdQuitBattleScNotify":
      return CmdBattleType.CmdQuitBattleScNotify;
    case -1:
    case "UNRECOGNIZED":
    default:
      return CmdBattleType.UNRECOGNIZED;
  }
}

export function cmdBattleTypeToJSON(object: CmdBattleType): string {
  switch (object) {
    case CmdBattleType.CmdBattleTypeNone:
      return "CmdBattleTypeNone";
    case CmdBattleType.CmdPVEBattleResultCsReq:
      return "CmdPVEBattleResultCsReq";
    case CmdBattleType.CmdPVEBattleResultScRsp:
      return "CmdPVEBattleResultScRsp";
    case CmdBattleType.CmdQuitBattleCsReq:
      return "CmdQuitBattleCsReq";
    case CmdBattleType.CmdQuitBattleScRsp:
      return "CmdQuitBattleScRsp";
    case CmdBattleType.CmdGetCurBattleInfoCsReq:
      return "CmdGetCurBattleInfoCsReq";
    case CmdBattleType.CmdGetCurBattleInfoScRsp:
      return "CmdGetCurBattleInfoScRsp";
    case CmdBattleType.CmdSyncClientResVersionCsReq:
      return "CmdSyncClientResVersionCsReq";
    case CmdBattleType.CmdSyncClientResVersionScRsp:
      return "CmdSyncClientResVersionScRsp";
    case CmdBattleType.CmdQuitBattleScNotify:
      return "CmdQuitBattleScNotify";
    case CmdBattleType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum CmdChallengeType {
  CmdChallengeTypeNone = 0,
  CmdGetChallengeCsReq = 1701,
  CmdGetChallengeScRsp = 1702,
  CmdStartChallengeCsReq = 1703,
  CmdStartChallengeScRsp = 1704,
  CmdLeaveChallengeCsReq = 1705,
  CmdLeaveChallengeScRsp = 1706,
  CmdChallengeSettleNotify = 1707,
  CmdFinishChallengeCsReq = 1708,
  CmdFinishChallengeScRsp = 1709,
  CmdGetCurChallengeCsReq = 1710,
  CmdGetCurChallengeScRsp = 1711,
  CmdChallengeLineupNotify = 1712,
  CmdTakeChallengeTargetRewardCsReq = 1713,
  CmdTakeChallengeTargetRewardScRsp = 1714,
  UNRECOGNIZED = -1,
}

export function cmdChallengeTypeFromJSON(object: any): CmdChallengeType {
  switch (object) {
    case 0:
    case "CmdChallengeTypeNone":
      return CmdChallengeType.CmdChallengeTypeNone;
    case 1701:
    case "CmdGetChallengeCsReq":
      return CmdChallengeType.CmdGetChallengeCsReq;
    case 1702:
    case "CmdGetChallengeScRsp":
      return CmdChallengeType.CmdGetChallengeScRsp;
    case 1703:
    case "CmdStartChallengeCsReq":
      return CmdChallengeType.CmdStartChallengeCsReq;
    case 1704:
    case "CmdStartChallengeScRsp":
      return CmdChallengeType.CmdStartChallengeScRsp;
    case 1705:
    case "CmdLeaveChallengeCsReq":
      return CmdChallengeType.CmdLeaveChallengeCsReq;
    case 1706:
    case "CmdLeaveChallengeScRsp":
      return CmdChallengeType.CmdLeaveChallengeScRsp;
    case 1707:
    case "CmdChallengeSettleNotify":
      return CmdChallengeType.CmdChallengeSettleNotify;
    case 1708:
    case "CmdFinishChallengeCsReq":
      return CmdChallengeType.CmdFinishChallengeCsReq;
    case 1709:
    case "CmdFinishChallengeScRsp":
      return CmdChallengeType.CmdFinishChallengeScRsp;
    case 1710:
    case "CmdGetCurChallengeCsReq":
      return CmdChallengeType.CmdGetCurChallengeCsReq;
    case 1711:
    case "CmdGetCurChallengeScRsp":
      return CmdChallengeType.CmdGetCurChallengeScRsp;
    case 1712:
    case "CmdChallengeLineupNotify":
      return CmdChallengeType.CmdChallengeLineupNotify;
    case 1713:
    case "CmdTakeChallengeTargetRewardCsReq":
      return CmdChallengeType.CmdTakeChallengeTargetRewardCsReq;
    case 1714:
    case "CmdTakeChallengeTargetRewardScRsp":
      return CmdChallengeType.CmdTakeChallengeTargetRewardScRsp;
    case -1:
    case "UNRECOGNIZED":
    default:
      return CmdChallengeType.UNRECOGNIZED;
  }
}

export function cmdChallengeTypeToJSON(object: CmdChallengeType): string {
  switch (object) {
    case CmdChallengeType.CmdChallengeTypeNone:
      return "CmdChallengeTypeNone";
    case CmdChallengeType.CmdGetChallengeCsReq:
      return "CmdGetChallengeCsReq";
    case CmdChallengeType.CmdGetChallengeScRsp:
      return "CmdGetChallengeScRsp";
    case CmdChallengeType.CmdStartChallengeCsReq:
      return "CmdStartChallengeCsReq";
    case CmdChallengeType.CmdStartChallengeScRsp:
      return "CmdStartChallengeScRsp";
    case CmdChallengeType.CmdLeaveChallengeCsReq:
      return "CmdLeaveChallengeCsReq";
    case CmdChallengeType.CmdLeaveChallengeScRsp:
      return "CmdLeaveChallengeScRsp";
    case CmdChallengeType.CmdChallengeSettleNotify:
      return "CmdChallengeSettleNotify";
    case CmdChallengeType.CmdFinishChallengeCsReq:
      return "CmdFinishChallengeCsReq";
    case CmdChallengeType.CmdFinishChallengeScRsp:
      return "CmdFinishChallengeScRsp";
    case CmdChallengeType.CmdGetCurChallengeCsReq:
      return "CmdGetCurChallengeCsReq";
    case CmdChallengeType.CmdGetCurChallengeScRsp:
      return "CmdGetCurChallengeScRsp";
    case CmdChallengeType.CmdChallengeLineupNotify:
      return "CmdChallengeLineupNotify";
    case CmdChallengeType.CmdTakeChallengeTargetRewardCsReq:
      return "CmdTakeChallengeTargetRewardCsReq";
    case CmdChallengeType.CmdTakeChallengeTargetRewardScRsp:
      return "CmdTakeChallengeTargetRewardScRsp";
    case CmdChallengeType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum ChallengeStatus {
  CHALLENGE_UNKNOWN = 0,
  CHALLENGE_DOING = 1,
  CHALLENGE_FINISH = 2,
  CHALLENGE_FAILED = 3,
  UNRECOGNIZED = -1,
}

export function challengeStatusFromJSON(object: any): ChallengeStatus {
  switch (object) {
    case 0:
    case "CHALLENGE_UNKNOWN":
      return ChallengeStatus.CHALLENGE_UNKNOWN;
    case 1:
    case "CHALLENGE_DOING":
      return ChallengeStatus.CHALLENGE_DOING;
    case 2:
    case "CHALLENGE_FINISH":
      return ChallengeStatus.CHALLENGE_FINISH;
    case 3:
    case "CHALLENGE_FAILED":
      return ChallengeStatus.CHALLENGE_FAILED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ChallengeStatus.UNRECOGNIZED;
  }
}

export function challengeStatusToJSON(object: ChallengeStatus): string {
  switch (object) {
    case ChallengeStatus.CHALLENGE_UNKNOWN:
      return "CHALLENGE_UNKNOWN";
    case ChallengeStatus.CHALLENGE_DOING:
      return "CHALLENGE_DOING";
    case ChallengeStatus.CHALLENGE_FINISH:
      return "CHALLENGE_FINISH";
    case ChallengeStatus.CHALLENGE_FAILED:
      return "CHALLENGE_FAILED";
    case ChallengeStatus.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum MissionStatus {
  MISSION_NONE = 0,
  MISSION_DOING = 1,
  MISSION_FINISH = 2,
  MISSION_PREPARED = 3,
  UNRECOGNIZED = -1,
}

export function missionStatusFromJSON(object: any): MissionStatus {
  switch (object) {
    case 0:
    case "MISSION_NONE":
      return MissionStatus.MISSION_NONE;
    case 1:
    case "MISSION_DOING":
      return MissionStatus.MISSION_DOING;
    case 2:
    case "MISSION_FINISH":
      return MissionStatus.MISSION_FINISH;
    case 3:
    case "MISSION_PREPARED":
      return MissionStatus.MISSION_PREPARED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return MissionStatus.UNRECOGNIZED;
  }
}

export function missionStatusToJSON(object: MissionStatus): string {
  switch (object) {
    case MissionStatus.MISSION_NONE:
      return "MISSION_NONE";
    case MissionStatus.MISSION_DOING:
      return "MISSION_DOING";
    case MissionStatus.MISSION_FINISH:
      return "MISSION_FINISH";
    case MissionStatus.MISSION_PREPARED:
      return "MISSION_PREPARED";
    case MissionStatus.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum MessageSectionStatus {
  MESSAGE_SECTION_NONE = 0,
  MESSAGE_SECTION_DOING = 1,
  MESSAGE_SECTION_FINISH = 2,
  UNRECOGNIZED = -1,
}

export function messageSectionStatusFromJSON(
  object: any
): MessageSectionStatus {
  switch (object) {
    case 0:
    case "MESSAGE_SECTION_NONE":
      return MessageSectionStatus.MESSAGE_SECTION_NONE;
    case 1:
    case "MESSAGE_SECTION_DOING":
      return MessageSectionStatus.MESSAGE_SECTION_DOING;
    case 2:
    case "MESSAGE_SECTION_FINISH":
      return MessageSectionStatus.MESSAGE_SECTION_FINISH;
    case -1:
    case "UNRECOGNIZED":
    default:
      return MessageSectionStatus.UNRECOGNIZED;
  }
}

export function messageSectionStatusToJSON(
  object: MessageSectionStatus
): string {
  switch (object) {
    case MessageSectionStatus.MESSAGE_SECTION_NONE:
      return "MESSAGE_SECTION_NONE";
    case MessageSectionStatus.MESSAGE_SECTION_DOING:
      return "MESSAGE_SECTION_DOING";
    case MessageSectionStatus.MESSAGE_SECTION_FINISH:
      return "MESSAGE_SECTION_FINISH";
    case MessageSectionStatus.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum MessageGroupStatus {
  MESSAGE_GROUP_NONE = 0,
  MESSAGE_GROUP_DOING = 1,
  MESSAGE_GROUP_FINISH = 2,
  UNRECOGNIZED = -1,
}

export function messageGroupStatusFromJSON(object: any): MessageGroupStatus {
  switch (object) {
    case 0:
    case "MESSAGE_GROUP_NONE":
      return MessageGroupStatus.MESSAGE_GROUP_NONE;
    case 1:
    case "MESSAGE_GROUP_DOING":
      return MessageGroupStatus.MESSAGE_GROUP_DOING;
    case 2:
    case "MESSAGE_GROUP_FINISH":
      return MessageGroupStatus.MESSAGE_GROUP_FINISH;
    case -1:
    case "UNRECOGNIZED":
    default:
      return MessageGroupStatus.UNRECOGNIZED;
  }
}

export function messageGroupStatusToJSON(object: MessageGroupStatus): string {
  switch (object) {
    case MessageGroupStatus.MESSAGE_GROUP_NONE:
      return "MESSAGE_GROUP_NONE";
    case MessageGroupStatus.MESSAGE_GROUP_DOING:
      return "MESSAGE_GROUP_DOING";
    case MessageGroupStatus.MESSAGE_GROUP_FINISH:
      return "MESSAGE_GROUP_FINISH";
    case MessageGroupStatus.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum CmdDialogueType {
  CmdDialogueTypeNone = 0,
  CmdGetDialogueEventDataCsReq = 2401,
  CmdGetDialogueEventDataScRsp = 2402,
  CmdSelectDialogueEventCsReq = 2403,
  CmdSelectDialogueEventScRsp = 2404,
  CmdSyncDialogueEventDataScNotify = 2405,
  UNRECOGNIZED = -1,
}

export function cmdDialogueTypeFromJSON(object: any): CmdDialogueType {
  switch (object) {
    case 0:
    case "CmdDialogueTypeNone":
      return CmdDialogueType.CmdDialogueTypeNone;
    case 2401:
    case "CmdGetDialogueEventDataCsReq":
      return CmdDialogueType.CmdGetDialogueEventDataCsReq;
    case 2402:
    case "CmdGetDialogueEventDataScRsp":
      return CmdDialogueType.CmdGetDialogueEventDataScRsp;
    case 2403:
    case "CmdSelectDialogueEventCsReq":
      return CmdDialogueType.CmdSelectDialogueEventCsReq;
    case 2404:
    case "CmdSelectDialogueEventScRsp":
      return CmdDialogueType.CmdSelectDialogueEventScRsp;
    case 2405:
    case "CmdSyncDialogueEventDataScNotify":
      return CmdDialogueType.CmdSyncDialogueEventDataScNotify;
    case -1:
    case "UNRECOGNIZED":
    default:
      return CmdDialogueType.UNRECOGNIZED;
  }
}

export function cmdDialogueTypeToJSON(object: CmdDialogueType): string {
  switch (object) {
    case CmdDialogueType.CmdDialogueTypeNone:
      return "CmdDialogueTypeNone";
    case CmdDialogueType.CmdGetDialogueEventDataCsReq:
      return "CmdGetDialogueEventDataCsReq";
    case CmdDialogueType.CmdGetDialogueEventDataScRsp:
      return "CmdGetDialogueEventDataScRsp";
    case CmdDialogueType.CmdSelectDialogueEventCsReq:
      return "CmdSelectDialogueEventCsReq";
    case CmdDialogueType.CmdSelectDialogueEventScRsp:
      return "CmdSelectDialogueEventScRsp";
    case CmdDialogueType.CmdSyncDialogueEventDataScNotify:
      return "CmdSyncDialogueEventDataScNotify";
    case CmdDialogueType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum CmdExpeditionType {
  CmdExpeditionTypeNone = 0,
  CmdGetExpeditionDataCsReq = 2501,
  CmdGetExpeditionDataScRsp = 2502,
  CmdAcceptExpeditionCsReq = 2503,
  CmdAcceptExpeditionScRsp = 2504,
  CmdCancelExpeditionCsReq = 2505,
  CmdCancelExpeditionScRsp = 2506,
  CmdTakeExpeditionRewardCsReq = 2507,
  CmdTakeExpeditionRewardScRsp = 2508,
  UNRECOGNIZED = -1,
}

export function cmdExpeditionTypeFromJSON(object: any): CmdExpeditionType {
  switch (object) {
    case 0:
    case "CmdExpeditionTypeNone":
      return CmdExpeditionType.CmdExpeditionTypeNone;
    case 2501:
    case "CmdGetExpeditionDataCsReq":
      return CmdExpeditionType.CmdGetExpeditionDataCsReq;
    case 2502:
    case "CmdGetExpeditionDataScRsp":
      return CmdExpeditionType.CmdGetExpeditionDataScRsp;
    case 2503:
    case "CmdAcceptExpeditionCsReq":
      return CmdExpeditionType.CmdAcceptExpeditionCsReq;
    case 2504:
    case "CmdAcceptExpeditionScRsp":
      return CmdExpeditionType.CmdAcceptExpeditionScRsp;
    case 2505:
    case "CmdCancelExpeditionCsReq":
      return CmdExpeditionType.CmdCancelExpeditionCsReq;
    case 2506:
    case "CmdCancelExpeditionScRsp":
      return CmdExpeditionType.CmdCancelExpeditionScRsp;
    case 2507:
    case "CmdTakeExpeditionRewardCsReq":
      return CmdExpeditionType.CmdTakeExpeditionRewardCsReq;
    case 2508:
    case "CmdTakeExpeditionRewardScRsp":
      return CmdExpeditionType.CmdTakeExpeditionRewardScRsp;
    case -1:
    case "UNRECOGNIZED":
    default:
      return CmdExpeditionType.UNRECOGNIZED;
  }
}

export function cmdExpeditionTypeToJSON(object: CmdExpeditionType): string {
  switch (object) {
    case CmdExpeditionType.CmdExpeditionTypeNone:
      return "CmdExpeditionTypeNone";
    case CmdExpeditionType.CmdGetExpeditionDataCsReq:
      return "CmdGetExpeditionDataCsReq";
    case CmdExpeditionType.CmdGetExpeditionDataScRsp:
      return "CmdGetExpeditionDataScRsp";
    case CmdExpeditionType.CmdAcceptExpeditionCsReq:
      return "CmdAcceptExpeditionCsReq";
    case CmdExpeditionType.CmdAcceptExpeditionScRsp:
      return "CmdAcceptExpeditionScRsp";
    case CmdExpeditionType.CmdCancelExpeditionCsReq:
      return "CmdCancelExpeditionCsReq";
    case CmdExpeditionType.CmdCancelExpeditionScRsp:
      return "CmdCancelExpeditionScRsp";
    case CmdExpeditionType.CmdTakeExpeditionRewardCsReq:
      return "CmdTakeExpeditionRewardCsReq";
    case CmdExpeditionType.CmdTakeExpeditionRewardScRsp:
      return "CmdTakeExpeditionRewardScRsp";
    case CmdExpeditionType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum CmdGachaType {
  CmdGachaTypeNone = 0,
  CmdGetGachaInfoCsReq = 1901,
  CmdGetGachaInfoScRsp = 1902,
  CmdDoGachaCsReq = 1903,
  CmdDoGachaScRsp = 1904,
  UNRECOGNIZED = -1,
}

export function cmdGachaTypeFromJSON(object: any): CmdGachaType {
  switch (object) {
    case 0:
    case "CmdGachaTypeNone":
      return CmdGachaType.CmdGachaTypeNone;
    case 1901:
    case "CmdGetGachaInfoCsReq":
      return CmdGachaType.CmdGetGachaInfoCsReq;
    case 1902:
    case "CmdGetGachaInfoScRsp":
      return CmdGachaType.CmdGetGachaInfoScRsp;
    case 1903:
    case "CmdDoGachaCsReq":
      return CmdGachaType.CmdDoGachaCsReq;
    case 1904:
    case "CmdDoGachaScRsp":
      return CmdGachaType.CmdDoGachaScRsp;
    case -1:
    case "UNRECOGNIZED":
    default:
      return CmdGachaType.UNRECOGNIZED;
  }
}

export function cmdGachaTypeToJSON(object: CmdGachaType): string {
  switch (object) {
    case CmdGachaType.CmdGachaTypeNone:
      return "CmdGachaTypeNone";
    case CmdGachaType.CmdGetGachaInfoCsReq:
      return "CmdGetGachaInfoCsReq";
    case CmdGachaType.CmdGetGachaInfoScRsp:
      return "CmdGetGachaInfoScRsp";
    case CmdGachaType.CmdDoGachaCsReq:
      return "CmdDoGachaCsReq";
    case CmdGachaType.CmdDoGachaScRsp:
      return "CmdDoGachaScRsp";
    case CmdGachaType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum CmdItemType {
  CmdItemTypeNone = 0,
  CmdGetBagCsReq = 501,
  CmdGetBagScRsp = 502,
  CmdPromoteEquipmentCsReq = 503,
  CmdPromoteEquipmentScRsp = 504,
  CmdLockEquipmentCsReq = 505,
  CmdLockEquipmentScRsp = 506,
  CmdUseItemCsReq = 507,
  CmdUseItemScRsp = 508,
  CmdRankUpEquipmentCsReq = 509,
  CmdRankUpEquipmentScRsp = 510,
  CmdExpUpEquipmentCsReq = 511,
  CmdExpUpEquipmentScRsp = 512,
  CmdComposeItemCsReq = 513,
  CmdComposeItemScRsp = 514,
  CmdExpUpRelicCsReq = 515,
  CmdExpUpRelicScRsp = 516,
  CmdLockRelicCsReq = 517,
  CmdLockRelicScRsp = 518,
  CmdSellItemCsReq = 519,
  CmdSellItemScRsp = 520,
  CmdRechargeSuccNotify = 521,
  UNRECOGNIZED = -1,
}

export function cmdItemTypeFromJSON(object: any): CmdItemType {
  switch (object) {
    case 0:
    case "CmdItemTypeNone":
      return CmdItemType.CmdItemTypeNone;
    case 501:
    case "CmdGetBagCsReq":
      return CmdItemType.CmdGetBagCsReq;
    case 502:
    case "CmdGetBagScRsp":
      return CmdItemType.CmdGetBagScRsp;
    case 503:
    case "CmdPromoteEquipmentCsReq":
      return CmdItemType.CmdPromoteEquipmentCsReq;
    case 504:
    case "CmdPromoteEquipmentScRsp":
      return CmdItemType.CmdPromoteEquipmentScRsp;
    case 505:
    case "CmdLockEquipmentCsReq":
      return CmdItemType.CmdLockEquipmentCsReq;
    case 506:
    case "CmdLockEquipmentScRsp":
      return CmdItemType.CmdLockEquipmentScRsp;
    case 507:
    case "CmdUseItemCsReq":
      return CmdItemType.CmdUseItemCsReq;
    case 508:
    case "CmdUseItemScRsp":
      return CmdItemType.CmdUseItemScRsp;
    case 509:
    case "CmdRankUpEquipmentCsReq":
      return CmdItemType.CmdRankUpEquipmentCsReq;
    case 510:
    case "CmdRankUpEquipmentScRsp":
      return CmdItemType.CmdRankUpEquipmentScRsp;
    case 511:
    case "CmdExpUpEquipmentCsReq":
      return CmdItemType.CmdExpUpEquipmentCsReq;
    case 512:
    case "CmdExpUpEquipmentScRsp":
      return CmdItemType.CmdExpUpEquipmentScRsp;
    case 513:
    case "CmdComposeItemCsReq":
      return CmdItemType.CmdComposeItemCsReq;
    case 514:
    case "CmdComposeItemScRsp":
      return CmdItemType.CmdComposeItemScRsp;
    case 515:
    case "CmdExpUpRelicCsReq":
      return CmdItemType.CmdExpUpRelicCsReq;
    case 516:
    case "CmdExpUpRelicScRsp":
      return CmdItemType.CmdExpUpRelicScRsp;
    case 517:
    case "CmdLockRelicCsReq":
      return CmdItemType.CmdLockRelicCsReq;
    case 518:
    case "CmdLockRelicScRsp":
      return CmdItemType.CmdLockRelicScRsp;
    case 519:
    case "CmdSellItemCsReq":
      return CmdItemType.CmdSellItemCsReq;
    case 520:
    case "CmdSellItemScRsp":
      return CmdItemType.CmdSellItemScRsp;
    case 521:
    case "CmdRechargeSuccNotify":
      return CmdItemType.CmdRechargeSuccNotify;
    case -1:
    case "UNRECOGNIZED":
    default:
      return CmdItemType.UNRECOGNIZED;
  }
}

export function cmdItemTypeToJSON(object: CmdItemType): string {
  switch (object) {
    case CmdItemType.CmdItemTypeNone:
      return "CmdItemTypeNone";
    case CmdItemType.CmdGetBagCsReq:
      return "CmdGetBagCsReq";
    case CmdItemType.CmdGetBagScRsp:
      return "CmdGetBagScRsp";
    case CmdItemType.CmdPromoteEquipmentCsReq:
      return "CmdPromoteEquipmentCsReq";
    case CmdItemType.CmdPromoteEquipmentScRsp:
      return "CmdPromoteEquipmentScRsp";
    case CmdItemType.CmdLockEquipmentCsReq:
      return "CmdLockEquipmentCsReq";
    case CmdItemType.CmdLockEquipmentScRsp:
      return "CmdLockEquipmentScRsp";
    case CmdItemType.CmdUseItemCsReq:
      return "CmdUseItemCsReq";
    case CmdItemType.CmdUseItemScRsp:
      return "CmdUseItemScRsp";
    case CmdItemType.CmdRankUpEquipmentCsReq:
      return "CmdRankUpEquipmentCsReq";
    case CmdItemType.CmdRankUpEquipmentScRsp:
      return "CmdRankUpEquipmentScRsp";
    case CmdItemType.CmdExpUpEquipmentCsReq:
      return "CmdExpUpEquipmentCsReq";
    case CmdItemType.CmdExpUpEquipmentScRsp:
      return "CmdExpUpEquipmentScRsp";
    case CmdItemType.CmdComposeItemCsReq:
      return "CmdComposeItemCsReq";
    case CmdItemType.CmdComposeItemScRsp:
      return "CmdComposeItemScRsp";
    case CmdItemType.CmdExpUpRelicCsReq:
      return "CmdExpUpRelicCsReq";
    case CmdItemType.CmdExpUpRelicScRsp:
      return "CmdExpUpRelicScRsp";
    case CmdItemType.CmdLockRelicCsReq:
      return "CmdLockRelicCsReq";
    case CmdItemType.CmdLockRelicScRsp:
      return "CmdLockRelicScRsp";
    case CmdItemType.CmdSellItemCsReq:
      return "CmdSellItemCsReq";
    case CmdItemType.CmdSellItemScRsp:
      return "CmdSellItemScRsp";
    case CmdItemType.CmdRechargeSuccNotify:
      return "CmdRechargeSuccNotify";
    case CmdItemType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum CmdLineupType {
  CmdLineupTypeNone = 0,
  CmdGetStageLineupCsReq = 701,
  CmdGetStageLineupScRsp = 702,
  CmdGetCurLineupDataCsReq = 703,
  CmdGetCurLineupDataScRsp = 704,
  CmdJoinLineupCsReq = 705,
  CmdJoinLineupScRsp = 706,
  CmdQuitLineupCsReq = 707,
  CmdQuitLineupScRsp = 708,
  CmdSwapLineupCsReq = 709,
  CmdSwapLineupScRsp = 710,
  CmdSyncLineupNotify = 711,
  CmdGetLineupAvatarDataCsReq = 712,
  CmdGetLineupAvatarDataScRsp = 713,
  CmdChangeLineupLeaderCsReq = 714,
  CmdChangeLineupLeaderScRsp = 715,
  CmdSwitchLineupIndexCsReq = 716,
  CmdSwitchLineupIndexScRsp = 717,
  CmdSetLineupNameCsReq = 718,
  CmdSetLineupNameScRsp = 719,
  CmdGetAllLineupDataCsReq = 720,
  CmdGetAllLineupDataScRsp = 721,
  CmdVirtualLineupDestroyNotify = 722,
  UNRECOGNIZED = -1,
}

export function cmdLineupTypeFromJSON(object: any): CmdLineupType {
  switch (object) {
    case 0:
    case "CmdLineupTypeNone":
      return CmdLineupType.CmdLineupTypeNone;
    case 701:
    case "CmdGetStageLineupCsReq":
      return CmdLineupType.CmdGetStageLineupCsReq;
    case 702:
    case "CmdGetStageLineupScRsp":
      return CmdLineupType.CmdGetStageLineupScRsp;
    case 703:
    case "CmdGetCurLineupDataCsReq":
      return CmdLineupType.CmdGetCurLineupDataCsReq;
    case 704:
    case "CmdGetCurLineupDataScRsp":
      return CmdLineupType.CmdGetCurLineupDataScRsp;
    case 705:
    case "CmdJoinLineupCsReq":
      return CmdLineupType.CmdJoinLineupCsReq;
    case 706:
    case "CmdJoinLineupScRsp":
      return CmdLineupType.CmdJoinLineupScRsp;
    case 707:
    case "CmdQuitLineupCsReq":
      return CmdLineupType.CmdQuitLineupCsReq;
    case 708:
    case "CmdQuitLineupScRsp":
      return CmdLineupType.CmdQuitLineupScRsp;
    case 709:
    case "CmdSwapLineupCsReq":
      return CmdLineupType.CmdSwapLineupCsReq;
    case 710:
    case "CmdSwapLineupScRsp":
      return CmdLineupType.CmdSwapLineupScRsp;
    case 711:
    case "CmdSyncLineupNotify":
      return CmdLineupType.CmdSyncLineupNotify;
    case 712:
    case "CmdGetLineupAvatarDataCsReq":
      return CmdLineupType.CmdGetLineupAvatarDataCsReq;
    case 713:
    case "CmdGetLineupAvatarDataScRsp":
      return CmdLineupType.CmdGetLineupAvatarDataScRsp;
    case 714:
    case "CmdChangeLineupLeaderCsReq":
      return CmdLineupType.CmdChangeLineupLeaderCsReq;
    case 715:
    case "CmdChangeLineupLeaderScRsp":
      return CmdLineupType.CmdChangeLineupLeaderScRsp;
    case 716:
    case "CmdSwitchLineupIndexCsReq":
      return CmdLineupType.CmdSwitchLineupIndexCsReq;
    case 717:
    case "CmdSwitchLineupIndexScRsp":
      return CmdLineupType.CmdSwitchLineupIndexScRsp;
    case 718:
    case "CmdSetLineupNameCsReq":
      return CmdLineupType.CmdSetLineupNameCsReq;
    case 719:
    case "CmdSetLineupNameScRsp":
      return CmdLineupType.CmdSetLineupNameScRsp;
    case 720:
    case "CmdGetAllLineupDataCsReq":
      return CmdLineupType.CmdGetAllLineupDataCsReq;
    case 721:
    case "CmdGetAllLineupDataScRsp":
      return CmdLineupType.CmdGetAllLineupDataScRsp;
    case 722:
    case "CmdVirtualLineupDestroyNotify":
      return CmdLineupType.CmdVirtualLineupDestroyNotify;
    case -1:
    case "UNRECOGNIZED":
    default:
      return CmdLineupType.UNRECOGNIZED;
  }
}

export function cmdLineupTypeToJSON(object: CmdLineupType): string {
  switch (object) {
    case CmdLineupType.CmdLineupTypeNone:
      return "CmdLineupTypeNone";
    case CmdLineupType.CmdGetStageLineupCsReq:
      return "CmdGetStageLineupCsReq";
    case CmdLineupType.CmdGetStageLineupScRsp:
      return "CmdGetStageLineupScRsp";
    case CmdLineupType.CmdGetCurLineupDataCsReq:
      return "CmdGetCurLineupDataCsReq";
    case CmdLineupType.CmdGetCurLineupDataScRsp:
      return "CmdGetCurLineupDataScRsp";
    case CmdLineupType.CmdJoinLineupCsReq:
      return "CmdJoinLineupCsReq";
    case CmdLineupType.CmdJoinLineupScRsp:
      return "CmdJoinLineupScRsp";
    case CmdLineupType.CmdQuitLineupCsReq:
      return "CmdQuitLineupCsReq";
    case CmdLineupType.CmdQuitLineupScRsp:
      return "CmdQuitLineupScRsp";
    case CmdLineupType.CmdSwapLineupCsReq:
      return "CmdSwapLineupCsReq";
    case CmdLineupType.CmdSwapLineupScRsp:
      return "CmdSwapLineupScRsp";
    case CmdLineupType.CmdSyncLineupNotify:
      return "CmdSyncLineupNotify";
    case CmdLineupType.CmdGetLineupAvatarDataCsReq:
      return "CmdGetLineupAvatarDataCsReq";
    case CmdLineupType.CmdGetLineupAvatarDataScRsp:
      return "CmdGetLineupAvatarDataScRsp";
    case CmdLineupType.CmdChangeLineupLeaderCsReq:
      return "CmdChangeLineupLeaderCsReq";
    case CmdLineupType.CmdChangeLineupLeaderScRsp:
      return "CmdChangeLineupLeaderScRsp";
    case CmdLineupType.CmdSwitchLineupIndexCsReq:
      return "CmdSwitchLineupIndexCsReq";
    case CmdLineupType.CmdSwitchLineupIndexScRsp:
      return "CmdSwitchLineupIndexScRsp";
    case CmdLineupType.CmdSetLineupNameCsReq:
      return "CmdSetLineupNameCsReq";
    case CmdLineupType.CmdSetLineupNameScRsp:
      return "CmdSetLineupNameScRsp";
    case CmdLineupType.CmdGetAllLineupDataCsReq:
      return "CmdGetAllLineupDataCsReq";
    case CmdLineupType.CmdGetAllLineupDataScRsp:
      return "CmdGetAllLineupDataScRsp";
    case CmdLineupType.CmdVirtualLineupDestroyNotify:
      return "CmdVirtualLineupDestroyNotify";
    case CmdLineupType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum ExtraLineupType {
  LINEUP_NONE = 0,
  LINEUP_CHALLENGE = 1,
  LINEUP_ROGUE = 2,
  LINEUP_CHALLENGE_2 = 3,
  LINEUP_CHALLENGE_3 = 4,
  LINEUP_ROGUE_CHALLENGE = 5,
  UNRECOGNIZED = -1,
}

export function extraLineupTypeFromJSON(object: any): ExtraLineupType {
  switch (object) {
    case 0:
    case "LINEUP_NONE":
      return ExtraLineupType.LINEUP_NONE;
    case 1:
    case "LINEUP_CHALLENGE":
      return ExtraLineupType.LINEUP_CHALLENGE;
    case 2:
    case "LINEUP_ROGUE":
      return ExtraLineupType.LINEUP_ROGUE;
    case 3:
    case "LINEUP_CHALLENGE_2":
      return ExtraLineupType.LINEUP_CHALLENGE_2;
    case 4:
    case "LINEUP_CHALLENGE_3":
      return ExtraLineupType.LINEUP_CHALLENGE_3;
    case 5:
    case "LINEUP_ROGUE_CHALLENGE":
      return ExtraLineupType.LINEUP_ROGUE_CHALLENGE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ExtraLineupType.UNRECOGNIZED;
  }
}

export function extraLineupTypeToJSON(object: ExtraLineupType): string {
  switch (object) {
    case ExtraLineupType.LINEUP_NONE:
      return "LINEUP_NONE";
    case ExtraLineupType.LINEUP_CHALLENGE:
      return "LINEUP_CHALLENGE";
    case ExtraLineupType.LINEUP_ROGUE:
      return "LINEUP_ROGUE";
    case ExtraLineupType.LINEUP_CHALLENGE_2:
      return "LINEUP_CHALLENGE_2";
    case ExtraLineupType.LINEUP_CHALLENGE_3:
      return "LINEUP_CHALLENGE_3";
    case ExtraLineupType.LINEUP_ROGUE_CHALLENGE:
      return "LINEUP_ROGUE_CHALLENGE";
    case ExtraLineupType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum SyncLineupReason {
  SYNC_REASON_NONE = 0,
  SYNC_REASON_MP_ADD = 1,
  SYNC_REASON_HP_ADD = 2,
  UNRECOGNIZED = -1,
}

export function syncLineupReasonFromJSON(object: any): SyncLineupReason {
  switch (object) {
    case 0:
    case "SYNC_REASON_NONE":
      return SyncLineupReason.SYNC_REASON_NONE;
    case 1:
    case "SYNC_REASON_MP_ADD":
      return SyncLineupReason.SYNC_REASON_MP_ADD;
    case 2:
    case "SYNC_REASON_HP_ADD":
      return SyncLineupReason.SYNC_REASON_HP_ADD;
    case -1:
    case "UNRECOGNIZED":
    default:
      return SyncLineupReason.UNRECOGNIZED;
  }
}

export function syncLineupReasonToJSON(object: SyncLineupReason): string {
  switch (object) {
    case SyncLineupReason.SYNC_REASON_NONE:
      return "SYNC_REASON_NONE";
    case SyncLineupReason.SYNC_REASON_MP_ADD:
      return "SYNC_REASON_MP_ADD";
    case SyncLineupReason.SYNC_REASON_HP_ADD:
      return "SYNC_REASON_HP_ADD";
    case SyncLineupReason.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum CmdMailType {
  CmdMailTypeNone = 0,
  CmdGetMailCsReq = 801,
  CmdGetMailScRsp = 802,
  CmdMarkReadMailCsReq = 803,
  CmdMarkReadMailScRsp = 804,
  CmdDelMailCsReq = 805,
  CmdDelMailScRsp = 806,
  CmdTakeMailAttachmentCsReq = 807,
  CmdTakeMailAttachmentScRsp = 808,
  CmdNewMailScNotify = 809,
  UNRECOGNIZED = -1,
}

export function cmdMailTypeFromJSON(object: any): CmdMailType {
  switch (object) {
    case 0:
    case "CmdMailTypeNone":
      return CmdMailType.CmdMailTypeNone;
    case 801:
    case "CmdGetMailCsReq":
      return CmdMailType.CmdGetMailCsReq;
    case 802:
    case "CmdGetMailScRsp":
      return CmdMailType.CmdGetMailScRsp;
    case 803:
    case "CmdMarkReadMailCsReq":
      return CmdMailType.CmdMarkReadMailCsReq;
    case 804:
    case "CmdMarkReadMailScRsp":
      return CmdMailType.CmdMarkReadMailScRsp;
    case 805:
    case "CmdDelMailCsReq":
      return CmdMailType.CmdDelMailCsReq;
    case 806:
    case "CmdDelMailScRsp":
      return CmdMailType.CmdDelMailScRsp;
    case 807:
    case "CmdTakeMailAttachmentCsReq":
      return CmdMailType.CmdTakeMailAttachmentCsReq;
    case 808:
    case "CmdTakeMailAttachmentScRsp":
      return CmdMailType.CmdTakeMailAttachmentScRsp;
    case 809:
    case "CmdNewMailScNotify":
      return CmdMailType.CmdNewMailScNotify;
    case -1:
    case "UNRECOGNIZED":
    default:
      return CmdMailType.UNRECOGNIZED;
  }
}

export function cmdMailTypeToJSON(object: CmdMailType): string {
  switch (object) {
    case CmdMailType.CmdMailTypeNone:
      return "CmdMailTypeNone";
    case CmdMailType.CmdGetMailCsReq:
      return "CmdGetMailCsReq";
    case CmdMailType.CmdGetMailScRsp:
      return "CmdGetMailScRsp";
    case CmdMailType.CmdMarkReadMailCsReq:
      return "CmdMarkReadMailCsReq";
    case CmdMailType.CmdMarkReadMailScRsp:
      return "CmdMarkReadMailScRsp";
    case CmdMailType.CmdDelMailCsReq:
      return "CmdDelMailCsReq";
    case CmdMailType.CmdDelMailScRsp:
      return "CmdDelMailScRsp";
    case CmdMailType.CmdTakeMailAttachmentCsReq:
      return "CmdTakeMailAttachmentCsReq";
    case CmdMailType.CmdTakeMailAttachmentScRsp:
      return "CmdTakeMailAttachmentScRsp";
    case CmdMailType.CmdNewMailScNotify:
      return "CmdNewMailScNotify";
    case CmdMailType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum CmdMazeType {
  CmdMazeTypeNode = 0,
  CmdGetMazeCsReq = 1001,
  CmdGetMazeScRsp = 1002,
  CmdChooseMazeSeriesCsReq = 1003,
  CmdChooseMazeSeriesScRsp = 1004,
  CmdChooseMazeAbilityCsReq = 1005,
  CmdChooseMazeAbilityScRsp = 1006,
  CmdEnterMazeCsReq = 1007,
  CmdEnterMazeScRsp = 1008,
  CmdMazeBuffScNotify = 1011,
  CmdCastMazeSkillCsReq = 1012,
  CmdCastMazeSkillScRsp = 1013,
  CmdMazePlaneEventScNotify = 1014,
  CmdEnterMazeByServerScNotify = 1015,
  CmdGetMazeMapInfoCsReq = 1016,
  CmdGetMazeMapInfoScRsp = 1017,
  CmdGetMazeTimeOfDayCsReq = 1018,
  CmdGetMazeTimeOfDayScRsp = 1019,
  CmdSetMazeTimeOfDayCsReq = 1020,
  CmdSetMazeTimeOfDayScRsp = 1021,
  CmdDelMazeTimeOfDayCsReq = 1022,
  CmdDelMazeTimeOfDayScRsp = 1023,
  CmdReturnStartAnchorCsReq = 1024,
  CmdReturnStartAnchorScRsp = 1025,
  UNRECOGNIZED = -1,
}

export function cmdMazeTypeFromJSON(object: any): CmdMazeType {
  switch (object) {
    case 0:
    case "CmdMazeTypeNode":
      return CmdMazeType.CmdMazeTypeNode;
    case 1001:
    case "CmdGetMazeCsReq":
      return CmdMazeType.CmdGetMazeCsReq;
    case 1002:
    case "CmdGetMazeScRsp":
      return CmdMazeType.CmdGetMazeScRsp;
    case 1003:
    case "CmdChooseMazeSeriesCsReq":
      return CmdMazeType.CmdChooseMazeSeriesCsReq;
    case 1004:
    case "CmdChooseMazeSeriesScRsp":
      return CmdMazeType.CmdChooseMazeSeriesScRsp;
    case 1005:
    case "CmdChooseMazeAbilityCsReq":
      return CmdMazeType.CmdChooseMazeAbilityCsReq;
    case 1006:
    case "CmdChooseMazeAbilityScRsp":
      return CmdMazeType.CmdChooseMazeAbilityScRsp;
    case 1007:
    case "CmdEnterMazeCsReq":
      return CmdMazeType.CmdEnterMazeCsReq;
    case 1008:
    case "CmdEnterMazeScRsp":
      return CmdMazeType.CmdEnterMazeScRsp;
    case 1011:
    case "CmdMazeBuffScNotify":
      return CmdMazeType.CmdMazeBuffScNotify;
    case 1012:
    case "CmdCastMazeSkillCsReq":
      return CmdMazeType.CmdCastMazeSkillCsReq;
    case 1013:
    case "CmdCastMazeSkillScRsp":
      return CmdMazeType.CmdCastMazeSkillScRsp;
    case 1014:
    case "CmdMazePlaneEventScNotify":
      return CmdMazeType.CmdMazePlaneEventScNotify;
    case 1015:
    case "CmdEnterMazeByServerScNotify":
      return CmdMazeType.CmdEnterMazeByServerScNotify;
    case 1016:
    case "CmdGetMazeMapInfoCsReq":
      return CmdMazeType.CmdGetMazeMapInfoCsReq;
    case 1017:
    case "CmdGetMazeMapInfoScRsp":
      return CmdMazeType.CmdGetMazeMapInfoScRsp;
    case 1018:
    case "CmdGetMazeTimeOfDayCsReq":
      return CmdMazeType.CmdGetMazeTimeOfDayCsReq;
    case 1019:
    case "CmdGetMazeTimeOfDayScRsp":
      return CmdMazeType.CmdGetMazeTimeOfDayScRsp;
    case 1020:
    case "CmdSetMazeTimeOfDayCsReq":
      return CmdMazeType.CmdSetMazeTimeOfDayCsReq;
    case 1021:
    case "CmdSetMazeTimeOfDayScRsp":
      return CmdMazeType.CmdSetMazeTimeOfDayScRsp;
    case 1022:
    case "CmdDelMazeTimeOfDayCsReq":
      return CmdMazeType.CmdDelMazeTimeOfDayCsReq;
    case 1023:
    case "CmdDelMazeTimeOfDayScRsp":
      return CmdMazeType.CmdDelMazeTimeOfDayScRsp;
    case 1024:
    case "CmdReturnStartAnchorCsReq":
      return CmdMazeType.CmdReturnStartAnchorCsReq;
    case 1025:
    case "CmdReturnStartAnchorScRsp":
      return CmdMazeType.CmdReturnStartAnchorScRsp;
    case -1:
    case "UNRECOGNIZED":
    default:
      return CmdMazeType.UNRECOGNIZED;
  }
}

export function cmdMazeTypeToJSON(object: CmdMazeType): string {
  switch (object) {
    case CmdMazeType.CmdMazeTypeNode:
      return "CmdMazeTypeNode";
    case CmdMazeType.CmdGetMazeCsReq:
      return "CmdGetMazeCsReq";
    case CmdMazeType.CmdGetMazeScRsp:
      return "CmdGetMazeScRsp";
    case CmdMazeType.CmdChooseMazeSeriesCsReq:
      return "CmdChooseMazeSeriesCsReq";
    case CmdMazeType.CmdChooseMazeSeriesScRsp:
      return "CmdChooseMazeSeriesScRsp";
    case CmdMazeType.CmdChooseMazeAbilityCsReq:
      return "CmdChooseMazeAbilityCsReq";
    case CmdMazeType.CmdChooseMazeAbilityScRsp:
      return "CmdChooseMazeAbilityScRsp";
    case CmdMazeType.CmdEnterMazeCsReq:
      return "CmdEnterMazeCsReq";
    case CmdMazeType.CmdEnterMazeScRsp:
      return "CmdEnterMazeScRsp";
    case CmdMazeType.CmdMazeBuffScNotify:
      return "CmdMazeBuffScNotify";
    case CmdMazeType.CmdCastMazeSkillCsReq:
      return "CmdCastMazeSkillCsReq";
    case CmdMazeType.CmdCastMazeSkillScRsp:
      return "CmdCastMazeSkillScRsp";
    case CmdMazeType.CmdMazePlaneEventScNotify:
      return "CmdMazePlaneEventScNotify";
    case CmdMazeType.CmdEnterMazeByServerScNotify:
      return "CmdEnterMazeByServerScNotify";
    case CmdMazeType.CmdGetMazeMapInfoCsReq:
      return "CmdGetMazeMapInfoCsReq";
    case CmdMazeType.CmdGetMazeMapInfoScRsp:
      return "CmdGetMazeMapInfoScRsp";
    case CmdMazeType.CmdGetMazeTimeOfDayCsReq:
      return "CmdGetMazeTimeOfDayCsReq";
    case CmdMazeType.CmdGetMazeTimeOfDayScRsp:
      return "CmdGetMazeTimeOfDayScRsp";
    case CmdMazeType.CmdSetMazeTimeOfDayCsReq:
      return "CmdSetMazeTimeOfDayCsReq";
    case CmdMazeType.CmdSetMazeTimeOfDayScRsp:
      return "CmdSetMazeTimeOfDayScRsp";
    case CmdMazeType.CmdDelMazeTimeOfDayCsReq:
      return "CmdDelMazeTimeOfDayCsReq";
    case CmdMazeType.CmdDelMazeTimeOfDayScRsp:
      return "CmdDelMazeTimeOfDayScRsp";
    case CmdMazeType.CmdReturnStartAnchorCsReq:
      return "CmdReturnStartAnchorCsReq";
    case CmdMazeType.CmdReturnStartAnchorScRsp:
      return "CmdReturnStartAnchorScRsp";
    case CmdMazeType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum MazeBuffOp {
  MAZE_BUFF_OP_NONE = 0,
  MAZE_BUFF_OP_ADD = 1,
  MAZE_BUFF_OP_DEL = 2,
  UNRECOGNIZED = -1,
}

export function mazeBuffOpFromJSON(object: any): MazeBuffOp {
  switch (object) {
    case 0:
    case "MAZE_BUFF_OP_NONE":
      return MazeBuffOp.MAZE_BUFF_OP_NONE;
    case 1:
    case "MAZE_BUFF_OP_ADD":
      return MazeBuffOp.MAZE_BUFF_OP_ADD;
    case 2:
    case "MAZE_BUFF_OP_DEL":
      return MazeBuffOp.MAZE_BUFF_OP_DEL;
    case -1:
    case "UNRECOGNIZED":
    default:
      return MazeBuffOp.UNRECOGNIZED;
  }
}

export function mazeBuffOpToJSON(object: MazeBuffOp): string {
  switch (object) {
    case MazeBuffOp.MAZE_BUFF_OP_NONE:
      return "MAZE_BUFF_OP_NONE";
    case MazeBuffOp.MAZE_BUFF_OP_ADD:
      return "MAZE_BUFF_OP_ADD";
    case MazeBuffOp.MAZE_BUFF_OP_DEL:
      return "MAZE_BUFF_OP_DEL";
    case MazeBuffOp.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum EnterMazeReason {
  REASON_NONE = 0,
  REASON_CHALLENGE_TIMEOUT = 1,
  REASON_ROGUE_TIMEOUT = 2,
  UNRECOGNIZED = -1,
}

export function enterMazeReasonFromJSON(object: any): EnterMazeReason {
  switch (object) {
    case 0:
    case "REASON_NONE":
      return EnterMazeReason.REASON_NONE;
    case 1:
    case "REASON_CHALLENGE_TIMEOUT":
      return EnterMazeReason.REASON_CHALLENGE_TIMEOUT;
    case 2:
    case "REASON_ROGUE_TIMEOUT":
      return EnterMazeReason.REASON_ROGUE_TIMEOUT;
    case -1:
    case "UNRECOGNIZED":
    default:
      return EnterMazeReason.UNRECOGNIZED;
  }
}

export function enterMazeReasonToJSON(object: EnterMazeReason): string {
  switch (object) {
    case EnterMazeReason.REASON_NONE:
      return "REASON_NONE";
    case EnterMazeReason.REASON_CHALLENGE_TIMEOUT:
      return "REASON_CHALLENGE_TIMEOUT";
    case EnterMazeReason.REASON_ROGUE_TIMEOUT:
      return "REASON_ROGUE_TIMEOUT";
    case EnterMazeReason.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum CmdMessageType {
  CmdMessageTypeNone = 0,
  CmdGetNpcMessageGroupCsReq = 2701,
  CmdGetNpcMessageGroupScRsp = 2702,
  CmdGetNpcStatusCsReq = 2703,
  CmdGetNpcStatusScRsp = 2704,
  CmdFinishItemIdCsReq = 2705,
  CmdFinishItemIdScRsp = 2706,
  CmdFinishSectionIdCsReq = 2707,
  CmdFinishSectionIdScRsp = 2708,
  UNRECOGNIZED = -1,
}

export function cmdMessageTypeFromJSON(object: any): CmdMessageType {
  switch (object) {
    case 0:
    case "CmdMessageTypeNone":
      return CmdMessageType.CmdMessageTypeNone;
    case 2701:
    case "CmdGetNpcMessageGroupCsReq":
      return CmdMessageType.CmdGetNpcMessageGroupCsReq;
    case 2702:
    case "CmdGetNpcMessageGroupScRsp":
      return CmdMessageType.CmdGetNpcMessageGroupScRsp;
    case 2703:
    case "CmdGetNpcStatusCsReq":
      return CmdMessageType.CmdGetNpcStatusCsReq;
    case 2704:
    case "CmdGetNpcStatusScRsp":
      return CmdMessageType.CmdGetNpcStatusScRsp;
    case 2705:
    case "CmdFinishItemIdCsReq":
      return CmdMessageType.CmdFinishItemIdCsReq;
    case 2706:
    case "CmdFinishItemIdScRsp":
      return CmdMessageType.CmdFinishItemIdScRsp;
    case 2707:
    case "CmdFinishSectionIdCsReq":
      return CmdMessageType.CmdFinishSectionIdCsReq;
    case 2708:
    case "CmdFinishSectionIdScRsp":
      return CmdMessageType.CmdFinishSectionIdScRsp;
    case -1:
    case "UNRECOGNIZED":
    default:
      return CmdMessageType.UNRECOGNIZED;
  }
}

export function cmdMessageTypeToJSON(object: CmdMessageType): string {
  switch (object) {
    case CmdMessageType.CmdMessageTypeNone:
      return "CmdMessageTypeNone";
    case CmdMessageType.CmdGetNpcMessageGroupCsReq:
      return "CmdGetNpcMessageGroupCsReq";
    case CmdMessageType.CmdGetNpcMessageGroupScRsp:
      return "CmdGetNpcMessageGroupScRsp";
    case CmdMessageType.CmdGetNpcStatusCsReq:
      return "CmdGetNpcStatusCsReq";
    case CmdMessageType.CmdGetNpcStatusScRsp:
      return "CmdGetNpcStatusScRsp";
    case CmdMessageType.CmdFinishItemIdCsReq:
      return "CmdFinishItemIdCsReq";
    case CmdMessageType.CmdFinishItemIdScRsp:
      return "CmdFinishItemIdScRsp";
    case CmdMessageType.CmdFinishSectionIdCsReq:
      return "CmdFinishSectionIdCsReq";
    case CmdMessageType.CmdFinishSectionIdScRsp:
      return "CmdFinishSectionIdScRsp";
    case CmdMessageType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum CmdMissionType {
  CmdMissionTypeNone = 0,
  CmdGetMissionDataCsReq = 1201,
  CmdGetMissionDataScRsp = 1202,
  CmdFinishTalkMissionCsReq = 1203,
  CmdFinishTalkMissionScRsp = 1204,
  CmdMissionRewardScNotify = 1205,
  CmdSyncTaskCsReq = 1206,
  CmdSyncTaskScRsp = 1207,
  CmdDailyTaskDataScNotify = 1208,
  CmdTakeDailyTaskExtraRewardCsReq = 1209,
  CmdTakeDailyTaskExtraRewardScRsp = 1210,
  CmdDailyTaskRewardScNotify = 1211,
  CmdMissionGroupWarnScNotify = 1212,
  CmdFinishCosumeItemMissionCsReq = 1213,
  CmdFinishCosumeItemMissionScRsp = 1214,
  CmdGetMissionEventDataCsReq = 1215,
  CmdGetMissionEventDataScRsp = 1216,
  CmdMissionEventRewardScNotify = 1217,
  CmdAcceptMissionEventCsReq = 1218,
  CmdAcceptMissionEventScRsp = 1219,
  CmdGetMissionStatusCsReq = 1220,
  CmdGetMissionStatusScRsp = 1221,
  CmdInterruptMissionEventCsReq = 1222,
  CmdInterruptMissionEventScRsp = 1223,
  CmdSetMissionEventProgressCsReq = 1224,
  CmdSetMissionEventProgressScRsp = 1225,
  CmdSubMissionRewardScNotify = 1226,
  UNRECOGNIZED = -1,
}

export function cmdMissionTypeFromJSON(object: any): CmdMissionType {
  switch (object) {
    case 0:
    case "CmdMissionTypeNone":
      return CmdMissionType.CmdMissionTypeNone;
    case 1201:
    case "CmdGetMissionDataCsReq":
      return CmdMissionType.CmdGetMissionDataCsReq;
    case 1202:
    case "CmdGetMissionDataScRsp":
      return CmdMissionType.CmdGetMissionDataScRsp;
    case 1203:
    case "CmdFinishTalkMissionCsReq":
      return CmdMissionType.CmdFinishTalkMissionCsReq;
    case 1204:
    case "CmdFinishTalkMissionScRsp":
      return CmdMissionType.CmdFinishTalkMissionScRsp;
    case 1205:
    case "CmdMissionRewardScNotify":
      return CmdMissionType.CmdMissionRewardScNotify;
    case 1206:
    case "CmdSyncTaskCsReq":
      return CmdMissionType.CmdSyncTaskCsReq;
    case 1207:
    case "CmdSyncTaskScRsp":
      return CmdMissionType.CmdSyncTaskScRsp;
    case 1208:
    case "CmdDailyTaskDataScNotify":
      return CmdMissionType.CmdDailyTaskDataScNotify;
    case 1209:
    case "CmdTakeDailyTaskExtraRewardCsReq":
      return CmdMissionType.CmdTakeDailyTaskExtraRewardCsReq;
    case 1210:
    case "CmdTakeDailyTaskExtraRewardScRsp":
      return CmdMissionType.CmdTakeDailyTaskExtraRewardScRsp;
    case 1211:
    case "CmdDailyTaskRewardScNotify":
      return CmdMissionType.CmdDailyTaskRewardScNotify;
    case 1212:
    case "CmdMissionGroupWarnScNotify":
      return CmdMissionType.CmdMissionGroupWarnScNotify;
    case 1213:
    case "CmdFinishCosumeItemMissionCsReq":
      return CmdMissionType.CmdFinishCosumeItemMissionCsReq;
    case 1214:
    case "CmdFinishCosumeItemMissionScRsp":
      return CmdMissionType.CmdFinishCosumeItemMissionScRsp;
    case 1215:
    case "CmdGetMissionEventDataCsReq":
      return CmdMissionType.CmdGetMissionEventDataCsReq;
    case 1216:
    case "CmdGetMissionEventDataScRsp":
      return CmdMissionType.CmdGetMissionEventDataScRsp;
    case 1217:
    case "CmdMissionEventRewardScNotify":
      return CmdMissionType.CmdMissionEventRewardScNotify;
    case 1218:
    case "CmdAcceptMissionEventCsReq":
      return CmdMissionType.CmdAcceptMissionEventCsReq;
    case 1219:
    case "CmdAcceptMissionEventScRsp":
      return CmdMissionType.CmdAcceptMissionEventScRsp;
    case 1220:
    case "CmdGetMissionStatusCsReq":
      return CmdMissionType.CmdGetMissionStatusCsReq;
    case 1221:
    case "CmdGetMissionStatusScRsp":
      return CmdMissionType.CmdGetMissionStatusScRsp;
    case 1222:
    case "CmdInterruptMissionEventCsReq":
      return CmdMissionType.CmdInterruptMissionEventCsReq;
    case 1223:
    case "CmdInterruptMissionEventScRsp":
      return CmdMissionType.CmdInterruptMissionEventScRsp;
    case 1224:
    case "CmdSetMissionEventProgressCsReq":
      return CmdMissionType.CmdSetMissionEventProgressCsReq;
    case 1225:
    case "CmdSetMissionEventProgressScRsp":
      return CmdMissionType.CmdSetMissionEventProgressScRsp;
    case 1226:
    case "CmdSubMissionRewardScNotify":
      return CmdMissionType.CmdSubMissionRewardScNotify;
    case -1:
    case "UNRECOGNIZED":
    default:
      return CmdMissionType.UNRECOGNIZED;
  }
}

export function cmdMissionTypeToJSON(object: CmdMissionType): string {
  switch (object) {
    case CmdMissionType.CmdMissionTypeNone:
      return "CmdMissionTypeNone";
    case CmdMissionType.CmdGetMissionDataCsReq:
      return "CmdGetMissionDataCsReq";
    case CmdMissionType.CmdGetMissionDataScRsp:
      return "CmdGetMissionDataScRsp";
    case CmdMissionType.CmdFinishTalkMissionCsReq:
      return "CmdFinishTalkMissionCsReq";
    case CmdMissionType.CmdFinishTalkMissionScRsp:
      return "CmdFinishTalkMissionScRsp";
    case CmdMissionType.CmdMissionRewardScNotify:
      return "CmdMissionRewardScNotify";
    case CmdMissionType.CmdSyncTaskCsReq:
      return "CmdSyncTaskCsReq";
    case CmdMissionType.CmdSyncTaskScRsp:
      return "CmdSyncTaskScRsp";
    case CmdMissionType.CmdDailyTaskDataScNotify:
      return "CmdDailyTaskDataScNotify";
    case CmdMissionType.CmdTakeDailyTaskExtraRewardCsReq:
      return "CmdTakeDailyTaskExtraRewardCsReq";
    case CmdMissionType.CmdTakeDailyTaskExtraRewardScRsp:
      return "CmdTakeDailyTaskExtraRewardScRsp";
    case CmdMissionType.CmdDailyTaskRewardScNotify:
      return "CmdDailyTaskRewardScNotify";
    case CmdMissionType.CmdMissionGroupWarnScNotify:
      return "CmdMissionGroupWarnScNotify";
    case CmdMissionType.CmdFinishCosumeItemMissionCsReq:
      return "CmdFinishCosumeItemMissionCsReq";
    case CmdMissionType.CmdFinishCosumeItemMissionScRsp:
      return "CmdFinishCosumeItemMissionScRsp";
    case CmdMissionType.CmdGetMissionEventDataCsReq:
      return "CmdGetMissionEventDataCsReq";
    case CmdMissionType.CmdGetMissionEventDataScRsp:
      return "CmdGetMissionEventDataScRsp";
    case CmdMissionType.CmdMissionEventRewardScNotify:
      return "CmdMissionEventRewardScNotify";
    case CmdMissionType.CmdAcceptMissionEventCsReq:
      return "CmdAcceptMissionEventCsReq";
    case CmdMissionType.CmdAcceptMissionEventScRsp:
      return "CmdAcceptMissionEventScRsp";
    case CmdMissionType.CmdGetMissionStatusCsReq:
      return "CmdGetMissionStatusCsReq";
    case CmdMissionType.CmdGetMissionStatusScRsp:
      return "CmdGetMissionStatusScRsp";
    case CmdMissionType.CmdInterruptMissionEventCsReq:
      return "CmdInterruptMissionEventCsReq";
    case CmdMissionType.CmdInterruptMissionEventScRsp:
      return "CmdInterruptMissionEventScRsp";
    case CmdMissionType.CmdSetMissionEventProgressCsReq:
      return "CmdSetMissionEventProgressCsReq";
    case CmdMissionType.CmdSetMissionEventProgressScRsp:
      return "CmdSetMissionEventProgressScRsp";
    case CmdMissionType.CmdSubMissionRewardScNotify:
      return "CmdSubMissionRewardScNotify";
    case CmdMissionType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum CmdPlayerType {
  CmdPlayerTypeNone = 0,
  CmdPlayerLoginCsReq = 1,
  CmdPlayerLoginScRsp = 2,
  CmdPlayerLogoutCsReq = 3,
  CmdPlayerLogoutScRsp = 4,
  CmdPlayerGetTokenCsReq = 5,
  CmdPlayerGetTokenScRsp = 6,
  CmdPlayerKeepAliveNotify = 7,
  CmdGmTalkScNotify = 8,
  CmdPlayerKickOutScNotify = 9,
  CmdGmTalkCsReq = 10,
  CmdGmTalkScRsp = 11,
  CmdExchangeStaminaCsReq = 14,
  CmdExchangeStaminaScRsp = 15,
  CmdGetAuthkeyCsReq = 16,
  CmdGetAuthkeyScRsp = 17,
  CmdRegionStopScNotify = 18,
  CmdAntiAddictScNotify = 19,
  CmdSetNicknameCsReq = 20,
  CmdSetNicknameScRsp = 21,
  CmdGetLevelRewardTakenListCsReq = 22,
  CmdGetLevelRewardTakenListScRsp = 23,
  CmdGetLevelRewardCsReq = 24,
  CmdGetLevelRewardScRsp = 25,
  CmdSyncTimeCsReq = 26,
  CmdSyncTimeScRsp = 27,
  CmdSetLanguageCsReq = 28,
  CmdSetLanguageScRsp = 29,
  CmdServerAnnounceNotify = 30,
  CmdSetHeroBasicTypeCsReq = 31,
  CmdSetHeroBasicTypeScRsp = 32,
  CmdGetHeroBasicTypeInfoCsReq = 33,
  CmdGetHeroBasicTypeInfoScRsp = 34,
  CmdGetHeroPathCsReq = 35,
  CmdGetHeroPathScRsp = 36,
  CmdHeroPathChangedNotify = 37,
  CmdSetGenderCsReq = 38,
  CmdSetGenderScRsp = 39,
  CmdSetPlayerInfoCsReq = 40,
  CmdSetPlayerInfoScRsp = 41,
  CmdHeroBasicTypeChangedNotify = 42,
  CmdQueryProductInfoCsReq = 43,
  CmdQueryProductInfoScRsp = 44,
  CmdClientDownloadDataScNotify = 45,
  CmdUpdateFeatureSwitchScNotify = 46,
  CmdGetBasicInfoCsReq = 47,
  CmdGetBasicInfoScRsp = 48,
  CmdDailyRefreshNotify = 49,
  UNRECOGNIZED = -1,
}

export function cmdPlayerTypeFromJSON(object: any): CmdPlayerType {
  switch (object) {
    case 0:
    case "CmdPlayerTypeNone":
      return CmdPlayerType.CmdPlayerTypeNone;
    case 1:
    case "CmdPlayerLoginCsReq":
      return CmdPlayerType.CmdPlayerLoginCsReq;
    case 2:
    case "CmdPlayerLoginScRsp":
      return CmdPlayerType.CmdPlayerLoginScRsp;
    case 3:
    case "CmdPlayerLogoutCsReq":
      return CmdPlayerType.CmdPlayerLogoutCsReq;
    case 4:
    case "CmdPlayerLogoutScRsp":
      return CmdPlayerType.CmdPlayerLogoutScRsp;
    case 5:
    case "CmdPlayerGetTokenCsReq":
      return CmdPlayerType.CmdPlayerGetTokenCsReq;
    case 6:
    case "CmdPlayerGetTokenScRsp":
      return CmdPlayerType.CmdPlayerGetTokenScRsp;
    case 7:
    case "CmdPlayerKeepAliveNotify":
      return CmdPlayerType.CmdPlayerKeepAliveNotify;
    case 8:
    case "CmdGmTalkScNotify":
      return CmdPlayerType.CmdGmTalkScNotify;
    case 9:
    case "CmdPlayerKickOutScNotify":
      return CmdPlayerType.CmdPlayerKickOutScNotify;
    case 10:
    case "CmdGmTalkCsReq":
      return CmdPlayerType.CmdGmTalkCsReq;
    case 11:
    case "CmdGmTalkScRsp":
      return CmdPlayerType.CmdGmTalkScRsp;
    case 14:
    case "CmdExchangeStaminaCsReq":
      return CmdPlayerType.CmdExchangeStaminaCsReq;
    case 15:
    case "CmdExchangeStaminaScRsp":
      return CmdPlayerType.CmdExchangeStaminaScRsp;
    case 16:
    case "CmdGetAuthkeyCsReq":
      return CmdPlayerType.CmdGetAuthkeyCsReq;
    case 17:
    case "CmdGetAuthkeyScRsp":
      return CmdPlayerType.CmdGetAuthkeyScRsp;
    case 18:
    case "CmdRegionStopScNotify":
      return CmdPlayerType.CmdRegionStopScNotify;
    case 19:
    case "CmdAntiAddictScNotify":
      return CmdPlayerType.CmdAntiAddictScNotify;
    case 20:
    case "CmdSetNicknameCsReq":
      return CmdPlayerType.CmdSetNicknameCsReq;
    case 21:
    case "CmdSetNicknameScRsp":
      return CmdPlayerType.CmdSetNicknameScRsp;
    case 22:
    case "CmdGetLevelRewardTakenListCsReq":
      return CmdPlayerType.CmdGetLevelRewardTakenListCsReq;
    case 23:
    case "CmdGetLevelRewardTakenListScRsp":
      return CmdPlayerType.CmdGetLevelRewardTakenListScRsp;
    case 24:
    case "CmdGetLevelRewardCsReq":
      return CmdPlayerType.CmdGetLevelRewardCsReq;
    case 25:
    case "CmdGetLevelRewardScRsp":
      return CmdPlayerType.CmdGetLevelRewardScRsp;
    case 26:
    case "CmdSyncTimeCsReq":
      return CmdPlayerType.CmdSyncTimeCsReq;
    case 27:
    case "CmdSyncTimeScRsp":
      return CmdPlayerType.CmdSyncTimeScRsp;
    case 28:
    case "CmdSetLanguageCsReq":
      return CmdPlayerType.CmdSetLanguageCsReq;
    case 29:
    case "CmdSetLanguageScRsp":
      return CmdPlayerType.CmdSetLanguageScRsp;
    case 30:
    case "CmdServerAnnounceNotify":
      return CmdPlayerType.CmdServerAnnounceNotify;
    case 31:
    case "CmdSetHeroBasicTypeCsReq":
      return CmdPlayerType.CmdSetHeroBasicTypeCsReq;
    case 32:
    case "CmdSetHeroBasicTypeScRsp":
      return CmdPlayerType.CmdSetHeroBasicTypeScRsp;
    case 33:
    case "CmdGetHeroBasicTypeInfoCsReq":
      return CmdPlayerType.CmdGetHeroBasicTypeInfoCsReq;
    case 34:
    case "CmdGetHeroBasicTypeInfoScRsp":
      return CmdPlayerType.CmdGetHeroBasicTypeInfoScRsp;
    case 35:
    case "CmdGetHeroPathCsReq":
      return CmdPlayerType.CmdGetHeroPathCsReq;
    case 36:
    case "CmdGetHeroPathScRsp":
      return CmdPlayerType.CmdGetHeroPathScRsp;
    case 37:
    case "CmdHeroPathChangedNotify":
      return CmdPlayerType.CmdHeroPathChangedNotify;
    case 38:
    case "CmdSetGenderCsReq":
      return CmdPlayerType.CmdSetGenderCsReq;
    case 39:
    case "CmdSetGenderScRsp":
      return CmdPlayerType.CmdSetGenderScRsp;
    case 40:
    case "CmdSetPlayerInfoCsReq":
      return CmdPlayerType.CmdSetPlayerInfoCsReq;
    case 41:
    case "CmdSetPlayerInfoScRsp":
      return CmdPlayerType.CmdSetPlayerInfoScRsp;
    case 42:
    case "CmdHeroBasicTypeChangedNotify":
      return CmdPlayerType.CmdHeroBasicTypeChangedNotify;
    case 43:
    case "CmdQueryProductInfoCsReq":
      return CmdPlayerType.CmdQueryProductInfoCsReq;
    case 44:
    case "CmdQueryProductInfoScRsp":
      return CmdPlayerType.CmdQueryProductInfoScRsp;
    case 45:
    case "CmdClientDownloadDataScNotify":
      return CmdPlayerType.CmdClientDownloadDataScNotify;
    case 46:
    case "CmdUpdateFeatureSwitchScNotify":
      return CmdPlayerType.CmdUpdateFeatureSwitchScNotify;
    case 47:
    case "CmdGetBasicInfoCsReq":
      return CmdPlayerType.CmdGetBasicInfoCsReq;
    case 48:
    case "CmdGetBasicInfoScRsp":
      return CmdPlayerType.CmdGetBasicInfoScRsp;
    case 49:
    case "CmdDailyRefreshNotify":
      return CmdPlayerType.CmdDailyRefreshNotify;
    case -1:
    case "UNRECOGNIZED":
    default:
      return CmdPlayerType.UNRECOGNIZED;
  }
}

export function cmdPlayerTypeToJSON(object: CmdPlayerType): string {
  switch (object) {
    case CmdPlayerType.CmdPlayerTypeNone:
      return "CmdPlayerTypeNone";
    case CmdPlayerType.CmdPlayerLoginCsReq:
      return "CmdPlayerLoginCsReq";
    case CmdPlayerType.CmdPlayerLoginScRsp:
      return "CmdPlayerLoginScRsp";
    case CmdPlayerType.CmdPlayerLogoutCsReq:
      return "CmdPlayerLogoutCsReq";
    case CmdPlayerType.CmdPlayerLogoutScRsp:
      return "CmdPlayerLogoutScRsp";
    case CmdPlayerType.CmdPlayerGetTokenCsReq:
      return "CmdPlayerGetTokenCsReq";
    case CmdPlayerType.CmdPlayerGetTokenScRsp:
      return "CmdPlayerGetTokenScRsp";
    case CmdPlayerType.CmdPlayerKeepAliveNotify:
      return "CmdPlayerKeepAliveNotify";
    case CmdPlayerType.CmdGmTalkScNotify:
      return "CmdGmTalkScNotify";
    case CmdPlayerType.CmdPlayerKickOutScNotify:
      return "CmdPlayerKickOutScNotify";
    case CmdPlayerType.CmdGmTalkCsReq:
      return "CmdGmTalkCsReq";
    case CmdPlayerType.CmdGmTalkScRsp:
      return "CmdGmTalkScRsp";
    case CmdPlayerType.CmdExchangeStaminaCsReq:
      return "CmdExchangeStaminaCsReq";
    case CmdPlayerType.CmdExchangeStaminaScRsp:
      return "CmdExchangeStaminaScRsp";
    case CmdPlayerType.CmdGetAuthkeyCsReq:
      return "CmdGetAuthkeyCsReq";
    case CmdPlayerType.CmdGetAuthkeyScRsp:
      return "CmdGetAuthkeyScRsp";
    case CmdPlayerType.CmdRegionStopScNotify:
      return "CmdRegionStopScNotify";
    case CmdPlayerType.CmdAntiAddictScNotify:
      return "CmdAntiAddictScNotify";
    case CmdPlayerType.CmdSetNicknameCsReq:
      return "CmdSetNicknameCsReq";
    case CmdPlayerType.CmdSetNicknameScRsp:
      return "CmdSetNicknameScRsp";
    case CmdPlayerType.CmdGetLevelRewardTakenListCsReq:
      return "CmdGetLevelRewardTakenListCsReq";
    case CmdPlayerType.CmdGetLevelRewardTakenListScRsp:
      return "CmdGetLevelRewardTakenListScRsp";
    case CmdPlayerType.CmdGetLevelRewardCsReq:
      return "CmdGetLevelRewardCsReq";
    case CmdPlayerType.CmdGetLevelRewardScRsp:
      return "CmdGetLevelRewardScRsp";
    case CmdPlayerType.CmdSyncTimeCsReq:
      return "CmdSyncTimeCsReq";
    case CmdPlayerType.CmdSyncTimeScRsp:
      return "CmdSyncTimeScRsp";
    case CmdPlayerType.CmdSetLanguageCsReq:
      return "CmdSetLanguageCsReq";
    case CmdPlayerType.CmdSetLanguageScRsp:
      return "CmdSetLanguageScRsp";
    case CmdPlayerType.CmdServerAnnounceNotify:
      return "CmdServerAnnounceNotify";
    case CmdPlayerType.CmdSetHeroBasicTypeCsReq:
      return "CmdSetHeroBasicTypeCsReq";
    case CmdPlayerType.CmdSetHeroBasicTypeScRsp:
      return "CmdSetHeroBasicTypeScRsp";
    case CmdPlayerType.CmdGetHeroBasicTypeInfoCsReq:
      return "CmdGetHeroBasicTypeInfoCsReq";
    case CmdPlayerType.CmdGetHeroBasicTypeInfoScRsp:
      return "CmdGetHeroBasicTypeInfoScRsp";
    case CmdPlayerType.CmdGetHeroPathCsReq:
      return "CmdGetHeroPathCsReq";
    case CmdPlayerType.CmdGetHeroPathScRsp:
      return "CmdGetHeroPathScRsp";
    case CmdPlayerType.CmdHeroPathChangedNotify:
      return "CmdHeroPathChangedNotify";
    case CmdPlayerType.CmdSetGenderCsReq:
      return "CmdSetGenderCsReq";
    case CmdPlayerType.CmdSetGenderScRsp:
      return "CmdSetGenderScRsp";
    case CmdPlayerType.CmdSetPlayerInfoCsReq:
      return "CmdSetPlayerInfoCsReq";
    case CmdPlayerType.CmdSetPlayerInfoScRsp:
      return "CmdSetPlayerInfoScRsp";
    case CmdPlayerType.CmdHeroBasicTypeChangedNotify:
      return "CmdHeroBasicTypeChangedNotify";
    case CmdPlayerType.CmdQueryProductInfoCsReq:
      return "CmdQueryProductInfoCsReq";
    case CmdPlayerType.CmdQueryProductInfoScRsp:
      return "CmdQueryProductInfoScRsp";
    case CmdPlayerType.CmdClientDownloadDataScNotify:
      return "CmdClientDownloadDataScNotify";
    case CmdPlayerType.CmdUpdateFeatureSwitchScNotify:
      return "CmdUpdateFeatureSwitchScNotify";
    case CmdPlayerType.CmdGetBasicInfoCsReq:
      return "CmdGetBasicInfoCsReq";
    case CmdPlayerType.CmdGetBasicInfoScRsp:
      return "CmdGetBasicInfoScRsp";
    case CmdPlayerType.CmdDailyRefreshNotify:
      return "CmdDailyRefreshNotify";
    case CmdPlayerType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum AuthkeySignType {
  AUTHKEY_SIGN_TYPE_NONE = 0,
  AUTHKEY_SIGN_TYPE_DEFAULT = 1,
  AUTHKEY_SIGN_TYPE_RSA = 2,
  UNRECOGNIZED = -1,
}

export function authkeySignTypeFromJSON(object: any): AuthkeySignType {
  switch (object) {
    case 0:
    case "AUTHKEY_SIGN_TYPE_NONE":
      return AuthkeySignType.AUTHKEY_SIGN_TYPE_NONE;
    case 1:
    case "AUTHKEY_SIGN_TYPE_DEFAULT":
      return AuthkeySignType.AUTHKEY_SIGN_TYPE_DEFAULT;
    case 2:
    case "AUTHKEY_SIGN_TYPE_RSA":
      return AuthkeySignType.AUTHKEY_SIGN_TYPE_RSA;
    case -1:
    case "UNRECOGNIZED":
    default:
      return AuthkeySignType.UNRECOGNIZED;
  }
}

export function authkeySignTypeToJSON(object: AuthkeySignType): string {
  switch (object) {
    case AuthkeySignType.AUTHKEY_SIGN_TYPE_NONE:
      return "AUTHKEY_SIGN_TYPE_NONE";
    case AuthkeySignType.AUTHKEY_SIGN_TYPE_DEFAULT:
      return "AUTHKEY_SIGN_TYPE_DEFAULT";
    case AuthkeySignType.AUTHKEY_SIGN_TYPE_RSA:
      return "AUTHKEY_SIGN_TYPE_RSA";
    case AuthkeySignType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum CmdPlotType {
  CmdPlotTypeNone = 0,
  CmdFinishPlotCsReq = 1101,
  CmdFinishPlotScRsp = 1102,
  UNRECOGNIZED = -1,
}

export function cmdPlotTypeFromJSON(object: any): CmdPlotType {
  switch (object) {
    case 0:
    case "CmdPlotTypeNone":
      return CmdPlotType.CmdPlotTypeNone;
    case 1101:
    case "CmdFinishPlotCsReq":
      return CmdPlotType.CmdFinishPlotCsReq;
    case 1102:
    case "CmdFinishPlotScRsp":
      return CmdPlotType.CmdFinishPlotScRsp;
    case -1:
    case "UNRECOGNIZED":
    default:
      return CmdPlotType.UNRECOGNIZED;
  }
}

export function cmdPlotTypeToJSON(object: CmdPlotType): string {
  switch (object) {
    case CmdPlotType.CmdPlotTypeNone:
      return "CmdPlotTypeNone";
    case CmdPlotType.CmdFinishPlotCsReq:
      return "CmdFinishPlotCsReq";
    case CmdPlotType.CmdFinishPlotScRsp:
      return "CmdFinishPlotScRsp";
    case CmdPlotType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum CmdPrestigeType {
  CmdPrestigeTypeNone = 0,
  CmdGetPrestigeInfoCsReq = 2001,
  CmdGetPrestigeInfoScRsp = 2002,
  CmdPrestigeInfoChangeNotify = 2003,
  CmdTakePrestigeLevelRewardCsReq = 2004,
  CmdTakePrestigeLevelRewardScRsp = 2005,
  UNRECOGNIZED = -1,
}

export function cmdPrestigeTypeFromJSON(object: any): CmdPrestigeType {
  switch (object) {
    case 0:
    case "CmdPrestigeTypeNone":
      return CmdPrestigeType.CmdPrestigeTypeNone;
    case 2001:
    case "CmdGetPrestigeInfoCsReq":
      return CmdPrestigeType.CmdGetPrestigeInfoCsReq;
    case 2002:
    case "CmdGetPrestigeInfoScRsp":
      return CmdPrestigeType.CmdGetPrestigeInfoScRsp;
    case 2003:
    case "CmdPrestigeInfoChangeNotify":
      return CmdPrestigeType.CmdPrestigeInfoChangeNotify;
    case 2004:
    case "CmdTakePrestigeLevelRewardCsReq":
      return CmdPrestigeType.CmdTakePrestigeLevelRewardCsReq;
    case 2005:
    case "CmdTakePrestigeLevelRewardScRsp":
      return CmdPrestigeType.CmdTakePrestigeLevelRewardScRsp;
    case -1:
    case "UNRECOGNIZED":
    default:
      return CmdPrestigeType.UNRECOGNIZED;
  }
}

export function cmdPrestigeTypeToJSON(object: CmdPrestigeType): string {
  switch (object) {
    case CmdPrestigeType.CmdPrestigeTypeNone:
      return "CmdPrestigeTypeNone";
    case CmdPrestigeType.CmdGetPrestigeInfoCsReq:
      return "CmdGetPrestigeInfoCsReq";
    case CmdPrestigeType.CmdGetPrestigeInfoScRsp:
      return "CmdGetPrestigeInfoScRsp";
    case CmdPrestigeType.CmdPrestigeInfoChangeNotify:
      return "CmdPrestigeInfoChangeNotify";
    case CmdPrestigeType.CmdTakePrestigeLevelRewardCsReq:
      return "CmdTakePrestigeLevelRewardCsReq";
    case CmdPrestigeType.CmdTakePrestigeLevelRewardScRsp:
      return "CmdTakePrestigeLevelRewardScRsp";
    case CmdPrestigeType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum CmdQuestType {
  CmdQuestTypeNone = 0,
  CmdGetQuestDataCsReq = 901,
  CmdGetQuestDataScRsp = 902,
  CmdTakeQuestRewardCsReq = 903,
  CmdTakeQuestRewardScRsp = 904,
  CmdTakeAchievementLevelRewardCsReq = 905,
  CmdTakeAchievementLevelRewardScRsp = 906,
  UNRECOGNIZED = -1,
}

export function cmdQuestTypeFromJSON(object: any): CmdQuestType {
  switch (object) {
    case 0:
    case "CmdQuestTypeNone":
      return CmdQuestType.CmdQuestTypeNone;
    case 901:
    case "CmdGetQuestDataCsReq":
      return CmdQuestType.CmdGetQuestDataCsReq;
    case 902:
    case "CmdGetQuestDataScRsp":
      return CmdQuestType.CmdGetQuestDataScRsp;
    case 903:
    case "CmdTakeQuestRewardCsReq":
      return CmdQuestType.CmdTakeQuestRewardCsReq;
    case 904:
    case "CmdTakeQuestRewardScRsp":
      return CmdQuestType.CmdTakeQuestRewardScRsp;
    case 905:
    case "CmdTakeAchievementLevelRewardCsReq":
      return CmdQuestType.CmdTakeAchievementLevelRewardCsReq;
    case 906:
    case "CmdTakeAchievementLevelRewardScRsp":
      return CmdQuestType.CmdTakeAchievementLevelRewardScRsp;
    case -1:
    case "UNRECOGNIZED":
    default:
      return CmdQuestType.UNRECOGNIZED;
  }
}

export function cmdQuestTypeToJSON(object: CmdQuestType): string {
  switch (object) {
    case CmdQuestType.CmdQuestTypeNone:
      return "CmdQuestTypeNone";
    case CmdQuestType.CmdGetQuestDataCsReq:
      return "CmdGetQuestDataCsReq";
    case CmdQuestType.CmdGetQuestDataScRsp:
      return "CmdGetQuestDataScRsp";
    case CmdQuestType.CmdTakeQuestRewardCsReq:
      return "CmdTakeQuestRewardCsReq";
    case CmdQuestType.CmdTakeQuestRewardScRsp:
      return "CmdTakeQuestRewardScRsp";
    case CmdQuestType.CmdTakeAchievementLevelRewardCsReq:
      return "CmdTakeAchievementLevelRewardCsReq";
    case CmdQuestType.CmdTakeAchievementLevelRewardScRsp:
      return "CmdTakeAchievementLevelRewardScRsp";
    case CmdQuestType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum QuestStatus {
  QUEST_NONE = 0,
  QUEST_DOING = 1,
  QUEST_FINISH = 2,
  QUEST_CLOSE = 3,
  QUEST_DELETE = 4,
  UNRECOGNIZED = -1,
}

export function questStatusFromJSON(object: any): QuestStatus {
  switch (object) {
    case 0:
    case "QUEST_NONE":
      return QuestStatus.QUEST_NONE;
    case 1:
    case "QUEST_DOING":
      return QuestStatus.QUEST_DOING;
    case 2:
    case "QUEST_FINISH":
      return QuestStatus.QUEST_FINISH;
    case 3:
    case "QUEST_CLOSE":
      return QuestStatus.QUEST_CLOSE;
    case 4:
    case "QUEST_DELETE":
      return QuestStatus.QUEST_DELETE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return QuestStatus.UNRECOGNIZED;
  }
}

export function questStatusToJSON(object: QuestStatus): string {
  switch (object) {
    case QuestStatus.QUEST_NONE:
      return "QUEST_NONE";
    case QuestStatus.QUEST_DOING:
      return "QUEST_DOING";
    case QuestStatus.QUEST_FINISH:
      return "QUEST_FINISH";
    case QuestStatus.QUEST_CLOSE:
      return "QUEST_CLOSE";
    case QuestStatus.QUEST_DELETE:
      return "QUEST_DELETE";
    case QuestStatus.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum CmdRaidType {
  CmdRaidTypeNone = 0,
  CmdStartRaidCsReq = 2201,
  CmdStartRaidScRsp = 2202,
  CmdLeaveRaidCsReq = 2203,
  CmdLeaveRaidScRsp = 2204,
  CmdRaidInfoNotify = 2205,
  CmdGetChallengeRaidInfoCsReq = 2206,
  CmdGetChallengeRaidInfoScRsp = 2207,
  CmdTakeChallengeRaidRewardCsReq = 2208,
  CmdTakeChallengeRaidRewardScRsp = 2209,
  CmdChallengeRaidNotify = 2210,
  UNRECOGNIZED = -1,
}

export function cmdRaidTypeFromJSON(object: any): CmdRaidType {
  switch (object) {
    case 0:
    case "CmdRaidTypeNone":
      return CmdRaidType.CmdRaidTypeNone;
    case 2201:
    case "CmdStartRaidCsReq":
      return CmdRaidType.CmdStartRaidCsReq;
    case 2202:
    case "CmdStartRaidScRsp":
      return CmdRaidType.CmdStartRaidScRsp;
    case 2203:
    case "CmdLeaveRaidCsReq":
      return CmdRaidType.CmdLeaveRaidCsReq;
    case 2204:
    case "CmdLeaveRaidScRsp":
      return CmdRaidType.CmdLeaveRaidScRsp;
    case 2205:
    case "CmdRaidInfoNotify":
      return CmdRaidType.CmdRaidInfoNotify;
    case 2206:
    case "CmdGetChallengeRaidInfoCsReq":
      return CmdRaidType.CmdGetChallengeRaidInfoCsReq;
    case 2207:
    case "CmdGetChallengeRaidInfoScRsp":
      return CmdRaidType.CmdGetChallengeRaidInfoScRsp;
    case 2208:
    case "CmdTakeChallengeRaidRewardCsReq":
      return CmdRaidType.CmdTakeChallengeRaidRewardCsReq;
    case 2209:
    case "CmdTakeChallengeRaidRewardScRsp":
      return CmdRaidType.CmdTakeChallengeRaidRewardScRsp;
    case 2210:
    case "CmdChallengeRaidNotify":
      return CmdRaidType.CmdChallengeRaidNotify;
    case -1:
    case "UNRECOGNIZED":
    default:
      return CmdRaidType.UNRECOGNIZED;
  }
}

export function cmdRaidTypeToJSON(object: CmdRaidType): string {
  switch (object) {
    case CmdRaidType.CmdRaidTypeNone:
      return "CmdRaidTypeNone";
    case CmdRaidType.CmdStartRaidCsReq:
      return "CmdStartRaidCsReq";
    case CmdRaidType.CmdStartRaidScRsp:
      return "CmdStartRaidScRsp";
    case CmdRaidType.CmdLeaveRaidCsReq:
      return "CmdLeaveRaidCsReq";
    case CmdRaidType.CmdLeaveRaidScRsp:
      return "CmdLeaveRaidScRsp";
    case CmdRaidType.CmdRaidInfoNotify:
      return "CmdRaidInfoNotify";
    case CmdRaidType.CmdGetChallengeRaidInfoCsReq:
      return "CmdGetChallengeRaidInfoCsReq";
    case CmdRaidType.CmdGetChallengeRaidInfoScRsp:
      return "CmdGetChallengeRaidInfoScRsp";
    case CmdRaidType.CmdTakeChallengeRaidRewardCsReq:
      return "CmdTakeChallengeRaidRewardCsReq";
    case CmdRaidType.CmdTakeChallengeRaidRewardScRsp:
      return "CmdTakeChallengeRaidRewardScRsp";
    case CmdRaidType.CmdChallengeRaidNotify:
      return "CmdChallengeRaidNotify";
    case CmdRaidType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum RaidStatus {
  RAID_STATUS_NONE = 0,
  RAID_STATUS_DOING = 1,
  RAID_STATUS_FINISH = 2,
  RAID_STATUS_FAILED = 3,
  UNRECOGNIZED = -1,
}

export function raidStatusFromJSON(object: any): RaidStatus {
  switch (object) {
    case 0:
    case "RAID_STATUS_NONE":
      return RaidStatus.RAID_STATUS_NONE;
    case 1:
    case "RAID_STATUS_DOING":
      return RaidStatus.RAID_STATUS_DOING;
    case 2:
    case "RAID_STATUS_FINISH":
      return RaidStatus.RAID_STATUS_FINISH;
    case 3:
    case "RAID_STATUS_FAILED":
      return RaidStatus.RAID_STATUS_FAILED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return RaidStatus.UNRECOGNIZED;
  }
}

export function raidStatusToJSON(object: RaidStatus): string {
  switch (object) {
    case RaidStatus.RAID_STATUS_NONE:
      return "RAID_STATUS_NONE";
    case RaidStatus.RAID_STATUS_DOING:
      return "RAID_STATUS_DOING";
    case RaidStatus.RAID_STATUS_FINISH:
      return "RAID_STATUS_FINISH";
    case RaidStatus.RAID_STATUS_FAILED:
      return "RAID_STATUS_FAILED";
    case RaidStatus.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum CmdRogueType {
  CmdRogueTypeNone = 0,
  CmdGetRogueInfoCsReq = 1801,
  CmdGetRogueInfoScRsp = 1802,
  CmdStartRogueCsReq = 1803,
  CmdStartRogueScRsp = 1804,
  CmdEnterRogueCsReq = 1805,
  CmdEnterRogueScRsp = 1806,
  CmdLeaveRogueCsReq = 1807,
  CmdLeaveRogueScRsp = 1808,
  CmdSyncRogueBuffSelectInfoScNotify = 1809,
  CmdSelectRogueBuffCsReq = 1810,
  CmdSelectRogueBuffScRsp = 1811,
  CmdRollRogueBuffCsReq = 1812,
  CmdRollRogueBuffScRsp = 1813,
  CmdEnterNextRogueRoomScNotify = 1814,
  CmdSyncRogueFinishScNotify = 1815,
  CmdPickRogueAvatarCsReq = 1816,
  CmdPickRogueAvatarScRsp = 1817,
  CmdAddRogueBuffScNotify = 1818,
  CmdReviveRogueAvatarCsReq = 1819,
  CmdReviveRogueAvatarScRsp = 1820,
  CmdSaveRogueRecordCsReq = 1821,
  CmdSaveRogueRecordScRsp = 1822,
  CmdRecoverRogueStaminaCsReq = 1823,
  CmdRecoverRogueStaminaScRsp = 1824,
  CmdStartRogueChallengeCsReq = 1827,
  CmdStartRogueChallengeScRsp = 1828,
  CmdLeaveRogueChallengeCsReq = 1829,
  CmdLeaveRogueChallengeScRsp = 1830,
  CmdSyncRogueChallengeFinishScNotify = 1831,
  CmdQuitRogueCsReq = 1832,
  CmdQuitRogueScRsp = 1833,
  CmdAppraisalRogueStoneCsReq = 1834,
  CmdAppraisalRogueStoneScRsp = 1835,
  CmdSyncRogueSeasonFinishScNotify = 1836,
  CmdSyncRogueInfoChangeScNotify = 1837,
  CmdAddRogueExtraBuffScNotify = 1838,
  CmdEnterRogueMapRoomCsReq = 1839,
  CmdEnterRogueMapRoomScRsp = 1840,
  CmdEnterRogueNextLevelCsReq = 1841,
  CmdEnterRogueNextLevelScRsp = 1842,
  CmdSyncRogueMapRoomScNotify = 1843,
  CmdSyncRoguePickAvatarScNotify = 1844,
  CmdSetRogueBlessCsReq = 1845,
  CmdSetRogueBlessScRsp = 1846,
  CmdSyncRogueBlessScNotify = 1847,
  CmdGetRogueShopInfoCsReq = 1848,
  CmdGetRogueShopInfoScRsp = 1849,
  CmdBuyRogueShopBuffCsReq = 1850,
  CmdBuyRogueShopBuffScRsp = 1851,
  CmdFinishRogueDialogueGroupCsReq = 1852,
  CmdFinishRogueDialogueGroupScRsp = 1853,
  CmdUnlockRogueRoomCsReq = 1856,
  CmdUnlockRogueRoomScRsp = 1857,
  CmdGetRogueGachaInfoCsReq = 1858,
  CmdGetRogueGachaInfoScRsp = 1859,
  CmdSetRogueGachaWishListCsReq = 1860,
  CmdSetRogueGachaWishListScRsp = 1861,
  CmdDoRogueGachaCsReq = 1862,
  CmdDoRogueGachaScRsp = 1863,
  CmdSyncRogueGachaRefreshScNotify = 1864,
  CmdBuyRogueShopItemCsReq = 1865,
  CmdBuyRogueShopItemScRsp = 1866,
  CmdGetRogueAppraisalItemInfoCsReq = 1867,
  CmdGetRogueAppraisalItemInfoScRsp = 1868,
  CmdSyncRogueMiracleGetItemScNotify = 1869,
  CmdSyncRogueQuestScNotify = 1870,
  CmdGetRogueQuestRewardCsReq = 1871,
  CmdGetRogueQuestRewardScRsp = 1872,
  UNRECOGNIZED = -1,
}

export function cmdRogueTypeFromJSON(object: any): CmdRogueType {
  switch (object) {
    case 0:
    case "CmdRogueTypeNone":
      return CmdRogueType.CmdRogueTypeNone;
    case 1801:
    case "CmdGetRogueInfoCsReq":
      return CmdRogueType.CmdGetRogueInfoCsReq;
    case 1802:
    case "CmdGetRogueInfoScRsp":
      return CmdRogueType.CmdGetRogueInfoScRsp;
    case 1803:
    case "CmdStartRogueCsReq":
      return CmdRogueType.CmdStartRogueCsReq;
    case 1804:
    case "CmdStartRogueScRsp":
      return CmdRogueType.CmdStartRogueScRsp;
    case 1805:
    case "CmdEnterRogueCsReq":
      return CmdRogueType.CmdEnterRogueCsReq;
    case 1806:
    case "CmdEnterRogueScRsp":
      return CmdRogueType.CmdEnterRogueScRsp;
    case 1807:
    case "CmdLeaveRogueCsReq":
      return CmdRogueType.CmdLeaveRogueCsReq;
    case 1808:
    case "CmdLeaveRogueScRsp":
      return CmdRogueType.CmdLeaveRogueScRsp;
    case 1809:
    case "CmdSyncRogueBuffSelectInfoScNotify":
      return CmdRogueType.CmdSyncRogueBuffSelectInfoScNotify;
    case 1810:
    case "CmdSelectRogueBuffCsReq":
      return CmdRogueType.CmdSelectRogueBuffCsReq;
    case 1811:
    case "CmdSelectRogueBuffScRsp":
      return CmdRogueType.CmdSelectRogueBuffScRsp;
    case 1812:
    case "CmdRollRogueBuffCsReq":
      return CmdRogueType.CmdRollRogueBuffCsReq;
    case 1813:
    case "CmdRollRogueBuffScRsp":
      return CmdRogueType.CmdRollRogueBuffScRsp;
    case 1814:
    case "CmdEnterNextRogueRoomScNotify":
      return CmdRogueType.CmdEnterNextRogueRoomScNotify;
    case 1815:
    case "CmdSyncRogueFinishScNotify":
      return CmdRogueType.CmdSyncRogueFinishScNotify;
    case 1816:
    case "CmdPickRogueAvatarCsReq":
      return CmdRogueType.CmdPickRogueAvatarCsReq;
    case 1817:
    case "CmdPickRogueAvatarScRsp":
      return CmdRogueType.CmdPickRogueAvatarScRsp;
    case 1818:
    case "CmdAddRogueBuffScNotify":
      return CmdRogueType.CmdAddRogueBuffScNotify;
    case 1819:
    case "CmdReviveRogueAvatarCsReq":
      return CmdRogueType.CmdReviveRogueAvatarCsReq;
    case 1820:
    case "CmdReviveRogueAvatarScRsp":
      return CmdRogueType.CmdReviveRogueAvatarScRsp;
    case 1821:
    case "CmdSaveRogueRecordCsReq":
      return CmdRogueType.CmdSaveRogueRecordCsReq;
    case 1822:
    case "CmdSaveRogueRecordScRsp":
      return CmdRogueType.CmdSaveRogueRecordScRsp;
    case 1823:
    case "CmdRecoverRogueStaminaCsReq":
      return CmdRogueType.CmdRecoverRogueStaminaCsReq;
    case 1824:
    case "CmdRecoverRogueStaminaScRsp":
      return CmdRogueType.CmdRecoverRogueStaminaScRsp;
    case 1827:
    case "CmdStartRogueChallengeCsReq":
      return CmdRogueType.CmdStartRogueChallengeCsReq;
    case 1828:
    case "CmdStartRogueChallengeScRsp":
      return CmdRogueType.CmdStartRogueChallengeScRsp;
    case 1829:
    case "CmdLeaveRogueChallengeCsReq":
      return CmdRogueType.CmdLeaveRogueChallengeCsReq;
    case 1830:
    case "CmdLeaveRogueChallengeScRsp":
      return CmdRogueType.CmdLeaveRogueChallengeScRsp;
    case 1831:
    case "CmdSyncRogueChallengeFinishScNotify":
      return CmdRogueType.CmdSyncRogueChallengeFinishScNotify;
    case 1832:
    case "CmdQuitRogueCsReq":
      return CmdRogueType.CmdQuitRogueCsReq;
    case 1833:
    case "CmdQuitRogueScRsp":
      return CmdRogueType.CmdQuitRogueScRsp;
    case 1834:
    case "CmdAppraisalRogueStoneCsReq":
      return CmdRogueType.CmdAppraisalRogueStoneCsReq;
    case 1835:
    case "CmdAppraisalRogueStoneScRsp":
      return CmdRogueType.CmdAppraisalRogueStoneScRsp;
    case 1836:
    case "CmdSyncRogueSeasonFinishScNotify":
      return CmdRogueType.CmdSyncRogueSeasonFinishScNotify;
    case 1837:
    case "CmdSyncRogueInfoChangeScNotify":
      return CmdRogueType.CmdSyncRogueInfoChangeScNotify;
    case 1838:
    case "CmdAddRogueExtraBuffScNotify":
      return CmdRogueType.CmdAddRogueExtraBuffScNotify;
    case 1839:
    case "CmdEnterRogueMapRoomCsReq":
      return CmdRogueType.CmdEnterRogueMapRoomCsReq;
    case 1840:
    case "CmdEnterRogueMapRoomScRsp":
      return CmdRogueType.CmdEnterRogueMapRoomScRsp;
    case 1841:
    case "CmdEnterRogueNextLevelCsReq":
      return CmdRogueType.CmdEnterRogueNextLevelCsReq;
    case 1842:
    case "CmdEnterRogueNextLevelScRsp":
      return CmdRogueType.CmdEnterRogueNextLevelScRsp;
    case 1843:
    case "CmdSyncRogueMapRoomScNotify":
      return CmdRogueType.CmdSyncRogueMapRoomScNotify;
    case 1844:
    case "CmdSyncRoguePickAvatarScNotify":
      return CmdRogueType.CmdSyncRoguePickAvatarScNotify;
    case 1845:
    case "CmdSetRogueBlessCsReq":
      return CmdRogueType.CmdSetRogueBlessCsReq;
    case 1846:
    case "CmdSetRogueBlessScRsp":
      return CmdRogueType.CmdSetRogueBlessScRsp;
    case 1847:
    case "CmdSyncRogueBlessScNotify":
      return CmdRogueType.CmdSyncRogueBlessScNotify;
    case 1848:
    case "CmdGetRogueShopInfoCsReq":
      return CmdRogueType.CmdGetRogueShopInfoCsReq;
    case 1849:
    case "CmdGetRogueShopInfoScRsp":
      return CmdRogueType.CmdGetRogueShopInfoScRsp;
    case 1850:
    case "CmdBuyRogueShopBuffCsReq":
      return CmdRogueType.CmdBuyRogueShopBuffCsReq;
    case 1851:
    case "CmdBuyRogueShopBuffScRsp":
      return CmdRogueType.CmdBuyRogueShopBuffScRsp;
    case 1852:
    case "CmdFinishRogueDialogueGroupCsReq":
      return CmdRogueType.CmdFinishRogueDialogueGroupCsReq;
    case 1853:
    case "CmdFinishRogueDialogueGroupScRsp":
      return CmdRogueType.CmdFinishRogueDialogueGroupScRsp;
    case 1856:
    case "CmdUnlockRogueRoomCsReq":
      return CmdRogueType.CmdUnlockRogueRoomCsReq;
    case 1857:
    case "CmdUnlockRogueRoomScRsp":
      return CmdRogueType.CmdUnlockRogueRoomScRsp;
    case 1858:
    case "CmdGetRogueGachaInfoCsReq":
      return CmdRogueType.CmdGetRogueGachaInfoCsReq;
    case 1859:
    case "CmdGetRogueGachaInfoScRsp":
      return CmdRogueType.CmdGetRogueGachaInfoScRsp;
    case 1860:
    case "CmdSetRogueGachaWishListCsReq":
      return CmdRogueType.CmdSetRogueGachaWishListCsReq;
    case 1861:
    case "CmdSetRogueGachaWishListScRsp":
      return CmdRogueType.CmdSetRogueGachaWishListScRsp;
    case 1862:
    case "CmdDoRogueGachaCsReq":
      return CmdRogueType.CmdDoRogueGachaCsReq;
    case 1863:
    case "CmdDoRogueGachaScRsp":
      return CmdRogueType.CmdDoRogueGachaScRsp;
    case 1864:
    case "CmdSyncRogueGachaRefreshScNotify":
      return CmdRogueType.CmdSyncRogueGachaRefreshScNotify;
    case 1865:
    case "CmdBuyRogueShopItemCsReq":
      return CmdRogueType.CmdBuyRogueShopItemCsReq;
    case 1866:
    case "CmdBuyRogueShopItemScRsp":
      return CmdRogueType.CmdBuyRogueShopItemScRsp;
    case 1867:
    case "CmdGetRogueAppraisalItemInfoCsReq":
      return CmdRogueType.CmdGetRogueAppraisalItemInfoCsReq;
    case 1868:
    case "CmdGetRogueAppraisalItemInfoScRsp":
      return CmdRogueType.CmdGetRogueAppraisalItemInfoScRsp;
    case 1869:
    case "CmdSyncRogueMiracleGetItemScNotify":
      return CmdRogueType.CmdSyncRogueMiracleGetItemScNotify;
    case 1870:
    case "CmdSyncRogueQuestScNotify":
      return CmdRogueType.CmdSyncRogueQuestScNotify;
    case 1871:
    case "CmdGetRogueQuestRewardCsReq":
      return CmdRogueType.CmdGetRogueQuestRewardCsReq;
    case 1872:
    case "CmdGetRogueQuestRewardScRsp":
      return CmdRogueType.CmdGetRogueQuestRewardScRsp;
    case -1:
    case "UNRECOGNIZED":
    default:
      return CmdRogueType.UNRECOGNIZED;
  }
}

export function cmdRogueTypeToJSON(object: CmdRogueType): string {
  switch (object) {
    case CmdRogueType.CmdRogueTypeNone:
      return "CmdRogueTypeNone";
    case CmdRogueType.CmdGetRogueInfoCsReq:
      return "CmdGetRogueInfoCsReq";
    case CmdRogueType.CmdGetRogueInfoScRsp:
      return "CmdGetRogueInfoScRsp";
    case CmdRogueType.CmdStartRogueCsReq:
      return "CmdStartRogueCsReq";
    case CmdRogueType.CmdStartRogueScRsp:
      return "CmdStartRogueScRsp";
    case CmdRogueType.CmdEnterRogueCsReq:
      return "CmdEnterRogueCsReq";
    case CmdRogueType.CmdEnterRogueScRsp:
      return "CmdEnterRogueScRsp";
    case CmdRogueType.CmdLeaveRogueCsReq:
      return "CmdLeaveRogueCsReq";
    case CmdRogueType.CmdLeaveRogueScRsp:
      return "CmdLeaveRogueScRsp";
    case CmdRogueType.CmdSyncRogueBuffSelectInfoScNotify:
      return "CmdSyncRogueBuffSelectInfoScNotify";
    case CmdRogueType.CmdSelectRogueBuffCsReq:
      return "CmdSelectRogueBuffCsReq";
    case CmdRogueType.CmdSelectRogueBuffScRsp:
      return "CmdSelectRogueBuffScRsp";
    case CmdRogueType.CmdRollRogueBuffCsReq:
      return "CmdRollRogueBuffCsReq";
    case CmdRogueType.CmdRollRogueBuffScRsp:
      return "CmdRollRogueBuffScRsp";
    case CmdRogueType.CmdEnterNextRogueRoomScNotify:
      return "CmdEnterNextRogueRoomScNotify";
    case CmdRogueType.CmdSyncRogueFinishScNotify:
      return "CmdSyncRogueFinishScNotify";
    case CmdRogueType.CmdPickRogueAvatarCsReq:
      return "CmdPickRogueAvatarCsReq";
    case CmdRogueType.CmdPickRogueAvatarScRsp:
      return "CmdPickRogueAvatarScRsp";
    case CmdRogueType.CmdAddRogueBuffScNotify:
      return "CmdAddRogueBuffScNotify";
    case CmdRogueType.CmdReviveRogueAvatarCsReq:
      return "CmdReviveRogueAvatarCsReq";
    case CmdRogueType.CmdReviveRogueAvatarScRsp:
      return "CmdReviveRogueAvatarScRsp";
    case CmdRogueType.CmdSaveRogueRecordCsReq:
      return "CmdSaveRogueRecordCsReq";
    case CmdRogueType.CmdSaveRogueRecordScRsp:
      return "CmdSaveRogueRecordScRsp";
    case CmdRogueType.CmdRecoverRogueStaminaCsReq:
      return "CmdRecoverRogueStaminaCsReq";
    case CmdRogueType.CmdRecoverRogueStaminaScRsp:
      return "CmdRecoverRogueStaminaScRsp";
    case CmdRogueType.CmdStartRogueChallengeCsReq:
      return "CmdStartRogueChallengeCsReq";
    case CmdRogueType.CmdStartRogueChallengeScRsp:
      return "CmdStartRogueChallengeScRsp";
    case CmdRogueType.CmdLeaveRogueChallengeCsReq:
      return "CmdLeaveRogueChallengeCsReq";
    case CmdRogueType.CmdLeaveRogueChallengeScRsp:
      return "CmdLeaveRogueChallengeScRsp";
    case CmdRogueType.CmdSyncRogueChallengeFinishScNotify:
      return "CmdSyncRogueChallengeFinishScNotify";
    case CmdRogueType.CmdQuitRogueCsReq:
      return "CmdQuitRogueCsReq";
    case CmdRogueType.CmdQuitRogueScRsp:
      return "CmdQuitRogueScRsp";
    case CmdRogueType.CmdAppraisalRogueStoneCsReq:
      return "CmdAppraisalRogueStoneCsReq";
    case CmdRogueType.CmdAppraisalRogueStoneScRsp:
      return "CmdAppraisalRogueStoneScRsp";
    case CmdRogueType.CmdSyncRogueSeasonFinishScNotify:
      return "CmdSyncRogueSeasonFinishScNotify";
    case CmdRogueType.CmdSyncRogueInfoChangeScNotify:
      return "CmdSyncRogueInfoChangeScNotify";
    case CmdRogueType.CmdAddRogueExtraBuffScNotify:
      return "CmdAddRogueExtraBuffScNotify";
    case CmdRogueType.CmdEnterRogueMapRoomCsReq:
      return "CmdEnterRogueMapRoomCsReq";
    case CmdRogueType.CmdEnterRogueMapRoomScRsp:
      return "CmdEnterRogueMapRoomScRsp";
    case CmdRogueType.CmdEnterRogueNextLevelCsReq:
      return "CmdEnterRogueNextLevelCsReq";
    case CmdRogueType.CmdEnterRogueNextLevelScRsp:
      return "CmdEnterRogueNextLevelScRsp";
    case CmdRogueType.CmdSyncRogueMapRoomScNotify:
      return "CmdSyncRogueMapRoomScNotify";
    case CmdRogueType.CmdSyncRoguePickAvatarScNotify:
      return "CmdSyncRoguePickAvatarScNotify";
    case CmdRogueType.CmdSetRogueBlessCsReq:
      return "CmdSetRogueBlessCsReq";
    case CmdRogueType.CmdSetRogueBlessScRsp:
      return "CmdSetRogueBlessScRsp";
    case CmdRogueType.CmdSyncRogueBlessScNotify:
      return "CmdSyncRogueBlessScNotify";
    case CmdRogueType.CmdGetRogueShopInfoCsReq:
      return "CmdGetRogueShopInfoCsReq";
    case CmdRogueType.CmdGetRogueShopInfoScRsp:
      return "CmdGetRogueShopInfoScRsp";
    case CmdRogueType.CmdBuyRogueShopBuffCsReq:
      return "CmdBuyRogueShopBuffCsReq";
    case CmdRogueType.CmdBuyRogueShopBuffScRsp:
      return "CmdBuyRogueShopBuffScRsp";
    case CmdRogueType.CmdFinishRogueDialogueGroupCsReq:
      return "CmdFinishRogueDialogueGroupCsReq";
    case CmdRogueType.CmdFinishRogueDialogueGroupScRsp:
      return "CmdFinishRogueDialogueGroupScRsp";
    case CmdRogueType.CmdUnlockRogueRoomCsReq:
      return "CmdUnlockRogueRoomCsReq";
    case CmdRogueType.CmdUnlockRogueRoomScRsp:
      return "CmdUnlockRogueRoomScRsp";
    case CmdRogueType.CmdGetRogueGachaInfoCsReq:
      return "CmdGetRogueGachaInfoCsReq";
    case CmdRogueType.CmdGetRogueGachaInfoScRsp:
      return "CmdGetRogueGachaInfoScRsp";
    case CmdRogueType.CmdSetRogueGachaWishListCsReq:
      return "CmdSetRogueGachaWishListCsReq";
    case CmdRogueType.CmdSetRogueGachaWishListScRsp:
      return "CmdSetRogueGachaWishListScRsp";
    case CmdRogueType.CmdDoRogueGachaCsReq:
      return "CmdDoRogueGachaCsReq";
    case CmdRogueType.CmdDoRogueGachaScRsp:
      return "CmdDoRogueGachaScRsp";
    case CmdRogueType.CmdSyncRogueGachaRefreshScNotify:
      return "CmdSyncRogueGachaRefreshScNotify";
    case CmdRogueType.CmdBuyRogueShopItemCsReq:
      return "CmdBuyRogueShopItemCsReq";
    case CmdRogueType.CmdBuyRogueShopItemScRsp:
      return "CmdBuyRogueShopItemScRsp";
    case CmdRogueType.CmdGetRogueAppraisalItemInfoCsReq:
      return "CmdGetRogueAppraisalItemInfoCsReq";
    case CmdRogueType.CmdGetRogueAppraisalItemInfoScRsp:
      return "CmdGetRogueAppraisalItemInfoScRsp";
    case CmdRogueType.CmdSyncRogueMiracleGetItemScNotify:
      return "CmdSyncRogueMiracleGetItemScNotify";
    case CmdRogueType.CmdSyncRogueQuestScNotify:
      return "CmdSyncRogueQuestScNotify";
    case CmdRogueType.CmdGetRogueQuestRewardCsReq:
      return "CmdGetRogueQuestRewardCsReq";
    case CmdRogueType.CmdGetRogueQuestRewardScRsp:
      return "CmdGetRogueQuestRewardScRsp";
    case CmdRogueType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum RogueStatus {
  ROGUE_STATUS_NONE = 0,
  ROGUE_STATUS_DOING = 1,
  ROGUE_STATUS_PENDING = 2,
  ROGUE_STATUS_FINISH = 3,
  UNRECOGNIZED = -1,
}

export function rogueStatusFromJSON(object: any): RogueStatus {
  switch (object) {
    case 0:
    case "ROGUE_STATUS_NONE":
      return RogueStatus.ROGUE_STATUS_NONE;
    case 1:
    case "ROGUE_STATUS_DOING":
      return RogueStatus.ROGUE_STATUS_DOING;
    case 2:
    case "ROGUE_STATUS_PENDING":
      return RogueStatus.ROGUE_STATUS_PENDING;
    case 3:
    case "ROGUE_STATUS_FINISH":
      return RogueStatus.ROGUE_STATUS_FINISH;
    case -1:
    case "UNRECOGNIZED":
    default:
      return RogueStatus.UNRECOGNIZED;
  }
}

export function rogueStatusToJSON(object: RogueStatus): string {
  switch (object) {
    case RogueStatus.ROGUE_STATUS_NONE:
      return "ROGUE_STATUS_NONE";
    case RogueStatus.ROGUE_STATUS_DOING:
      return "ROGUE_STATUS_DOING";
    case RogueStatus.ROGUE_STATUS_PENDING:
      return "ROGUE_STATUS_PENDING";
    case RogueStatus.ROGUE_STATUS_FINISH:
      return "ROGUE_STATUS_FINISH";
    case RogueStatus.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum RogueRoomStatus {
  ROGUE_ROOM_STATUS_NONE = 0,
  ROGUE_ROOM_STATUS_LOCK = 1,
  ROGUE_ROOM_STATUS_UNLOCK = 2,
  ROGUE_ROOM_STATUS_PLAY = 3,
  ROGUE_ROOM_STATUS_FINISH = 4,
  UNRECOGNIZED = -1,
}

export function rogueRoomStatusFromJSON(object: any): RogueRoomStatus {
  switch (object) {
    case 0:
    case "ROGUE_ROOM_STATUS_NONE":
      return RogueRoomStatus.ROGUE_ROOM_STATUS_NONE;
    case 1:
    case "ROGUE_ROOM_STATUS_LOCK":
      return RogueRoomStatus.ROGUE_ROOM_STATUS_LOCK;
    case 2:
    case "ROGUE_ROOM_STATUS_UNLOCK":
      return RogueRoomStatus.ROGUE_ROOM_STATUS_UNLOCK;
    case 3:
    case "ROGUE_ROOM_STATUS_PLAY":
      return RogueRoomStatus.ROGUE_ROOM_STATUS_PLAY;
    case 4:
    case "ROGUE_ROOM_STATUS_FINISH":
      return RogueRoomStatus.ROGUE_ROOM_STATUS_FINISH;
    case -1:
    case "UNRECOGNIZED":
    default:
      return RogueRoomStatus.UNRECOGNIZED;
  }
}

export function rogueRoomStatusToJSON(object: RogueRoomStatus): string {
  switch (object) {
    case RogueRoomStatus.ROGUE_ROOM_STATUS_NONE:
      return "ROGUE_ROOM_STATUS_NONE";
    case RogueRoomStatus.ROGUE_ROOM_STATUS_LOCK:
      return "ROGUE_ROOM_STATUS_LOCK";
    case RogueRoomStatus.ROGUE_ROOM_STATUS_UNLOCK:
      return "ROGUE_ROOM_STATUS_UNLOCK";
    case RogueRoomStatus.ROGUE_ROOM_STATUS_PLAY:
      return "ROGUE_ROOM_STATUS_PLAY";
    case RogueRoomStatus.ROGUE_ROOM_STATUS_FINISH:
      return "ROGUE_ROOM_STATUS_FINISH";
    case RogueRoomStatus.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum RogueStoneAppraisalResult {
  ROGUE_STONE_APPRAISAL_NONE = 0,
  ROGUE_STONE_APPRAISAL_FAILED = 1,
  ROGUE_STONE_APPRAISAL_NORMAL = 2,
  ROGUE_STONE_APPRAISAL_PERFECT = 3,
  UNRECOGNIZED = -1,
}

export function rogueStoneAppraisalResultFromJSON(
  object: any
): RogueStoneAppraisalResult {
  switch (object) {
    case 0:
    case "ROGUE_STONE_APPRAISAL_NONE":
      return RogueStoneAppraisalResult.ROGUE_STONE_APPRAISAL_NONE;
    case 1:
    case "ROGUE_STONE_APPRAISAL_FAILED":
      return RogueStoneAppraisalResult.ROGUE_STONE_APPRAISAL_FAILED;
    case 2:
    case "ROGUE_STONE_APPRAISAL_NORMAL":
      return RogueStoneAppraisalResult.ROGUE_STONE_APPRAISAL_NORMAL;
    case 3:
    case "ROGUE_STONE_APPRAISAL_PERFECT":
      return RogueStoneAppraisalResult.ROGUE_STONE_APPRAISAL_PERFECT;
    case -1:
    case "UNRECOGNIZED":
    default:
      return RogueStoneAppraisalResult.UNRECOGNIZED;
  }
}

export function rogueStoneAppraisalResultToJSON(
  object: RogueStoneAppraisalResult
): string {
  switch (object) {
    case RogueStoneAppraisalResult.ROGUE_STONE_APPRAISAL_NONE:
      return "ROGUE_STONE_APPRAISAL_NONE";
    case RogueStoneAppraisalResult.ROGUE_STONE_APPRAISAL_FAILED:
      return "ROGUE_STONE_APPRAISAL_FAILED";
    case RogueStoneAppraisalResult.ROGUE_STONE_APPRAISAL_NORMAL:
      return "ROGUE_STONE_APPRAISAL_NORMAL";
    case RogueStoneAppraisalResult.ROGUE_STONE_APPRAISAL_PERFECT:
      return "ROGUE_STONE_APPRAISAL_PERFECT";
    case RogueStoneAppraisalResult.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum RogueDialogStatus {
  ROGUE_DIALOG_STATUS_NONE = 0,
  ROGUE_DIALOG_STATUS_LOCK = 1,
  ROGUE_DIALOG_STATUS_UNLOCK = 2,
  UNRECOGNIZED = -1,
}

export function rogueDialogStatusFromJSON(object: any): RogueDialogStatus {
  switch (object) {
    case 0:
    case "ROGUE_DIALOG_STATUS_NONE":
      return RogueDialogStatus.ROGUE_DIALOG_STATUS_NONE;
    case 1:
    case "ROGUE_DIALOG_STATUS_LOCK":
      return RogueDialogStatus.ROGUE_DIALOG_STATUS_LOCK;
    case 2:
    case "ROGUE_DIALOG_STATUS_UNLOCK":
      return RogueDialogStatus.ROGUE_DIALOG_STATUS_UNLOCK;
    case -1:
    case "UNRECOGNIZED":
    default:
      return RogueDialogStatus.UNRECOGNIZED;
  }
}

export function rogueDialogStatusToJSON(object: RogueDialogStatus): string {
  switch (object) {
    case RogueDialogStatus.ROGUE_DIALOG_STATUS_NONE:
      return "ROGUE_DIALOG_STATUS_NONE";
    case RogueDialogStatus.ROGUE_DIALOG_STATUS_LOCK:
      return "ROGUE_DIALOG_STATUS_LOCK";
    case RogueDialogStatus.ROGUE_DIALOG_STATUS_UNLOCK:
      return "ROGUE_DIALOG_STATUS_UNLOCK";
    case RogueDialogStatus.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum RogueGachaGoodsStatus {
  ROGUE_GACHA_GOODS_DEFAULT = 0,
  ROGUE_GACHA_GOODS_UP = 1,
  ROGUE_GACHA_GOODS_EMPTY = 2,
  UNRECOGNIZED = -1,
}

export function rogueGachaGoodsStatusFromJSON(
  object: any
): RogueGachaGoodsStatus {
  switch (object) {
    case 0:
    case "ROGUE_GACHA_GOODS_DEFAULT":
      return RogueGachaGoodsStatus.ROGUE_GACHA_GOODS_DEFAULT;
    case 1:
    case "ROGUE_GACHA_GOODS_UP":
      return RogueGachaGoodsStatus.ROGUE_GACHA_GOODS_UP;
    case 2:
    case "ROGUE_GACHA_GOODS_EMPTY":
      return RogueGachaGoodsStatus.ROGUE_GACHA_GOODS_EMPTY;
    case -1:
    case "UNRECOGNIZED":
    default:
      return RogueGachaGoodsStatus.UNRECOGNIZED;
  }
}

export function rogueGachaGoodsStatusToJSON(
  object: RogueGachaGoodsStatus
): string {
  switch (object) {
    case RogueGachaGoodsStatus.ROGUE_GACHA_GOODS_DEFAULT:
      return "ROGUE_GACHA_GOODS_DEFAULT";
    case RogueGachaGoodsStatus.ROGUE_GACHA_GOODS_UP:
      return "ROGUE_GACHA_GOODS_UP";
    case RogueGachaGoodsStatus.ROGUE_GACHA_GOODS_EMPTY:
      return "ROGUE_GACHA_GOODS_EMPTY";
    case RogueGachaGoodsStatus.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum RogueQuestStatus {
  ROGUE_QUEST_STATUS_NONE = 0,
  ROGUE_QUEST_STATUS_DOING = 1,
  ROGUE_QUEST_STATUS_REWARD = 2,
  ROGUE_QUEST_STATUS_FINISH = 3,
  UNRECOGNIZED = -1,
}

export function rogueQuestStatusFromJSON(object: any): RogueQuestStatus {
  switch (object) {
    case 0:
    case "ROGUE_QUEST_STATUS_NONE":
      return RogueQuestStatus.ROGUE_QUEST_STATUS_NONE;
    case 1:
    case "ROGUE_QUEST_STATUS_DOING":
      return RogueQuestStatus.ROGUE_QUEST_STATUS_DOING;
    case 2:
    case "ROGUE_QUEST_STATUS_REWARD":
      return RogueQuestStatus.ROGUE_QUEST_STATUS_REWARD;
    case 3:
    case "ROGUE_QUEST_STATUS_FINISH":
      return RogueQuestStatus.ROGUE_QUEST_STATUS_FINISH;
    case -1:
    case "UNRECOGNIZED":
    default:
      return RogueQuestStatus.UNRECOGNIZED;
  }
}

export function rogueQuestStatusToJSON(object: RogueQuestStatus): string {
  switch (object) {
    case RogueQuestStatus.ROGUE_QUEST_STATUS_NONE:
      return "ROGUE_QUEST_STATUS_NONE";
    case RogueQuestStatus.ROGUE_QUEST_STATUS_DOING:
      return "ROGUE_QUEST_STATUS_DOING";
    case RogueQuestStatus.ROGUE_QUEST_STATUS_REWARD:
      return "ROGUE_QUEST_STATUS_REWARD";
    case RogueQuestStatus.ROGUE_QUEST_STATUS_FINISH:
      return "ROGUE_QUEST_STATUS_FINISH";
    case RogueQuestStatus.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum RogueQuestType {
  ROGUE_QUEST_TYPE_EXPLORE = 0,
  ROGUE_QUEST_TYPE_CHALLENGE = 1,
  UNRECOGNIZED = -1,
}

export function rogueQuestTypeFromJSON(object: any): RogueQuestType {
  switch (object) {
    case 0:
    case "ROGUE_QUEST_TYPE_EXPLORE":
      return RogueQuestType.ROGUE_QUEST_TYPE_EXPLORE;
    case 1:
    case "ROGUE_QUEST_TYPE_CHALLENGE":
      return RogueQuestType.ROGUE_QUEST_TYPE_CHALLENGE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return RogueQuestType.UNRECOGNIZED;
  }
}

export function rogueQuestTypeToJSON(object: RogueQuestType): string {
  switch (object) {
    case RogueQuestType.ROGUE_QUEST_TYPE_EXPLORE:
      return "ROGUE_QUEST_TYPE_EXPLORE";
    case RogueQuestType.ROGUE_QUEST_TYPE_CHALLENGE:
      return "ROGUE_QUEST_TYPE_CHALLENGE";
    case RogueQuestType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum CmdSceneType {
  CmdSceneTypeNone = 0,
  CmdSceneEntityMoveCsReq = 1401,
  CmdSceneEntityMoveScRsp = 1402,
  CmdInteractPropCsReq = 1403,
  CmdInteractPropScRsp = 1404,
  CmdSceneCastSkillCsReq = 1405,
  CmdSceneCastSkillScRsp = 1406,
  CmdGetCurSceneInfoCsReq = 1407,
  CmdGetCurSceneInfoScRsp = 1408,
  CmdSceneEntityUpdateScNotify = 1409,
  CmdSceneEntityDisappearScNotify = 1410,
  CmdSceneEntityMoveScNotify = 1411,
  CmdSpringTransferCsReq = 1414,
  CmdSpringTransferScRsp = 1415,
  CmdUpdateBuffScNotify = 1416,
  CmdDelBuffScNotify = 1417,
  CmdSpringRefreshCsReq = 1418,
  CmdSpringRefreshScRsp = 1419,
  CmdLastSpringRefreshTimeNotify = 1420,
  CmdReturnLastTownCsReq = 1421,
  CmdReturnLastTownScRsp = 1422,
  CmdSceneEnterStageCsReq = 1423,
  CmdSceneEnterStageScRsp = 1424,
  CmdEnterSectionCsReq = 1427,
  CmdEnterSectionScRsp = 1428,
  CmdSetCurInteractEntityCsReq = 1431,
  CmdSetCurInteractEntityScRsp = 1432,
  CmdRecoverAllLineupCsReq = 1433,
  CmdRecoverAllLineupScRsp = 1434,
  CmdSavePointsInfoNotify = 1435,
  CmdStartCocoonStageCsReq = 1436,
  CmdStartCocoonStageScRsp = 1437,
  CmdEntityBindPropCsReq = 1438,
  CmdEntityBindPropScRsp = 1439,
  CmdSetClientPausedCsReq = 1440,
  CmdSetClientPausedScRsp = 1441,
  CmdUpdateBuffGroupStartScNotify = 1442,
  CmdUpdateBuffGroupEndScNotify = 1443,
  CmdActivateFarmElementCsReq = 1445,
  CmdActivateFarmElementScRsp = 1446,
  CmdGetSpringRecoverDataCsReq = 1447,
  CmdGetSpringRecoverDataScRsp = 1448,
  CmdSetSpringRecoverConfigCsReq = 1449,
  CmdSetSpringRecoverConfigScRsp = 1450,
  CmdSpringRecoverCsReq = 1451,
  CmdSpringRecoverScRsp = 1452,
  CmdHealPoolInfoNotify = 1453,
  CmdSpringRecoverSingleAvatarCsReq = 1454,
  CmdSpringRecoverSingleAvatarScRsp = 1455,
  UNRECOGNIZED = -1,
}

export function cmdSceneTypeFromJSON(object: any): CmdSceneType {
  switch (object) {
    case 0:
    case "CmdSceneTypeNone":
      return CmdSceneType.CmdSceneTypeNone;
    case 1401:
    case "CmdSceneEntityMoveCsReq":
      return CmdSceneType.CmdSceneEntityMoveCsReq;
    case 1402:
    case "CmdSceneEntityMoveScRsp":
      return CmdSceneType.CmdSceneEntityMoveScRsp;
    case 1403:
    case "CmdInteractPropCsReq":
      return CmdSceneType.CmdInteractPropCsReq;
    case 1404:
    case "CmdInteractPropScRsp":
      return CmdSceneType.CmdInteractPropScRsp;
    case 1405:
    case "CmdSceneCastSkillCsReq":
      return CmdSceneType.CmdSceneCastSkillCsReq;
    case 1406:
    case "CmdSceneCastSkillScRsp":
      return CmdSceneType.CmdSceneCastSkillScRsp;
    case 1407:
    case "CmdGetCurSceneInfoCsReq":
      return CmdSceneType.CmdGetCurSceneInfoCsReq;
    case 1408:
    case "CmdGetCurSceneInfoScRsp":
      return CmdSceneType.CmdGetCurSceneInfoScRsp;
    case 1409:
    case "CmdSceneEntityUpdateScNotify":
      return CmdSceneType.CmdSceneEntityUpdateScNotify;
    case 1410:
    case "CmdSceneEntityDisappearScNotify":
      return CmdSceneType.CmdSceneEntityDisappearScNotify;
    case 1411:
    case "CmdSceneEntityMoveScNotify":
      return CmdSceneType.CmdSceneEntityMoveScNotify;
    case 1414:
    case "CmdSpringTransferCsReq":
      return CmdSceneType.CmdSpringTransferCsReq;
    case 1415:
    case "CmdSpringTransferScRsp":
      return CmdSceneType.CmdSpringTransferScRsp;
    case 1416:
    case "CmdUpdateBuffScNotify":
      return CmdSceneType.CmdUpdateBuffScNotify;
    case 1417:
    case "CmdDelBuffScNotify":
      return CmdSceneType.CmdDelBuffScNotify;
    case 1418:
    case "CmdSpringRefreshCsReq":
      return CmdSceneType.CmdSpringRefreshCsReq;
    case 1419:
    case "CmdSpringRefreshScRsp":
      return CmdSceneType.CmdSpringRefreshScRsp;
    case 1420:
    case "CmdLastSpringRefreshTimeNotify":
      return CmdSceneType.CmdLastSpringRefreshTimeNotify;
    case 1421:
    case "CmdReturnLastTownCsReq":
      return CmdSceneType.CmdReturnLastTownCsReq;
    case 1422:
    case "CmdReturnLastTownScRsp":
      return CmdSceneType.CmdReturnLastTownScRsp;
    case 1423:
    case "CmdSceneEnterStageCsReq":
      return CmdSceneType.CmdSceneEnterStageCsReq;
    case 1424:
    case "CmdSceneEnterStageScRsp":
      return CmdSceneType.CmdSceneEnterStageScRsp;
    case 1427:
    case "CmdEnterSectionCsReq":
      return CmdSceneType.CmdEnterSectionCsReq;
    case 1428:
    case "CmdEnterSectionScRsp":
      return CmdSceneType.CmdEnterSectionScRsp;
    case 1431:
    case "CmdSetCurInteractEntityCsReq":
      return CmdSceneType.CmdSetCurInteractEntityCsReq;
    case 1432:
    case "CmdSetCurInteractEntityScRsp":
      return CmdSceneType.CmdSetCurInteractEntityScRsp;
    case 1433:
    case "CmdRecoverAllLineupCsReq":
      return CmdSceneType.CmdRecoverAllLineupCsReq;
    case 1434:
    case "CmdRecoverAllLineupScRsp":
      return CmdSceneType.CmdRecoverAllLineupScRsp;
    case 1435:
    case "CmdSavePointsInfoNotify":
      return CmdSceneType.CmdSavePointsInfoNotify;
    case 1436:
    case "CmdStartCocoonStageCsReq":
      return CmdSceneType.CmdStartCocoonStageCsReq;
    case 1437:
    case "CmdStartCocoonStageScRsp":
      return CmdSceneType.CmdStartCocoonStageScRsp;
    case 1438:
    case "CmdEntityBindPropCsReq":
      return CmdSceneType.CmdEntityBindPropCsReq;
    case 1439:
    case "CmdEntityBindPropScRsp":
      return CmdSceneType.CmdEntityBindPropScRsp;
    case 1440:
    case "CmdSetClientPausedCsReq":
      return CmdSceneType.CmdSetClientPausedCsReq;
    case 1441:
    case "CmdSetClientPausedScRsp":
      return CmdSceneType.CmdSetClientPausedScRsp;
    case 1442:
    case "CmdUpdateBuffGroupStartScNotify":
      return CmdSceneType.CmdUpdateBuffGroupStartScNotify;
    case 1443:
    case "CmdUpdateBuffGroupEndScNotify":
      return CmdSceneType.CmdUpdateBuffGroupEndScNotify;
    case 1445:
    case "CmdActivateFarmElementCsReq":
      return CmdSceneType.CmdActivateFarmElementCsReq;
    case 1446:
    case "CmdActivateFarmElementScRsp":
      return CmdSceneType.CmdActivateFarmElementScRsp;
    case 1447:
    case "CmdGetSpringRecoverDataCsReq":
      return CmdSceneType.CmdGetSpringRecoverDataCsReq;
    case 1448:
    case "CmdGetSpringRecoverDataScRsp":
      return CmdSceneType.CmdGetSpringRecoverDataScRsp;
    case 1449:
    case "CmdSetSpringRecoverConfigCsReq":
      return CmdSceneType.CmdSetSpringRecoverConfigCsReq;
    case 1450:
    case "CmdSetSpringRecoverConfigScRsp":
      return CmdSceneType.CmdSetSpringRecoverConfigScRsp;
    case 1451:
    case "CmdSpringRecoverCsReq":
      return CmdSceneType.CmdSpringRecoverCsReq;
    case 1452:
    case "CmdSpringRecoverScRsp":
      return CmdSceneType.CmdSpringRecoverScRsp;
    case 1453:
    case "CmdHealPoolInfoNotify":
      return CmdSceneType.CmdHealPoolInfoNotify;
    case 1454:
    case "CmdSpringRecoverSingleAvatarCsReq":
      return CmdSceneType.CmdSpringRecoverSingleAvatarCsReq;
    case 1455:
    case "CmdSpringRecoverSingleAvatarScRsp":
      return CmdSceneType.CmdSpringRecoverSingleAvatarScRsp;
    case -1:
    case "UNRECOGNIZED":
    default:
      return CmdSceneType.UNRECOGNIZED;
  }
}

export function cmdSceneTypeToJSON(object: CmdSceneType): string {
  switch (object) {
    case CmdSceneType.CmdSceneTypeNone:
      return "CmdSceneTypeNone";
    case CmdSceneType.CmdSceneEntityMoveCsReq:
      return "CmdSceneEntityMoveCsReq";
    case CmdSceneType.CmdSceneEntityMoveScRsp:
      return "CmdSceneEntityMoveScRsp";
    case CmdSceneType.CmdInteractPropCsReq:
      return "CmdInteractPropCsReq";
    case CmdSceneType.CmdInteractPropScRsp:
      return "CmdInteractPropScRsp";
    case CmdSceneType.CmdSceneCastSkillCsReq:
      return "CmdSceneCastSkillCsReq";
    case CmdSceneType.CmdSceneCastSkillScRsp:
      return "CmdSceneCastSkillScRsp";
    case CmdSceneType.CmdGetCurSceneInfoCsReq:
      return "CmdGetCurSceneInfoCsReq";
    case CmdSceneType.CmdGetCurSceneInfoScRsp:
      return "CmdGetCurSceneInfoScRsp";
    case CmdSceneType.CmdSceneEntityUpdateScNotify:
      return "CmdSceneEntityUpdateScNotify";
    case CmdSceneType.CmdSceneEntityDisappearScNotify:
      return "CmdSceneEntityDisappearScNotify";
    case CmdSceneType.CmdSceneEntityMoveScNotify:
      return "CmdSceneEntityMoveScNotify";
    case CmdSceneType.CmdSpringTransferCsReq:
      return "CmdSpringTransferCsReq";
    case CmdSceneType.CmdSpringTransferScRsp:
      return "CmdSpringTransferScRsp";
    case CmdSceneType.CmdUpdateBuffScNotify:
      return "CmdUpdateBuffScNotify";
    case CmdSceneType.CmdDelBuffScNotify:
      return "CmdDelBuffScNotify";
    case CmdSceneType.CmdSpringRefreshCsReq:
      return "CmdSpringRefreshCsReq";
    case CmdSceneType.CmdSpringRefreshScRsp:
      return "CmdSpringRefreshScRsp";
    case CmdSceneType.CmdLastSpringRefreshTimeNotify:
      return "CmdLastSpringRefreshTimeNotify";
    case CmdSceneType.CmdReturnLastTownCsReq:
      return "CmdReturnLastTownCsReq";
    case CmdSceneType.CmdReturnLastTownScRsp:
      return "CmdReturnLastTownScRsp";
    case CmdSceneType.CmdSceneEnterStageCsReq:
      return "CmdSceneEnterStageCsReq";
    case CmdSceneType.CmdSceneEnterStageScRsp:
      return "CmdSceneEnterStageScRsp";
    case CmdSceneType.CmdEnterSectionCsReq:
      return "CmdEnterSectionCsReq";
    case CmdSceneType.CmdEnterSectionScRsp:
      return "CmdEnterSectionScRsp";
    case CmdSceneType.CmdSetCurInteractEntityCsReq:
      return "CmdSetCurInteractEntityCsReq";
    case CmdSceneType.CmdSetCurInteractEntityScRsp:
      return "CmdSetCurInteractEntityScRsp";
    case CmdSceneType.CmdRecoverAllLineupCsReq:
      return "CmdRecoverAllLineupCsReq";
    case CmdSceneType.CmdRecoverAllLineupScRsp:
      return "CmdRecoverAllLineupScRsp";
    case CmdSceneType.CmdSavePointsInfoNotify:
      return "CmdSavePointsInfoNotify";
    case CmdSceneType.CmdStartCocoonStageCsReq:
      return "CmdStartCocoonStageCsReq";
    case CmdSceneType.CmdStartCocoonStageScRsp:
      return "CmdStartCocoonStageScRsp";
    case CmdSceneType.CmdEntityBindPropCsReq:
      return "CmdEntityBindPropCsReq";
    case CmdSceneType.CmdEntityBindPropScRsp:
      return "CmdEntityBindPropScRsp";
    case CmdSceneType.CmdSetClientPausedCsReq:
      return "CmdSetClientPausedCsReq";
    case CmdSceneType.CmdSetClientPausedScRsp:
      return "CmdSetClientPausedScRsp";
    case CmdSceneType.CmdUpdateBuffGroupStartScNotify:
      return "CmdUpdateBuffGroupStartScNotify";
    case CmdSceneType.CmdUpdateBuffGroupEndScNotify:
      return "CmdUpdateBuffGroupEndScNotify";
    case CmdSceneType.CmdActivateFarmElementCsReq:
      return "CmdActivateFarmElementCsReq";
    case CmdSceneType.CmdActivateFarmElementScRsp:
      return "CmdActivateFarmElementScRsp";
    case CmdSceneType.CmdGetSpringRecoverDataCsReq:
      return "CmdGetSpringRecoverDataCsReq";
    case CmdSceneType.CmdGetSpringRecoverDataScRsp:
      return "CmdGetSpringRecoverDataScRsp";
    case CmdSceneType.CmdSetSpringRecoverConfigCsReq:
      return "CmdSetSpringRecoverConfigCsReq";
    case CmdSceneType.CmdSetSpringRecoverConfigScRsp:
      return "CmdSetSpringRecoverConfigScRsp";
    case CmdSceneType.CmdSpringRecoverCsReq:
      return "CmdSpringRecoverCsReq";
    case CmdSceneType.CmdSpringRecoverScRsp:
      return "CmdSpringRecoverScRsp";
    case CmdSceneType.CmdHealPoolInfoNotify:
      return "CmdHealPoolInfoNotify";
    case CmdSceneType.CmdSpringRecoverSingleAvatarCsReq:
      return "CmdSpringRecoverSingleAvatarCsReq";
    case CmdSceneType.CmdSpringRecoverSingleAvatarScRsp:
      return "CmdSpringRecoverSingleAvatarScRsp";
    case CmdSceneType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum CmdShopType {
  CmdShopTypeNone = 0,
  CmdGetShopListCsReq = 1501,
  CmdGetShopListScRsp = 1502,
  CmdBuyGoodsCsReq = 1503,
  CmdBuyGoodsScRsp = 1504,
  UNRECOGNIZED = -1,
}

export function cmdShopTypeFromJSON(object: any): CmdShopType {
  switch (object) {
    case 0:
    case "CmdShopTypeNone":
      return CmdShopType.CmdShopTypeNone;
    case 1501:
    case "CmdGetShopListCsReq":
      return CmdShopType.CmdGetShopListCsReq;
    case 1502:
    case "CmdGetShopListScRsp":
      return CmdShopType.CmdGetShopListScRsp;
    case 1503:
    case "CmdBuyGoodsCsReq":
      return CmdShopType.CmdBuyGoodsCsReq;
    case 1504:
    case "CmdBuyGoodsScRsp":
      return CmdShopType.CmdBuyGoodsScRsp;
    case -1:
    case "UNRECOGNIZED":
    default:
      return CmdShopType.UNRECOGNIZED;
  }
}

export function cmdShopTypeToJSON(object: CmdShopType): string {
  switch (object) {
    case CmdShopType.CmdShopTypeNone:
      return "CmdShopTypeNone";
    case CmdShopType.CmdGetShopListCsReq:
      return "CmdGetShopListCsReq";
    case CmdShopType.CmdGetShopListScRsp:
      return "CmdGetShopListScRsp";
    case CmdShopType.CmdBuyGoodsCsReq:
      return "CmdBuyGoodsCsReq";
    case CmdShopType.CmdBuyGoodsScRsp:
      return "CmdBuyGoodsScRsp";
    case CmdShopType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum CmdStageType {
  CmdStageTypeNone = 0,
  CmdGetStageDataCsReq = 201,
  CmdGetStageDataScRsp = 202,
  CmdStageBeginCsReq = 203,
  CmdStageBeginScRsp = 204,
  UNRECOGNIZED = -1,
}

export function cmdStageTypeFromJSON(object: any): CmdStageType {
  switch (object) {
    case 0:
    case "CmdStageTypeNone":
      return CmdStageType.CmdStageTypeNone;
    case 201:
    case "CmdGetStageDataCsReq":
      return CmdStageType.CmdGetStageDataCsReq;
    case 202:
    case "CmdGetStageDataScRsp":
      return CmdStageType.CmdGetStageDataScRsp;
    case 203:
    case "CmdStageBeginCsReq":
      return CmdStageType.CmdStageBeginCsReq;
    case 204:
    case "CmdStageBeginScRsp":
      return CmdStageType.CmdStageBeginScRsp;
    case -1:
    case "UNRECOGNIZED":
    default:
      return CmdStageType.UNRECOGNIZED;
  }
}

export function cmdStageTypeToJSON(object: CmdStageType): string {
  switch (object) {
    case CmdStageType.CmdStageTypeNone:
      return "CmdStageTypeNone";
    case CmdStageType.CmdGetStageDataCsReq:
      return "CmdGetStageDataCsReq";
    case CmdStageType.CmdGetStageDataScRsp:
      return "CmdGetStageDataScRsp";
    case CmdStageType.CmdStageBeginCsReq:
      return "CmdStageBeginCsReq";
    case CmdStageType.CmdStageBeginScRsp:
      return "CmdStageBeginScRsp";
    case CmdStageType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum CmdPlayerSyncType {
  CmdPlayerSyncNone = 0,
  CmdPlayerSyncScNotify = 601,
  UNRECOGNIZED = -1,
}

export function cmdPlayerSyncTypeFromJSON(object: any): CmdPlayerSyncType {
  switch (object) {
    case 0:
    case "CmdPlayerSyncNone":
      return CmdPlayerSyncType.CmdPlayerSyncNone;
    case 601:
    case "CmdPlayerSyncScNotify":
      return CmdPlayerSyncType.CmdPlayerSyncScNotify;
    case -1:
    case "UNRECOGNIZED":
    default:
      return CmdPlayerSyncType.UNRECOGNIZED;
  }
}

export function cmdPlayerSyncTypeToJSON(object: CmdPlayerSyncType): string {
  switch (object) {
    case CmdPlayerSyncType.CmdPlayerSyncNone:
      return "CmdPlayerSyncNone";
    case CmdPlayerSyncType.CmdPlayerSyncScNotify:
      return "CmdPlayerSyncScNotify";
    case CmdPlayerSyncType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum CmdTalkEventType {
  CmdTalkRewardTypeNone = 0,
  CmdGetNpcTakenRewardCsReq = 2101,
  CmdGetNpcTakenRewardScRsp = 2102,
  CmdTakeTalkRewardCsReq = 2103,
  CmdTakeTalkRewardScRsp = 2104,
  CmdGetFirstTalkNpcCsReq = 2105,
  CmdGetFirstTalkNpcScRsp = 2106,
  CmdFinishFirstTalkNpcCsReq = 2107,
  CmdFinishFirstTalkNpcScRsp = 2108,
  UNRECOGNIZED = -1,
}

export function cmdTalkEventTypeFromJSON(object: any): CmdTalkEventType {
  switch (object) {
    case 0:
    case "CmdTalkRewardTypeNone":
      return CmdTalkEventType.CmdTalkRewardTypeNone;
    case 2101:
    case "CmdGetNpcTakenRewardCsReq":
      return CmdTalkEventType.CmdGetNpcTakenRewardCsReq;
    case 2102:
    case "CmdGetNpcTakenRewardScRsp":
      return CmdTalkEventType.CmdGetNpcTakenRewardScRsp;
    case 2103:
    case "CmdTakeTalkRewardCsReq":
      return CmdTalkEventType.CmdTakeTalkRewardCsReq;
    case 2104:
    case "CmdTakeTalkRewardScRsp":
      return CmdTalkEventType.CmdTakeTalkRewardScRsp;
    case 2105:
    case "CmdGetFirstTalkNpcCsReq":
      return CmdTalkEventType.CmdGetFirstTalkNpcCsReq;
    case 2106:
    case "CmdGetFirstTalkNpcScRsp":
      return CmdTalkEventType.CmdGetFirstTalkNpcScRsp;
    case 2107:
    case "CmdFinishFirstTalkNpcCsReq":
      return CmdTalkEventType.CmdFinishFirstTalkNpcCsReq;
    case 2108:
    case "CmdFinishFirstTalkNpcScRsp":
      return CmdTalkEventType.CmdFinishFirstTalkNpcScRsp;
    case -1:
    case "UNRECOGNIZED":
    default:
      return CmdTalkEventType.UNRECOGNIZED;
  }
}

export function cmdTalkEventTypeToJSON(object: CmdTalkEventType): string {
  switch (object) {
    case CmdTalkEventType.CmdTalkRewardTypeNone:
      return "CmdTalkRewardTypeNone";
    case CmdTalkEventType.CmdGetNpcTakenRewardCsReq:
      return "CmdGetNpcTakenRewardCsReq";
    case CmdTalkEventType.CmdGetNpcTakenRewardScRsp:
      return "CmdGetNpcTakenRewardScRsp";
    case CmdTalkEventType.CmdTakeTalkRewardCsReq:
      return "CmdTakeTalkRewardCsReq";
    case CmdTalkEventType.CmdTakeTalkRewardScRsp:
      return "CmdTakeTalkRewardScRsp";
    case CmdTalkEventType.CmdGetFirstTalkNpcCsReq:
      return "CmdGetFirstTalkNpcCsReq";
    case CmdTalkEventType.CmdGetFirstTalkNpcScRsp:
      return "CmdGetFirstTalkNpcScRsp";
    case CmdTalkEventType.CmdFinishFirstTalkNpcCsReq:
      return "CmdFinishFirstTalkNpcCsReq";
    case CmdTalkEventType.CmdFinishFirstTalkNpcScRsp:
      return "CmdFinishFirstTalkNpcScRsp";
    case CmdTalkEventType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum CmdTutorialType {
  CmdTutorialTypeNone = 0,
  CmdGetTutorialCsReq = 1601,
  CmdGetTutorialScRsp = 1602,
  CmdGetTutorialGuideCsReq = 1603,
  CmdGetTutorialGuideScRsp = 1604,
  CmdUnlockTutorialCsReq = 1605,
  CmdUnlockTutorialScRsp = 1606,
  CmdUnlockTutorialGuideCsReq = 1607,
  CmdUnlockTutorialGuideScRsp = 1608,
  CmdFinishTutorialCsReq = 1609,
  CmdFinishTutorialScRsp = 1610,
  CmdFinishTutorialGuideCsReq = 1611,
  CmdFinishTutorialGuideScRsp = 1612,
  UNRECOGNIZED = -1,
}

export function cmdTutorialTypeFromJSON(object: any): CmdTutorialType {
  switch (object) {
    case 0:
    case "CmdTutorialTypeNone":
      return CmdTutorialType.CmdTutorialTypeNone;
    case 1601:
    case "CmdGetTutorialCsReq":
      return CmdTutorialType.CmdGetTutorialCsReq;
    case 1602:
    case "CmdGetTutorialScRsp":
      return CmdTutorialType.CmdGetTutorialScRsp;
    case 1603:
    case "CmdGetTutorialGuideCsReq":
      return CmdTutorialType.CmdGetTutorialGuideCsReq;
    case 1604:
    case "CmdGetTutorialGuideScRsp":
      return CmdTutorialType.CmdGetTutorialGuideScRsp;
    case 1605:
    case "CmdUnlockTutorialCsReq":
      return CmdTutorialType.CmdUnlockTutorialCsReq;
    case 1606:
    case "CmdUnlockTutorialScRsp":
      return CmdTutorialType.CmdUnlockTutorialScRsp;
    case 1607:
    case "CmdUnlockTutorialGuideCsReq":
      return CmdTutorialType.CmdUnlockTutorialGuideCsReq;
    case 1608:
    case "CmdUnlockTutorialGuideScRsp":
      return CmdTutorialType.CmdUnlockTutorialGuideScRsp;
    case 1609:
    case "CmdFinishTutorialCsReq":
      return CmdTutorialType.CmdFinishTutorialCsReq;
    case 1610:
    case "CmdFinishTutorialScRsp":
      return CmdTutorialType.CmdFinishTutorialScRsp;
    case 1611:
    case "CmdFinishTutorialGuideCsReq":
      return CmdTutorialType.CmdFinishTutorialGuideCsReq;
    case 1612:
    case "CmdFinishTutorialGuideScRsp":
      return CmdTutorialType.CmdFinishTutorialGuideScRsp;
    case -1:
    case "UNRECOGNIZED":
    default:
      return CmdTutorialType.UNRECOGNIZED;
  }
}

export function cmdTutorialTypeToJSON(object: CmdTutorialType): string {
  switch (object) {
    case CmdTutorialType.CmdTutorialTypeNone:
      return "CmdTutorialTypeNone";
    case CmdTutorialType.CmdGetTutorialCsReq:
      return "CmdGetTutorialCsReq";
    case CmdTutorialType.CmdGetTutorialScRsp:
      return "CmdGetTutorialScRsp";
    case CmdTutorialType.CmdGetTutorialGuideCsReq:
      return "CmdGetTutorialGuideCsReq";
    case CmdTutorialType.CmdGetTutorialGuideScRsp:
      return "CmdGetTutorialGuideScRsp";
    case CmdTutorialType.CmdUnlockTutorialCsReq:
      return "CmdUnlockTutorialCsReq";
    case CmdTutorialType.CmdUnlockTutorialScRsp:
      return "CmdUnlockTutorialScRsp";
    case CmdTutorialType.CmdUnlockTutorialGuideCsReq:
      return "CmdUnlockTutorialGuideCsReq";
    case CmdTutorialType.CmdUnlockTutorialGuideScRsp:
      return "CmdUnlockTutorialGuideScRsp";
    case CmdTutorialType.CmdFinishTutorialCsReq:
      return "CmdFinishTutorialCsReq";
    case CmdTutorialType.CmdFinishTutorialScRsp:
      return "CmdFinishTutorialScRsp";
    case CmdTutorialType.CmdFinishTutorialGuideCsReq:
      return "CmdFinishTutorialGuideCsReq";
    case CmdTutorialType.CmdFinishTutorialGuideScRsp:
      return "CmdFinishTutorialGuideScRsp";
    case CmdTutorialType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum TutorialStatus {
  TUTORIAL_NONE = 0,
  TUTORIAL_UNLOCK = 1,
  TUTORIAL_FINISH = 2,
  UNRECOGNIZED = -1,
}

export function tutorialStatusFromJSON(object: any): TutorialStatus {
  switch (object) {
    case 0:
    case "TUTORIAL_NONE":
      return TutorialStatus.TUTORIAL_NONE;
    case 1:
    case "TUTORIAL_UNLOCK":
      return TutorialStatus.TUTORIAL_UNLOCK;
    case 2:
    case "TUTORIAL_FINISH":
      return TutorialStatus.TUTORIAL_FINISH;
    case -1:
    case "UNRECOGNIZED":
    default:
      return TutorialStatus.UNRECOGNIZED;
  }
}

export function tutorialStatusToJSON(object: TutorialStatus): string {
  switch (object) {
    case TutorialStatus.TUTORIAL_NONE:
      return "TUTORIAL_NONE";
    case TutorialStatus.TUTORIAL_UNLOCK:
      return "TUTORIAL_UNLOCK";
    case TutorialStatus.TUTORIAL_FINISH:
      return "TUTORIAL_FINISH";
    case TutorialStatus.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum CmdWaypointType {
  CmdWaypointTypeNone = 0,
  CmdGetWaypointCsReq = 401,
  CmdGetWaypointScRsp = 402,
  CmdSetCurWaypointCsReq = 403,
  CmdSetCurWaypointScRsp = 404,
  CmdGetChapterCsReq = 405,
  CmdGetChapterScRsp = 406,
  CmdWaypointShowNewCsNotify = 407,
  CmdTakeChapterRewardCsReq = 408,
  CmdTakeChapterRewardScRsp = 409,
  UNRECOGNIZED = -1,
}

export function cmdWaypointTypeFromJSON(object: any): CmdWaypointType {
  switch (object) {
    case 0:
    case "CmdWaypointTypeNone":
      return CmdWaypointType.CmdWaypointTypeNone;
    case 401:
    case "CmdGetWaypointCsReq":
      return CmdWaypointType.CmdGetWaypointCsReq;
    case 402:
    case "CmdGetWaypointScRsp":
      return CmdWaypointType.CmdGetWaypointScRsp;
    case 403:
    case "CmdSetCurWaypointCsReq":
      return CmdWaypointType.CmdSetCurWaypointCsReq;
    case 404:
    case "CmdSetCurWaypointScRsp":
      return CmdWaypointType.CmdSetCurWaypointScRsp;
    case 405:
    case "CmdGetChapterCsReq":
      return CmdWaypointType.CmdGetChapterCsReq;
    case 406:
    case "CmdGetChapterScRsp":
      return CmdWaypointType.CmdGetChapterScRsp;
    case 407:
    case "CmdWaypointShowNewCsNotify":
      return CmdWaypointType.CmdWaypointShowNewCsNotify;
    case 408:
    case "CmdTakeChapterRewardCsReq":
      return CmdWaypointType.CmdTakeChapterRewardCsReq;
    case 409:
    case "CmdTakeChapterRewardScRsp":
      return CmdWaypointType.CmdTakeChapterRewardScRsp;
    case -1:
    case "UNRECOGNIZED":
    default:
      return CmdWaypointType.UNRECOGNIZED;
  }
}

export function cmdWaypointTypeToJSON(object: CmdWaypointType): string {
  switch (object) {
    case CmdWaypointType.CmdWaypointTypeNone:
      return "CmdWaypointTypeNone";
    case CmdWaypointType.CmdGetWaypointCsReq:
      return "CmdGetWaypointCsReq";
    case CmdWaypointType.CmdGetWaypointScRsp:
      return "CmdGetWaypointScRsp";
    case CmdWaypointType.CmdSetCurWaypointCsReq:
      return "CmdSetCurWaypointCsReq";
    case CmdWaypointType.CmdSetCurWaypointScRsp:
      return "CmdSetCurWaypointScRsp";
    case CmdWaypointType.CmdGetChapterCsReq:
      return "CmdGetChapterCsReq";
    case CmdWaypointType.CmdGetChapterScRsp:
      return "CmdGetChapterScRsp";
    case CmdWaypointType.CmdWaypointShowNewCsNotify:
      return "CmdWaypointShowNewCsNotify";
    case CmdWaypointType.CmdTakeChapterRewardCsReq:
      return "CmdTakeChapterRewardCsReq";
    case CmdWaypointType.CmdTakeChapterRewardScRsp:
      return "CmdTakeChapterRewardScRsp";
    case CmdWaypointType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum WaypointType {
  WAYPOINT_TYPE_NONE = 0,
  WAYPOINT_TYPE_STAGE = 1,
  WAYPOINT_TYPE_PLOT = 2,
  UNRECOGNIZED = -1,
}

export function waypointTypeFromJSON(object: any): WaypointType {
  switch (object) {
    case 0:
    case "WAYPOINT_TYPE_NONE":
      return WaypointType.WAYPOINT_TYPE_NONE;
    case 1:
    case "WAYPOINT_TYPE_STAGE":
      return WaypointType.WAYPOINT_TYPE_STAGE;
    case 2:
    case "WAYPOINT_TYPE_PLOT":
      return WaypointType.WAYPOINT_TYPE_PLOT;
    case -1:
    case "UNRECOGNIZED":
    default:
      return WaypointType.UNRECOGNIZED;
  }
}

export function waypointTypeToJSON(object: WaypointType): string {
  switch (object) {
    case WaypointType.WAYPOINT_TYPE_NONE:
      return "WAYPOINT_TYPE_NONE";
    case WaypointType.WAYPOINT_TYPE_STAGE:
      return "WAYPOINT_TYPE_STAGE";
    case WaypointType.WAYPOINT_TYPE_PLOT:
      return "WAYPOINT_TYPE_PLOT";
    case WaypointType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum WaypointUnlockType {
  WAYPOINT_UNLOCK_NONE = 0,
  WAYPOINT_UNLOCK_PRE = 1,
  WAYPOINT_UNLOCK_LEVEL = 2,
  UNRECOGNIZED = -1,
}

export function waypointUnlockTypeFromJSON(object: any): WaypointUnlockType {
  switch (object) {
    case 0:
    case "WAYPOINT_UNLOCK_NONE":
      return WaypointUnlockType.WAYPOINT_UNLOCK_NONE;
    case 1:
    case "WAYPOINT_UNLOCK_PRE":
      return WaypointUnlockType.WAYPOINT_UNLOCK_PRE;
    case 2:
    case "WAYPOINT_UNLOCK_LEVEL":
      return WaypointUnlockType.WAYPOINT_UNLOCK_LEVEL;
    case -1:
    case "UNRECOGNIZED":
    default:
      return WaypointUnlockType.UNRECOGNIZED;
  }
}

export function waypointUnlockTypeToJSON(object: WaypointUnlockType): string {
  switch (object) {
    case WaypointUnlockType.WAYPOINT_UNLOCK_NONE:
      return "WAYPOINT_UNLOCK_NONE";
    case WaypointUnlockType.WAYPOINT_UNLOCK_PRE:
      return "WAYPOINT_UNLOCK_PRE";
    case WaypointUnlockType.WAYPOINT_UNLOCK_LEVEL:
      return "WAYPOINT_UNLOCK_LEVEL";
    case WaypointUnlockType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum DispatchType {
  DISPATCH_TYPE_NONE = 0,
  DISPATCH_TYPE_BY_ADDR = 1,
  DISPATCH_TYPE_BY_MOD = 2,
  DISPATCH_TYPE_BY_RAND = 3,
  DISPATCH_TYPE_BY_CHASH = 4,
  DISPATCH_TYPE_BY_STICKY_SESSION = 5,
  DISPATCH_TYPE_BY_OBJECT = 6,
  UNRECOGNIZED = -1,
}

export function dispatchTypeFromJSON(object: any): DispatchType {
  switch (object) {
    case 0:
    case "DISPATCH_TYPE_NONE":
      return DispatchType.DISPATCH_TYPE_NONE;
    case 1:
    case "DISPATCH_TYPE_BY_ADDR":
      return DispatchType.DISPATCH_TYPE_BY_ADDR;
    case 2:
    case "DISPATCH_TYPE_BY_MOD":
      return DispatchType.DISPATCH_TYPE_BY_MOD;
    case 3:
    case "DISPATCH_TYPE_BY_RAND":
      return DispatchType.DISPATCH_TYPE_BY_RAND;
    case 4:
    case "DISPATCH_TYPE_BY_CHASH":
      return DispatchType.DISPATCH_TYPE_BY_CHASH;
    case 5:
    case "DISPATCH_TYPE_BY_STICKY_SESSION":
      return DispatchType.DISPATCH_TYPE_BY_STICKY_SESSION;
    case 6:
    case "DISPATCH_TYPE_BY_OBJECT":
      return DispatchType.DISPATCH_TYPE_BY_OBJECT;
    case -1:
    case "UNRECOGNIZED":
    default:
      return DispatchType.UNRECOGNIZED;
  }
}

export function dispatchTypeToJSON(object: DispatchType): string {
  switch (object) {
    case DispatchType.DISPATCH_TYPE_NONE:
      return "DISPATCH_TYPE_NONE";
    case DispatchType.DISPATCH_TYPE_BY_ADDR:
      return "DISPATCH_TYPE_BY_ADDR";
    case DispatchType.DISPATCH_TYPE_BY_MOD:
      return "DISPATCH_TYPE_BY_MOD";
    case DispatchType.DISPATCH_TYPE_BY_RAND:
      return "DISPATCH_TYPE_BY_RAND";
    case DispatchType.DISPATCH_TYPE_BY_CHASH:
      return "DISPATCH_TYPE_BY_CHASH";
    case DispatchType.DISPATCH_TYPE_BY_STICKY_SESSION:
      return "DISPATCH_TYPE_BY_STICKY_SESSION";
    case DispatchType.DISPATCH_TYPE_BY_OBJECT:
      return "DISPATCH_TYPE_BY_OBJECT";
    case DispatchType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface PlayerBasicInfo {
  nickname: string;
  level: number;
  exp: number;
  stamina: number;
  mcoin: number;
  hcoin: number;
  scoin: number;
  worldLevel: number;
}

export interface BlackInfo {
  beginTime: number;
  endTime: number;
  limitLevel: number;
  banType: number;
}

export interface VersionCount {
  version: number;
  count: number;
}

export interface ClientDownloadData {
  version: number;
  time: number;
  data: Uint8Array;
}

export interface ClientUploadData {
  tag: string;
  value: string;
}

export interface FeatureSwitchParam {
  paramList: number[];
}

export interface FeatureSwitchInfo {
  type: FeatureSwitchType;
  switchList: FeatureSwitchParam[];
  isAllClosed: boolean;
}

export interface BattleOp {
  turnCounter: number;
  state: number;
  actionEntityId: number;
  targetEntityId: number;
  opType: number;
  skillIndex: number;
  operationCounter: number;
}

export interface BattleEquipment {
  id: number;
  level: number;
  promotion: number;
  rank: number;
}

export interface BattleRelic {
  id: number;
  level: number;
  mainAffixId: number;
  subAffixList: RelicAffix[];
  uniqueId: number;
}

export interface AvatarSkillTree {
  pointId: number;
  level: number;
}

export interface RelicAffix {
  affixId: number;
  cnt: number;
  step: number;
}

export interface BattleAvatar {
  avatarType: AvatarType;
  id: number;
  level: number;
  rank: number;
  index: number;
  skilltreeList: AvatarSkillTree[];
  equipmentList: BattleEquipment[];
  hp: number;
  sp: number;
  promotion: number;
  relicList: BattleRelic[];
}

export interface BattleMonsterWave {
  monsterIdList: number[];
}

export interface BattleBuff {
  id: number;
  level: number;
  ownerIndex: number;
  waveFlag: number;
  targetIndexList: number[];
  dynamicValues: { [key: string]: number };
}

export interface BattleBuff_DynamicValuesEntry {
  key: string;
  value: number;
}

export interface BattleLineup {
  avatarList: BattleAvatar[];
  monsterWaveList: BattleMonsterWave[];
  buffList: BattleBuff[];
  heroPathList: HeroPath[];
  battleScoringList: number[];
}

export interface ClientTurnSnapshot {
  turnCounter: number;
  randomCounter: number;
  animEventCounter: number;
  snapshotList: CharacterSnapshot[];
  animEventList: AnimEventSnapshot[];
}

export interface GamecoreConfig {
  isSkipVerify: boolean;
  maxTurnCnt: number;
  isAutoFight: boolean;
  csvPath: string;
}

export interface BattleBuffMsg {
  buffIdList: number[];
  buffIndexList: number[];
  buffLevelList: number[];
  buffFlagList: number[];
}

export interface BattleReplay {
  version: number;
  logicRandomSeed: number;
  stageId: number;
  lineup: BattleLineup | undefined;
  opList: BattleOp[];
  turnSnapshotHash: Uint8Array;
  mazePlaneId: number;
  extraAbilityList: number[];
  isAiConsiderUltraSkill: boolean;
  checkStrategy: BattleCheckStrategyType;
  battleModuleType: BattleModuleType;
  turnSnapshotList: ClientTurnSnapshot[];
  localLevelPath: string;
  debugExtraInfo: string;
  config: GamecoreConfig | undefined;
  gameCoreLogEncode: Uint8Array;
  roundsLimit: number;
  logStringHash: BattleReplayStringHash[];
  planeId: number;
  floorId: number;
  battleAreaGroupId: number;
  battleAreaId: number;
}

export interface BattleReplayStringHash {
  hash: number;
  value: string;
}

export interface AvatarProperty {
  maxHp: number;
  attack: number;
  defence: number;
  speed: number;
  leftHp: number;
  leftSp: number;
  maxSp: number;
}

export interface EquipmentProperty {
  id: number;
  rank: number;
  promotion: number;
  level: number;
}

export interface AttackDamageProperty {
  attackType: string;
  damage: number;
}

export interface SkillUseProperty {
  skillId: number;
  skillType: string;
  skillLevel: number;
  skillUseCount: number;
}

export interface SpAddSource {
  source: string;
  spAdd: number;
}

export interface AvatarBattleInfo {
  avatarType: AvatarType;
  id: number;
  avatarLevel: number;
  avatarRank: number;
  avatarPromotion: number;
  avatarStatus: AvatarProperty | undefined;
  avatarSkill: AvatarSkillTree[];
  avatarEquipment: EquipmentProperty[];
  totalTurns: number;
  totalDamage: number;
  totalHeal: number;
  totalDamageTaken: number;
  totalHpRecover: number;
  totalSpCost: number;
  stageId: number;
  stageType: number;
  totalBreakDamage: number;
  attackTypeDamage: AttackDamageProperty[];
  attackTypeBreakDamage: AttackDamageProperty[];
  attackTypeMaxDamage: AttackDamageProperty[];
  skillTimes: SkillUseProperty[];
  delayCumulate: number;
  totalSpAdd: number;
  spAddSource: SpAddSource[];
  totalBpCost: number;
  dieTimes: number;
  reviveTimes: number;
  breakTimes: number;
  extraTurns: number;
  totalShield: number;
  totalShieldTaken: number;
  totalShieldDamage: number;
  initialStatus: AvatarProperty | undefined;
  relics: BattleRelic[];
}

export interface MonsterProperty {
  maxHp: number;
  attack: number;
  defence: number;
  shield: number;
  speed: number;
  leftHp: number;
}

export interface MonsterBattleInfo {
  entityId: number;
  monsterId: number;
  monsterTemplateId: number;
  monsterLevel: number;
  monsterStatus: MonsterProperty | undefined;
  totalTurns: number;
  totalDamage: number;
  totalHeal: number;
  totalDamageTaken: number;
  totalStanceDamageTaken: number;
  totalHpRecover: number;
  stageId: number;
  battleId: number;
  monsterType: number;
  attackTypeDamage: AttackDamageProperty[];
  skillTimes: SkillUseProperty[];
  stageType: number;
  totalBreakDamageTaken: number;
  delayCumulate: number;
  deathSource: DeathSource;
  wave: number;
  indexInWave: number;
  phase: number;
  maxPhase: number;
  battleTag: BattleTag;
}

export interface BattleStatistics {
  totalBattleTurns: number;
  totalAutoTurns: number;
  avatarIdList: number[];
  ultraCnt: number;
  totalDelayCumulate: number;
  costTime: number;
  avatarBattleList: AvatarBattleInfo[];
  monsterBattleList: MonsterBattleInfo[];
  roundCnt: number;
  cocoonDeadWave: number;
  avatarBattleTurns: number;
  monsterBattleTurns: number;
  customValues: { [key: string]: number };
  challengeScore: number;
  battleChallengeList: number[];
}

export interface BattleStatistics_CustomValuesEntry {
  key: string;
  value: number;
}

export interface HeroPath {
  heroPathType: number;
  level: number;
  exp: number;
}

export interface BattleResult {
  retcode: BattleCheckResultType;
  endStatus: BattleEndStatus;
  stt: BattleStatistics | undefined;
  gameCoreLogEncode: Uint8Array;
  tags: { [key: string]: number };
  mismatchTurnCount: number;
}

export interface BattleResult_TagsEntry {
  key: string;
  value: number;
}

export interface CharacterSnapshot {
  runtimeId: number;
  properties: number[];
}

export interface AnimEventSnapshot {
  eventName: string;
  count: number;
}

export interface LoginActivityData {
  id: number;
  loginDays: number;
  hasTakenLoginActivityRewardDaysList: number[];
}

export interface GetLoginActivityCsReq {}

export interface GetLoginActivityScRsp {
  retcode: number;
  loginActivityList: LoginActivityData[];
}

export interface TakeLoginActivityRewardCsReq {
  id: number;
  takeDays: number;
}

export interface TakeLoginActivityRewardScRsp {
  retcode: number;
  id: number;
  takeDays: number;
  reward: ItemList | undefined;
}

export interface EnterAdventureCsReq {
  mapId: number;
}

export interface EnterAdventureScRsp {
  retcode: number;
  scene: SceneInfo | undefined;
}

export interface ArchiveData {
  itemIdList: number[];
  monsterTemplateIdList: number[];
}

export interface GetArchiveDataCsReq {}

export interface GetArchiveDataScRsp {
  retcode: number;
  archiveData: ArchiveData | undefined;
}

export interface GetUpdatedArchiveDataCsReq {}

export interface GetUpdatedArchiveDataScRsp {
  retcode: number;
  archiveData: ArchiveData | undefined;
}

export interface GetAvatarDataCsReq {
  isGetAll: boolean;
  baseAvatarIdList: number[];
}

export interface EquipRelic {
  type: number;
  relicUniqueId: number;
}

export interface Avatar {
  baseAvatarId: number;
  exp: number;
  level: number;
  promotion: number;
  rank: number;
  skilltreeList: AvatarSkillTree[];
  equipmentUniqueId: number;
  equipRelicList: EquipRelic[];
}

export interface GetAvatarDataScRsp {
  retcode: number;
  avatarList: Avatar[];
  isAll: boolean;
}

export interface AvatarExpUpCsReq {
  baseAvatarId: number;
  itemCost: ItemCostData | undefined;
}

export interface AvatarExpUpScRsp {
  retcode: number;
  returnItemList: PileItem[];
}

export interface UnlockSkilltreeCsReq {
  pointId: number;
  level: number;
  itemList: ItemCost[];
}

export interface UnlockSkilltreeScRsp {
  retcode: number;
  baseAvatarId: number;
  pointId: number;
  level: number;
}

export interface PromoteAvatarCsReq {
  baseAvatarId: number;
  itemList: ItemCost[];
}

export interface PromoteAvatarScRsp {
  retcode: number;
}

export interface DressAvatarCsReq {
  equipmentUniqueId: number;
  baseAvatarId: number;
}

export interface DressAvatarScRsp {
  retcode: number;
}

export interface TakeOffEquipmentCsReq {
  baseAvatarId: number;
}

export interface TakeOffEquipmentScRsp {
  retcode: number;
}

export interface AddAvatarScNotify {
  baseAvatarId: number;
  reward: ItemList | undefined;
  src: AddAvatarSrc;
}

export interface RankUpAvatarCsReq {
  baseAvatarId: number;
  rank: number;
  costData: ItemCostData | undefined;
}

export interface RankUpAvatarScRsp {
  retcode: number;
}

export interface DressRelicAvatarCsReq {
  relicType: number;
  relicUniqueId: number;
  baseAvatarId: number;
}

export interface DressRelicAvatarScRsp {
  retcode: number;
}

export interface TakeOffRelicCsReq {
  relicType: number;
  baseAvatarId: number;
}

export interface TakeOffRelicScRsp {
  retcode: number;
}

export interface PVEBattleResultCsReq {
  stageId: number;
  opList: BattleOp[];
  turnSnapshotHash: Uint8Array;
  costTime: number;
  debugExtraInfo: string;
  resVersion: number;
  isAiConsiderUltraSkill: boolean;
  endStatus: BattleEndStatus;
  stt: BattleStatistics | undefined;
  battleId: number;
}

export interface PVEBattleResultScRsp {
  retcode: number;
  stageId: number;
  curFinishChallenge: number;
  dropData: ItemList | undefined;
  avatarExpReward: number;
  binVer: string;
  resVer: string;
  battleId: number;
  endStatus: BattleEndStatus;
  extraDropData: ItemList | undefined;
  checkIdentical: boolean;
  eventId: number;
  mismatchTurnCount: number;
}

export interface QuitBattleCsReq {}

export interface QuitBattleScRsp {
  retcode: number;
}

export interface GetCurBattleInfoCsReq {}

export interface GetCurBattleInfoScRsp {
  retcode: number;
  stageId: number;
  logicRandomSeed: number;
  avatarList: BattleAvatar[];
  battleInfo: SceneBattleInfo | undefined;
  lastEndStatus: BattleEndStatus;
  lastEventId: number;
}

export interface SyncClientResVersionCsReq {
  resVersion: number;
}

export interface SyncClientResVersionScRsp {
  retcode: number;
  resVersion: number;
}

export interface QuitBattleScNotify {}

export interface Challenge {
  challengeId: number;
  stars: number;
  takenReward: number;
}

export interface GetChallengeCsReq {}

export interface GetChallengeScRsp {
  retcode: number;
  challengeList: Challenge[];
}

export interface StartChallengeCsReq {
  challengeId: number;
}

export interface StartChallengeScRsp {
  retcode: number;
  maze: Maze | undefined;
  curChallenge: CurChallenge | undefined;
}

export interface LeaveChallengeCsReq {}

export interface LeaveChallengeScRsp {
  retcode: number;
  maze: Maze | undefined;
}

export interface ChallengeSettleNotify {
  challengeId: number;
  isWin: boolean;
  reward: ItemList | undefined;
  stars: number;
}

export interface FinishChallengeCsReq {
  challengeId: number;
}

export interface FinishChallengeScRsp {
  retcode: number;
}

export interface KillMonster {
  monsterId: number;
  killNum: number;
}

export interface CurChallenge {
  challengeId: number;
  rounds: number;
  status: ChallengeStatus;
  extraLineupType: ExtraLineupType;
  killMonsterList: KillMonster[];
  deadAvatarNum: number;
}

export interface GetCurChallengeCsReq {}

export interface GetCurChallengeScRsp {
  retcode: number;
  curChallenge: CurChallenge | undefined;
}

export interface ChallengeLineupNotify {
  extraLineupType: ExtraLineupType;
}

export interface TakeChallengeTargetRewardCsReq {
  challengeId: number;
  indexList: number[];
}

export interface TakeChallengeTargetRewardScRsp {
  retcode: number;
  challengeId: number;
  takenIndexList: number[];
  reward: ItemList | undefined;
}

export interface Item {
  itemId: number;
  num: number;
  level: number;
  rank: number;
  promotion: number;
  uniqueId: number;
}

export interface ItemList {
  itemList: Item[];
}

export interface PileItem {
  itemId: number;
  itemNum: number;
}

export interface ItemCost {
  pileItem: PileItem | undefined;
  equipmentUniqueId: number | undefined;
  relicUniqueId: number | undefined;
}

export interface ItemCostData {
  itemList: ItemCost[];
}

export interface SceneMonsterWave {
  monsterIdList: number[];
  dropList: ItemList[];
}

export interface SceneBattleInfo {
  logicRandomSeed: number;
  stageId: number;
  monsterWaveList: SceneMonsterWave[];
  battleAvatarList: BattleAvatar[];
  buffList: BattleBuff[];
  battleId: number;
  heroPathList: HeroPath[];
  roundsLimit: number;
}

export interface DialogueEvent {
  dialogueGroupId: number;
  dialogueEventIdList: number[];
}

export interface DialogueResultInfo {
  itemResult: ItemList | undefined;
  rogueBuffResult: RogueBuffList | undefined;
}

export interface GetDialogueEventDataCsReq {}

export interface GetDialogueEventDataScRsp {
  retcode: number;
  dialogueEventList: DialogueEvent[];
}

export interface SelectDialogueEventCsReq {
  dialogueGroupId: number;
  dialogueEventId: number;
}

export interface SelectDialogueEventScRsp {
  retcode: number;
  dialogueGroupId: number;
  dialogueEventId: number;
  resultInfo: DialogueResultInfo | undefined;
}

export interface SyncDialogueEventDataScNotify {
  dialogueEventList: DialogueEvent[];
}

export interface Expedition {
  id: number;
  acceptTime: number;
  duration: number;
  avatarIdList: number[];
}

export interface GetExpeditionDataCsReq {}

export interface GetExpeditionDataScRsp {
  retcode: number;
  teamCount: number;
  unlockedExpeditionIdList: number[];
  expedtionList: Expedition[];
}

export interface AcceptExpeditionCsReq {
  expedition: Expedition | undefined;
}

export interface AcceptExpeditionScRsp {
  retcode: number;
  expedition: Expedition | undefined;
}

export interface CancelExpeditionCsReq {
  expeditionId: number;
}

export interface CancelExpeditionScRsp {
  retcode: number;
  expeditionId: number;
}

export interface TakeExpeditionRewardCsReq {
  expeditionId: number;
}

export interface TakeExpeditionRewardScRsp {
  retcode: number;
  expeditionId: number;
  reward: ItemList | undefined;
}

export interface GetGachaInfoCsReq {}

export interface GachaInfo {
  gachaId: number;
  beginTime: number;
  endTime: number;
  detailWebview: string;
  newbieGachaCnt: number;
  todayGachaCnt: number;
}

export interface GetGachaInfoScRsp {
  retcode: number;
  gachaInfoList: GachaInfo[];
  gachaRandom: number;
  todayTotalGachaCnt: number;
  todaySingleGachaMaxCnt: number;
  todayTotalGachaMaxCnt: number;
}

export interface DoGachaCsReq {
  gachaId: number;
  gachaNum: number;
  gachaRandom: number;
  simulateMagic: number;
}

export interface GachaItem {
  gachaItem: Item | undefined;
  transferItemList: ItemList | undefined;
  isNew: boolean;
  tokenItem: ItemList | undefined;
}

export interface DoGachaScRsp {
  retcode: number;
  gachaId: number;
  gachaNum: number;
  gachaItemList: GachaItem[];
  newGachaRandom: number;
  newbieGachaCnt: number;
  todayGachaCnt: number;
  todayTotalGachaCnt: number;
}

export interface GetBagCsReq {}

export interface Equipment {
  uniqueId: number;
  tid: number;
  level: number;
  exp: number;
  rank: number;
  baseAvatarId: number;
  isProtected: boolean;
  promotion: number;
}

export interface Relic {
  uniqueId: number;
  tid: number;
  level: number;
  exp: number;
  baseAvatarId: number;
  isProtected: boolean;
  mainAffixId: number;
  subAffixList: RelicAffix[];
}

export interface Material {
  tid: number;
  num: number;
}

export interface WaitDelResource {
  tid: number;
  num: number;
}

export interface GetBagScRsp {
  retcode: number;
  equipmentList: Equipment[];
  materialList: Material[];
  relicList: Relic[];
  rogueItemList: Material[];
  waitDelResourceList: WaitDelResource[];
}

export interface PromoteEquipmentCsReq {
  equipmentUniqueId: number;
  costData: ItemCostData | undefined;
}

export interface PromoteEquipmentScRsp {
  retcode: number;
}

export interface LockEquipmentCsReq {
  equipmentUniqueId: number;
  isLock: boolean;
}

export interface LockEquipmentScRsp {
  retcode: number;
  equipmentUniqueId: number;
}

export interface UseItemCsReq {
  useItemId: number;
  useItemCount: number;
  baseAvatarId: number;
  useAvatarType: AvatarType;
  optionalRewardId: number;
}

export interface UseItemScRsp {
  retcode: number;
  useItemId: number;
  useItemCount: number;
  returnData: ItemList | undefined;
}

export interface RankUpEquipmentCsReq {
  equipmentUniqueId: number;
  equipmentIdList: number[];
}

export interface RankUpEquipmentScRsp {
  retcode: number;
}

export interface ExpUpEquipmentCsReq {
  equipmentUniqueId: number;
  costData: ItemCostData | undefined;
}

export interface ExpUpEquipmentScRsp {
  retcode: number;
  returnItemList: PileItem[];
}

export interface ComposeItemCsReq {
  composeId: number;
  count: number;
}

export interface ComposeItemScRsp {
  retcode: number;
  composeId: number;
  count: number;
  returnItemList: ItemList | undefined;
}

export interface ExpUpRelicCsReq {
  relicUniqueId: number;
  costData: ItemCostData | undefined;
}

export interface ExpUpRelicScRsp {
  retcode: number;
  returnItemList: PileItem[];
}

export interface LockRelicCsReq {
  relicUniqueId: number;
  isLock: boolean;
}

export interface LockRelicScRsp {
  retcode: number;
  relicUniqueId: number;
}

export interface SellItemCsReq {
  costData: ItemCostData | undefined;
}

export interface SellItemScRsp {
  retcode: number;
  returnItemList: ItemList | undefined;
}

export interface RechargeSuccNotify {
  itemList: ItemList | undefined;
}

export interface GetStageLineupCsReq {}

export interface StageLineup {
  stageType: number;
  lineupIndex: number;
}

export interface GetStageLineupScRsp {
  retcode: number;
  stageLineupList: StageLineup[];
}

export interface LineupAvatar {
  slot: number;
  avatarType: AvatarType;
  id: number;
  hp: number;
  sp: number;
  satiety: number;
}

export interface LineupInfo {
  avatarList: LineupAvatar[];
  isVirtual: boolean;
  planeId: number;
  mp: number;
  leaderSlot: number;
  index: number;
  extraLineupType: ExtraLineupType;
  name: string;
}

export interface GetCurLineupDataCsReq {}

export interface GetCurLineupDataScRsp {
  retcode: number;
  lineup: LineupInfo | undefined;
}

export interface JoinLineupCsReq {
  baseAvatarId: number;
  isVirtual: boolean;
  planeId: number;
  slot: number;
  index: number;
  extraLineupType: ExtraLineupType;
}

export interface JoinLineupScRsp {
  retcode: number;
}

export interface QuitLineupCsReq {
  baseAvatarId: number;
  isVirtual: boolean;
  planeId: number;
  index: number;
  extraLineupType: ExtraLineupType;
}

export interface QuitLineupScRsp {
  retcode: number;
  baseAvatarId: number;
  isMainline: boolean;
  planeId: number;
  isVirtual: boolean;
}

export interface SwapLineupCsReq {
  isVirtual: boolean;
  planeId: number;
  srcSlot: number;
  dstSlot: number;
  index: number;
  extraLineupType: ExtraLineupType;
}

export interface SwapLineupScRsp {
  retcode: number;
}

export interface SyncLineupNotify {
  lineup: LineupInfo | undefined;
  reasonList: SyncLineupReason[];
}

export interface GetLineupAvatarDataCsReq {}

export interface LineupAvatarData {
  avatarType: AvatarType;
  id: number;
  hp: number;
}

export interface GetLineupAvatarDataScRsp {
  retcode: number;
  avatarDataList: LineupAvatarData[];
}

export interface ChangeLineupLeaderCsReq {
  slot: number;
}

export interface ChangeLineupLeaderScRsp {
  retcode: number;
  slot: number;
}

export interface SwitchLineupIndexCsReq {
  index: number;
}

export interface SwitchLineupIndexScRsp {
  retcode: number;
  index: number;
}

export interface SetLineupNameCsReq {
  name: string;
  index: number;
}

export interface SetLineupNameScRsp {
  retcode: number;
  name: string;
  index: number;
}

export interface GetAllLineupDataCsReq {}

export interface GetAllLineupDataScRsp {
  retcode: number;
  curIndex: number;
  lineupList: LineupInfo[];
}

export interface VirtualLineupDestroyNotify {
  planeId: number;
}

export interface GetMailCsReq {
  start: number;
  stop: number;
}

export interface ClientMail {
  id: number;
  templateId: number;
  title: string;
  content: string;
  sender: string;
  time: number;
  attachment: ItemList | undefined;
  isRead: boolean;
  expireTime: number;
  paraList: string[];
}

export interface GetMailScRsp {
  retcode: number;
  mailList: ClientMail[];
  isEnd: boolean;
  totalNum: number;
  start: number;
  noticeMailList: ClientMail[];
}

export interface MarkReadMailCsReq {
  id: number;
}

export interface MarkReadMailScRsp {
  retcode: number;
  id: number;
}

export interface DelMailCsReq {
  idList: number[];
}

export interface DelMailScRsp {
  retcode: number;
  idList: number[];
}

export interface TakeMailAttachmentCsReq {
  mailIdList: number[];
}

export interface ClientMailAttachmentItem {
  mailId: number;
  itemId: number;
}

export interface TakeMailAttachmentScRsp {
  retcode: number;
  succMailIdList: number[];
  attachment: ItemList | undefined;
  failMailList: ClientMailAttachmentItem[];
}

export interface NewMailScNotify {
  mailIdList: number[];
}

export interface MazeFloor {
  floorId: number;
  scene: SceneInfo | undefined;
}

export interface Maze {
  id: number;
  floor: MazeFloor | undefined;
  mapEntryId: number;
}

export interface MazeAvatar {
  baseAvatarId: number;
  leftHp: number;
  sp: number;
}

export interface MazeMission {
  subMissionId: number;
  status: MissionStatus;
}

export interface GetMazeCsReq {}

export interface GetMazeScRsp {
  retcode: number;
  mazeList: Maze[];
  curSeriesId: number;
  finishedPlaneList: number[];
  waitPlaneList: number[];
  takenRewardList: number[];
  avatarList: MazeAvatar[];
  chosenAbilityList: number[];
  candidateAbilityList: number[];
  mazeMissionList: MazeMission[];
}

export interface ChooseMazeSeriesCsReq {
  seriesId: number;
}

export interface ChooseMazeSeriesScRsp {
  retcode: number;
  seriesId: number;
}

export interface ChooseMazeAbilityCsReq {
  abilityId: number;
}

export interface ChooseMazeAbilityScRsp {
  retcode: number;
  abilityList: number[];
}

export interface EnterMazeCsReq {
  entryId: number;
  teleportId: number;
}

export interface EnterMazeScRsp {
  retcode: number;
  maze: Maze | undefined;
}

export interface MazeBuffScNotify {
  buffId: number;
  op: MazeBuffOp;
}

export interface CastMazeSkillCsReq {
  skillId: number;
}

export interface CastMazeSkillScRsp {
  retcode: number;
}

export interface MazePlaneEventScNotify {
  itemData: ItemList | undefined;
}

export interface EnterMazeByServerScNotify {
  maze: Maze | undefined;
  reason: EnterMazeReason;
}

export interface MazePropState {
  groupId: number;
  configId: number;
  state: number;
}

export interface MazeGroup {
  groupId: number;
  modifyTime: number;
}

export interface GetMazeMapInfoCsReq {
  entryId: number;
}

export interface GetMazeMapInfoScRsp {
  retcode: number;
  entryId: number;
  lightenSectionList: number[];
  mazePropList: MazePropState[];
  mazeGroupList: MazeGroup[];
  opendChestNum: number;
  unlockTeleportList: number[];
}

export interface GetMazeTimeOfDayCsReq {}

export interface GetMazeTimeOfDayScRsp {
  retcode: number;
  mazeTimeOfDayMap: { [key: number]: number };
}

export interface GetMazeTimeOfDayScRsp_MazeTimeOfDayMapEntry {
  key: number;
  value: number;
}

export interface SetMazeTimeOfDayCsReq {
  planeId: number;
  timeOfDayType: number;
}

export interface SetMazeTimeOfDayScRsp {
  retcode: number;
  planeId: number;
  timeOfDayType: number;
}

export interface DelMazeTimeOfDayCsReq {
  planeId: number;
}

export interface DelMazeTimeOfDayScRsp {
  retcode: number;
  planeId: number;
}

export interface ReturnStartAnchorCsReq {
  entryId: number;
}

export interface ReturnStartAnchorScRsp {
  retcode: number;
}

export interface GetNpcMessageGroupCsReq {
  contactIdList: number[];
}

export interface MessageItem {
  itemId: number;
  textId: number;
}

export interface MessageSection {
  id: number;
  messageItemId: number;
  status: MessageSectionStatus;
  itemList: MessageItem[];
}

export interface MessageGroup {
  id: number;
  messageSectionId: number;
  status: MessageGroupStatus;
  refreshTime: number;
  messageSectionList: MessageSection[];
}

export interface GetNpcMessageGroupScRsp {
  retcode: number;
  messageGroupList: MessageGroup[];
}

export interface GetNpcStatusCsReq {}

export interface NpcStatus {
  npcId: number;
  isFinish: boolean;
}

export interface GroupStatus {
  groupId: number;
  groupStatus: MessageGroupStatus;
  refreshTime: number;
}

export interface SectionStatus {
  sectionId: number;
  sectionStatus: MessageSectionStatus;
}

export interface GetNpcStatusScRsp {
  retcode: number;
  messageStatusList: NpcStatus[];
}

export interface FinishItemIdCsReq {
  itemId: number;
  textId: number;
}

export interface FinishItemIdScRsp {
  retcode: number;
  itemId: number;
  textId: number;
}

export interface FinishSectionIdCsReq {
  sectionId: number;
}

export interface FinishSectionIdScRsp {
  retcode: number;
  sectionId: number;
}

export interface GetMissionDataCsReq {}

export interface Mission {
  id: number;
  status: MissionStatus;
  progress: number;
}

export interface GetMissionDataScRsp {
  retcode: number;
  missionList: Mission[];
}

export interface FinishTalkMissionCsReq {
  talkStr: string;
}

export interface FinishTalkMissionScRsp {
  retcode: number;
  talkStr: string;
}

export interface MissionRewardScNotify {
  mainMissionId: number;
  reward: ItemList | undefined;
}

export interface SubMissionRewardScNotify {
  subMissionId: number;
  reward: ItemList | undefined;
}

export interface SyncTaskCsReq {
  key: string;
}

export interface SyncTaskScRsp {
  retcode: number;
  key: string;
}

export interface DailyTask {
  mainMissionId: number;
  isFinished: boolean;
}

export interface DailyTaskDataScNotify {
  isTakenExtraReward: boolean;
  finishedNum: number;
  dailyTaskList: DailyTask[];
}

export interface TakeDailyTaskExtraRewardCsReq {}

export interface TakeDailyTaskExtraRewardScRsp {
  retcode: number;
  reward: ItemList | undefined;
}

export interface DailyTaskRewardScNotify {
  count: number;
  reward: ItemList | undefined;
}

export interface MissionGroupWarnScNotify {
  groupIdList: number[];
}

export interface FinishCosumeItemMissionCsReq {
  subMissionId: number;
}

export interface FinishCosumeItemMissionScRsp {
  retcode: number;
  subMissionId: number;
}

export interface GetMissionEventDataCsReq {}

export interface GetMissionEventDataScRsp {
  retcode: number;
  missionEventList: Mission[];
  challengeEventId: number;
}

export interface MissionEventRewardScNotify {
  missionEventId: number;
  reward: ItemList | undefined;
}

export interface AcceptMissionEventCsReq {
  missionEventId: number;
}

export interface AcceptMissionEventScRsp {
  retcode: number;
  missionEvent: Mission | undefined;
}

export interface GetMissionStatusCsReq {
  mainMissionIdList: number[];
  subMissionIdList: number[];
  missionEventIdList: number[];
}

export interface GetMissionStatusScRsp {
  retcode: number;
  finishedMainMissionIdList: number[];
  unfinishedMainMissionIdList: number[];
  subMissionStatusList: Mission[];
  missionEventStatusList: Mission[];
}

export interface InterruptMissionEventCsReq {
  missionEventId: number;
}

export interface InterruptMissionEventScRsp {
  retcode: number;
  missionEventId: number;
}

export interface SetMissionEventProgressCsReq {
  missionEventId: number;
  progress: number;
}

export interface SetMissionEventProgressScRsp {
  retcode: number;
}

export interface PlayerLoginCsReq {
  platform: PlatformType;
  cps: string;
  deviceUuid: string;
  deviceInfo: string;
  systemInfo: string;
  clientVersion: string;
  language: LanguageType;
  lastServerPacketId: number;
  checkSum1: string;
  checkSum2: string;
  signature: string;
  resolution: string;
  loginRandom: number;
  systemLanguage: string;
  resVersion: number;
  clientTimeZone: string;
}

export interface PlayerLoginScRsp {
  retcode: number;
  isNewPlayer: boolean;
  basicInfo: PlayerBasicInfo | undefined;
  serverTimestampMs: number;
  stamina: number;
  isRelay: boolean;
  loginRandom: number;
  curTimezone: number;
  bsBinVersion: string;
}

export interface PlayerLogoutCsReq {}

export interface PlayerGetTokenCsReq {
  channelId: number;
  accountUid: string;
  token: string;
  uid: number;
  device: string;
}

export interface PlayerGetTokenScRsp {
  retcode: number;
  uid: number;
  blackInfo: BlackInfo | undefined;
  msg: string;
  secretKeySeed: number;
}

export interface PlayerKeepAliveNotify {
  data: ClientUploadData | undefined;
}

export interface GmTalkScNotify {
  msg: string;
}

export interface PlayerKickOutScNotify {
  kickType: PlayerKickOutScNotify_KickType;
  blackInfo: BlackInfo | undefined;
}

export enum PlayerKickOutScNotify_KickType {
  KICK_SQUEEZED = 0,
  KICK_BLACK = 1,
  KICK_CHANGE_PWD = 2,
  UNRECOGNIZED = -1,
}

export function playerKickOutScNotify_KickTypeFromJSON(
  object: any
): PlayerKickOutScNotify_KickType {
  switch (object) {
    case 0:
    case "KICK_SQUEEZED":
      return PlayerKickOutScNotify_KickType.KICK_SQUEEZED;
    case 1:
    case "KICK_BLACK":
      return PlayerKickOutScNotify_KickType.KICK_BLACK;
    case 2:
    case "KICK_CHANGE_PWD":
      return PlayerKickOutScNotify_KickType.KICK_CHANGE_PWD;
    case -1:
    case "UNRECOGNIZED":
    default:
      return PlayerKickOutScNotify_KickType.UNRECOGNIZED;
  }
}

export function playerKickOutScNotify_KickTypeToJSON(
  object: PlayerKickOutScNotify_KickType
): string {
  switch (object) {
    case PlayerKickOutScNotify_KickType.KICK_SQUEEZED:
      return "KICK_SQUEEZED";
    case PlayerKickOutScNotify_KickType.KICK_BLACK:
      return "KICK_BLACK";
    case PlayerKickOutScNotify_KickType.KICK_CHANGE_PWD:
      return "KICK_CHANGE_PWD";
    case PlayerKickOutScNotify_KickType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface GmTalkCsReq {
  msg: string;
}

export interface GmTalkScRsp {
  retcode: number;
  retmsg: string;
}

export interface GetBasicInfoCsReq {}

export interface GetBasicInfoScRsp {
  retcode: number;
  nextRecoverTime: number;
  exchangeTimes: number;
  weekCocoonFinishedCount: number;
  curDay: number;
}

export interface ExchangeStaminaCsReq {}

export interface ExchangeStaminaScRsp {
  retcode: number;
  staminaAdd: number;
  itemCostList: ItemCost[];
  lastRecoverTime: number;
  exchangeTimes: number;
}

export interface GetAuthkeyCsReq {
  authAppid: string;
  signType: number;
  authkeyVer: number;
}

export interface GetAuthkeyScRsp {
  retcode: number;
  authkey: string;
  authAppid: string;
  signType: number;
  authkeyVer: number;
}

export interface RegionStopScNotify {
  stopBeginTime: number;
  stopEndTime: number;
}

export interface AntiAddictScNotify {
  msgType: number;
  msg: string;
  level: string;
}

export interface SetNicknameCsReq {
  nickname: string;
  isModify: boolean;
}

export interface SetNicknameScRsp {
  retcode: number;
  isModify: boolean;
}

export interface GetLevelRewardTakenListCsReq {}

export interface GetLevelRewardTakenListScRsp {
  retcode: number;
  takenLevelList: number[];
}

export interface GetLevelRewardCsReq {
  level: number;
}

export interface GetLevelRewardScRsp {
  retcode: number;
  reward: ItemList | undefined;
}

export interface SyncTimeCsReq {
  clientTimeMs: number;
}

export interface SyncTimeScRsp {
  retcode: number;
  clientTimeMs: number;
  serverTimeMs: number;
  downloadData: ClientDownloadData | undefined;
}

export interface SetLanguageCsReq {
  language: LanguageType;
}

export interface SetLanguageScRsp {
  retcode: number;
  language: LanguageType;
}

export interface AnnounceData {
  configId: number;
  beginTime: number;
  endTime: number;
  centerSystemText: string;
  countDownText: string;
  dungeonConfirmText: string;
  centerSystemFrequency: number;
  countDownFrequency: number;
  isCenterSystemLast5EveryMinutes: boolean;
}

export interface ServerAnnounceNotify {
  announceDataList: AnnounceData[];
}

export interface Gateserver {
  retcode: number;
  msg: string;
  regionName: string;
  ip: string;
  port: number;
  stopBeginTime: number;
  stopEndTime: number;
  dataUseAssetBoundle: boolean;
  resUseAssetBoundle: boolean;
  assetBundleUrl: string;
  exResourceUrl: string;
  luaUrl: string;
  asbRelogin: number;
  asbMemo: string;
  designDataRelogin: number;
  designDataMemo: string;
  clientSecretKey: string;
  recordGameObjectUserData: string;
  useTcp: boolean;
  customServiceUrl: string;
  operationFeedbackUrl: string;
  privacyInGameUrl: string;
  clientRecordReplay: boolean;
  serverDescription: string;
}

export interface SetHeroBasicTypeCsReq {
  basicType: HeroBasicType;
}

export interface SetHeroBasicTypeScRsp {
  retcode: number;
  basicType: HeroBasicType;
}

export interface GetHeroBasicTypeInfoCsReq {}

export interface HeroBasicTypeInfo {
  basicType: HeroBasicType;
  rank: number;
  skillTreeList: AvatarSkillTree[];
}

export interface GetHeroBasicTypeInfoScRsp {
  retcode: number;
  gender: Gender;
  curBasicType: HeroBasicType;
  basicTypeInfoList: HeroBasicTypeInfo[];
  heroPathList: HeroPath[];
  isGenderModified: boolean;
  isPlayerInfoModified: boolean;
}

export interface GetHeroPathCsReq {}

export interface GetHeroPathScRsp {
  retcode: number;
  heroPathList: HeroPath[];
}

export interface HeroPathChangedNotify {
  heroPath: HeroPath | undefined;
}

export interface SetGenderCsReq {
  gender: Gender;
}

export interface SetGenderScRsp {
  retcode: number;
  curBasicType: HeroBasicType;
}

export interface SetPlayerInfoCsReq {
  nickname: string;
  isModify: boolean;
  gender: Gender;
}

export interface SetPlayerInfoScRsp {
  retcode: number;
  curBasicType: HeroBasicType;
  isModify: boolean;
}

export interface HeroBasicTypeChangedNotify {
  curBasicType: HeroBasicType;
}

export interface QueryProductInfoCsReq {}

export interface Product {
  productId: string;
  priceTier: string;
}

export interface QueryProductInfoScRsp {
  retcode: number;
  productList: Product[];
}

export interface ClientDownloadDataScNotify {
  downloadData: ClientDownloadData | undefined;
}

export interface UpdateFeatureSwitchScNotify {
  switchInfoList: FeatureSwitchInfo[];
}

export interface DailyRefreshNotify {
  curDay: number;
}

export interface FinishPlotCsReq {
  plotId: number;
}

export interface FinishPlotScRsp {
  retcode: number;
  plotId: number;
}

export interface PrestigeInfo {
  prestigeId: number;
  level: number;
  exp: number;
  takenLevelList: number[];
}

export interface GetPrestigeInfoCsReq {
  prestigeId: number;
}

export interface GetPrestigeInfoScRsp {
  retcode: number;
  prestigeInfo: PrestigeInfo | undefined;
}

export interface PrestigeInfoChangeNotify {
  prestigeInfo: PrestigeInfo | undefined;
}

export interface TakePrestigeLevelRewardCsReq {
  prestigeId: number;
  level: number;
}

export interface TakePrestigeLevelRewardScRsp {
  retcode: number;
  prestigeId: number;
  reward: ItemList | undefined;
}

export interface GetQuestDataCsReq {}

export interface Quest {
  id: number;
  status: QuestStatus;
  progress: number;
  finishTime: number;
}

export interface GetQuestDataScRsp {
  retcode: number;
  questList: Quest[];
  totalAchievementExp: number;
  takenAchievementLevelList: number[];
}

export interface TakeQuestRewardCsReq {
  questIdList: number[];
}

export interface TakeQuestRewardScRsp {
  retcode: number;
  reward: ItemList | undefined;
  succQuestIdList: number[];
}

export interface TakeAchievementLevelRewardCsReq {
  achievementLevelList: number[];
}

export interface TakeAchievementLevelRewardScRsp {
  retcode: number;
  reward: ItemList | undefined;
  succAchievementLevelList: number[];
}

export interface StartRaidCsReq {
  propEntityId: number;
  raidId: number;
  worldLevel: number;
  avatarList: number[];
}

export interface StartRaidScRsp {
  retcode: number;
}

export interface LeaveRaidCsReq {
  raidId: number;
}

export interface LeaveRaidScRsp {
  retcode: number;
}

export interface RaidInfoNotify {
  raidId: number;
  worldLevel: number;
  status: RaidStatus;
  itemList: ItemList | undefined;
}

export interface ChallengeRaid {
  raidId: number;
  maxScore: number;
}

export interface GetChallengeRaidInfoCsReq {}

export interface GetChallengeRaidInfoScRsp {
  retcode: number;
  challengeRaidList: ChallengeRaid[];
  takenRewardIdList: number[];
}

export interface TakeChallengeRaidRewardCsReq {
  rewardId: number;
}

export interface TakeChallengeRaidRewardScRsp {
  retcode: number;
  rewardId: number;
  reward: ItemList | undefined;
}

export interface ChallengeRaidNotify {
  challengeRaid: ChallengeRaid | undefined;
}

export interface RogueBuff {
  buffId: number;
  level: number;
}

export interface RogueBuffList {
  buffList: RogueBuff[];
}

export interface RogueRoom {
  roomId: number;
  status: RogueRoomStatus;
  siteId: number;
}

export interface RogueLevel {
  levelId: number;
  mapId: number;
  roomList: RogueRoom[];
  curRoomId: number;
}

export interface RogueBless {
  blessId: number;
  level: number;
}

export interface RogueBlessInfo {
  blessList: RogueBless[];
  activeBlessId: number;
  bless: RogueBless | undefined;
  monsterKillCount: number;
}

export interface RogueBuffSelectInfo {
  rollBuffCount: number;
  rogueCoin: number;
  leftSelectCount: number;
  mazeBuffList: RogueBuff[];
  rollBuffMaxCount: number;
  rollBuffCostData: ItemCostData | undefined;
}

export interface RogueShopBuff {
  buffInfo: RogueBuff | undefined;
  totalCount: number;
  leftCount: number;
}

export interface RogueShopItem {
  itemId: number;
  totalCount: number;
  leftCount: number;
  costData: ItemCostData | undefined;
}

export interface RogueShopInfo {
  rogueShopId: number;
  shopBuffList: RogueShopBuff[];
  shopItemList: RogueShopItem[];
}

export interface RogueAppraisalRecord {
  groupId: number;
  configId: number;
  appraisalCount: number;
}

export interface RogueAppraisalInfo {
  appraisalList: RogueAppraisalRecord[];
}

export interface RogueAppraisalItem {
  itemId: number;
  succRatio: number;
  perfectRatio: number;
}

export interface RogueAppraisalItemInfo {
  itemList: RogueAppraisalItem[];
}

export interface RogueQuest {
  rogueQuestId: number;
  worldLevel: number;
  progress: number;
  status: RogueQuestStatus;
  beginTime: number;
  endTime: number;
  type: RogueQuestType;
}

export interface RogueInfo {
  status: RogueStatus;
  levelInfo: RogueLevel | undefined;
  roomList: RogueRoom[];
  rogueCoin: number;
  baseAvatarIdList: number[];
  rogueStamina: number;
  reviveCount: number;
  recoverStaminaCount: number;
  isRecordSaved: boolean;
  exploreRewardList: number[];
  seasonId: number;
  beginTime: number;
  endTime: number;
  isWin: boolean;
  mazeBuffList: RogueBuff[];
  extraBuffList: RogueBuff[];
  rogueExploreExp: number;
  rogueExploreLv: number;
  buffSelectInfo: RogueBuffSelectInfo | undefined;
  isPickAvatar: boolean;
  blessInfo: RogueBlessInfo | undefined;
  buffScore: number;
  appraisalInfo: RogueAppraisalInfo | undefined;
  worldLevel: number;
  rogueGachaItemNumOnEnter: number;
  rogueQuestList: RogueQuest[];
}

export interface RogueRecord {
  slot: number;
  avatarList: number[];
  mazeBuffList: RogueBuff[];
  name: string;
  score: number;
}

export interface RogueChallengeInfo {
  isInChallenge: boolean;
  challengeRewardList: number[];
  histroyMaxScore: number;
  recordList: RogueRecord[];
  recordSlot: number;
}

export interface RogueFinishInfo {
  isWin: boolean;
  reward: ItemList | undefined;
  exploreQuestList: number[];
  canSave: boolean;
  buffScore: number;
  rogueGachaItemNum: number;
}

export interface RogueChallengeSpecialScore {
  scoreId: number;
  score: number;
}

export interface RogueChallengeScoreInfo {
  totalScore: number;
  turnScore: number;
  damageScore: number;
  specialScoreList: RogueChallengeSpecialScore[];
}

export interface RogueChallengeFinishInfo {
  isWin: boolean;
  rounds: number;
  damage: number;
  reward: ItemList | undefined;
  challengeQuestList: number[];
  scoreInfo: RogueChallengeScoreInfo | undefined;
}

export interface RogueDialog {
  rogueDialogId: number;
  status: RogueDialogStatus;
}

export interface RogueGachaGoods {
  gachaGoodsId: number;
  status: number;
}

export interface RogueGachaInfo {
  gachaPoolId: number;
  goodsList: RogueGachaGoods[];
  wishIdList: number[];
  curWishId: number;
  gachaCount: number;
  totalCount: number;
}

export interface GetRogueInfoCsReq {}

export interface GetRogueInfoScRsp {
  retcode: number;
  rogueInfo: RogueInfo | undefined;
  rogueChallengeInfo: RogueChallengeInfo | undefined;
}

export interface StartRogueCsReq {
  baseAvatarIdList: number[];
}

export interface StartRogueScRsp {
  retcode: number;
  maze: Maze | undefined;
  rogueInfo: RogueInfo | undefined;
}

export interface EnterRogueCsReq {}

export interface EnterRogueScRsp {
  retcode: number;
  maze: Maze | undefined;
  rogueInfo: RogueInfo | undefined;
}

export interface LeaveRogueCsReq {}

export interface LeaveRogueScRsp {
  retcode: number;
  maze: Maze | undefined;
}

export interface SyncRogueBuffSelectInfoScNotify {
  buffSelectInfo: RogueBuffSelectInfo | undefined;
}

export interface SelectRogueBuffCsReq {
  mazeBuffId: number;
}

export interface SelectRogueBuffScRsp {
  retcode: number;
  godPlotId: number;
  buffSelectInfo: RogueBuffSelectInfo | undefined;
}

export interface RollRogueBuffCsReq {}

export interface RollRogueBuffScRsp {
  retcode: number;
  buffSelectInfo: RogueBuffSelectInfo | undefined;
}

export interface EnterNextRogueRoomScNotify {
  maze: Maze | undefined;
  room: RogueRoom | undefined;
  appraisalInfo: RogueAppraisalInfo | undefined;
}

export interface SyncRogueFinishScNotify {
  finishInfo: RogueFinishInfo | undefined;
}

export interface PickRogueAvatarCsReq {
  baseAvatarId: number;
  propEntityId: number;
  baseAvatarIdList: number[];
}

export interface PickRogueAvatarScRsp {
  retcode: number;
  baseAvatarId: number;
  baseAvatarIdList: number[];
}

export interface AddRogueBuffScNotify {
  mazeBuffInfo: RogueBuff | undefined;
}

export interface ReviveRogueAvatarCsReq {
  baseAvatarId: number;
}

export interface ReviveRogueAvatarScRsp {
  retcode: number;
  baseAvatarId: number;
  rogueStamina: number;
  reviveCount: number;
}

export interface SaveRogueRecordCsReq {
  save: boolean;
  slot: number;
  name: string;
}

export interface SaveRogueRecordScRsp {
  retcode: number;
  record: RogueRecord | undefined;
}

export interface RecoverRogueStaminaCsReq {
  propEntityId: number;
}

export interface RecoverRogueStaminaScRsp {
  retcode: number;
  rogueStamina: number;
  rogueCoin: number;
  recoverStaminaCount: number;
}

export interface StartRogueChallengeCsReq {
  recordSlot: number;
}

export interface StartRogueChallengeScRsp {
  retcode: number;
  maze: Maze | undefined;
  rogueChallengeInfo: RogueChallengeInfo | undefined;
}

export interface LeaveRogueChallengeCsReq {}

export interface LeaveRogueChallengeScRsp {
  retcode: number;
  maze: Maze | undefined;
  rogueChallengeInfo: RogueChallengeInfo | undefined;
}

export interface SyncRogueChallengeFinishScNotify {
  finishInfo: RogueChallengeFinishInfo | undefined;
}

export interface QuitRogueCsReq {}

export interface QuitRogueScRsp {
  retcode: number;
  finishInfo: RogueFinishInfo | undefined;
}

export interface AppraisalRogueStoneCsReq {
  stoneItemId: number;
}

export interface AppraisalRogueStoneScRsp {
  retcode: number;
  result: RogueStoneAppraisalResult;
  reward: ItemList | undefined;
  mazeBuffInfo: RogueBuff | undefined;
  appraisalRecord: RogueAppraisalRecord | undefined;
  itemInfo: RogueAppraisalItemInfo | undefined;
}

export interface SyncRogueSeasonFinishScNotify {
  finishInfo: RogueFinishInfo | undefined;
}

export interface SyncRogueInfoChangeScNotify {
  recoverStaminaCount: number;
  rogueExploreLv: number;
}

export interface AddRogueExtraBuffScNotify {
  extraBuffInfo: RogueBuff | undefined;
}

export interface EnterRogueMapRoomCsReq {
  roomId: number;
}

export interface EnterRogueMapRoomScRsp {
  retcode: number;
  maze: Maze | undefined;
  curRoomId: number;
}

export interface EnterRogueNextLevelCsReq {}

export interface EnterRogueNextLevelScRsp {
  retcode: number;
  maze: Maze | undefined;
  levelInfo: RogueLevel | undefined;
  appraisalInfo: RogueAppraisalInfo | undefined;
}

export interface SyncRogueMapRoomScNotify {
  levelId: number;
  mapId: number;
  roomInfo: RogueRoom | undefined;
}

export interface SyncRoguePickAvatarScNotify {}

export interface SetRogueBlessCsReq {
  blessId: number;
}

export interface SetRogueBlessScRsp {
  retcode: number;
  blessId: number;
}

export interface SyncRogueBlessScNotify {
  blessInfo: RogueBlessInfo | undefined;
  levelUpMax: boolean;
}

export interface GetRogueShopInfoCsReq {}

export interface GetRogueShopInfoScRsp {
  retcode: number;
  rogueShopInfo: RogueShopInfo | undefined;
}

export interface BuyRogueShopBuffCsReq {
  buffId: number;
  buyCount: number;
}

export interface BuyRogueShopBuffScRsp {
  retcode: number;
  buyRogueBuff: RogueBuff | undefined;
  buyCount: number;
  rogueShopBuff: RogueShopBuff | undefined;
}

export interface BuyRogueShopItemCsReq {
  itemId: number;
  buyCount: number;
}

export interface BuyRogueShopItemScRsp {
  retcode: number;
  itemId: number;
  buyCount: number;
  rogueShopItem: RogueShopItem | undefined;
  rogueShopInfo: RogueShopInfo | undefined;
}

export interface FinishRogueDialogueGroupCsReq {
  dialogueGroupId: number;
}

export interface FinishRogueDialogueGroupScRsp {
  retcode: number;
}

export interface UnlockRogueRoomCsReq {
  roomId: number;
}

export interface UnlockRogueRoomScRsp {
  retcode: number;
}

export interface GetRogueGachaInfoCsReq {}

export interface GetRogueGachaInfoScRsp {
  retcode: number;
  rogueGachaInfo: RogueGachaInfo | undefined;
}

export interface SetRogueGachaWishListCsReq {
  wishListId: number;
}

export interface SetRogueGachaWishListScRsp {
  retcode: number;
  rogueGachaInfo: RogueGachaInfo | undefined;
}

export interface DoRogueGachaCsReq {
  count: number;
}

export interface DoRogueGachaScRsp {
  retcode: number;
  itemList: ItemList | undefined;
  rogueGachaInfo: RogueGachaInfo | undefined;
}

export interface SyncRogueGachaRefreshScNotify {
  rogueGachaInfo: RogueGachaInfo | undefined;
}

export interface GetRogueAppraisalItemInfoCsReq {}

export interface GetRogueAppraisalItemInfoScRsp {
  retcode: number;
  itemInfo: RogueAppraisalItemInfo | undefined;
}

export interface SyncRogueMiracleGetItemScNotify {
  itemData: ItemList | undefined;
}

export interface SyncRogueQuestScNotify {
  rogueQuest: RogueQuest | undefined;
}

export interface GetRogueQuestRewardCsReq {
  rogueQuestId: number;
  type: RogueQuestType;
}

export interface GetRogueQuestRewardScRsp {
  retcode: number;
  reward: ItemList | undefined;
  rogueQuest: RogueQuest | undefined;
}

export interface Vector {
  x: number;
  y: number;
  z: number;
}

export interface MotionInfo {
  pos: Vector | undefined;
  rot: Vector | undefined;
}

export interface SceneActorInfo {
  uid: number;
  avatarType: AvatarType;
  baseAvatarId: number;
  mapLayer: number;
}

export interface SceneNpcMonsterInfo {
  monsterId: number;
  isGenMonster: boolean;
  eventId: number;
  isSetWorldLevel: boolean;
  worldLevel: number;
}

export interface NpcRogueInfo {
  dialogueGroupId: number;
  rogueNpcId: number;
}

export interface NpcExtraInfo {
  rogueInfo: NpcRogueInfo | undefined;
}

export interface SceneNpcInfo {
  npcId: number;
  extraInfo: NpcExtraInfo | undefined;
}

export interface PropRogueInfo {
  roomId: number;
  appraisalCount: number;
  appraisalMaxCount: number;
  pickAvatarMaxCount: number;
}

export interface PropExtraInfo {
  rogueInfo: PropRogueInfo | undefined;
}

export interface ScenePropInfo {
  propId: number;
  propState: number;
  createTimeMs: number;
  lifeTimeMs: number;
  extraInfo: PropExtraInfo | undefined;
}

export interface SceneEntityInfo {
  entityId: number;
  motion: MotionInfo | undefined;
  groupId: number;
  instId: number;
  actor: SceneActorInfo | undefined;
  npcMonster: SceneNpcMonsterInfo | undefined;
  npc: SceneNpcInfo | undefined;
  prop: ScenePropInfo | undefined;
}

export interface BuffInfo {
  buffId: number;
  level: number;
  addTimeMs: number;
  lifeTime: number;
  count: number;
  baseAvatarId: number;
  dynamicValues: { [key: string]: number };
}

export interface BuffInfo_DynamicValuesEntry {
  key: string;
  value: number;
}

export interface EntityBuffInfo {
  entityId: number;
  buffList: BuffInfo[];
}

export interface SceneInfo {
  planeId: number;
  floorId: number;
  entityList: SceneEntityInfo[];
  lightenSectionList: number[];
  leaderEntityId: number;
  entryId: number;
  envBuffList: BuffInfo[];
  entityBuffList: EntityBuffInfo[];
  gameModeType: number;
}

export interface EntityMotion {
  entityId: number;
  motion: MotionInfo | undefined;
  mapLayer: number;
}

export interface SceneEntityMoveCsReq {
  entityMotionList: EntityMotion[];
  entryId: number;
}

export interface SceneEntityMoveScRsp {
  retcode: number;
  downloadData: ClientDownloadData | undefined;
}

export interface SceneEntityMoveScNotify {
  entityId: number;
  motion: MotionInfo | undefined;
}

export interface InteractPropCsReq {
  propEntityId: number;
  interactId: number;
  motion: MotionInfo | undefined;
}

export interface InteractPropScRsp {
  retcode: number;
  propEntityId: number;
  propState: number;
}

export interface SceneCastSkillCsReq {
  castEntityId: number;
  skillIndex: number;
  abilityTargetEntityId: number;
  hitTargetEntityIdList: number[];
  assistMonsterEntityIdList: number[];
  targetMotion: MotionInfo | undefined;
}

export interface SceneCastSkillScRsp {
  retcode: number;
  battleInfo: SceneBattleInfo | undefined;
}

export interface SceneEnterStageCsReq {
  eventId: number;
}

export interface SceneEnterStageScRsp {
  retcode: number;
  battleInfo: SceneBattleInfo | undefined;
}

export interface GetCurSceneInfoCsReq {}

export interface GetCurSceneInfoScRsp {
  retcode: number;
  scene: SceneInfo | undefined;
}

export interface SceneEntityUpdateScNotify {
  entityList: SceneEntityInfo[];
}

export interface SceneEntityDisappearScNotify {
  entityIdList: number[];
}

export interface SpringTransferCsReq {
  planeId: number;
  floorId: number;
  propEntityId: number;
}

export interface SpringTransferScRsp {
  retcode: number;
}

export interface UpdateBuffScNotify {
  entityId: number;
  buff: BuffInfo | undefined;
}

export interface DelBuffScNotify {
  entityId: number;
  buffId: number;
}

export interface SpringRefreshCsReq {
  planeId: number;
  floorId: number;
  propEntityId: number;
}

export interface SpringRefreshScRsp {
  retcode: number;
}

export interface LastSpringRefreshTimeNotify {
  lastTime: number;
}

export interface ReturnLastTownCsReq {}

export interface ReturnLastTownScRsp {
  retcode: number;
  scene: SceneInfo | undefined;
}

export interface EnterSectionCsReq {
  sectionId: number;
}

export interface EnterSectionScRsp {
  retcode: number;
}

export interface SetCurInteractEntityCsReq {
  entityId: number;
}

export interface SetCurInteractEntityScRsp {
  retcode: number;
}

export interface RecoverAllLineupCsReq {}

export interface RecoverAllLineupScRsp {
  retcode: number;
}

export interface SavePointsInfoNotify {
  validTimes: number;
  refreshTime: number;
}

export interface StartCocoonStageCsReq {
  propEntityId: number;
  cocoonId: number;
  wave: number;
  worldLevel: number;
}

export interface StartCocoonStageScRsp {
  retcode: number;
  battleInfo: SceneBattleInfo | undefined;
  propEntityId: number;
  cocoonId: number;
  wave: number;
}

export interface EntityBindPropCsReq {
  isBind: boolean;
  motion: MotionInfo | undefined;
}

export interface EntityBindPropScRsp {
  retcode: number;
}

export interface SetClientPausedCsReq {
  paused: boolean;
}

export interface SetClientPausedScRsp {
  retcode: number;
  paused: boolean;
}

export interface UpdateBuffGroupStartScNotify {}

export interface UpdateBuffGroupEndScNotify {}

export interface ActivateFarmElementCsReq {
  entityId: number;
  worldLevel: number;
}

export interface ActivateFarmElementScRsp {
  retcode: number;
  entityId: number;
  worldLevel: number;
}

export interface AvatarPresetHp {
  avatarId: number;
  presetHp: number;
}

export interface SpringRecoverConfig {
  avatarPresetHpList: AvatarPresetHp[];
  autoRecoverHp: boolean;
  defaultHp: number;
}

export interface HealPoolInfo {
  healPool: number;
  refreshTime: number;
}

export interface GetSpringRecoverDataCsReq {}

export interface GetSpringRecoverDataScRsp {
  retcode: number;
  springRecoverConfig: SpringRecoverConfig | undefined;
  healPoolInfo: HealPoolInfo | undefined;
}

export interface SetSpringRecoverConfigCsReq {
  springRecoverConfig: SpringRecoverConfig | undefined;
}

export interface SetSpringRecoverConfigScRsp {
  retcode: number;
  springRecoverConfig: SpringRecoverConfig | undefined;
}

export interface SpringRecoverCsReq {
  planeId: number;
  floorId: number;
  propEntityId: number;
}

export interface SpringRecoverScRsp {
  retcode: number;
  healPoolInfo: HealPoolInfo | undefined;
}

export interface HealPoolInfoNotify {
  healPoolInfo: HealPoolInfo | undefined;
}

export interface SpringRecoverSingleAvatarCsReq {
  planeId: number;
  floorId: number;
  propEntityId: number;
  avatarType: AvatarType;
  id: number;
  recoverFull: boolean;
}

export interface SpringRecoverSingleAvatarScRsp {
  retcode: number;
  avatarType: AvatarType;
  id: number;
  hp: number;
}

export interface Shop {
  shopId: number;
  beginTime: number;
  endTime: number;
  goodsList: Goods[];
}

export interface Goods {
  goodsId: number;
  buyTimes: number;
  beginTime: number;
  endTime: number;
}

export interface GetShopListCsReq {
  shopType: number;
}

export interface GetShopListScRsp {
  retcode: number;
  shopList: Shop[];
  shopType: number;
}

export interface BuyGoodsCsReq {
  shopId: number;
  goodsId: number;
  goodsNum: number;
}

export interface BuyGoodsScRsp {
  retcode: number;
  shopId: number;
  goodsId: number;
  goodsBuyTimes: number;
  returnItemList: ItemList | undefined;
}

export interface Stage {
  id: number;
  winTimes: number;
  challengeValue: number;
}

export interface GetStageDataCsReq {
  stageIdList: number[];
}

export interface GetStageDataScRsp {
  retcode: number;
  stageList: Stage[];
  isAll: boolean;
}

export interface StageBeginCsReq {
  stageId: number;
  lineupIndex: number;
}

export interface StageBeginScRsp {
  retcode: number;
  logicRandomSeed: number;
  stageId: number;
  battleAvatarList: BattleAvatar[];
}

export interface BasicModuleSync {
  stamina: number;
  weekCocoonFinishedCount: number;
}

export interface RogueModuleSync {
  rogueCoin: number;
  rogueStamina: number;
  rogueExploreExp: number;
}

export interface AvatarSync {
  avatarList: Avatar[];
}

export interface MissionSync {
  missionList: Mission[];
  finishedMainMissionIdList: number[];
  delMissionIdList: number[];
  delMainMissionIdList: number[];
}

export interface MissionEventSync {
  missionEventList: Mission[];
  finishedMissionEventIdList: number[];
  delMissionEventIdList: number[];
}

export interface PlayerSyncScNotify {
  basicInfo: PlayerBasicInfo | undefined;
  avatarSync: AvatarSync | undefined;
  equipmentList: Equipment[];
  delEquipmentList: number[];
  materialList: Material[];
  questList: Quest[];
  missionSync: MissionSync | undefined;
  basicModuleSync: BasicModuleSync | undefined;
  relicList: Relic[];
  delRelicList: number[];
  missionEventSync: MissionEventSync | undefined;
  basicTypeInfoList: HeroBasicTypeInfo[];
  rogueItemList: Material[];
  rogueModuleSync: RogueModuleSync | undefined;
  waitDelResourceList: WaitDelResource[];
  totalAchievementExp: number;
  newItemHintList: number[];
  groupStatusList: GroupStatus[];
  sectionStatusList: SectionStatus[];
}

export interface GetNpcTakenRewardCsReq {
  npcId: number;
}

export interface GetNpcTakenRewardScRsp {
  retcode: number;
  npcId: number;
  talkEventList: number[];
}

export interface TakeTalkRewardCsReq {
  talkEventId: number;
  npcLocation: Vector | undefined;
}

export interface TakeTalkRewardScRsp {
  retcode: number;
  talkEventId: number;
  reward: ItemList | undefined;
}

export interface GetFirstTalkNpcCsReq {
  seriesIdList: number[];
}

export interface NpcMeetStatus {
  seriesId: number;
  isMeet: boolean;
}

export interface GetFirstTalkNpcScRsp {
  retcode: number;
  npcMeetStatusList: NpcMeetStatus[];
}

export interface FinishFirstTalkNpcCsReq {
  seriesId: number;
}

export interface FinishFirstTalkNpcScRsp {
  retcode: number;
  seriesId: number;
}

export interface Tutorial {
  id: number;
  status: TutorialStatus;
}

export interface TutorialGuide {
  id: number;
  status: TutorialStatus;
}

export interface GetTutorialCsReq {}

export interface GetTutorialScRsp {
  retcode: number;
  tutorialList: Tutorial[];
}

export interface GetTutorialGuideCsReq {}

export interface GetTutorialGuideScRsp {
  retcode: number;
  tutorialGuideList: TutorialGuide[];
}

export interface UnlockTutorialCsReq {
  tutorialId: number;
}

export interface UnlockTutorialScRsp {
  retcode: number;
  tutorial: Tutorial | undefined;
}

export interface UnlockTutorialGuideCsReq {
  groupId: number;
}

export interface UnlockTutorialGuideScRsp {
  retcode: number;
  tutorialGuide: TutorialGuide | undefined;
}

export interface FinishTutorialCsReq {
  tutorialId: number;
}

export interface FinishTutorialScRsp {
  retcode: number;
  tutorial: Tutorial | undefined;
}

export interface FinishTutorialGuideCsReq {
  groupId: number;
}

export interface FinishTutorialGuideScRsp {
  retcode: number;
  tutorialGuide: TutorialGuide | undefined;
  reward: ItemList | undefined;
}

export interface Waypoint {
  id: number;
  finishTimes: number;
  isNew: boolean;
}

export interface ChapterBrief {
  id: number;
  finishChallengeNum: number;
  takenRewardIdList: number[];
  isNew: boolean;
}

export interface Chapter {
  briefInfo: ChapterBrief | undefined;
  waypointList: Waypoint[];
}

export interface GetWaypointCsReq {
  chapterId: number;
}

export interface GetWaypointScRsp {
  retcode: number;
  chapter: Chapter | undefined;
  curWaypointId: number;
}

export interface SetCurWaypointCsReq {
  waypointId: number;
}

export interface SetCurWaypointScRsp {
  retcode: number;
  curWaypointId: number;
}

export interface GetChapterCsReq {}

export interface GetChapterScRsp {
  retcode: number;
  chapterList: ChapterBrief[];
  curWaypointId: number;
}

export interface WaypointShowNewCsNotify {
  waypointId: number;
  chapterId: number;
}

export interface TakeChapterRewardCsReq {
  chapterId: number;
  chapterRewardId: number;
}

export interface TakeChapterRewardScRsp {
  retcode: number;
  chapterId: number;
  chapterRewardId: number;
}

export interface PacketHead {
  packetId: number;
  signType: number;
  sign: number;
  userId: number;
  srcAddr: number;
  dstAddr: number;
  dispatchType: number;
  serverType: number;
  dispatchKey: number;
  userSessionId: number;
  id: number;
  coroutineId: number;
  hopCnt: number;
}

function createBasePlayerBasicInfo(): PlayerBasicInfo {
  return {
    nickname: "",
    level: 0,
    exp: 0,
    stamina: 0,
    mcoin: 0,
    hcoin: 0,
    scoin: 0,
    worldLevel: 0,
  };
}

export const PlayerBasicInfo = {
  encode(
    message: PlayerBasicInfo,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.nickname !== "") {
      writer.uint32(10).string(message.nickname);
    }
    if (message.level !== 0) {
      writer.uint32(16).uint32(message.level);
    }
    if (message.exp !== 0) {
      writer.uint32(24).uint32(message.exp);
    }
    if (message.stamina !== 0) {
      writer.uint32(32).uint32(message.stamina);
    }
    if (message.mcoin !== 0) {
      writer.uint32(40).uint32(message.mcoin);
    }
    if (message.hcoin !== 0) {
      writer.uint32(48).uint32(message.hcoin);
    }
    if (message.scoin !== 0) {
      writer.uint32(56).uint32(message.scoin);
    }
    if (message.worldLevel !== 0) {
      writer.uint32(64).uint32(message.worldLevel);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): PlayerBasicInfo {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePlayerBasicInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.nickname = reader.string();
          break;
        case 2:
          message.level = reader.uint32();
          break;
        case 3:
          message.exp = reader.uint32();
          break;
        case 4:
          message.stamina = reader.uint32();
          break;
        case 5:
          message.mcoin = reader.uint32();
          break;
        case 6:
          message.hcoin = reader.uint32();
          break;
        case 7:
          message.scoin = reader.uint32();
          break;
        case 8:
          message.worldLevel = reader.uint32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): PlayerBasicInfo {
    return {
      nickname: isSet(object.nickname) ? String(object.nickname) : "",
      level: isSet(object.level) ? Number(object.level) : 0,
      exp: isSet(object.exp) ? Number(object.exp) : 0,
      stamina: isSet(object.stamina) ? Number(object.stamina) : 0,
      mcoin: isSet(object.mcoin) ? Number(object.mcoin) : 0,
      hcoin: isSet(object.hcoin) ? Number(object.hcoin) : 0,
      scoin: isSet(object.scoin) ? Number(object.scoin) : 0,
      worldLevel: isSet(object.worldLevel) ? Number(object.worldLevel) : 0,
    };
  },

  toJSON(message: PlayerBasicInfo): unknown {
    const obj: any = {};
    message.nickname !== undefined && (obj.nickname = message.nickname);
    message.level !== undefined && (obj.level = Math.round(message.level));
    message.exp !== undefined && (obj.exp = Math.round(message.exp));
    message.stamina !== undefined &&
      (obj.stamina = Math.round(message.stamina));
    message.mcoin !== undefined && (obj.mcoin = Math.round(message.mcoin));
    message.hcoin !== undefined && (obj.hcoin = Math.round(message.hcoin));
    message.scoin !== undefined && (obj.scoin = Math.round(message.scoin));
    message.worldLevel !== undefined &&
      (obj.worldLevel = Math.round(message.worldLevel));
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<PlayerBasicInfo>, I>>(
    object: I
  ): PlayerBasicInfo {
    const message = createBasePlayerBasicInfo();
    message.nickname = object.nickname ?? "";
    message.level = object.level ?? 0;
    message.exp = object.exp ?? 0;
    message.stamina = object.stamina ?? 0;
    message.mcoin = object.mcoin ?? 0;
    message.hcoin = object.hcoin ?? 0;
    message.scoin = object.scoin ?? 0;
    message.worldLevel = object.worldLevel ?? 0;
    return message;
  },
};

function createBaseBlackInfo(): BlackInfo {
  return { beginTime: 0, endTime: 0, limitLevel: 0, banType: 0 };
}

export const BlackInfo = {
  encode(
    message: BlackInfo,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.beginTime !== 0) {
      writer.uint32(8).uint32(message.beginTime);
    }
    if (message.endTime !== 0) {
      writer.uint32(16).uint32(message.endTime);
    }
    if (message.limitLevel !== 0) {
      writer.uint32(24).uint32(message.limitLevel);
    }
    if (message.banType !== 0) {
      writer.uint32(32).uint32(message.banType);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): BlackInfo {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBlackInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.beginTime = reader.uint32();
          break;
        case 2:
          message.endTime = reader.uint32();
          break;
        case 3:
          message.limitLevel = reader.uint32();
          break;
        case 4:
          message.banType = reader.uint32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): BlackInfo {
    return {
      beginTime: isSet(object.beginTime) ? Number(object.beginTime) : 0,
      endTime: isSet(object.endTime) ? Number(object.endTime) : 0,
      limitLevel: isSet(object.limitLevel) ? Number(object.limitLevel) : 0,
      banType: isSet(object.banType) ? Number(object.banType) : 0,
    };
  },

  toJSON(message: BlackInfo): unknown {
    const obj: any = {};
    message.beginTime !== undefined &&
      (obj.beginTime = Math.round(message.beginTime));
    message.endTime !== undefined &&
      (obj.endTime = Math.round(message.endTime));
    message.limitLevel !== undefined &&
      (obj.limitLevel = Math.round(message.limitLevel));
    message.banType !== undefined &&
      (obj.banType = Math.round(message.banType));
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<BlackInfo>, I>>(
    object: I
  ): BlackInfo {
    const message = createBaseBlackInfo();
    message.beginTime = object.beginTime ?? 0;
    message.endTime = object.endTime ?? 0;
    message.limitLevel = object.limitLevel ?? 0;
    message.banType = object.banType ?? 0;
    return message;
  },
};

function createBaseVersionCount(): VersionCount {
  return { version: 0, count: 0 };
}

export const VersionCount = {
  encode(
    message: VersionCount,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.version !== 0) {
      writer.uint32(8).uint32(message.version);
    }
    if (message.count !== 0) {
      writer.uint32(16).uint32(message.count);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): VersionCount {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVersionCount();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.version = reader.uint32();
          break;
        case 2:
          message.count = reader.uint32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): VersionCount {
    return {
      version: isSet(object.version) ? Number(object.version) : 0,
      count: isSet(object.count) ? Number(object.count) : 0,
    };
  },

  toJSON(message: VersionCount): unknown {
    const obj: any = {};
    message.version !== undefined &&
      (obj.version = Math.round(message.version));
    message.count !== undefined && (obj.count = Math.round(message.count));
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<VersionCount>, I>>(
    object: I
  ): VersionCount {
    const message = createBaseVersionCount();
    message.version = object.version ?? 0;
    message.count = object.count ?? 0;
    return message;
  },
};

function createBaseClientDownloadData(): ClientDownloadData {
  return { version: 0, time: 0, data: new Uint8Array() };
}

export const ClientDownloadData = {
  encode(
    message: ClientDownloadData,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.version !== 0) {
      writer.uint32(8).uint32(message.version);
    }
    if (message.time !== 0) {
      writer.uint32(16).uint32(message.time);
    }
    if (message.data.length !== 0) {
      writer.uint32(26).bytes(message.data);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ClientDownloadData {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseClientDownloadData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.version = reader.uint32();
          break;
        case 2:
          message.time = reader.uint32();
          break;
        case 3:
          message.data = reader.bytes();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): ClientDownloadData {
    return {
      version: isSet(object.version) ? Number(object.version) : 0,
      time: isSet(object.time) ? Number(object.time) : 0,
      data: isSet(object.data)
        ? bytesFromBase64(object.data)
        : new Uint8Array(),
    };
  },

  toJSON(message: ClientDownloadData): unknown {
    const obj: any = {};
    message.version !== undefined &&
      (obj.version = Math.round(message.version));
    message.time !== undefined && (obj.time = Math.round(message.time));
    message.data !== undefined &&
      (obj.data = base64FromBytes(
        message.data !== undefined ? message.data : new Uint8Array()
      ));
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<ClientDownloadData>, I>>(
    object: I
  ): ClientDownloadData {
    const message = createBaseClientDownloadData();
    message.version = object.version ?? 0;
    message.time = object.time ?? 0;
    message.data = object.data ?? new Uint8Array();
    return message;
  },
};

function createBaseClientUploadData(): ClientUploadData {
  return { tag: "", value: "" };
}

export const ClientUploadData = {
  encode(
    message: ClientUploadData,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.tag !== "") {
      writer.uint32(10).string(message.tag);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ClientUploadData {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseClientUploadData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.tag = reader.string();
          break;
        case 2:
          message.value = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): ClientUploadData {
    return {
      tag: isSet(object.tag) ? String(object.tag) : "",
      value: isSet(object.value) ? String(object.value) : "",
    };
  },

  toJSON(message: ClientUploadData): unknown {
    const obj: any = {};
    message.tag !== undefined && (obj.tag = message.tag);
    message.value !== undefined && (obj.value = message.value);
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<ClientUploadData>, I>>(
    object: I
  ): ClientUploadData {
    const message = createBaseClientUploadData();
    message.tag = object.tag ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseFeatureSwitchParam(): FeatureSwitchParam {
  return { paramList: [] };
}

export const FeatureSwitchParam = {
  encode(
    message: FeatureSwitchParam,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    writer.uint32(10).fork();
    for (const v of message.paramList) {
      writer.uint32(v);
    }
    writer.ldelim();
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): FeatureSwitchParam {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFeatureSwitchParam();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if ((tag & 7) === 2) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.paramList.push(reader.uint32());
            }
          } else {
            message.paramList.push(reader.uint32());
          }
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): FeatureSwitchParam {
    return {
      paramList: Array.isArray(object?.paramList)
        ? object.paramList.map((e: any) => Number(e))
        : [],
    };
  },

  toJSON(message: FeatureSwitchParam): unknown {
    const obj: any = {};
    if (message.paramList) {
      obj.paramList = message.paramList.map((e) => Math.round(e));
    } else {
      obj.paramList = [];
    }
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<FeatureSwitchParam>, I>>(
    object: I
  ): FeatureSwitchParam {
    const message = createBaseFeatureSwitchParam();
    message.paramList = object.paramList?.map((e) => e) || [];
    return message;
  },
};

function createBaseFeatureSwitchInfo(): FeatureSwitchInfo {
  return { type: 0, switchList: [], isAllClosed: false };
}

export const FeatureSwitchInfo = {
  encode(
    message: FeatureSwitchInfo,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.type !== 0) {
      writer.uint32(8).int32(message.type);
    }
    for (const v of message.switchList) {
      FeatureSwitchParam.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    if (message.isAllClosed === true) {
      writer.uint32(24).bool(message.isAllClosed);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): FeatureSwitchInfo {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFeatureSwitchInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.type = reader.int32() as any;
          break;
        case 2:
          message.switchList.push(
            FeatureSwitchParam.decode(reader, reader.uint32())
          );
          break;
        case 3:
          message.isAllClosed = reader.bool();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): FeatureSwitchInfo {
    return {
      type: isSet(object.type) ? featureSwitchTypeFromJSON(object.type) : 0,
      switchList: Array.isArray(object?.switchList)
        ? object.switchList.map((e: any) => FeatureSwitchParam.fromJSON(e))
        : [],
      isAllClosed: isSet(object.isAllClosed)
        ? Boolean(object.isAllClosed)
        : false,
    };
  },

  toJSON(message: FeatureSwitchInfo): unknown {
    const obj: any = {};
    message.type !== undefined &&
      (obj.type = featureSwitchTypeToJSON(message.type));
    if (message.switchList) {
      obj.switchList = message.switchList.map((e) =>
        e ? FeatureSwitchParam.toJSON(e) : undefined
      );
    } else {
      obj.switchList = [];
    }
    message.isAllClosed !== undefined &&
      (obj.isAllClosed = message.isAllClosed);
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<FeatureSwitchInfo>, I>>(
    object: I
  ): FeatureSwitchInfo {
    const message = createBaseFeatureSwitchInfo();
    message.type = object.type ?? 0;
    message.switchList =
      object.switchList?.map((e) => FeatureSwitchParam.fromPartial(e)) || [];
    message.isAllClosed = object.isAllClosed ?? false;
    return message;
  },
};

function createBaseBattleOp(): BattleOp {
  return {
    turnCounter: 0,
    state: 0,
    actionEntityId: 0,
    targetEntityId: 0,
    opType: 0,
    skillIndex: 0,
    operationCounter: 0,
  };
}

export const BattleOp = {
  encode(
    message: BattleOp,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.turnCounter !== 0) {
      writer.uint32(8).uint32(message.turnCounter);
    }
    if (message.state !== 0) {
      writer.uint32(16).uint32(message.state);
    }
    if (message.actionEntityId !== 0) {
      writer.uint32(24).uint32(message.actionEntityId);
    }
    if (message.targetEntityId !== 0) {
      writer.uint32(32).uint32(message.targetEntityId);
    }
    if (message.opType !== 0) {
      writer.uint32(40).uint32(message.opType);
    }
    if (message.skillIndex !== 0) {
      writer.uint32(48).uint32(message.skillIndex);
    }
    if (message.operationCounter !== 0) {
      writer.uint32(56).uint32(message.operationCounter);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): BattleOp {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBattleOp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.turnCounter = reader.uint32();
          break;
        case 2:
          message.state = reader.uint32();
          break;
        case 3:
          message.actionEntityId = reader.uint32();
          break;
        case 4:
          message.targetEntityId = reader.uint32();
          break;
        case 5:
          message.opType = reader.uint32();
          break;
        case 6:
          message.skillIndex = reader.uint32();
          break;
        case 7:
          message.operationCounter = reader.uint32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): BattleOp {
    return {
      turnCounter: isSet(object.turnCounter) ? Number(object.turnCounter) : 0,
      state: isSet(object.state) ? Number(object.state) : 0,
      actionEntityId: isSet(object.actionEntityId)
        ? Number(object.actionEntityId)
        : 0,
      targetEntityId: isSet(object.targetEntityId)
        ? Number(object.targetEntityId)
        : 0,
      opType: isSet(object.opType) ? Number(object.opType) : 0,
      skillIndex: isSet(object.skillIndex) ? Number(object.skillIndex) : 0,
      operationCounter: isSet(object.operationCounter)
        ? Number(object.operationCounter)
        : 0,
    };
  },

  toJSON(message: BattleOp): unknown {
    const obj: any = {};
    message.turnCounter !== undefined &&
      (obj.turnCounter = Math.round(message.turnCounter));
    message.state !== undefined && (obj.state = Math.round(message.state));
    message.actionEntityId !== undefined &&
      (obj.actionEntityId = Math.round(message.actionEntityId));
    message.targetEntityId !== undefined &&
      (obj.targetEntityId = Math.round(message.targetEntityId));
    message.opType !== undefined && (obj.opType = Math.round(message.opType));
    message.skillIndex !== undefined &&
      (obj.skillIndex = Math.round(message.skillIndex));
    message.operationCounter !== undefined &&
      (obj.operationCounter = Math.round(message.operationCounter));
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<BattleOp>, I>>(object: I): BattleOp {
    const message = createBaseBattleOp();
    message.turnCounter = object.turnCounter ?? 0;
    message.state = object.state ?? 0;
    message.actionEntityId = object.actionEntityId ?? 0;
    message.targetEntityId = object.targetEntityId ?? 0;
    message.opType = object.opType ?? 0;
    message.skillIndex = object.skillIndex ?? 0;
    message.operationCounter = object.operationCounter ?? 0;
    return message;
  },
};

function createBaseBattleEquipment(): BattleEquipment {
  return { id: 0, level: 0, promotion: 0, rank: 0 };
}

export const BattleEquipment = {
  encode(
    message: BattleEquipment,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.id !== 0) {
      writer.uint32(8).uint32(message.id);
    }
    if (message.level !== 0) {
      writer.uint32(16).uint32(message.level);
    }
    if (message.promotion !== 0) {
      writer.uint32(24).uint32(message.promotion);
    }
    if (message.rank !== 0) {
      writer.uint32(32).uint32(message.rank);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): BattleEquipment {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBattleEquipment();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.id = reader.uint32();
          break;
        case 2:
          message.level = reader.uint32();
          break;
        case 3:
          message.promotion = reader.uint32();
          break;
        case 4:
          message.rank = reader.uint32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): BattleEquipment {
    return {
      id: isSet(object.id) ? Number(object.id) : 0,
      level: isSet(object.level) ? Number(object.level) : 0,
      promotion: isSet(object.promotion) ? Number(object.promotion) : 0,
      rank: isSet(object.rank) ? Number(object.rank) : 0,
    };
  },

  toJSON(message: BattleEquipment): unknown {
    const obj: any = {};
    message.id !== undefined && (obj.id = Math.round(message.id));
    message.level !== undefined && (obj.level = Math.round(message.level));
    message.promotion !== undefined &&
      (obj.promotion = Math.round(message.promotion));
    message.rank !== undefined && (obj.rank = Math.round(message.rank));
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<BattleEquipment>, I>>(
    object: I
  ): BattleEquipment {
    const message = createBaseBattleEquipment();
    message.id = object.id ?? 0;
    message.level = object.level ?? 0;
    message.promotion = object.promotion ?? 0;
    message.rank = object.rank ?? 0;
    return message;
  },
};

function createBaseBattleRelic(): BattleRelic {
  return { id: 0, level: 0, mainAffixId: 0, subAffixList: [], uniqueId: 0 };
}

export const BattleRelic = {
  encode(
    message: BattleRelic,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.id !== 0) {
      writer.uint32(8).uint32(message.id);
    }
    if (message.level !== 0) {
      writer.uint32(16).uint32(message.level);
    }
    if (message.mainAffixId !== 0) {
      writer.uint32(24).uint32(message.mainAffixId);
    }
    for (const v of message.subAffixList) {
      RelicAffix.encode(v!, writer.uint32(34).fork()).ldelim();
    }
    if (message.uniqueId !== 0) {
      writer.uint32(40).uint32(message.uniqueId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): BattleRelic {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBattleRelic();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.id = reader.uint32();
          break;
        case 2:
          message.level = reader.uint32();
          break;
        case 3:
          message.mainAffixId = reader.uint32();
          break;
        case 4:
          message.subAffixList.push(RelicAffix.decode(reader, reader.uint32()));
          break;
        case 5:
          message.uniqueId = reader.uint32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): BattleRelic {
    return {
      id: isSet(object.id) ? Number(object.id) : 0,
      level: isSet(object.level) ? Number(object.level) : 0,
      mainAffixId: isSet(object.mainAffixId) ? Number(object.mainAffixId) : 0,
      subAffixList: Array.isArray(object?.subAffixList)
        ? object.subAffixList.map((e: any) => RelicAffix.fromJSON(e))
        : [],
      uniqueId: isSet(object.uniqueId) ? Number(object.uniqueId) : 0,
    };
  },

  toJSON(message: BattleRelic): unknown {
    const obj: any = {};
    message.id !== undefined && (obj.id = Math.round(message.id));
    message.level !== undefined && (obj.level = Math.round(message.level));
    message.mainAffixId !== undefined &&
      (obj.mainAffixId = Math.round(message.mainAffixId));
    if (message.subAffixList) {
      obj.subAffixList = message.subAffixList.map((e) =>
        e ? RelicAffix.toJSON(e) : undefined
      );
    } else {
      obj.subAffixList = [];
    }
    message.uniqueId !== undefined &&
      (obj.uniqueId = Math.round(message.uniqueId));
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<BattleRelic>, I>>(
    object: I
  ): BattleRelic {
    const message = createBaseBattleRelic();
    message.id = object.id ?? 0;
    message.level = object.level ?? 0;
    message.mainAffixId = object.mainAffixId ?? 0;
    message.subAffixList =
      object.subAffixList?.map((e) => RelicAffix.fromPartial(e)) || [];
    message.uniqueId = object.uniqueId ?? 0;
    return message;
  },
};

function createBaseAvatarSkillTree(): AvatarSkillTree {
  return { pointId: 0, level: 0 };
}

export const AvatarSkillTree = {
  encode(
    message: AvatarSkillTree,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.pointId !== 0) {
      writer.uint32(8).uint32(message.pointId);
    }
    if (message.level !== 0) {
      writer.uint32(16).uint32(message.level);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): AvatarSkillTree {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAvatarSkillTree();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.pointId = reader.uint32();
          break;
        case 2:
          message.level = reader.uint32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): AvatarSkillTree {
    return {
      pointId: isSet(object.pointId) ? Number(object.pointId) : 0,
      level: isSet(object.level) ? Number(object.level) : 0,
    };
  },

  toJSON(message: AvatarSkillTree): unknown {
    const obj: any = {};
    message.pointId !== undefined &&
      (obj.pointId = Math.round(message.pointId));
    message.level !== undefined && (obj.level = Math.round(message.level));
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<AvatarSkillTree>, I>>(
    object: I
  ): AvatarSkillTree {
    const message = createBaseAvatarSkillTree();
    message.pointId = object.pointId ?? 0;
    message.level = object.level ?? 0;
    return message;
  },
};

function createBaseRelicAffix(): RelicAffix {
  return { affixId: 0, cnt: 0, step: 0 };
}

export const RelicAffix = {
  encode(
    message: RelicAffix,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.affixId !== 0) {
      writer.uint32(8).uint32(message.affixId);
    }
    if (message.cnt !== 0) {
      writer.uint32(16).uint32(message.cnt);
    }
    if (message.step !== 0) {
      writer.uint32(24).uint32(message.step);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): RelicAffix {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRelicAffix();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.affixId = reader.uint32();
          break;
        case 2:
          message.cnt = reader.uint32();
          break;
        case 3:
          message.step = reader.uint32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): RelicAffix {
    return {
      affixId: isSet(object.affixId) ? Number(object.affixId) : 0,
      cnt: isSet(object.cnt) ? Number(object.cnt) : 0,
      step: isSet(object.step) ? Number(object.step) : 0,
    };
  },

  toJSON(message: RelicAffix): unknown {
    const obj: any = {};
    message.affixId !== undefined &&
      (obj.affixId = Math.round(message.affixId));
    message.cnt !== undefined && (obj.cnt = Math.round(message.cnt));
    message.step !== undefined && (obj.step = Math.round(message.step));
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<RelicAffix>, I>>(
    object: I
  ): RelicAffix {
    const message = createBaseRelicAffix();
    message.affixId = object.affixId ?? 0;
    message.cnt = object.cnt ?? 0;
    message.step = object.step ?? 0;
    return message;
  },
};

function createBaseBattleAvatar(): BattleAvatar {
  return {
    avatarType: 0,
    id: 0,
    level: 0,
    rank: 0,
    index: 0,
    skilltreeList: [],
    equipmentList: [],
    hp: 0,
    sp: 0,
    promotion: 0,
    relicList: [],
  };
}

export const BattleAvatar = {
  encode(
    message: BattleAvatar,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.avatarType !== 0) {
      writer.uint32(8).int32(message.avatarType);
    }
    if (message.id !== 0) {
      writer.uint32(16).uint32(message.id);
    }
    if (message.level !== 0) {
      writer.uint32(24).uint32(message.level);
    }
    if (message.rank !== 0) {
      writer.uint32(32).uint32(message.rank);
    }
    if (message.index !== 0) {
      writer.uint32(40).uint32(message.index);
    }
    for (const v of message.skilltreeList) {
      AvatarSkillTree.encode(v!, writer.uint32(50).fork()).ldelim();
    }
    for (const v of message.equipmentList) {
      BattleEquipment.encode(v!, writer.uint32(58).fork()).ldelim();
    }
    if (message.hp !== 0) {
      writer.uint32(64).uint32(message.hp);
    }
    if (message.sp !== 0) {
      writer.uint32(72).uint32(message.sp);
    }
    if (message.promotion !== 0) {
      writer.uint32(80).uint32(message.promotion);
    }
    for (const v of message.relicList) {
      BattleRelic.encode(v!, writer.uint32(90).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): BattleAvatar {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBattleAvatar();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.avatarType = reader.int32() as any;
          break;
        case 2:
          message.id = reader.uint32();
          break;
        case 3:
          message.level = reader.uint32();
          break;
        case 4:
          message.rank = reader.uint32();
          break;
        case 5:
          message.index = reader.uint32();
          break;
        case 6:
          message.skilltreeList.push(
            AvatarSkillTree.decode(reader, reader.uint32())
          );
          break;
        case 7:
          message.equipmentList.push(
            BattleEquipment.decode(reader, reader.uint32())
          );
          break;
        case 8:
          message.hp = reader.uint32();
          break;
        case 9:
          message.sp = reader.uint32();
          break;
        case 10:
          message.promotion = reader.uint32();
          break;
        case 11:
          message.relicList.push(BattleRelic.decode(reader, reader.uint32()));
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): BattleAvatar {
    return {
      avatarType: isSet(object.avatarType)
        ? avatarTypeFromJSON(object.avatarType)
        : 0,
      id: isSet(object.id) ? Number(object.id) : 0,
      level: isSet(object.level) ? Number(object.level) : 0,
      rank: isSet(object.rank) ? Number(object.rank) : 0,
      index: isSet(object.index) ? Number(object.index) : 0,
      skilltreeList: Array.isArray(object?.skilltreeList)
        ? object.skilltreeList.map((e: any) => AvatarSkillTree.fromJSON(e))
        : [],
      equipmentList: Array.isArray(object?.equipmentList)
        ? object.equipmentList.map((e: any) => BattleEquipment.fromJSON(e))
        : [],
      hp: isSet(object.hp) ? Number(object.hp) : 0,
      sp: isSet(object.sp) ? Number(object.sp) : 0,
      promotion: isSet(object.promotion) ? Number(object.promotion) : 0,
      relicList: Array.isArray(object?.relicList)
        ? object.relicList.map((e: any) => BattleRelic.fromJSON(e))
        : [],
    };
  },

  toJSON(message: BattleAvatar): unknown {
    const obj: any = {};
    message.avatarType !== undefined &&
      (obj.avatarType = avatarTypeToJSON(message.avatarType));
    message.id !== undefined && (obj.id = Math.round(message.id));
    message.level !== undefined && (obj.level = Math.round(message.level));
    message.rank !== undefined && (obj.rank = Math.round(message.rank));
    message.index !== undefined && (obj.index = Math.round(message.index));
    if (message.skilltreeList) {
      obj.skilltreeList = message.skilltreeList.map((e) =>
        e ? AvatarSkillTree.toJSON(e) : undefined
      );
    } else {
      obj.skilltreeList = [];
    }
    if (message.equipmentList) {
      obj.equipmentList = message.equipmentList.map((e) =>
        e ? BattleEquipment.toJSON(e) : undefined
      );
    } else {
      obj.equipmentList = [];
    }
    message.hp !== undefined && (obj.hp = Math.round(message.hp));
    message.sp !== undefined && (obj.sp = Math.round(message.sp));
    message.promotion !== undefined &&
      (obj.promotion = Math.round(message.promotion));
    if (message.relicList) {
      obj.relicList = message.relicList.map((e) =>
        e ? BattleRelic.toJSON(e) : undefined
      );
    } else {
      obj.relicList = [];
    }
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<BattleAvatar>, I>>(
    object: I
  ): BattleAvatar {
    const message = createBaseBattleAvatar();
    message.avatarType = object.avatarType ?? 0;
    message.id = object.id ?? 0;
    message.level = object.level ?? 0;
    message.rank = object.rank ?? 0;
    message.index = object.index ?? 0;
    message.skilltreeList =
      object.skilltreeList?.map((e) => AvatarSkillTree.fromPartial(e)) || [];
    message.equipmentList =
      object.equipmentList?.map((e) => BattleEquipment.fromPartial(e)) || [];
    message.hp = object.hp ?? 0;
    message.sp = object.sp ?? 0;
    message.promotion = object.promotion ?? 0;
    message.relicList =
      object.relicList?.map((e) => BattleRelic.fromPartial(e)) || [];
    return message;
  },
};

function createBaseBattleMonsterWave(): BattleMonsterWave {
  return { monsterIdList: [] };
}

export const BattleMonsterWave = {
  encode(
    message: BattleMonsterWave,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    writer.uint32(10).fork();
    for (const v of message.monsterIdList) {
      writer.uint32(v);
    }
    writer.ldelim();
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): BattleMonsterWave {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBattleMonsterWave();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if ((tag & 7) === 2) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.monsterIdList.push(reader.uint32());
            }
          } else {
            message.monsterIdList.push(reader.uint32());
          }
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): BattleMonsterWave {
    return {
      monsterIdList: Array.isArray(object?.monsterIdList)
        ? object.monsterIdList.map((e: any) => Number(e))
        : [],
    };
  },

  toJSON(message: BattleMonsterWave): unknown {
    const obj: any = {};
    if (message.monsterIdList) {
      obj.monsterIdList = message.monsterIdList.map((e) => Math.round(e));
    } else {
      obj.monsterIdList = [];
    }
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<BattleMonsterWave>, I>>(
    object: I
  ): BattleMonsterWave {
    const message = createBaseBattleMonsterWave();
    message.monsterIdList = object.monsterIdList?.map((e) => e) || [];
    return message;
  },
};

function createBaseBattleBuff(): BattleBuff {
  return {
    id: 0,
    level: 0,
    ownerIndex: 0,
    waveFlag: 0,
    targetIndexList: [],
    dynamicValues: {},
  };
}

export const BattleBuff = {
  encode(
    message: BattleBuff,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.id !== 0) {
      writer.uint32(8).uint32(message.id);
    }
    if (message.level !== 0) {
      writer.uint32(16).uint32(message.level);
    }
    if (message.ownerIndex !== 0) {
      writer.uint32(24).uint32(message.ownerIndex);
    }
    if (message.waveFlag !== 0) {
      writer.uint32(32).uint32(message.waveFlag);
    }
    writer.uint32(42).fork();
    for (const v of message.targetIndexList) {
      writer.uint32(v);
    }
    writer.ldelim();
    Object.entries(message.dynamicValues).forEach(([key, value]) => {
      BattleBuff_DynamicValuesEntry.encode(
        { key: key as any, value },
        writer.uint32(50).fork()
      ).ldelim();
    });
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): BattleBuff {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBattleBuff();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.id = reader.uint32();
          break;
        case 2:
          message.level = reader.uint32();
          break;
        case 3:
          message.ownerIndex = reader.uint32();
          break;
        case 4:
          message.waveFlag = reader.uint32();
          break;
        case 5:
          if ((tag & 7) === 2) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.targetIndexList.push(reader.uint32());
            }
          } else {
            message.targetIndexList.push(reader.uint32());
          }
          break;
        case 6:
          const entry6 = BattleBuff_DynamicValuesEntry.decode(
            reader,
            reader.uint32()
          );
          if (entry6.value !== undefined) {
            message.dynamicValues[entry6.key] = entry6.value;
          }
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): BattleBuff {
    return {
      id: isSet(object.id) ? Number(object.id) : 0,
      level: isSet(object.level) ? Number(object.level) : 0,
      ownerIndex: isSet(object.ownerIndex) ? Number(object.ownerIndex) : 0,
      waveFlag: isSet(object.waveFlag) ? Number(object.waveFlag) : 0,
      targetIndexList: Array.isArray(object?.targetIndexList)
        ? object.targetIndexList.map((e: any) => Number(e))
        : [],
      dynamicValues: isObject(object.dynamicValues)
        ? Object.entries(object.dynamicValues).reduce<{
            [key: string]: number;
          }>((acc, [key, value]) => {
            acc[key] = Number(value);
            return acc;
          }, {})
        : {},
    };
  },

  toJSON(message: BattleBuff): unknown {
    const obj: any = {};
    message.id !== undefined && (obj.id = Math.round(message.id));
    message.level !== undefined && (obj.level = Math.round(message.level));
    message.ownerIndex !== undefined &&
      (obj.ownerIndex = Math.round(message.ownerIndex));
    message.waveFlag !== undefined &&
      (obj.waveFlag = Math.round(message.waveFlag));
    if (message.targetIndexList) {
      obj.targetIndexList = message.targetIndexList.map((e) => Math.round(e));
    } else {
      obj.targetIndexList = [];
    }
    obj.dynamicValues = {};
    if (message.dynamicValues) {
      Object.entries(message.dynamicValues).forEach(([k, v]) => {
        obj.dynamicValues[k] = v;
      });
    }
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<BattleBuff>, I>>(
    object: I
  ): BattleBuff {
    const message = createBaseBattleBuff();
    message.id = object.id ?? 0;
    message.level = object.level ?? 0;
    message.ownerIndex = object.ownerIndex ?? 0;
    message.waveFlag = object.waveFlag ?? 0;
    message.targetIndexList = object.targetIndexList?.map((e) => e) || [];
    message.dynamicValues = Object.entries(object.dynamicValues ?? {}).reduce<{
      [key: string]: number;
    }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = Number(value);
      }
      return acc;
    }, {});
    return message;
  },
};

function createBaseBattleBuff_DynamicValuesEntry(): BattleBuff_DynamicValuesEntry {
  return { key: "", value: 0 };
}

export const BattleBuff_DynamicValuesEntry = {
  encode(
    message: BattleBuff_DynamicValuesEntry,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== 0) {
      writer.uint32(21).float(message.value);
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): BattleBuff_DynamicValuesEntry {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBattleBuff_DynamicValuesEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.key = reader.string();
          break;
        case 2:
          message.value = reader.float();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): BattleBuff_DynamicValuesEntry {
    return {
      key: isSet(object.key) ? String(object.key) : "",
      value: isSet(object.value) ? Number(object.value) : 0,
    };
  },

  toJSON(message: BattleBuff_DynamicValuesEntry): unknown {
    const obj: any = {};
    message.key !== undefined && (obj.key = message.key);
    message.value !== undefined && (obj.value = message.value);
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<BattleBuff_DynamicValuesEntry>, I>>(
    object: I
  ): BattleBuff_DynamicValuesEntry {
    const message = createBaseBattleBuff_DynamicValuesEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? 0;
    return message;
  },
};

function createBaseBattleLineup(): BattleLineup {
  return {
    avatarList: [],
    monsterWaveList: [],
    buffList: [],
    heroPathList: [],
    battleScoringList: [],
  };
}

export const BattleLineup = {
  encode(
    message: BattleLineup,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    for (const v of message.avatarList) {
      BattleAvatar.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    for (const v of message.monsterWaveList) {
      BattleMonsterWave.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    for (const v of message.buffList) {
      BattleBuff.encode(v!, writer.uint32(26).fork()).ldelim();
    }
    for (const v of message.heroPathList) {
      HeroPath.encode(v!, writer.uint32(34).fork()).ldelim();
    }
    writer.uint32(42).fork();
    for (const v of message.battleScoringList) {
      writer.uint32(v);
    }
    writer.ldelim();
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): BattleLineup {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBattleLineup();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.avatarList.push(BattleAvatar.decode(reader, reader.uint32()));
          break;
        case 2:
          message.monsterWaveList.push(
            BattleMonsterWave.decode(reader, reader.uint32())
          );
          break;
        case 3:
          message.buffList.push(BattleBuff.decode(reader, reader.uint32()));
          break;
        case 4:
          message.heroPathList.push(HeroPath.decode(reader, reader.uint32()));
          break;
        case 5:
          if ((tag & 7) === 2) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.battleScoringList.push(reader.uint32());
            }
          } else {
            message.battleScoringList.push(reader.uint32());
          }
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): BattleLineup {
    return {
      avatarList: Array.isArray(object?.avatarList)
        ? object.avatarList.map((e: any) => BattleAvatar.fromJSON(e))
        : [],
      monsterWaveList: Array.isArray(object?.monsterWaveList)
        ? object.monsterWaveList.map((e: any) => BattleMonsterWave.fromJSON(e))
        : [],
      buffList: Array.isArray(object?.buffList)
        ? object.buffList.map((e: any) => BattleBuff.fromJSON(e))
        : [],
      heroPathList: Array.isArray(object?.heroPathList)
        ? object.heroPathList.map((e: any) => HeroPath.fromJSON(e))
        : [],
      battleScoringList: Array.isArray(object?.battleScoringList)
        ? object.battleScoringList.map((e: any) => Number(e))
        : [],
    };
  },

  toJSON(message: BattleLineup): unknown {
    const obj: any = {};
    if (message.avatarList) {
      obj.avatarList = message.avatarList.map((e) =>
        e ? BattleAvatar.toJSON(e) : undefined
      );
    } else {
      obj.avatarList = [];
    }
    if (message.monsterWaveList) {
      obj.monsterWaveList = message.monsterWaveList.map((e) =>
        e ? BattleMonsterWave.toJSON(e) : undefined
      );
    } else {
      obj.monsterWaveList = [];
    }
    if (message.buffList) {
      obj.buffList = message.buffList.map((e) =>
        e ? BattleBuff.toJSON(e) : undefined
      );
    } else {
      obj.buffList = [];
    }
    if (message.heroPathList) {
      obj.heroPathList = message.heroPathList.map((e) =>
        e ? HeroPath.toJSON(e) : undefined
      );
    } else {
      obj.heroPathList = [];
    }
    if (message.battleScoringList) {
      obj.battleScoringList = message.battleScoringList.map((e) =>
        Math.round(e)
      );
    } else {
      obj.battleScoringList = [];
    }
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<BattleLineup>, I>>(
    object: I
  ): BattleLineup {
    const message = createBaseBattleLineup();
    message.avatarList =
      object.avatarList?.map((e) => BattleAvatar.fromPartial(e)) || [];
    message.monsterWaveList =
      object.monsterWaveList?.map((e) => BattleMonsterWave.fromPartial(e)) ||
      [];
    message.buffList =
      object.buffList?.map((e) => BattleBuff.fromPartial(e)) || [];
    message.heroPathList =
      object.heroPathList?.map((e) => HeroPath.fromPartial(e)) || [];
    message.battleScoringList = object.battleScoringList?.map((e) => e) || [];
    return message;
  },
};

function createBaseClientTurnSnapshot(): ClientTurnSnapshot {
  return {
    turnCounter: 0,
    randomCounter: 0,
    animEventCounter: 0,
    snapshotList: [],
    animEventList: [],
  };
}

export const ClientTurnSnapshot = {
  encode(
    message: ClientTurnSnapshot,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.turnCounter !== 0) {
      writer.uint32(8).uint32(message.turnCounter);
    }
    if (message.randomCounter !== 0) {
      writer.uint32(16).uint32(message.randomCounter);
    }
    if (message.animEventCounter !== 0) {
      writer.uint32(24).uint32(message.animEventCounter);
    }
    for (const v of message.snapshotList) {
      CharacterSnapshot.encode(v!, writer.uint32(34).fork()).ldelim();
    }
    for (const v of message.animEventList) {
      AnimEventSnapshot.encode(v!, writer.uint32(42).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ClientTurnSnapshot {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseClientTurnSnapshot();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.turnCounter = reader.uint32();
          break;
        case 2:
          message.randomCounter = reader.uint32();
          break;
        case 3:
          message.animEventCounter = reader.uint32();
          break;
        case 4:
          message.snapshotList.push(
            CharacterSnapshot.decode(reader, reader.uint32())
          );
          break;
        case 5:
          message.animEventList.push(
            AnimEventSnapshot.decode(reader, reader.uint32())
          );
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): ClientTurnSnapshot {
    return {
      turnCounter: isSet(object.turnCounter) ? Number(object.turnCounter) : 0,
      randomCounter: isSet(object.randomCounter)
        ? Number(object.randomCounter)
        : 0,
      animEventCounter: isSet(object.animEventCounter)
        ? Number(object.animEventCounter)
        : 0,
      snapshotList: Array.isArray(object?.snapshotList)
        ? object.snapshotList.map((e: any) => CharacterSnapshot.fromJSON(e))
        : [],
      animEventList: Array.isArray(object?.animEventList)
        ? object.animEventList.map((e: any) => AnimEventSnapshot.fromJSON(e))
        : [],
    };
  },

  toJSON(message: ClientTurnSnapshot): unknown {
    const obj: any = {};
    message.turnCounter !== undefined &&
      (obj.turnCounter = Math.round(message.turnCounter));
    message.randomCounter !== undefined &&
      (obj.randomCounter = Math.round(message.randomCounter));
    message.animEventCounter !== undefined &&
      (obj.animEventCounter = Math.round(message.animEventCounter));
    if (message.snapshotList) {
      obj.snapshotList = message.snapshotList.map((e) =>
        e ? CharacterSnapshot.toJSON(e) : undefined
      );
    } else {
      obj.snapshotList = [];
    }
    if (message.animEventList) {
      obj.animEventList = message.animEventList.map((e) =>
        e ? AnimEventSnapshot.toJSON(e) : undefined
      );
    } else {
      obj.animEventList = [];
    }
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<ClientTurnSnapshot>, I>>(
    object: I
  ): ClientTurnSnapshot {
    const message = createBaseClientTurnSnapshot();
    message.turnCounter = object.turnCounter ?? 0;
    message.randomCounter = object.randomCounter ?? 0;
    message.animEventCounter = object.animEventCounter ?? 0;
    message.snapshotList =
      object.snapshotList?.map((e) => CharacterSnapshot.fromPartial(e)) || [];
    message.animEventList =
      object.animEventList?.map((e) => AnimEventSnapshot.fromPartial(e)) || [];
    return message;
  },
};

function createBaseGamecoreConfig(): GamecoreConfig {
  return {
    isSkipVerify: false,
    maxTurnCnt: 0,
    isAutoFight: false,
    csvPath: "",
  };
}

export const GamecoreConfig = {
  encode(
    message: GamecoreConfig,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.isSkipVerify === true) {
      writer.uint32(8).bool(message.isSkipVerify);
    }
    if (message.maxTurnCnt !== 0) {
      writer.uint32(16).uint32(message.maxTurnCnt);
    }
    if (message.isAutoFight === true) {
      writer.uint32(24).bool(message.isAutoFight);
    }
    if (message.csvPath !== "") {
      writer.uint32(34).string(message.csvPath);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GamecoreConfig {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGamecoreConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.isSkipVerify = reader.bool();
          break;
        case 2:
          message.maxTurnCnt = reader.uint32();
          break;
        case 3:
          message.isAutoFight = reader.bool();
          break;
        case 4:
          message.csvPath = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): GamecoreConfig {
    return {
      isSkipVerify: isSet(object.isSkipVerify)
        ? Boolean(object.isSkipVerify)
        : false,
      maxTurnCnt: isSet(object.maxTurnCnt) ? Number(object.maxTurnCnt) : 0,
      isAutoFight: isSet(object.isAutoFight)
        ? Boolean(object.isAutoFight)
        : false,
      csvPath: isSet(object.csvPath) ? String(object.csvPath) : "",
    };
  },

  toJSON(message: GamecoreConfig): unknown {
    const obj: any = {};
    message.isSkipVerify !== undefined &&
      (obj.isSkipVerify = message.isSkipVerify);
    message.maxTurnCnt !== undefined &&
      (obj.maxTurnCnt = Math.round(message.maxTurnCnt));
    message.isAutoFight !== undefined &&
      (obj.isAutoFight = message.isAutoFight);
    message.csvPath !== undefined && (obj.csvPath = message.csvPath);
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<GamecoreConfig>, I>>(
    object: I
  ): GamecoreConfig {
    const message = createBaseGamecoreConfig();
    message.isSkipVerify = object.isSkipVerify ?? false;
    message.maxTurnCnt = object.maxTurnCnt ?? 0;
    message.isAutoFight = object.isAutoFight ?? false;
    message.csvPath = object.csvPath ?? "";
    return message;
  },
};

function createBaseBattleBuffMsg(): BattleBuffMsg {
  return {
    buffIdList: [],
    buffIndexList: [],
    buffLevelList: [],
    buffFlagList: [],
  };
}

export const BattleBuffMsg = {
  encode(
    message: BattleBuffMsg,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    writer.uint32(10).fork();
    for (const v of message.buffIdList) {
      writer.uint32(v);
    }
    writer.ldelim();
    writer.uint32(18).fork();
    for (const v of message.buffIndexList) {
      writer.uint32(v);
    }
    writer.ldelim();
    writer.uint32(26).fork();
    for (const v of message.buffLevelList) {
      writer.uint32(v);
    }
    writer.ldelim();
    writer.uint32(34).fork();
    for (const v of message.buffFlagList) {
      writer.uint32(v);
    }
    writer.ldelim();
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): BattleBuffMsg {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBattleBuffMsg();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if ((tag & 7) === 2) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.buffIdList.push(reader.uint32());
            }
          } else {
            message.buffIdList.push(reader.uint32());
          }
          break;
        case 2:
          if ((tag & 7) === 2) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.buffIndexList.push(reader.uint32());
            }
          } else {
            message.buffIndexList.push(reader.uint32());
          }
          break;
        case 3:
          if ((tag & 7) === 2) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.buffLevelList.push(reader.uint32());
            }
          } else {
            message.buffLevelList.push(reader.uint32());
          }
          break;
        case 4:
          if ((tag & 7) === 2) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.buffFlagList.push(reader.uint32());
            }
          } else {
            message.buffFlagList.push(reader.uint32());
          }
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): BattleBuffMsg {
    return {
      buffIdList: Array.isArray(object?.buffIdList)
        ? object.buffIdList.map((e: any) => Number(e))
        : [],
      buffIndexList: Array.isArray(object?.buffIndexList)
        ? object.buffIndexList.map((e: any) => Number(e))
        : [],
      buffLevelList: Array.isArray(object?.buffLevelList)
        ? object.buffLevelList.map((e: any) => Number(e))
        : [],
      buffFlagList: Array.isArray(object?.buffFlagList)
        ? object.buffFlagList.map((e: any) => Number(e))
        : [],
    };
  },

  toJSON(message: BattleBuffMsg): unknown {
    const obj: any = {};
    if (message.buffIdList) {
      obj.buffIdList = message.buffIdList.map((e) => Math.round(e));
    } else {
      obj.buffIdList = [];
    }
    if (message.buffIndexList) {
      obj.buffIndexList = message.buffIndexList.map((e) => Math.round(e));
    } else {
      obj.buffIndexList = [];
    }
    if (message.buffLevelList) {
      obj.buffLevelList = message.buffLevelList.map((e) => Math.round(e));
    } else {
      obj.buffLevelList = [];
    }
    if (message.buffFlagList) {
      obj.buffFlagList = message.buffFlagList.map((e) => Math.round(e));
    } else {
      obj.buffFlagList = [];
    }
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<BattleBuffMsg>, I>>(
    object: I
  ): BattleBuffMsg {
    const message = createBaseBattleBuffMsg();
    message.buffIdList = object.buffIdList?.map((e) => e) || [];
    message.buffIndexList = object.buffIndexList?.map((e) => e) || [];
    message.buffLevelList = object.buffLevelList?.map((e) => e) || [];
    message.buffFlagList = object.buffFlagList?.map((e) => e) || [];
    return message;
  },
};

function createBaseBattleReplay(): BattleReplay {
  return {
    version: 0,
    logicRandomSeed: 0,
    stageId: 0,
    lineup: undefined,
    opList: [],
    turnSnapshotHash: new Uint8Array(),
    mazePlaneId: 0,
    extraAbilityList: [],
    isAiConsiderUltraSkill: false,
    checkStrategy: 0,
    battleModuleType: 0,
    turnSnapshotList: [],
    localLevelPath: "",
    debugExtraInfo: "",
    config: undefined,
    gameCoreLogEncode: new Uint8Array(),
    roundsLimit: 0,
    logStringHash: [],
    planeId: 0,
    floorId: 0,
    battleAreaGroupId: 0,
    battleAreaId: 0,
  };
}

export const BattleReplay = {
  encode(
    message: BattleReplay,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.version !== 0) {
      writer.uint32(8).uint32(message.version);
    }
    if (message.logicRandomSeed !== 0) {
      writer.uint32(16).uint32(message.logicRandomSeed);
    }
    if (message.stageId !== 0) {
      writer.uint32(24).uint32(message.stageId);
    }
    if (message.lineup !== undefined) {
      BattleLineup.encode(message.lineup, writer.uint32(34).fork()).ldelim();
    }
    for (const v of message.opList) {
      BattleOp.encode(v!, writer.uint32(42).fork()).ldelim();
    }
    if (message.turnSnapshotHash.length !== 0) {
      writer.uint32(50).bytes(message.turnSnapshotHash);
    }
    if (message.mazePlaneId !== 0) {
      writer.uint32(56).uint32(message.mazePlaneId);
    }
    writer.uint32(66).fork();
    for (const v of message.extraAbilityList) {
      writer.uint32(v);
    }
    writer.ldelim();
    if (message.isAiConsiderUltraSkill === true) {
      writer.uint32(72).bool(message.isAiConsiderUltraSkill);
    }
    if (message.checkStrategy !== 0) {
      writer.uint32(80).int32(message.checkStrategy);
    }
    if (message.battleModuleType !== 0) {
      writer.uint32(88).int32(message.battleModuleType);
    }
    for (const v of message.turnSnapshotList) {
      ClientTurnSnapshot.encode(v!, writer.uint32(170).fork()).ldelim();
    }
    if (message.localLevelPath !== "") {
      writer.uint32(178).string(message.localLevelPath);
    }
    if (message.debugExtraInfo !== "") {
      writer.uint32(186).string(message.debugExtraInfo);
    }
    if (message.config !== undefined) {
      GamecoreConfig.encode(message.config, writer.uint32(194).fork()).ldelim();
    }
    if (message.gameCoreLogEncode.length !== 0) {
      writer.uint32(210).bytes(message.gameCoreLogEncode);
    }
    if (message.roundsLimit !== 0) {
      writer.uint32(216).uint32(message.roundsLimit);
    }
    for (const v of message.logStringHash) {
      BattleReplayStringHash.encode(v!, writer.uint32(226).fork()).ldelim();
    }
    if (message.planeId !== 0) {
      writer.uint32(232).uint32(message.planeId);
    }
    if (message.floorId !== 0) {
      writer.uint32(240).uint32(message.floorId);
    }
    if (message.battleAreaGroupId !== 0) {
      writer.uint32(248).uint32(message.battleAreaGroupId);
    }
    if (message.battleAreaId !== 0) {
      writer.uint32(256).uint32(message.battleAreaId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): BattleReplay {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBattleReplay();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.version = reader.uint32();
          break;
        case 2:
          message.logicRandomSeed = reader.uint32();
          break;
        case 3:
          message.stageId = reader.uint32();
          break;
        case 4:
          message.lineup = BattleLineup.decode(reader, reader.uint32());
          break;
        case 5:
          message.opList.push(BattleOp.decode(reader, reader.uint32()));
          break;
        case 6:
          message.turnSnapshotHash = reader.bytes();
          break;
        case 7:
          message.mazePlaneId = reader.uint32();
          break;
        case 8:
          if ((tag & 7) === 2) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.extraAbilityList.push(reader.uint32());
            }
          } else {
            message.extraAbilityList.push(reader.uint32());
          }
          break;
        case 9:
          message.isAiConsiderUltraSkill = reader.bool();
          break;
        case 10:
          message.checkStrategy = reader.int32() as any;
          break;
        case 11:
          message.battleModuleType = reader.int32() as any;
          break;
        case 21:
          message.turnSnapshotList.push(
            ClientTurnSnapshot.decode(reader, reader.uint32())
          );
          break;
        case 22:
          message.localLevelPath = reader.string();
          break;
        case 23:
          message.debugExtraInfo = reader.string();
          break;
        case 24:
          message.config = GamecoreConfig.decode(reader, reader.uint32());
          break;
        case 26:
          message.gameCoreLogEncode = reader.bytes();
          break;
        case 27:
          message.roundsLimit = reader.uint32();
          break;
        case 28:
          message.logStringHash.push(
            BattleReplayStringHash.decode(reader, reader.uint32())
          );
          break;
        case 29:
          message.planeId = reader.uint32();
          break;
        case 30:
          message.floorId = reader.uint32();
          break;
        case 31:
          message.battleAreaGroupId = reader.uint32();
          break;
        case 32:
          message.battleAreaId = reader.uint32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): BattleReplay {
    return {
      version: isSet(object.version) ? Number(object.version) : 0,
      logicRandomSeed: isSet(object.logicRandomSeed)
        ? Number(object.logicRandomSeed)
        : 0,
      stageId: isSet(object.stageId) ? Number(object.stageId) : 0,
      lineup: isSet(object.lineup)
        ? BattleLineup.fromJSON(object.lineup)
        : undefined,
      opList: Array.isArray(object?.opList)
        ? object.opList.map((e: any) => BattleOp.fromJSON(e))
        : [],
      turnSnapshotHash: isSet(object.turnSnapshotHash)
        ? bytesFromBase64(object.turnSnapshotHash)
        : new Uint8Array(),
      mazePlaneId: isSet(object.mazePlaneId) ? Number(object.mazePlaneId) : 0,
      extraAbilityList: Array.isArray(object?.extraAbilityList)
        ? object.extraAbilityList.map((e: any) => Number(e))
        : [],
      isAiConsiderUltraSkill: isSet(object.isAiConsiderUltraSkill)
        ? Boolean(object.isAiConsiderUltraSkill)
        : false,
      checkStrategy: isSet(object.checkStrategy)
        ? battleCheckStrategyTypeFromJSON(object.checkStrategy)
        : 0,
      battleModuleType: isSet(object.battleModuleType)
        ? battleModuleTypeFromJSON(object.battleModuleType)
        : 0,
      turnSnapshotList: Array.isArray(object?.turnSnapshotList)
        ? object.turnSnapshotList.map((e: any) =>
            ClientTurnSnapshot.fromJSON(e)
          )
        : [],
      localLevelPath: isSet(object.localLevelPath)
        ? String(object.localLevelPath)
        : "",
      debugExtraInfo: isSet(object.debugExtraInfo)
        ? String(object.debugExtraInfo)
        : "",
      config: isSet(object.config)
        ? GamecoreConfig.fromJSON(object.config)
        : undefined,
      gameCoreLogEncode: isSet(object.gameCoreLogEncode)
        ? bytesFromBase64(object.gameCoreLogEncode)
        : new Uint8Array(),
      roundsLimit: isSet(object.roundsLimit) ? Number(object.roundsLimit) : 0,
      logStringHash: Array.isArray(object?.logStringHash)
        ? object.logStringHash.map((e: any) =>
            BattleReplayStringHash.fromJSON(e)
          )
        : [],
      planeId: isSet(object.planeId) ? Number(object.planeId) : 0,
      floorId: isSet(object.floorId) ? Number(object.floorId) : 0,
      battleAreaGroupId: isSet(object.battleAreaGroupId)
        ? Number(object.battleAreaGroupId)
        : 0,
      battleAreaId: isSet(object.battleAreaId)
        ? Number(object.battleAreaId)
        : 0,
    };
  },

  toJSON(message: BattleReplay): unknown {
    const obj: any = {};
    message.version !== undefined &&
      (obj.version = Math.round(message.version));
    message.logicRandomSeed !== undefined &&
      (obj.logicRandomSeed = Math.round(message.logicRandomSeed));
    message.stageId !== undefined &&
      (obj.stageId = Math.round(message.stageId));
    message.lineup !== undefined &&
      (obj.lineup = message.lineup
        ? BattleLineup.toJSON(message.lineup)
        : undefined);
    if (message.opList) {
      obj.opList = message.opList.map((e) =>
        e ? BattleOp.toJSON(e) : undefined
      );
    } else {
      obj.opList = [];
    }
    message.turnSnapshotHash !== undefined &&
      (obj.turnSnapshotHash = base64FromBytes(
        message.turnSnapshotHash !== undefined
          ? message.turnSnapshotHash
          : new Uint8Array()
      ));
    message.mazePlaneId !== undefined &&
      (obj.mazePlaneId = Math.round(message.mazePlaneId));
    if (message.extraAbilityList) {
      obj.extraAbilityList = message.extraAbilityList.map((e) => Math.round(e));
    } else {
      obj.extraAbilityList = [];
    }
    message.isAiConsiderUltraSkill !== undefined &&
      (obj.isAiConsiderUltraSkill = message.isAiConsiderUltraSkill);
    message.checkStrategy !== undefined &&
      (obj.checkStrategy = battleCheckStrategyTypeToJSON(
        message.checkStrategy
      ));
    message.battleModuleType !== undefined &&
      (obj.battleModuleType = battleModuleTypeToJSON(message.battleModuleType));
    if (message.turnSnapshotList) {
      obj.turnSnapshotList = message.turnSnapshotList.map((e) =>
        e ? ClientTurnSnapshot.toJSON(e) : undefined
      );
    } else {
      obj.turnSnapshotList = [];
    }
    message.localLevelPath !== undefined &&
      (obj.localLevelPath = message.localLevelPath);
    message.debugExtraInfo !== undefined &&
      (obj.debugExtraInfo = message.debugExtraInfo);
    message.config !== undefined &&
      (obj.config = message.config
        ? GamecoreConfig.toJSON(message.config)
        : undefined);
    message.gameCoreLogEncode !== undefined &&
      (obj.gameCoreLogEncode = base64FromBytes(
        message.gameCoreLogEncode !== undefined
          ? message.gameCoreLogEncode
          : new Uint8Array()
      ));
    message.roundsLimit !== undefined &&
      (obj.roundsLimit = Math.round(message.roundsLimit));
    if (message.logStringHash) {
      obj.logStringHash = message.logStringHash.map((e) =>
        e ? BattleReplayStringHash.toJSON(e) : undefined
      );
    } else {
      obj.logStringHash = [];
    }
    message.planeId !== undefined &&
      (obj.planeId = Math.round(message.planeId));
    message.floorId !== undefined &&
      (obj.floorId = Math.round(message.floorId));
    message.battleAreaGroupId !== undefined &&
      (obj.battleAreaGroupId = Math.round(message.battleAreaGroupId));
    message.battleAreaId !== undefined &&
      (obj.battleAreaId = Math.round(message.battleAreaId));
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<BattleReplay>, I>>(
    object: I
  ): BattleReplay {
    const message = createBaseBattleReplay();
    message.version = object.version ?? 0;
    message.logicRandomSeed = object.logicRandomSeed ?? 0;
    message.stageId = object.stageId ?? 0;
    message.lineup =
      object.lineup !== undefined && object.lineup !== null
        ? BattleLineup.fromPartial(object.lineup)
        : undefined;
    message.opList = object.opList?.map((e) => BattleOp.fromPartial(e)) || [];
    message.turnSnapshotHash = object.turnSnapshotHash ?? new Uint8Array();
    message.mazePlaneId = object.mazePlaneId ?? 0;
    message.extraAbilityList = object.extraAbilityList?.map((e) => e) || [];
    message.isAiConsiderUltraSkill = object.isAiConsiderUltraSkill ?? false;
    message.checkStrategy = object.checkStrategy ?? 0;
    message.battleModuleType = object.battleModuleType ?? 0;
    message.turnSnapshotList =
      object.turnSnapshotList?.map((e) => ClientTurnSnapshot.fromPartial(e)) ||
      [];
    message.localLevelPath = object.localLevelPath ?? "";
    message.debugExtraInfo = object.debugExtraInfo ?? "";
    message.config =
      object.config !== undefined && object.config !== null
        ? GamecoreConfig.fromPartial(object.config)
        : undefined;
    message.gameCoreLogEncode = object.gameCoreLogEncode ?? new Uint8Array();
    message.roundsLimit = object.roundsLimit ?? 0;
    message.logStringHash =
      object.logStringHash?.map((e) => BattleReplayStringHash.fromPartial(e)) ||
      [];
    message.planeId = object.planeId ?? 0;
    message.floorId = object.floorId ?? 0;
    message.battleAreaGroupId = object.battleAreaGroupId ?? 0;
    message.battleAreaId = object.battleAreaId ?? 0;
    return message;
  },
};

function createBaseBattleReplayStringHash(): BattleReplayStringHash {
  return { hash: 0, value: "" };
}

export const BattleReplayStringHash = {
  encode(
    message: BattleReplayStringHash,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.hash !== 0) {
      writer.uint32(8).int32(message.hash);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): BattleReplayStringHash {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBattleReplayStringHash();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.hash = reader.int32();
          break;
        case 2:
          message.value = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): BattleReplayStringHash {
    return {
      hash: isSet(object.hash) ? Number(object.hash) : 0,
      value: isSet(object.value) ? String(object.value) : "",
    };
  },

  toJSON(message: BattleReplayStringHash): unknown {
    const obj: any = {};
    message.hash !== undefined && (obj.hash = Math.round(message.hash));
    message.value !== undefined && (obj.value = message.value);
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<BattleReplayStringHash>, I>>(
    object: I
  ): BattleReplayStringHash {
    const message = createBaseBattleReplayStringHash();
    message.hash = object.hash ?? 0;
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseAvatarProperty(): AvatarProperty {
  return {
    maxHp: 0,
    attack: 0,
    defence: 0,
    speed: 0,
    leftHp: 0,
    leftSp: 0,
    maxSp: 0,
  };
}

export const AvatarProperty = {
  encode(
    message: AvatarProperty,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.maxHp !== 0) {
      writer.uint32(9).double(message.maxHp);
    }
    if (message.attack !== 0) {
      writer.uint32(17).double(message.attack);
    }
    if (message.defence !== 0) {
      writer.uint32(25).double(message.defence);
    }
    if (message.speed !== 0) {
      writer.uint32(33).double(message.speed);
    }
    if (message.leftHp !== 0) {
      writer.uint32(41).double(message.leftHp);
    }
    if (message.leftSp !== 0) {
      writer.uint32(49).double(message.leftSp);
    }
    if (message.maxSp !== 0) {
      writer.uint32(57).double(message.maxSp);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): AvatarProperty {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAvatarProperty();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.maxHp = reader.double();
          break;
        case 2:
          message.attack = reader.double();
          break;
        case 3:
          message.defence = reader.double();
          break;
        case 4:
          message.speed = reader.double();
          break;
        case 5:
          message.leftHp = reader.double();
          break;
        case 6:
          message.leftSp = reader.double();
          break;
        case 7:
          message.maxSp = reader.double();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): AvatarProperty {
    return {
      maxHp: isSet(object.maxHp) ? Number(object.maxHp) : 0,
      attack: isSet(object.attack) ? Number(object.attack) : 0,
      defence: isSet(object.defence) ? Number(object.defence) : 0,
      speed: isSet(object.speed) ? Number(object.speed) : 0,
      leftHp: isSet(object.leftHp) ? Number(object.leftHp) : 0,
      leftSp: isSet(object.leftSp) ? Number(object.leftSp) : 0,
      maxSp: isSet(object.maxSp) ? Number(object.maxSp) : 0,
    };
  },

  toJSON(message: AvatarProperty): unknown {
    const obj: any = {};
    message.maxHp !== undefined && (obj.maxHp = message.maxHp);
    message.attack !== undefined && (obj.attack = message.attack);
    message.defence !== undefined && (obj.defence = message.defence);
    message.speed !== undefined && (obj.speed = message.speed);
    message.leftHp !== undefined && (obj.leftHp = message.leftHp);
    message.leftSp !== undefined && (obj.leftSp = message.leftSp);
    message.maxSp !== undefined && (obj.maxSp = message.maxSp);
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<AvatarProperty>, I>>(
    object: I
  ): AvatarProperty {
    const message = createBaseAvatarProperty();
    message.maxHp = object.maxHp ?? 0;
    message.attack = object.attack ?? 0;
    message.defence = object.defence ?? 0;
    message.speed = object.speed ?? 0;
    message.leftHp = object.leftHp ?? 0;
    message.leftSp = object.leftSp ?? 0;
    message.maxSp = object.maxSp ?? 0;
    return message;
  },
};

function createBaseEquipmentProperty(): EquipmentProperty {
  return { id: 0, rank: 0, promotion: 0, level: 0 };
}

export const EquipmentProperty = {
  encode(
    message: EquipmentProperty,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.id !== 0) {
      writer.uint32(8).uint32(message.id);
    }
    if (message.rank !== 0) {
      writer.uint32(16).uint32(message.rank);
    }
    if (message.promotion !== 0) {
      writer.uint32(24).uint32(message.promotion);
    }
    if (message.level !== 0) {
      writer.uint32(32).uint32(message.level);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): EquipmentProperty {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEquipmentProperty();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.id = reader.uint32();
          break;
        case 2:
          message.rank = reader.uint32();
          break;
        case 3:
          message.promotion = reader.uint32();
          break;
        case 4:
          message.level = reader.uint32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): EquipmentProperty {
    return {
      id: isSet(object.id) ? Number(object.id) : 0,
      rank: isSet(object.rank) ? Number(object.rank) : 0,
      promotion: isSet(object.promotion) ? Number(object.promotion) : 0,
      level: isSet(object.level) ? Number(object.level) : 0,
    };
  },

  toJSON(message: EquipmentProperty): unknown {
    const obj: any = {};
    message.id !== undefined && (obj.id = Math.round(message.id));
    message.rank !== undefined && (obj.rank = Math.round(message.rank));
    message.promotion !== undefined &&
      (obj.promotion = Math.round(message.promotion));
    message.level !== undefined && (obj.level = Math.round(message.level));
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<EquipmentProperty>, I>>(
    object: I
  ): EquipmentProperty {
    const message = createBaseEquipmentProperty();
    message.id = object.id ?? 0;
    message.rank = object.rank ?? 0;
    message.promotion = object.promotion ?? 0;
    message.level = object.level ?? 0;
    return message;
  },
};

function createBaseAttackDamageProperty(): AttackDamageProperty {
  return { attackType: "", damage: 0 };
}

export const AttackDamageProperty = {
  encode(
    message: AttackDamageProperty,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.attackType !== "") {
      writer.uint32(10).string(message.attackType);
    }
    if (message.damage !== 0) {
      writer.uint32(17).double(message.damage);
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): AttackDamageProperty {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAttackDamageProperty();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.attackType = reader.string();
          break;
        case 2:
          message.damage = reader.double();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): AttackDamageProperty {
    return {
      attackType: isSet(object.attackType) ? String(object.attackType) : "",
      damage: isSet(object.damage) ? Number(object.damage) : 0,
    };
  },

  toJSON(message: AttackDamageProperty): unknown {
    const obj: any = {};
    message.attackType !== undefined && (obj.attackType = message.attackType);
    message.damage !== undefined && (obj.damage = message.damage);
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<AttackDamageProperty>, I>>(
    object: I
  ): AttackDamageProperty {
    const message = createBaseAttackDamageProperty();
    message.attackType = object.attackType ?? "";
    message.damage = object.damage ?? 0;
    return message;
  },
};

function createBaseSkillUseProperty(): SkillUseProperty {
  return { skillId: 0, skillType: "", skillLevel: 0, skillUseCount: 0 };
}

export const SkillUseProperty = {
  encode(
    message: SkillUseProperty,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.skillId !== 0) {
      writer.uint32(8).uint32(message.skillId);
    }
    if (message.skillType !== "") {
      writer.uint32(18).string(message.skillType);
    }
    if (message.skillLevel !== 0) {
      writer.uint32(24).uint32(message.skillLevel);
    }
    if (message.skillUseCount !== 0) {
      writer.uint32(32).uint32(message.skillUseCount);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SkillUseProperty {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSkillUseProperty();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.skillId = reader.uint32();
          break;
        case 2:
          message.skillType = reader.string();
          break;
        case 3:
          message.skillLevel = reader.uint32();
          break;
        case 4:
          message.skillUseCount = reader.uint32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): SkillUseProperty {
    return {
      skillId: isSet(object.skillId) ? Number(object.skillId) : 0,
      skillType: isSet(object.skillType) ? String(object.skillType) : "",
      skillLevel: isSet(object.skillLevel) ? Number(object.skillLevel) : 0,
      skillUseCount: isSet(object.skillUseCount)
        ? Number(object.skillUseCount)
        : 0,
    };
  },

  toJSON(message: SkillUseProperty): unknown {
    const obj: any = {};
    message.skillId !== undefined &&
      (obj.skillId = Math.round(message.skillId));
    message.skillType !== undefined && (obj.skillType = message.skillType);
    message.skillLevel !== undefined &&
      (obj.skillLevel = Math.round(message.skillLevel));
    message.skillUseCount !== undefined &&
      (obj.skillUseCount = Math.round(message.skillUseCount));
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<SkillUseProperty>, I>>(
    object: I
  ): SkillUseProperty {
    const message = createBaseSkillUseProperty();
    message.skillId = object.skillId ?? 0;
    message.skillType = object.skillType ?? "";
    message.skillLevel = object.skillLevel ?? 0;
    message.skillUseCount = object.skillUseCount ?? 0;
    return message;
  },
};

function createBaseSpAddSource(): SpAddSource {
  return { source: "", spAdd: 0 };
}

export const SpAddSource = {
  encode(
    message: SpAddSource,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.source !== "") {
      writer.uint32(10).string(message.source);
    }
    if (message.spAdd !== 0) {
      writer.uint32(16).uint32(message.spAdd);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SpAddSource {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSpAddSource();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.source = reader.string();
          break;
        case 2:
          message.spAdd = reader.uint32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): SpAddSource {
    return {
      source: isSet(object.source) ? String(object.source) : "",
      spAdd: isSet(object.spAdd) ? Number(object.spAdd) : 0,
    };
  },

  toJSON(message: SpAddSource): unknown {
    const obj: any = {};
    message.source !== undefined && (obj.source = message.source);
    message.spAdd !== undefined && (obj.spAdd = Math.round(message.spAdd));
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<SpAddSource>, I>>(
    object: I
  ): SpAddSource {
    const message = createBaseSpAddSource();
    message.source = object.source ?? "";
    message.spAdd = object.spAdd ?? 0;
    return message;
  },
};

function createBaseAvatarBattleInfo(): AvatarBattleInfo {
  return {
    avatarType: 0,
    id: 0,
    avatarLevel: 0,
    avatarRank: 0,
    avatarPromotion: 0,
    avatarStatus: undefined,
    avatarSkill: [],
    avatarEquipment: [],
    totalTurns: 0,
    totalDamage: 0,
    totalHeal: 0,
    totalDamageTaken: 0,
    totalHpRecover: 0,
    totalSpCost: 0,
    stageId: 0,
    stageType: 0,
    totalBreakDamage: 0,
    attackTypeDamage: [],
    attackTypeBreakDamage: [],
    attackTypeMaxDamage: [],
    skillTimes: [],
    delayCumulate: 0,
    totalSpAdd: 0,
    spAddSource: [],
    totalBpCost: 0,
    dieTimes: 0,
    reviveTimes: 0,
    breakTimes: 0,
    extraTurns: 0,
    totalShield: 0,
    totalShieldTaken: 0,
    totalShieldDamage: 0,
    initialStatus: undefined,
    relics: [],
  };
}

export const AvatarBattleInfo = {
  encode(
    message: AvatarBattleInfo,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.avatarType !== 0) {
      writer.uint32(8).int32(message.avatarType);
    }
    if (message.id !== 0) {
      writer.uint32(16).uint32(message.id);
    }
    if (message.avatarLevel !== 0) {
      writer.uint32(24).uint32(message.avatarLevel);
    }
    if (message.avatarRank !== 0) {
      writer.uint32(32).uint32(message.avatarRank);
    }
    if (message.avatarPromotion !== 0) {
      writer.uint32(40).uint32(message.avatarPromotion);
    }
    if (message.avatarStatus !== undefined) {
      AvatarProperty.encode(
        message.avatarStatus,
        writer.uint32(50).fork()
      ).ldelim();
    }
    for (const v of message.avatarSkill) {
      AvatarSkillTree.encode(v!, writer.uint32(58).fork()).ldelim();
    }
    for (const v of message.avatarEquipment) {
      EquipmentProperty.encode(v!, writer.uint32(66).fork()).ldelim();
    }
    if (message.totalTurns !== 0) {
      writer.uint32(72).uint32(message.totalTurns);
    }
    if (message.totalDamage !== 0) {
      writer.uint32(81).double(message.totalDamage);
    }
    if (message.totalHeal !== 0) {
      writer.uint32(89).double(message.totalHeal);
    }
    if (message.totalDamageTaken !== 0) {
      writer.uint32(97).double(message.totalDamageTaken);
    }
    if (message.totalHpRecover !== 0) {
      writer.uint32(105).double(message.totalHpRecover);
    }
    if (message.totalSpCost !== 0) {
      writer.uint32(113).double(message.totalSpCost);
    }
    if (message.stageId !== 0) {
      writer.uint32(120).uint32(message.stageId);
    }
    if (message.stageType !== 0) {
      writer.uint32(128).uint32(message.stageType);
    }
    if (message.totalBreakDamage !== 0) {
      writer.uint32(137).double(message.totalBreakDamage);
    }
    for (const v of message.attackTypeDamage) {
      AttackDamageProperty.encode(v!, writer.uint32(146).fork()).ldelim();
    }
    for (const v of message.attackTypeBreakDamage) {
      AttackDamageProperty.encode(v!, writer.uint32(154).fork()).ldelim();
    }
    for (const v of message.attackTypeMaxDamage) {
      AttackDamageProperty.encode(v!, writer.uint32(162).fork()).ldelim();
    }
    for (const v of message.skillTimes) {
      SkillUseProperty.encode(v!, writer.uint32(170).fork()).ldelim();
    }
    if (message.delayCumulate !== 0) {
      writer.uint32(177).double(message.delayCumulate);
    }
    if (message.totalSpAdd !== 0) {
      writer.uint32(184).uint32(message.totalSpAdd);
    }
    for (const v of message.spAddSource) {
      SpAddSource.encode(v!, writer.uint32(194).fork()).ldelim();
    }
    if (message.totalBpCost !== 0) {
      writer.uint32(200).uint32(message.totalBpCost);
    }
    if (message.dieTimes !== 0) {
      writer.uint32(208).uint32(message.dieTimes);
    }
    if (message.reviveTimes !== 0) {
      writer.uint32(216).uint32(message.reviveTimes);
    }
    if (message.breakTimes !== 0) {
      writer.uint32(224).uint32(message.breakTimes);
    }
    if (message.extraTurns !== 0) {
      writer.uint32(232).uint32(message.extraTurns);
    }
    if (message.totalShield !== 0) {
      writer.uint32(241).double(message.totalShield);
    }
    if (message.totalShieldTaken !== 0) {
      writer.uint32(249).double(message.totalShieldTaken);
    }
    if (message.totalShieldDamage !== 0) {
      writer.uint32(257).double(message.totalShieldDamage);
    }
    if (message.initialStatus !== undefined) {
      AvatarProperty.encode(
        message.initialStatus,
        writer.uint32(266).fork()
      ).ldelim();
    }
    for (const v of message.relics) {
      BattleRelic.encode(v!, writer.uint32(274).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): AvatarBattleInfo {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAvatarBattleInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.avatarType = reader.int32() as any;
          break;
        case 2:
          message.id = reader.uint32();
          break;
        case 3:
          message.avatarLevel = reader.uint32();
          break;
        case 4:
          message.avatarRank = reader.uint32();
          break;
        case 5:
          message.avatarPromotion = reader.uint32();
          break;
        case 6:
          message.avatarStatus = AvatarProperty.decode(reader, reader.uint32());
          break;
        case 7:
          message.avatarSkill.push(
            AvatarSkillTree.decode(reader, reader.uint32())
          );
          break;
        case 8:
          message.avatarEquipment.push(
            EquipmentProperty.decode(reader, reader.uint32())
          );
          break;
        case 9:
          message.totalTurns = reader.uint32();
          break;
        case 10:
          message.totalDamage = reader.double();
          break;
        case 11:
          message.totalHeal = reader.double();
          break;
        case 12:
          message.totalDamageTaken = reader.double();
          break;
        case 13:
          message.totalHpRecover = reader.double();
          break;
        case 14:
          message.totalSpCost = reader.double();
          break;
        case 15:
          message.stageId = reader.uint32();
          break;
        case 16:
          message.stageType = reader.uint32();
          break;
        case 17:
          message.totalBreakDamage = reader.double();
          break;
        case 18:
          message.attackTypeDamage.push(
            AttackDamageProperty.decode(reader, reader.uint32())
          );
          break;
        case 19:
          message.attackTypeBreakDamage.push(
            AttackDamageProperty.decode(reader, reader.uint32())
          );
          break;
        case 20:
          message.attackTypeMaxDamage.push(
            AttackDamageProperty.decode(reader, reader.uint32())
          );
          break;
        case 21:
          message.skillTimes.push(
            SkillUseProperty.decode(reader, reader.uint32())
          );
          break;
        case 22:
          message.delayCumulate = reader.double();
          break;
        case 23:
          message.totalSpAdd = reader.uint32();
          break;
        case 24:
          message.spAddSource.push(SpAddSource.decode(reader, reader.uint32()));
          break;
        case 25:
          message.totalBpCost = reader.uint32();
          break;
        case 26:
          message.dieTimes = reader.uint32();
          break;
        case 27:
          message.reviveTimes = reader.uint32();
          break;
        case 28:
          message.breakTimes = reader.uint32();
          break;
        case 29:
          message.extraTurns = reader.uint32();
          break;
        case 30:
          message.totalShield = reader.double();
          break;
        case 31:
          message.totalShieldTaken = reader.double();
          break;
        case 32:
          message.totalShieldDamage = reader.double();
          break;
        case 33:
          message.initialStatus = AvatarProperty.decode(
            reader,
            reader.uint32()
          );
          break;
        case 34:
          message.relics.push(BattleRelic.decode(reader, reader.uint32()));
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): AvatarBattleInfo {
    return {
      avatarType: isSet(object.avatarType)
        ? avatarTypeFromJSON(object.avatarType)
        : 0,
      id: isSet(object.id) ? Number(object.id) : 0,
      avatarLevel: isSet(object.avatarLevel) ? Number(object.avatarLevel) : 0,
      avatarRank: isSet(object.avatarRank) ? Number(object.avatarRank) : 0,
      avatarPromotion: isSet(object.avatarPromotion)
        ? Number(object.avatarPromotion)
        : 0,
      avatarStatus: isSet(object.avatarStatus)
        ? AvatarProperty.fromJSON(object.avatarStatus)
        : undefined,
      avatarSkill: Array.isArray(object?.avatarSkill)
        ? object.avatarSkill.map((e: any) => AvatarSkillTree.fromJSON(e))
        : [],
      avatarEquipment: Array.isArray(object?.avatarEquipment)
        ? object.avatarEquipment.map((e: any) => EquipmentProperty.fromJSON(e))
        : [],
      totalTurns: isSet(object.totalTurns) ? Number(object.totalTurns) : 0,
      totalDamage: isSet(object.totalDamage) ? Number(object.totalDamage) : 0,
      totalHeal: isSet(object.totalHeal) ? Number(object.totalHeal) : 0,
      totalDamageTaken: isSet(object.totalDamageTaken)
        ? Number(object.totalDamageTaken)
        : 0,
      totalHpRecover: isSet(object.totalHpRecover)
        ? Number(object.totalHpRecover)
        : 0,
      totalSpCost: isSet(object.totalSpCost) ? Number(object.totalSpCost) : 0,
      stageId: isSet(object.stageId) ? Number(object.stageId) : 0,
      stageType: isSet(object.stageType) ? Number(object.stageType) : 0,
      totalBreakDamage: isSet(object.totalBreakDamage)
        ? Number(object.totalBreakDamage)
        : 0,
      attackTypeDamage: Array.isArray(object?.attackTypeDamage)
        ? object.attackTypeDamage.map((e: any) =>
            AttackDamageProperty.fromJSON(e)
          )
        : [],
      attackTypeBreakDamage: Array.isArray(object?.attackTypeBreakDamage)
        ? object.attackTypeBreakDamage.map((e: any) =>
            AttackDamageProperty.fromJSON(e)
          )
        : [],
      attackTypeMaxDamage: Array.isArray(object?.attackTypeMaxDamage)
        ? object.attackTypeMaxDamage.map((e: any) =>
            AttackDamageProperty.fromJSON(e)
          )
        : [],
      skillTimes: Array.isArray(object?.skillTimes)
        ? object.skillTimes.map((e: any) => SkillUseProperty.fromJSON(e))
        : [],
      delayCumulate: isSet(object.delayCumulate)
        ? Number(object.delayCumulate)
        : 0,
      totalSpAdd: isSet(object.totalSpAdd) ? Number(object.totalSpAdd) : 0,
      spAddSource: Array.isArray(object?.spAddSource)
        ? object.spAddSource.map((e: any) => SpAddSource.fromJSON(e))
        : [],
      totalBpCost: isSet(object.totalBpCost) ? Number(object.totalBpCost) : 0,
      dieTimes: isSet(object.dieTimes) ? Number(object.dieTimes) : 0,
      reviveTimes: isSet(object.reviveTimes) ? Number(object.reviveTimes) : 0,
      breakTimes: isSet(object.breakTimes) ? Number(object.breakTimes) : 0,
      extraTurns: isSet(object.extraTurns) ? Number(object.extraTurns) : 0,
      totalShield: isSet(object.totalShield) ? Number(object.totalShield) : 0,
      totalShieldTaken: isSet(object.totalShieldTaken)
        ? Number(object.totalShieldTaken)
        : 0,
      totalShieldDamage: isSet(object.totalShieldDamage)
        ? Number(object.totalShieldDamage)
        : 0,
      initialStatus: isSet(object.initialStatus)
        ? AvatarProperty.fromJSON(object.initialStatus)
        : undefined,
      relics: Array.isArray(object?.relics)
        ? object.relics.map((e: any) => BattleRelic.fromJSON(e))
        : [],
    };
  },

  toJSON(message: AvatarBattleInfo): unknown {
    const obj: any = {};
    message.avatarType !== undefined &&
      (obj.avatarType = avatarTypeToJSON(message.avatarType));
    message.id !== undefined && (obj.id = Math.round(message.id));
    message.avatarLevel !== undefined &&
      (obj.avatarLevel = Math.round(message.avatarLevel));
    message.avatarRank !== undefined &&
      (obj.avatarRank = Math.round(message.avatarRank));
    message.avatarPromotion !== undefined &&
      (obj.avatarPromotion = Math.round(message.avatarPromotion));
    message.avatarStatus !== undefined &&
      (obj.avatarStatus = message.avatarStatus
        ? AvatarProperty.toJSON(message.avatarStatus)
        : undefined);
    if (message.avatarSkill) {
      obj.avatarSkill = message.avatarSkill.map((e) =>
        e ? AvatarSkillTree.toJSON(e) : undefined
      );
    } else {
      obj.avatarSkill = [];
    }
    if (message.avatarEquipment) {
      obj.avatarEquipment = message.avatarEquipment.map((e) =>
        e ? EquipmentProperty.toJSON(e) : undefined
      );
    } else {
      obj.avatarEquipment = [];
    }
    message.totalTurns !== undefined &&
      (obj.totalTurns = Math.round(message.totalTurns));
    message.totalDamage !== undefined &&
      (obj.totalDamage = message.totalDamage);
    message.totalHeal !== undefined && (obj.totalHeal = message.totalHeal);
    message.totalDamageTaken !== undefined &&
      (obj.totalDamageTaken = message.totalDamageTaken);
    message.totalHpRecover !== undefined &&
      (obj.totalHpRecover = message.totalHpRecover);
    message.totalSpCost !== undefined &&
      (obj.totalSpCost = message.totalSpCost);
    message.stageId !== undefined &&
      (obj.stageId = Math.round(message.stageId));
    message.stageType !== undefined &&
      (obj.stageType = Math.round(message.stageType));
    message.totalBreakDamage !== undefined &&
      (obj.totalBreakDamage = message.totalBreakDamage);
    if (message.attackTypeDamage) {
      obj.attackTypeDamage = message.attackTypeDamage.map((e) =>
        e ? AttackDamageProperty.toJSON(e) : undefined
      );
    } else {
      obj.attackTypeDamage = [];
    }
    if (message.attackTypeBreakDamage) {
      obj.attackTypeBreakDamage = message.attackTypeBreakDamage.map((e) =>
        e ? AttackDamageProperty.toJSON(e) : undefined
      );
    } else {
      obj.attackTypeBreakDamage = [];
    }
    if (message.attackTypeMaxDamage) {
      obj.attackTypeMaxDamage = message.attackTypeMaxDamage.map((e) =>
        e ? AttackDamageProperty.toJSON(e) : undefined
      );
    } else {
      obj.attackTypeMaxDamage = [];
    }
    if (message.skillTimes) {
      obj.skillTimes = message.skillTimes.map((e) =>
        e ? SkillUseProperty.toJSON(e) : undefined
      );
    } else {
      obj.skillTimes = [];
    }
    message.delayCumulate !== undefined &&
      (obj.delayCumulate = message.delayCumulate);
    message.totalSpAdd !== undefined &&
      (obj.totalSpAdd = Math.round(message.totalSpAdd));
    if (message.spAddSource) {
      obj.spAddSource = message.spAddSource.map((e) =>
        e ? SpAddSource.toJSON(e) : undefined
      );
    } else {
      obj.spAddSource = [];
    }
    message.totalBpCost !== undefined &&
      (obj.totalBpCost = Math.round(message.totalBpCost));
    message.dieTimes !== undefined &&
      (obj.dieTimes = Math.round(message.dieTimes));
    message.reviveTimes !== undefined &&
      (obj.reviveTimes = Math.round(message.reviveTimes));
    message.breakTimes !== undefined &&
      (obj.breakTimes = Math.round(message.breakTimes));
    message.extraTurns !== undefined &&
      (obj.extraTurns = Math.round(message.extraTurns));
    message.totalShield !== undefined &&
      (obj.totalShield = message.totalShield);
    message.totalShieldTaken !== undefined &&
      (obj.totalShieldTaken = message.totalShieldTaken);
    message.totalShieldDamage !== undefined &&
      (obj.totalShieldDamage = message.totalShieldDamage);
    message.initialStatus !== undefined &&
      (obj.initialStatus = message.initialStatus
        ? AvatarProperty.toJSON(message.initialStatus)
        : undefined);
    if (message.relics) {
      obj.relics = message.relics.map((e) =>
        e ? BattleRelic.toJSON(e) : undefined
      );
    } else {
      obj.relics = [];
    }
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<AvatarBattleInfo>, I>>(
    object: I
  ): AvatarBattleInfo {
    const message = createBaseAvatarBattleInfo();
    message.avatarType = object.avatarType ?? 0;
    message.id = object.id ?? 0;
    message.avatarLevel = object.avatarLevel ?? 0;
    message.avatarRank = object.avatarRank ?? 0;
    message.avatarPromotion = object.avatarPromotion ?? 0;
    message.avatarStatus =
      object.avatarStatus !== undefined && object.avatarStatus !== null
        ? AvatarProperty.fromPartial(object.avatarStatus)
        : undefined;
    message.avatarSkill =
      object.avatarSkill?.map((e) => AvatarSkillTree.fromPartial(e)) || [];
    message.avatarEquipment =
      object.avatarEquipment?.map((e) => EquipmentProperty.fromPartial(e)) ||
      [];
    message.totalTurns = object.totalTurns ?? 0;
    message.totalDamage = object.totalDamage ?? 0;
    message.totalHeal = object.totalHeal ?? 0;
    message.totalDamageTaken = object.totalDamageTaken ?? 0;
    message.totalHpRecover = object.totalHpRecover ?? 0;
    message.totalSpCost = object.totalSpCost ?? 0;
    message.stageId = object.stageId ?? 0;
    message.stageType = object.stageType ?? 0;
    message.totalBreakDamage = object.totalBreakDamage ?? 0;
    message.attackTypeDamage =
      object.attackTypeDamage?.map((e) =>
        AttackDamageProperty.fromPartial(e)
      ) || [];
    message.attackTypeBreakDamage =
      object.attackTypeBreakDamage?.map((e) =>
        AttackDamageProperty.fromPartial(e)
      ) || [];
    message.attackTypeMaxDamage =
      object.attackTypeMaxDamage?.map((e) =>
        AttackDamageProperty.fromPartial(e)
      ) || [];
    message.skillTimes =
      object.skillTimes?.map((e) => SkillUseProperty.fromPartial(e)) || [];
    message.delayCumulate = object.delayCumulate ?? 0;
    message.totalSpAdd = object.totalSpAdd ?? 0;
    message.spAddSource =
      object.spAddSource?.map((e) => SpAddSource.fromPartial(e)) || [];
    message.totalBpCost = object.totalBpCost ?? 0;
    message.dieTimes = object.dieTimes ?? 0;
    message.reviveTimes = object.reviveTimes ?? 0;
    message.breakTimes = object.breakTimes ?? 0;
    message.extraTurns = object.extraTurns ?? 0;
    message.totalShield = object.totalShield ?? 0;
    message.totalShieldTaken = object.totalShieldTaken ?? 0;
    message.totalShieldDamage = object.totalShieldDamage ?? 0;
    message.initialStatus =
      object.initialStatus !== undefined && object.initialStatus !== null
        ? AvatarProperty.fromPartial(object.initialStatus)
        : undefined;
    message.relics =
      object.relics?.map((e) => BattleRelic.fromPartial(e)) || [];
    return message;
  },
};

function createBaseMonsterProperty(): MonsterProperty {
  return { maxHp: 0, attack: 0, defence: 0, shield: 0, speed: 0, leftHp: 0 };
}

export const MonsterProperty = {
  encode(
    message: MonsterProperty,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.maxHp !== 0) {
      writer.uint32(9).double(message.maxHp);
    }
    if (message.attack !== 0) {
      writer.uint32(17).double(message.attack);
    }
    if (message.defence !== 0) {
      writer.uint32(25).double(message.defence);
    }
    if (message.shield !== 0) {
      writer.uint32(33).double(message.shield);
    }
    if (message.speed !== 0) {
      writer.uint32(41).double(message.speed);
    }
    if (message.leftHp !== 0) {
      writer.uint32(49).double(message.leftHp);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MonsterProperty {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMonsterProperty();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.maxHp = reader.double();
          break;
        case 2:
          message.attack = reader.double();
          break;
        case 3:
          message.defence = reader.double();
          break;
        case 4:
          message.shield = reader.double();
          break;
        case 5:
          message.speed = reader.double();
          break;
        case 6:
          message.leftHp = reader.double();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): MonsterProperty {
    return {
      maxHp: isSet(object.maxHp) ? Number(object.maxHp) : 0,
      attack: isSet(object.attack) ? Number(object.attack) : 0,
      defence: isSet(object.defence) ? Number(object.defence) : 0,
      shield: isSet(object.shield) ? Number(object.shield) : 0,
      speed: isSet(object.speed) ? Number(object.speed) : 0,
      leftHp: isSet(object.leftHp) ? Number(object.leftHp) : 0,
    };
  },

  toJSON(message: MonsterProperty): unknown {
    const obj: any = {};
    message.maxHp !== undefined && (obj.maxHp = message.maxHp);
    message.attack !== undefined && (obj.attack = message.attack);
    message.defence !== undefined && (obj.defence = message.defence);
    message.shield !== undefined && (obj.shield = message.shield);
    message.speed !== undefined && (obj.speed = message.speed);
    message.leftHp !== undefined && (obj.leftHp = message.leftHp);
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<MonsterProperty>, I>>(
    object: I
  ): MonsterProperty {
    const message = createBaseMonsterProperty();
    message.maxHp = object.maxHp ?? 0;
    message.attack = object.attack ?? 0;
    message.defence = object.defence ?? 0;
    message.shield = object.shield ?? 0;
    message.speed = object.speed ?? 0;
    message.leftHp = object.leftHp ?? 0;
    return message;
  },
};

function createBaseMonsterBattleInfo(): MonsterBattleInfo {
  return {
    entityId: 0,
    monsterId: 0,
    monsterTemplateId: 0,
    monsterLevel: 0,
    monsterStatus: undefined,
    totalTurns: 0,
    totalDamage: 0,
    totalHeal: 0,
    totalDamageTaken: 0,
    totalStanceDamageTaken: 0,
    totalHpRecover: 0,
    stageId: 0,
    battleId: 0,
    monsterType: 0,
    attackTypeDamage: [],
    skillTimes: [],
    stageType: 0,
    totalBreakDamageTaken: 0,
    delayCumulate: 0,
    deathSource: 0,
    wave: 0,
    indexInWave: 0,
    phase: 0,
    maxPhase: 0,
    battleTag: 0,
  };
}

export const MonsterBattleInfo = {
  encode(
    message: MonsterBattleInfo,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.entityId !== 0) {
      writer.uint32(8).uint32(message.entityId);
    }
    if (message.monsterId !== 0) {
      writer.uint32(16).uint32(message.monsterId);
    }
    if (message.monsterTemplateId !== 0) {
      writer.uint32(24).uint32(message.monsterTemplateId);
    }
    if (message.monsterLevel !== 0) {
      writer.uint32(32).uint32(message.monsterLevel);
    }
    if (message.monsterStatus !== undefined) {
      MonsterProperty.encode(
        message.monsterStatus,
        writer.uint32(42).fork()
      ).ldelim();
    }
    if (message.totalTurns !== 0) {
      writer.uint32(48).uint32(message.totalTurns);
    }
    if (message.totalDamage !== 0) {
      writer.uint32(57).double(message.totalDamage);
    }
    if (message.totalHeal !== 0) {
      writer.uint32(65).double(message.totalHeal);
    }
    if (message.totalDamageTaken !== 0) {
      writer.uint32(73).double(message.totalDamageTaken);
    }
    if (message.totalStanceDamageTaken !== 0) {
      writer.uint32(81).double(message.totalStanceDamageTaken);
    }
    if (message.totalHpRecover !== 0) {
      writer.uint32(89).double(message.totalHpRecover);
    }
    if (message.stageId !== 0) {
      writer.uint32(96).uint32(message.stageId);
    }
    if (message.battleId !== 0) {
      writer.uint32(104).uint32(message.battleId);
    }
    if (message.monsterType !== 0) {
      writer.uint32(112).uint32(message.monsterType);
    }
    for (const v of message.attackTypeDamage) {
      AttackDamageProperty.encode(v!, writer.uint32(122).fork()).ldelim();
    }
    for (const v of message.skillTimes) {
      SkillUseProperty.encode(v!, writer.uint32(130).fork()).ldelim();
    }
    if (message.stageType !== 0) {
      writer.uint32(136).uint32(message.stageType);
    }
    if (message.totalBreakDamageTaken !== 0) {
      writer.uint32(145).double(message.totalBreakDamageTaken);
    }
    if (message.delayCumulate !== 0) {
      writer.uint32(153).double(message.delayCumulate);
    }
    if (message.deathSource !== 0) {
      writer.uint32(160).int32(message.deathSource);
    }
    if (message.wave !== 0) {
      writer.uint32(168).uint32(message.wave);
    }
    if (message.indexInWave !== 0) {
      writer.uint32(176).int32(message.indexInWave);
    }
    if (message.phase !== 0) {
      writer.uint32(184).uint32(message.phase);
    }
    if (message.maxPhase !== 0) {
      writer.uint32(192).uint32(message.maxPhase);
    }
    if (message.battleTag !== 0) {
      writer.uint32(200).int32(message.battleTag);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MonsterBattleInfo {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMonsterBattleInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.entityId = reader.uint32();
          break;
        case 2:
          message.monsterId = reader.uint32();
          break;
        case 3:
          message.monsterTemplateId = reader.uint32();
          break;
        case 4:
          message.monsterLevel = reader.uint32();
          break;
        case 5:
          message.monsterStatus = MonsterProperty.decode(
            reader,
            reader.uint32()
          );
          break;
        case 6:
          message.totalTurns = reader.uint32();
          break;
        case 7:
          message.totalDamage = reader.double();
          break;
        case 8:
          message.totalHeal = reader.double();
          break;
        case 9:
          message.totalDamageTaken = reader.double();
          break;
        case 10:
          message.totalStanceDamageTaken = reader.double();
          break;
        case 11:
          message.totalHpRecover = reader.double();
          break;
        case 12:
          message.stageId = reader.uint32();
          break;
        case 13:
          message.battleId = reader.uint32();
          break;
        case 14:
          message.monsterType = reader.uint32();
          break;
        case 15:
          message.attackTypeDamage.push(
            AttackDamageProperty.decode(reader, reader.uint32())
          );
          break;
        case 16:
          message.skillTimes.push(
            SkillUseProperty.decode(reader, reader.uint32())
          );
          break;
        case 17:
          message.stageType = reader.uint32();
          break;
        case 18:
          message.totalBreakDamageTaken = reader.double();
          break;
        case 19:
          message.delayCumulate = reader.double();
          break;
        case 20:
          message.deathSource = reader.int32() as any;
          break;
        case 21:
          message.wave = reader.uint32();
          break;
        case 22:
          message.indexInWave = reader.int32();
          break;
        case 23:
          message.phase = reader.uint32();
          break;
        case 24:
          message.maxPhase = reader.uint32();
          break;
        case 25:
          message.battleTag = reader.int32() as any;
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): MonsterBattleInfo {
    return {
      entityId: isSet(object.entityId) ? Number(object.entityId) : 0,
      monsterId: isSet(object.monsterId) ? Number(object.monsterId) : 0,
      monsterTemplateId: isSet(object.monsterTemplateId)
        ? Number(object.monsterTemplateId)
        : 0,
      monsterLevel: isSet(object.monsterLevel)
        ? Number(object.monsterLevel)
        : 0,
      monsterStatus: isSet(object.monsterStatus)
        ? MonsterProperty.fromJSON(object.monsterStatus)
        : undefined,
      totalTurns: isSet(object.totalTurns) ? Number(object.totalTurns) : 0,
      totalDamage: isSet(object.totalDamage) ? Number(object.totalDamage) : 0,
      totalHeal: isSet(object.totalHeal) ? Number(object.totalHeal) : 0,
      totalDamageTaken: isSet(object.totalDamageTaken)
        ? Number(object.totalDamageTaken)
        : 0,
      totalStanceDamageTaken: isSet(object.totalStanceDamageTaken)
        ? Number(object.totalStanceDamageTaken)
        : 0,
      totalHpRecover: isSet(object.totalHpRecover)
        ? Number(object.totalHpRecover)
        : 0,
      stageId: isSet(object.stageId) ? Number(object.stageId) : 0,
      battleId: isSet(object.battleId) ? Number(object.battleId) : 0,
      monsterType: isSet(object.monsterType) ? Number(object.monsterType) : 0,
      attackTypeDamage: Array.isArray(object?.attackTypeDamage)
        ? object.attackTypeDamage.map((e: any) =>
            AttackDamageProperty.fromJSON(e)
          )
        : [],
      skillTimes: Array.isArray(object?.skillTimes)
        ? object.skillTimes.map((e: any) => SkillUseProperty.fromJSON(e))
        : [],
      stageType: isSet(object.stageType) ? Number(object.stageType) : 0,
      totalBreakDamageTaken: isSet(object.totalBreakDamageTaken)
        ? Number(object.totalBreakDamageTaken)
        : 0,
      delayCumulate: isSet(object.delayCumulate)
        ? Number(object.delayCumulate)
        : 0,
      deathSource: isSet(object.deathSource)
        ? deathSourceFromJSON(object.deathSource)
        : 0,
      wave: isSet(object.wave) ? Number(object.wave) : 0,
      indexInWave: isSet(object.indexInWave) ? Number(object.indexInWave) : 0,
      phase: isSet(object.phase) ? Number(object.phase) : 0,
      maxPhase: isSet(object.maxPhase) ? Number(object.maxPhase) : 0,
      battleTag: isSet(object.battleTag)
        ? battleTagFromJSON(object.battleTag)
        : 0,
    };
  },

  toJSON(message: MonsterBattleInfo): unknown {
    const obj: any = {};
    message.entityId !== undefined &&
      (obj.entityId = Math.round(message.entityId));
    message.monsterId !== undefined &&
      (obj.monsterId = Math.round(message.monsterId));
    message.monsterTemplateId !== undefined &&
      (obj.monsterTemplateId = Math.round(message.monsterTemplateId));
    message.monsterLevel !== undefined &&
      (obj.monsterLevel = Math.round(message.monsterLevel));
    message.monsterStatus !== undefined &&
      (obj.monsterStatus = message.monsterStatus
        ? MonsterProperty.toJSON(message.monsterStatus)
        : undefined);
    message.totalTurns !== undefined &&
      (obj.totalTurns = Math.round(message.totalTurns));
    message.totalDamage !== undefined &&
      (obj.totalDamage = message.totalDamage);
    message.totalHeal !== undefined && (obj.totalHeal = message.totalHeal);
    message.totalDamageTaken !== undefined &&
      (obj.totalDamageTaken = message.totalDamageTaken);
    message.totalStanceDamageTaken !== undefined &&
      (obj.totalStanceDamageTaken = message.totalStanceDamageTaken);
    message.totalHpRecover !== undefined &&
      (obj.totalHpRecover = message.totalHpRecover);
    message.stageId !== undefined &&
      (obj.stageId = Math.round(message.stageId));
    message.battleId !== undefined &&
      (obj.battleId = Math.round(message.battleId));
    message.monsterType !== undefined &&
      (obj.monsterType = Math.round(message.monsterType));
    if (message.attackTypeDamage) {
      obj.attackTypeDamage = message.attackTypeDamage.map((e) =>
        e ? AttackDamageProperty.toJSON(e) : undefined
      );
    } else {
      obj.attackTypeDamage = [];
    }
    if (message.skillTimes) {
      obj.skillTimes = message.skillTimes.map((e) =>
        e ? SkillUseProperty.toJSON(e) : undefined
      );
    } else {
      obj.skillTimes = [];
    }
    message.stageType !== undefined &&
      (obj.stageType = Math.round(message.stageType));
    message.totalBreakDamageTaken !== undefined &&
      (obj.totalBreakDamageTaken = message.totalBreakDamageTaken);
    message.delayCumulate !== undefined &&
      (obj.delayCumulate = message.delayCumulate);
    message.deathSource !== undefined &&
      (obj.deathSource = deathSourceToJSON(message.deathSource));
    message.wave !== undefined && (obj.wave = Math.round(message.wave));
    message.indexInWave !== undefined &&
      (obj.indexInWave = Math.round(message.indexInWave));
    message.phase !== undefined && (obj.phase = Math.round(message.phase));
    message.maxPhase !== undefined &&
      (obj.maxPhase = Math.round(message.maxPhase));
    message.battleTag !== undefined &&
      (obj.battleTag = battleTagToJSON(message.battleTag));
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<MonsterBattleInfo>, I>>(
    object: I
  ): MonsterBattleInfo {
    const message = createBaseMonsterBattleInfo();
    message.entityId = object.entityId ?? 0;
    message.monsterId = object.monsterId ?? 0;
    message.monsterTemplateId = object.monsterTemplateId ?? 0;
    message.monsterLevel = object.monsterLevel ?? 0;
    message.monsterStatus =
      object.monsterStatus !== undefined && object.monsterStatus !== null
        ? MonsterProperty.fromPartial(object.monsterStatus)
        : undefined;
    message.totalTurns = object.totalTurns ?? 0;
    message.totalDamage = object.totalDamage ?? 0;
    message.totalHeal = object.totalHeal ?? 0;
    message.totalDamageTaken = object.totalDamageTaken ?? 0;
    message.totalStanceDamageTaken = object.totalStanceDamageTaken ?? 0;
    message.totalHpRecover = object.totalHpRecover ?? 0;
    message.stageId = object.stageId ?? 0;
    message.battleId = object.battleId ?? 0;
    message.monsterType = object.monsterType ?? 0;
    message.attackTypeDamage =
      object.attackTypeDamage?.map((e) =>
        AttackDamageProperty.fromPartial(e)
      ) || [];
    message.skillTimes =
      object.skillTimes?.map((e) => SkillUseProperty.fromPartial(e)) || [];
    message.stageType = object.stageType ?? 0;
    message.totalBreakDamageTaken = object.totalBreakDamageTaken ?? 0;
    message.delayCumulate = object.delayCumulate ?? 0;
    message.deathSource = object.deathSource ?? 0;
    message.wave = object.wave ?? 0;
    message.indexInWave = object.indexInWave ?? 0;
    message.phase = object.phase ?? 0;
    message.maxPhase = object.maxPhase ?? 0;
    message.battleTag = object.battleTag ?? 0;
    return message;
  },
};

function createBaseBattleStatistics(): BattleStatistics {
  return {
    totalBattleTurns: 0,
    totalAutoTurns: 0,
    avatarIdList: [],
    ultraCnt: 0,
    totalDelayCumulate: 0,
    costTime: 0,
    avatarBattleList: [],
    monsterBattleList: [],
    roundCnt: 0,
    cocoonDeadWave: 0,
    avatarBattleTurns: 0,
    monsterBattleTurns: 0,
    customValues: {},
    challengeScore: 0,
    battleChallengeList: [],
  };
}

export const BattleStatistics = {
  encode(
    message: BattleStatistics,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.totalBattleTurns !== 0) {
      writer.uint32(8).uint32(message.totalBattleTurns);
    }
    if (message.totalAutoTurns !== 0) {
      writer.uint32(16).uint32(message.totalAutoTurns);
    }
    writer.uint32(26).fork();
    for (const v of message.avatarIdList) {
      writer.uint32(v);
    }
    writer.ldelim();
    if (message.ultraCnt !== 0) {
      writer.uint32(32).uint32(message.ultraCnt);
    }
    if (message.totalDelayCumulate !== 0) {
      writer.uint32(41).double(message.totalDelayCumulate);
    }
    if (message.costTime !== 0) {
      writer.uint32(49).double(message.costTime);
    }
    for (const v of message.avatarBattleList) {
      AvatarBattleInfo.encode(v!, writer.uint32(58).fork()).ldelim();
    }
    for (const v of message.monsterBattleList) {
      MonsterBattleInfo.encode(v!, writer.uint32(66).fork()).ldelim();
    }
    if (message.roundCnt !== 0) {
      writer.uint32(72).uint32(message.roundCnt);
    }
    if (message.cocoonDeadWave !== 0) {
      writer.uint32(80).uint32(message.cocoonDeadWave);
    }
    if (message.avatarBattleTurns !== 0) {
      writer.uint32(88).uint32(message.avatarBattleTurns);
    }
    if (message.monsterBattleTurns !== 0) {
      writer.uint32(96).uint32(message.monsterBattleTurns);
    }
    Object.entries(message.customValues).forEach(([key, value]) => {
      BattleStatistics_CustomValuesEntry.encode(
        { key: key as any, value },
        writer.uint32(106).fork()
      ).ldelim();
    });
    if (message.challengeScore !== 0) {
      writer.uint32(112).uint32(message.challengeScore);
    }
    writer.uint32(122).fork();
    for (const v of message.battleChallengeList) {
      writer.uint32(v);
    }
    writer.ldelim();
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): BattleStatistics {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBattleStatistics();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.totalBattleTurns = reader.uint32();
          break;
        case 2:
          message.totalAutoTurns = reader.uint32();
          break;
        case 3:
          if ((tag & 7) === 2) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.avatarIdList.push(reader.uint32());
            }
          } else {
            message.avatarIdList.push(reader.uint32());
          }
          break;
        case 4:
          message.ultraCnt = reader.uint32();
          break;
        case 5:
          message.totalDelayCumulate = reader.double();
          break;
        case 6:
          message.costTime = reader.double();
          break;
        case 7:
          message.avatarBattleList.push(
            AvatarBattleInfo.decode(reader, reader.uint32())
          );
          break;
        case 8:
          message.monsterBattleList.push(
            MonsterBattleInfo.decode(reader, reader.uint32())
          );
          break;
        case 9:
          message.roundCnt = reader.uint32();
          break;
        case 10:
          message.cocoonDeadWave = reader.uint32();
          break;
        case 11:
          message.avatarBattleTurns = reader.uint32();
          break;
        case 12:
          message.monsterBattleTurns = reader.uint32();
          break;
        case 13:
          const entry13 = BattleStatistics_CustomValuesEntry.decode(
            reader,
            reader.uint32()
          );
          if (entry13.value !== undefined) {
            message.customValues[entry13.key] = entry13.value;
          }
          break;
        case 14:
          message.challengeScore = reader.uint32();
          break;
        case 15:
          if ((tag & 7) === 2) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.battleChallengeList.push(reader.uint32());
            }
          } else {
            message.battleChallengeList.push(reader.uint32());
          }
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): BattleStatistics {
    return {
      totalBattleTurns: isSet(object.totalBattleTurns)
        ? Number(object.totalBattleTurns)
        : 0,
      totalAutoTurns: isSet(object.totalAutoTurns)
        ? Number(object.totalAutoTurns)
        : 0,
      avatarIdList: Array.isArray(object?.avatarIdList)
        ? object.avatarIdList.map((e: any) => Number(e))
        : [],
      ultraCnt: isSet(object.ultraCnt) ? Number(object.ultraCnt) : 0,
      totalDelayCumulate: isSet(object.totalDelayCumulate)
        ? Number(object.totalDelayCumulate)
        : 0,
      costTime: isSet(object.costTime) ? Number(object.costTime) : 0,
      avatarBattleList: Array.isArray(object?.avatarBattleList)
        ? object.avatarBattleList.map((e: any) => AvatarBattleInfo.fromJSON(e))
        : [],
      monsterBattleList: Array.isArray(object?.monsterBattleList)
        ? object.monsterBattleList.map((e: any) =>
            MonsterBattleInfo.fromJSON(e)
          )
        : [],
      roundCnt: isSet(object.roundCnt) ? Number(object.roundCnt) : 0,
      cocoonDeadWave: isSet(object.cocoonDeadWave)
        ? Number(object.cocoonDeadWave)
        : 0,
      avatarBattleTurns: isSet(object.avatarBattleTurns)
        ? Number(object.avatarBattleTurns)
        : 0,
      monsterBattleTurns: isSet(object.monsterBattleTurns)
        ? Number(object.monsterBattleTurns)
        : 0,
      customValues: isObject(object.customValues)
        ? Object.entries(object.customValues).reduce<{ [key: string]: number }>(
            (acc, [key, value]) => {
              acc[key] = Number(value);
              return acc;
            },
            {}
          )
        : {},
      challengeScore: isSet(object.challengeScore)
        ? Number(object.challengeScore)
        : 0,
      battleChallengeList: Array.isArray(object?.battleChallengeList)
        ? object.battleChallengeList.map((e: any) => Number(e))
        : [],
    };
  },

  toJSON(message: BattleStatistics): unknown {
    const obj: any = {};
    message.totalBattleTurns !== undefined &&
      (obj.totalBattleTurns = Math.round(message.totalBattleTurns));
    message.totalAutoTurns !== undefined &&
      (obj.totalAutoTurns = Math.round(message.totalAutoTurns));
    if (message.avatarIdList) {
      obj.avatarIdList = message.avatarIdList.map((e) => Math.round(e));
    } else {
      obj.avatarIdList = [];
    }
    message.ultraCnt !== undefined &&
      (obj.ultraCnt = Math.round(message.ultraCnt));
    message.totalDelayCumulate !== undefined &&
      (obj.totalDelayCumulate = message.totalDelayCumulate);
    message.costTime !== undefined && (obj.costTime = message.costTime);
    if (message.avatarBattleList) {
      obj.avatarBattleList = message.avatarBattleList.map((e) =>
        e ? AvatarBattleInfo.toJSON(e) : undefined
      );
    } else {
      obj.avatarBattleList = [];
    }
    if (message.monsterBattleList) {
      obj.monsterBattleList = message.monsterBattleList.map((e) =>
        e ? MonsterBattleInfo.toJSON(e) : undefined
      );
    } else {
      obj.monsterBattleList = [];
    }
    message.roundCnt !== undefined &&
      (obj.roundCnt = Math.round(message.roundCnt));
    message.cocoonDeadWave !== undefined &&
      (obj.cocoonDeadWave = Math.round(message.cocoonDeadWave));
    message.avatarBattleTurns !== undefined &&
      (obj.avatarBattleTurns = Math.round(message.avatarBattleTurns));
    message.monsterBattleTurns !== undefined &&
      (obj.monsterBattleTurns = Math.round(message.monsterBattleTurns));
    obj.customValues = {};
    if (message.customValues) {
      Object.entries(message.customValues).forEach(([k, v]) => {
        obj.customValues[k] = v;
      });
    }
    message.challengeScore !== undefined &&
      (obj.challengeScore = Math.round(message.challengeScore));
    if (message.battleChallengeList) {
      obj.battleChallengeList = message.battleChallengeList.map((e) =>
        Math.round(e)
      );
    } else {
      obj.battleChallengeList = [];
    }
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<BattleStatistics>, I>>(
    object: I
  ): BattleStatistics {
    const message = createBaseBattleStatistics();
    message.totalBattleTurns = object.totalBattleTurns ?? 0;
    message.totalAutoTurns = object.totalAutoTurns ?? 0;
    message.avatarIdList = object.avatarIdList?.map((e) => e) || [];
    message.ultraCnt = object.ultraCnt ?? 0;
    message.totalDelayCumulate = object.totalDelayCumulate ?? 0;
    message.costTime = object.costTime ?? 0;
    message.avatarBattleList =
      object.avatarBattleList?.map((e) => AvatarBattleInfo.fromPartial(e)) ||
      [];
    message.monsterBattleList =
      object.monsterBattleList?.map((e) => MonsterBattleInfo.fromPartial(e)) ||
      [];
    message.roundCnt = object.roundCnt ?? 0;
    message.cocoonDeadWave = object.cocoonDeadWave ?? 0;
    message.avatarBattleTurns = object.avatarBattleTurns ?? 0;
    message.monsterBattleTurns = object.monsterBattleTurns ?? 0;
    message.customValues = Object.entries(object.customValues ?? {}).reduce<{
      [key: string]: number;
    }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = Number(value);
      }
      return acc;
    }, {});
    message.challengeScore = object.challengeScore ?? 0;
    message.battleChallengeList =
      object.battleChallengeList?.map((e) => e) || [];
    return message;
  },
};

function createBaseBattleStatistics_CustomValuesEntry(): BattleStatistics_CustomValuesEntry {
  return { key: "", value: 0 };
}

export const BattleStatistics_CustomValuesEntry = {
  encode(
    message: BattleStatistics_CustomValuesEntry,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== 0) {
      writer.uint32(21).float(message.value);
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): BattleStatistics_CustomValuesEntry {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBattleStatistics_CustomValuesEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.key = reader.string();
          break;
        case 2:
          message.value = reader.float();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): BattleStatistics_CustomValuesEntry {
    return {
      key: isSet(object.key) ? String(object.key) : "",
      value: isSet(object.value) ? Number(object.value) : 0,
    };
  },

  toJSON(message: BattleStatistics_CustomValuesEntry): unknown {
    const obj: any = {};
    message.key !== undefined && (obj.key = message.key);
    message.value !== undefined && (obj.value = message.value);
    return obj;
  },

  fromPartial<
    I extends Exact<DeepPartial<BattleStatistics_CustomValuesEntry>, I>
  >(object: I): BattleStatistics_CustomValuesEntry {
    const message = createBaseBattleStatistics_CustomValuesEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? 0;
    return message;
  },
};

function createBaseHeroPath(): HeroPath {
  return { heroPathType: 0, level: 0, exp: 0 };
}

export const HeroPath = {
  encode(
    message: HeroPath,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.heroPathType !== 0) {
      writer.uint32(8).uint32(message.heroPathType);
    }
    if (message.level !== 0) {
      writer.uint32(16).uint32(message.level);
    }
    if (message.exp !== 0) {
      writer.uint32(24).uint32(message.exp);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): HeroPath {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHeroPath();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.heroPathType = reader.uint32();
          break;
        case 2:
          message.level = reader.uint32();
          break;
        case 3:
          message.exp = reader.uint32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): HeroPath {
    return {
      heroPathType: isSet(object.heroPathType)
        ? Number(object.heroPathType)
        : 0,
      level: isSet(object.level) ? Number(object.level) : 0,
      exp: isSet(object.exp) ? Number(object.exp) : 0,
    };
  },

  toJSON(message: HeroPath): unknown {
    const obj: any = {};
    message.heroPathType !== undefined &&
      (obj.heroPathType = Math.round(message.heroPathType));
    message.level !== undefined && (obj.level = Math.round(message.level));
    message.exp !== undefined && (obj.exp = Math.round(message.exp));
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<HeroPath>, I>>(object: I): HeroPath {
    const message = createBaseHeroPath();
    message.heroPathType = object.heroPathType ?? 0;
    message.level = object.level ?? 0;
    message.exp = object.exp ?? 0;
    return message;
  },
};

function createBaseBattleResult(): BattleResult {
  return {
    retcode: 0,
    endStatus: 0,
    stt: undefined,
    gameCoreLogEncode: new Uint8Array(),
    tags: {},
    mismatchTurnCount: 0,
  };
}

export const BattleResult = {
  encode(
    message: BattleResult,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.retcode !== 0) {
      writer.uint32(8).int32(message.retcode);
    }
    if (message.endStatus !== 0) {
      writer.uint32(16).int32(message.endStatus);
    }
    if (message.stt !== undefined) {
      BattleStatistics.encode(message.stt, writer.uint32(26).fork()).ldelim();
    }
    if (message.gameCoreLogEncode.length !== 0) {
      writer.uint32(34).bytes(message.gameCoreLogEncode);
    }
    Object.entries(message.tags).forEach(([key, value]) => {
      BattleResult_TagsEntry.encode(
        { key: key as any, value },
        writer.uint32(42).fork()
      ).ldelim();
    });
    if (message.mismatchTurnCount !== 0) {
      writer.uint32(48).uint32(message.mismatchTurnCount);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): BattleResult {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBattleResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.retcode = reader.int32() as any;
          break;
        case 2:
          message.endStatus = reader.int32() as any;
          break;
        case 3:
          message.stt = BattleStatistics.decode(reader, reader.uint32());
          break;
        case 4:
          message.gameCoreLogEncode = reader.bytes();
          break;
        case 5:
          const entry5 = BattleResult_TagsEntry.decode(reader, reader.uint32());
          if (entry5.value !== undefined) {
            message.tags[entry5.key] = entry5.value;
          }
          break;
        case 6:
          message.mismatchTurnCount = reader.uint32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): BattleResult {
    return {
      retcode: isSet(object.retcode)
        ? battleCheckResultTypeFromJSON(object.retcode)
        : 0,
      endStatus: isSet(object.endStatus)
        ? battleEndStatusFromJSON(object.endStatus)
        : 0,
      stt: isSet(object.stt)
        ? BattleStatistics.fromJSON(object.stt)
        : undefined,
      gameCoreLogEncode: isSet(object.gameCoreLogEncode)
        ? bytesFromBase64(object.gameCoreLogEncode)
        : new Uint8Array(),
      tags: isObject(object.tags)
        ? Object.entries(object.tags).reduce<{ [key: string]: number }>(
            (acc, [key, value]) => {
              acc[key] = Number(value);
              return acc;
            },
            {}
          )
        : {},
      mismatchTurnCount: isSet(object.mismatchTurnCount)
        ? Number(object.mismatchTurnCount)
        : 0,
    };
  },

  toJSON(message: BattleResult): unknown {
    const obj: any = {};
    message.retcode !== undefined &&
      (obj.retcode = battleCheckResultTypeToJSON(message.retcode));
    message.endStatus !== undefined &&
      (obj.endStatus = battleEndStatusToJSON(message.endStatus));
    message.stt !== undefined &&
      (obj.stt = message.stt
        ? BattleStatistics.toJSON(message.stt)
        : undefined);
    message.gameCoreLogEncode !== undefined &&
      (obj.gameCoreLogEncode = base64FromBytes(
        message.gameCoreLogEncode !== undefined
          ? message.gameCoreLogEncode
          : new Uint8Array()
      ));
    obj.tags = {};
    if (message.tags) {
      Object.entries(message.tags).forEach(([k, v]) => {
        obj.tags[k] = Math.round(v);
      });
    }
    message.mismatchTurnCount !== undefined &&
      (obj.mismatchTurnCount = Math.round(message.mismatchTurnCount));
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<BattleResult>, I>>(
    object: I
  ): BattleResult {
    const message = createBaseBattleResult();
    message.retcode = object.retcode ?? 0;
    message.endStatus = object.endStatus ?? 0;
    message.stt =
      object.stt !== undefined && object.stt !== null
        ? BattleStatistics.fromPartial(object.stt)
        : undefined;
    message.gameCoreLogEncode = object.gameCoreLogEncode ?? new Uint8Array();
    message.tags = Object.entries(object.tags ?? {}).reduce<{
      [key: string]: number;
    }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = Number(value);
      }
      return acc;
    }, {});
    message.mismatchTurnCount = object.mismatchTurnCount ?? 0;
    return message;
  },
};

function createBaseBattleResult_TagsEntry(): BattleResult_TagsEntry {
  return { key: "", value: 0 };
}

export const BattleResult_TagsEntry = {
  encode(
    message: BattleResult_TagsEntry,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== 0) {
      writer.uint32(16).uint32(message.value);
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): BattleResult_TagsEntry {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBattleResult_TagsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.key = reader.string();
          break;
        case 2:
          message.value = reader.uint32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): BattleResult_TagsEntry {
    return {
      key: isSet(object.key) ? String(object.key) : "",
      value: isSet(object.value) ? Number(object.value) : 0,
    };
  },

  toJSON(message: BattleResult_TagsEntry): unknown {
    const obj: any = {};
    message.key !== undefined && (obj.key = message.key);
    message.value !== undefined && (obj.value = Math.round(message.value));
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<BattleResult_TagsEntry>, I>>(
    object: I
  ): BattleResult_TagsEntry {
    const message = createBaseBattleResult_TagsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? 0;
    return message;
  },
};

function createBaseCharacterSnapshot(): CharacterSnapshot {
  return { runtimeId: 0, properties: [] };
}

export const CharacterSnapshot = {
  encode(
    message: CharacterSnapshot,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.runtimeId !== 0) {
      writer.uint32(8).uint32(message.runtimeId);
    }
    writer.uint32(18).fork();
    for (const v of message.properties) {
      writer.uint64(v);
    }
    writer.ldelim();
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CharacterSnapshot {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCharacterSnapshot();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.runtimeId = reader.uint32();
          break;
        case 2:
          if ((tag & 7) === 2) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.properties.push(longToNumber(reader.uint64() as Long));
            }
          } else {
            message.properties.push(longToNumber(reader.uint64() as Long));
          }
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): CharacterSnapshot {
    return {
      runtimeId: isSet(object.runtimeId) ? Number(object.runtimeId) : 0,
      properties: Array.isArray(object?.properties)
        ? object.properties.map((e: any) => Number(e))
        : [],
    };
  },

  toJSON(message: CharacterSnapshot): unknown {
    const obj: any = {};
    message.runtimeId !== undefined &&
      (obj.runtimeId = Math.round(message.runtimeId));
    if (message.properties) {
      obj.properties = message.properties.map((e) => Math.round(e));
    } else {
      obj.properties = [];
    }
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<CharacterSnapshot>, I>>(
    object: I
  ): CharacterSnapshot {
    const message = createBaseCharacterSnapshot();
    message.runtimeId = object.runtimeId ?? 0;
    message.properties = object.properties?.map((e) => e) || [];
    return message;
  },
};

function createBaseAnimEventSnapshot(): AnimEventSnapshot {
  return { eventName: "", count: 0 };
}

export const AnimEventSnapshot = {
  encode(
    message: AnimEventSnapshot,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.eventName !== "") {
      writer.uint32(10).string(message.eventName);
    }
    if (message.count !== 0) {
      writer.uint32(16).uint32(message.count);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): AnimEventSnapshot {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAnimEventSnapshot();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.eventName = reader.string();
          break;
        case 2:
          message.count = reader.uint32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): AnimEventSnapshot {
    return {
      eventName: isSet(object.eventName) ? String(object.eventName) : "",
      count: isSet(object.count) ? Number(object.count) : 0,
    };
  },

  toJSON(message: AnimEventSnapshot): unknown {
    const obj: any = {};
    message.eventName !== undefined && (obj.eventName = message.eventName);
    message.count !== undefined && (obj.count = Math.round(message.count));
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<AnimEventSnapshot>, I>>(
    object: I
  ): AnimEventSnapshot {
    const message = createBaseAnimEventSnapshot();
    message.eventName = object.eventName ?? "";
    message.count = object.count ?? 0;
    return message;
  },
};

function createBaseLoginActivityData(): LoginActivityData {
  return { id: 0, loginDays: 0, hasTakenLoginActivityRewardDaysList: [] };
}

export const LoginActivityData = {
  encode(
    message: LoginActivityData,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.id !== 0) {
      writer.uint32(8).uint32(message.id);
    }
    if (message.loginDays !== 0) {
      writer.uint32(16).uint32(message.loginDays);
    }
    writer.uint32(26).fork();
    for (const v of message.hasTakenLoginActivityRewardDaysList) {
      writer.uint32(v);
    }
    writer.ldelim();
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): LoginActivityData {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLoginActivityData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.id = reader.uint32();
          break;
        case 2:
          message.loginDays = reader.uint32();
          break;
        case 3:
          if ((tag & 7) === 2) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.hasTakenLoginActivityRewardDaysList.push(reader.uint32());
            }
          } else {
            message.hasTakenLoginActivityRewardDaysList.push(reader.uint32());
          }
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): LoginActivityData {
    return {
      id: isSet(object.id) ? Number(object.id) : 0,
      loginDays: isSet(object.loginDays) ? Number(object.loginDays) : 0,
      hasTakenLoginActivityRewardDaysList: Array.isArray(
        object?.hasTakenLoginActivityRewardDaysList
      )
        ? object.hasTakenLoginActivityRewardDaysList.map((e: any) => Number(e))
        : [],
    };
  },

  toJSON(message: LoginActivityData): unknown {
    const obj: any = {};
    message.id !== undefined && (obj.id = Math.round(message.id));
    message.loginDays !== undefined &&
      (obj.loginDays = Math.round(message.loginDays));
    if (message.hasTakenLoginActivityRewardDaysList) {
      obj.hasTakenLoginActivityRewardDaysList =
        message.hasTakenLoginActivityRewardDaysList.map((e) => Math.round(e));
    } else {
      obj.hasTakenLoginActivityRewardDaysList = [];
    }
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<LoginActivityData>, I>>(
    object: I
  ): LoginActivityData {
    const message = createBaseLoginActivityData();
    message.id = object.id ?? 0;
    message.loginDays = object.loginDays ?? 0;
    message.hasTakenLoginActivityRewardDaysList =
      object.hasTakenLoginActivityRewardDaysList?.map((e) => e) || [];
    return message;
  },
};

function createBaseGetLoginActivityCsReq(): GetLoginActivityCsReq {
  return {};
}

export const GetLoginActivityCsReq = {
  encode(
    _: GetLoginActivityCsReq,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): GetLoginActivityCsReq {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetLoginActivityCsReq();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(_: any): GetLoginActivityCsReq {
    return {};
  },

  toJSON(_: GetLoginActivityCsReq): unknown {
    const obj: any = {};
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<GetLoginActivityCsReq>, I>>(
    _: I
  ): GetLoginActivityCsReq {
    const message = createBaseGetLoginActivityCsReq();
    return message;
  },
};

function createBaseGetLoginActivityScRsp(): GetLoginActivityScRsp {
  return { retcode: 0, loginActivityList: [] };
}

export const GetLoginActivityScRsp = {
  encode(
    message: GetLoginActivityScRsp,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.retcode !== 0) {
      writer.uint32(8).uint32(message.retcode);
    }
    for (const v of message.loginActivityList) {
      LoginActivityData.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): GetLoginActivityScRsp {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetLoginActivityScRsp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.retcode = reader.uint32();
          break;
        case 2:
          message.loginActivityList.push(
            LoginActivityData.decode(reader, reader.uint32())
          );
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): GetLoginActivityScRsp {
    return {
      retcode: isSet(object.retcode) ? Number(object.retcode) : 0,
      loginActivityList: Array.isArray(object?.loginActivityList)
        ? object.loginActivityList.map((e: any) =>
            LoginActivityData.fromJSON(e)
          )
        : [],
    };
  },

  toJSON(message: GetLoginActivityScRsp): unknown {
    const obj: any = {};
    message.retcode !== undefined &&
      (obj.retcode = Math.round(message.retcode));
    if (message.loginActivityList) {
      obj.loginActivityList = message.loginActivityList.map((e) =>
        e ? LoginActivityData.toJSON(e) : undefined
      );
    } else {
      obj.loginActivityList = [];
    }
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<GetLoginActivityScRsp>, I>>(
    object: I
  ): GetLoginActivityScRsp {
    const message = createBaseGetLoginActivityScRsp();
    message.retcode = object.retcode ?? 0;
    message.loginActivityList =
      object.loginActivityList?.map((e) => LoginActivityData.fromPartial(e)) ||
      [];
    return message;
  },
};

function createBaseTakeLoginActivityRewardCsReq(): TakeLoginActivityRewardCsReq {
  return { id: 0, takeDays: 0 };
}

export const TakeLoginActivityRewardCsReq = {
  encode(
    message: TakeLoginActivityRewardCsReq,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.id !== 0) {
      writer.uint32(8).uint32(message.id);
    }
    if (message.takeDays !== 0) {
      writer.uint32(16).uint32(message.takeDays);
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): TakeLoginActivityRewardCsReq {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTakeLoginActivityRewardCsReq();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.id = reader.uint32();
          break;
        case 2:
          message.takeDays = reader.uint32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): TakeLoginActivityRewardCsReq {
    return {
      id: isSet(object.id) ? Number(object.id) : 0,
      takeDays: isSet(object.takeDays) ? Number(object.takeDays) : 0,
    };
  },

  toJSON(message: TakeLoginActivityRewardCsReq): unknown {
    const obj: any = {};
    message.id !== undefined && (obj.id = Math.round(message.id));
    message.takeDays !== undefined &&
      (obj.takeDays = Math.round(message.takeDays));
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<TakeLoginActivityRewardCsReq>, I>>(
    object: I
  ): TakeLoginActivityRewardCsReq {
    const message = createBaseTakeLoginActivityRewardCsReq();
    message.id = object.id ?? 0;
    message.takeDays = object.takeDays ?? 0;
    return message;
  },
};

function createBaseTakeLoginActivityRewardScRsp(): TakeLoginActivityRewardScRsp {
  return { retcode: 0, id: 0, takeDays: 0, reward: undefined };
}

export const TakeLoginActivityRewardScRsp = {
  encode(
    message: TakeLoginActivityRewardScRsp,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.retcode !== 0) {
      writer.uint32(8).uint32(message.retcode);
    }
    if (message.id !== 0) {
      writer.uint32(16).uint32(message.id);
    }
    if (message.takeDays !== 0) {
      writer.uint32(24).uint32(message.takeDays);
    }
    if (message.reward !== undefined) {
      ItemList.encode(message.reward, writer.uint32(34).fork()).ldelim();
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): TakeLoginActivityRewardScRsp {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTakeLoginActivityRewardScRsp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.retcode = reader.uint32();
          break;
        case 2:
          message.id = reader.uint32();
          break;
        case 3:
          message.takeDays = reader.uint32();
          break;
        case 4:
          message.reward = ItemList.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): TakeLoginActivityRewardScRsp {
    return {
      retcode: isSet(object.retcode) ? Number(object.retcode) : 0,
      id: isSet(object.id) ? Number(object.id) : 0,
      takeDays: isSet(object.takeDays) ? Number(object.takeDays) : 0,
      reward: isSet(object.reward)
        ? ItemList.fromJSON(object.reward)
        : undefined,
    };
  },

  toJSON(message: TakeLoginActivityRewardScRsp): unknown {
    const obj: any = {};
    message.retcode !== undefined &&
      (obj.retcode = Math.round(message.retcode));
    message.id !== undefined && (obj.id = Math.round(message.id));
    message.takeDays !== undefined &&
      (obj.takeDays = Math.round(message.takeDays));
    message.reward !== undefined &&
      (obj.reward = message.reward
        ? ItemList.toJSON(message.reward)
        : undefined);
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<TakeLoginActivityRewardScRsp>, I>>(
    object: I
  ): TakeLoginActivityRewardScRsp {
    const message = createBaseTakeLoginActivityRewardScRsp();
    message.retcode = object.retcode ?? 0;
    message.id = object.id ?? 0;
    message.takeDays = object.takeDays ?? 0;
    message.reward =
      object.reward !== undefined && object.reward !== null
        ? ItemList.fromPartial(object.reward)
        : undefined;
    return message;
  },
};

function createBaseEnterAdventureCsReq(): EnterAdventureCsReq {
  return { mapId: 0 };
}

export const EnterAdventureCsReq = {
  encode(
    message: EnterAdventureCsReq,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.mapId !== 0) {
      writer.uint32(8).uint32(message.mapId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): EnterAdventureCsReq {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEnterAdventureCsReq();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.mapId = reader.uint32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): EnterAdventureCsReq {
    return {
      mapId: isSet(object.mapId) ? Number(object.mapId) : 0,
    };
  },

  toJSON(message: EnterAdventureCsReq): unknown {
    const obj: any = {};
    message.mapId !== undefined && (obj.mapId = Math.round(message.mapId));
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<EnterAdventureCsReq>, I>>(
    object: I
  ): EnterAdventureCsReq {
    const message = createBaseEnterAdventureCsReq();
    message.mapId = object.mapId ?? 0;
    return message;
  },
};

function createBaseEnterAdventureScRsp(): EnterAdventureScRsp {
  return { retcode: 0, scene: undefined };
}

export const EnterAdventureScRsp = {
  encode(
    message: EnterAdventureScRsp,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.retcode !== 0) {
      writer.uint32(8).uint32(message.retcode);
    }
    if (message.scene !== undefined) {
      SceneInfo.encode(message.scene, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): EnterAdventureScRsp {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEnterAdventureScRsp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.retcode = reader.uint32();
          break;
        case 2:
          message.scene = SceneInfo.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): EnterAdventureScRsp {
    return {
      retcode: isSet(object.retcode) ? Number(object.retcode) : 0,
      scene: isSet(object.scene) ? SceneInfo.fromJSON(object.scene) : undefined,
    };
  },

  toJSON(message: EnterAdventureScRsp): unknown {
    const obj: any = {};
    message.retcode !== undefined &&
      (obj.retcode = Math.round(message.retcode));
    message.scene !== undefined &&
      (obj.scene = message.scene ? SceneInfo.toJSON(message.scene) : undefined);
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<EnterAdventureScRsp>, I>>(
    object: I
  ): EnterAdventureScRsp {
    const message = createBaseEnterAdventureScRsp();
    message.retcode = object.retcode ?? 0;
    message.scene =
      object.scene !== undefined && object.scene !== null
        ? SceneInfo.fromPartial(object.scene)
        : undefined;
    return message;
  },
};

function createBaseArchiveData(): ArchiveData {
  return { itemIdList: [], monsterTemplateIdList: [] };
}

export const ArchiveData = {
  encode(
    message: ArchiveData,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    writer.uint32(10).fork();
    for (const v of message.itemIdList) {
      writer.uint32(v);
    }
    writer.ldelim();
    writer.uint32(18).fork();
    for (const v of message.monsterTemplateIdList) {
      writer.uint32(v);
    }
    writer.ldelim();
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ArchiveData {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseArchiveData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if ((tag & 7) === 2) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.itemIdList.push(reader.uint32());
            }
          } else {
            message.itemIdList.push(reader.uint32());
          }
          break;
        case 2:
          if ((tag & 7) === 2) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.monsterTemplateIdList.push(reader.uint32());
            }
          } else {
            message.monsterTemplateIdList.push(reader.uint32());
          }
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): ArchiveData {
    return {
      itemIdList: Array.isArray(object?.itemIdList)
        ? object.itemIdList.map((e: any) => Number(e))
        : [],
      monsterTemplateIdList: Array.isArray(object?.monsterTemplateIdList)
        ? object.monsterTemplateIdList.map((e: any) => Number(e))
        : [],
    };
  },

  toJSON(message: ArchiveData): unknown {
    const obj: any = {};
    if (message.itemIdList) {
      obj.itemIdList = message.itemIdList.map((e) => Math.round(e));
    } else {
      obj.itemIdList = [];
    }
    if (message.monsterTemplateIdList) {
      obj.monsterTemplateIdList = message.monsterTemplateIdList.map((e) =>
        Math.round(e)
      );
    } else {
      obj.monsterTemplateIdList = [];
    }
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<ArchiveData>, I>>(
    object: I
  ): ArchiveData {
    const message = createBaseArchiveData();
    message.itemIdList = object.itemIdList?.map((e) => e) || [];
    message.monsterTemplateIdList =
      object.monsterTemplateIdList?.map((e) => e) || [];
    return message;
  },
};

function createBaseGetArchiveDataCsReq(): GetArchiveDataCsReq {
  return {};
}

export const GetArchiveDataCsReq = {
  encode(
    _: GetArchiveDataCsReq,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetArchiveDataCsReq {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetArchiveDataCsReq();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(_: any): GetArchiveDataCsReq {
    return {};
  },

  toJSON(_: GetArchiveDataCsReq): unknown {
    const obj: any = {};
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<GetArchiveDataCsReq>, I>>(
    _: I
  ): GetArchiveDataCsReq {
    const message = createBaseGetArchiveDataCsReq();
    return message;
  },
};

function createBaseGetArchiveDataScRsp(): GetArchiveDataScRsp {
  return { retcode: 0, archiveData: undefined };
}

export const GetArchiveDataScRsp = {
  encode(
    message: GetArchiveDataScRsp,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.retcode !== 0) {
      writer.uint32(8).uint32(message.retcode);
    }
    if (message.archiveData !== undefined) {
      ArchiveData.encode(
        message.archiveData,
        writer.uint32(18).fork()
      ).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetArchiveDataScRsp {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetArchiveDataScRsp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.retcode = reader.uint32();
          break;
        case 2:
          message.archiveData = ArchiveData.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): GetArchiveDataScRsp {
    return {
      retcode: isSet(object.retcode) ? Number(object.retcode) : 0,
      archiveData: isSet(object.archiveData)
        ? ArchiveData.fromJSON(object.archiveData)
        : undefined,
    };
  },

  toJSON(message: GetArchiveDataScRsp): unknown {
    const obj: any = {};
    message.retcode !== undefined &&
      (obj.retcode = Math.round(message.retcode));
    message.archiveData !== undefined &&
      (obj.archiveData = message.archiveData
        ? ArchiveData.toJSON(message.archiveData)
        : undefined);
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<GetArchiveDataScRsp>, I>>(
    object: I
  ): GetArchiveDataScRsp {
    const message = createBaseGetArchiveDataScRsp();
    message.retcode = object.retcode ?? 0;
    message.archiveData =
      object.archiveData !== undefined && object.archiveData !== null
        ? ArchiveData.fromPartial(object.archiveData)
        : undefined;
    return message;
  },
};

function createBaseGetUpdatedArchiveDataCsReq(): GetUpdatedArchiveDataCsReq {
  return {};
}

export const GetUpdatedArchiveDataCsReq = {
  encode(
    _: GetUpdatedArchiveDataCsReq,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): GetUpdatedArchiveDataCsReq {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetUpdatedArchiveDataCsReq();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(_: any): GetUpdatedArchiveDataCsReq {
    return {};
  },

  toJSON(_: GetUpdatedArchiveDataCsReq): unknown {
    const obj: any = {};
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<GetUpdatedArchiveDataCsReq>, I>>(
    _: I
  ): GetUpdatedArchiveDataCsReq {
    const message = createBaseGetUpdatedArchiveDataCsReq();
    return message;
  },
};

function createBaseGetUpdatedArchiveDataScRsp(): GetUpdatedArchiveDataScRsp {
  return { retcode: 0, archiveData: undefined };
}

export const GetUpdatedArchiveDataScRsp = {
  encode(
    message: GetUpdatedArchiveDataScRsp,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.retcode !== 0) {
      writer.uint32(8).uint32(message.retcode);
    }
    if (message.archiveData !== undefined) {
      ArchiveData.encode(
        message.archiveData,
        writer.uint32(18).fork()
      ).ldelim();
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): GetUpdatedArchiveDataScRsp {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetUpdatedArchiveDataScRsp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.retcode = reader.uint32();
          break;
        case 2:
          message.archiveData = ArchiveData.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): GetUpdatedArchiveDataScRsp {
    return {
      retcode: isSet(object.retcode) ? Number(object.retcode) : 0,
      archiveData: isSet(object.archiveData)
        ? ArchiveData.fromJSON(object.archiveData)
        : undefined,
    };
  },

  toJSON(message: GetUpdatedArchiveDataScRsp): unknown {
    const obj: any = {};
    message.retcode !== undefined &&
      (obj.retcode = Math.round(message.retcode));
    message.archiveData !== undefined &&
      (obj.archiveData = message.archiveData
        ? ArchiveData.toJSON(message.archiveData)
        : undefined);
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<GetUpdatedArchiveDataScRsp>, I>>(
    object: I
  ): GetUpdatedArchiveDataScRsp {
    const message = createBaseGetUpdatedArchiveDataScRsp();
    message.retcode = object.retcode ?? 0;
    message.archiveData =
      object.archiveData !== undefined && object.archiveData !== null
        ? ArchiveData.fromPartial(object.archiveData)
        : undefined;
    return message;
  },
};

function createBaseGetAvatarDataCsReq(): GetAvatarDataCsReq {
  return { isGetAll: false, baseAvatarIdList: [] };
}

export const GetAvatarDataCsReq = {
  encode(
    message: GetAvatarDataCsReq,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.isGetAll === true) {
      writer.uint32(8).bool(message.isGetAll);
    }
    writer.uint32(18).fork();
    for (const v of message.baseAvatarIdList) {
      writer.uint32(v);
    }
    writer.ldelim();
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetAvatarDataCsReq {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetAvatarDataCsReq();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.isGetAll = reader.bool();
          break;
        case 2:
          if ((tag & 7) === 2) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.baseAvatarIdList.push(reader.uint32());
            }
          } else {
            message.baseAvatarIdList.push(reader.uint32());
          }
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): GetAvatarDataCsReq {
    return {
      isGetAll: isSet(object.isGetAll) ? Boolean(object.isGetAll) : false,
      baseAvatarIdList: Array.isArray(object?.baseAvatarIdList)
        ? object.baseAvatarIdList.map((e: any) => Number(e))
        : [],
    };
  },

  toJSON(message: GetAvatarDataCsReq): unknown {
    const obj: any = {};
    message.isGetAll !== undefined && (obj.isGetAll = message.isGetAll);
    if (message.baseAvatarIdList) {
      obj.baseAvatarIdList = message.baseAvatarIdList.map((e) => Math.round(e));
    } else {
      obj.baseAvatarIdList = [];
    }
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<GetAvatarDataCsReq>, I>>(
    object: I
  ): GetAvatarDataCsReq {
    const message = createBaseGetAvatarDataCsReq();
    message.isGetAll = object.isGetAll ?? false;
    message.baseAvatarIdList = object.baseAvatarIdList?.map((e) => e) || [];
    return message;
  },
};

function createBaseEquipRelic(): EquipRelic {
  return { type: 0, relicUniqueId: 0 };
}

export const EquipRelic = {
  encode(
    message: EquipRelic,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.type !== 0) {
      writer.uint32(8).uint32(message.type);
    }
    if (message.relicUniqueId !== 0) {
      writer.uint32(16).uint32(message.relicUniqueId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): EquipRelic {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEquipRelic();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.type = reader.uint32();
          break;
        case 2:
          message.relicUniqueId = reader.uint32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): EquipRelic {
    return {
      type: isSet(object.type) ? Number(object.type) : 0,
      relicUniqueId: isSet(object.relicUniqueId)
        ? Number(object.relicUniqueId)
        : 0,
    };
  },

  toJSON(message: EquipRelic): unknown {
    const obj: any = {};
    message.type !== undefined && (obj.type = Math.round(message.type));
    message.relicUniqueId !== undefined &&
      (obj.relicUniqueId = Math.round(message.relicUniqueId));
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<EquipRelic>, I>>(
    object: I
  ): EquipRelic {
    const message = createBaseEquipRelic();
    message.type = object.type ?? 0;
    message.relicUniqueId = object.relicUniqueId ?? 0;
    return message;
  },
};

function createBaseAvatar(): Avatar {
  return {
    baseAvatarId: 0,
    exp: 0,
    level: 0,
    promotion: 0,
    rank: 0,
    skilltreeList: [],
    equipmentUniqueId: 0,
    equipRelicList: [],
  };
}

export const Avatar = {
  encode(
    message: Avatar,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.baseAvatarId !== 0) {
      writer.uint32(8).uint32(message.baseAvatarId);
    }
    if (message.exp !== 0) {
      writer.uint32(16).uint32(message.exp);
    }
    if (message.level !== 0) {
      writer.uint32(24).uint32(message.level);
    }
    if (message.promotion !== 0) {
      writer.uint32(32).uint32(message.promotion);
    }
    if (message.rank !== 0) {
      writer.uint32(40).uint32(message.rank);
    }
    for (const v of message.skilltreeList) {
      AvatarSkillTree.encode(v!, writer.uint32(50).fork()).ldelim();
    }
    if (message.equipmentUniqueId !== 0) {
      writer.uint32(56).uint32(message.equipmentUniqueId);
    }
    for (const v of message.equipRelicList) {
      EquipRelic.encode(v!, writer.uint32(66).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Avatar {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAvatar();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.baseAvatarId = reader.uint32();
          break;
        case 2:
          message.exp = reader.uint32();
          break;
        case 3:
          message.level = reader.uint32();
          break;
        case 4:
          message.promotion = reader.uint32();
          break;
        case 5:
          message.rank = reader.uint32();
          break;
        case 6:
          message.skilltreeList.push(
            AvatarSkillTree.decode(reader, reader.uint32())
          );
          break;
        case 7:
          message.equipmentUniqueId = reader.uint32();
          break;
        case 8:
          message.equipRelicList.push(
            EquipRelic.decode(reader, reader.uint32())
          );
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): Avatar {
    return {
      baseAvatarId: isSet(object.baseAvatarId)
        ? Number(object.baseAvatarId)
        : 0,
      exp: isSet(object.exp) ? Number(object.exp) : 0,
      level: isSet(object.level) ? Number(object.level) : 0,
      promotion: isSet(object.promotion) ? Number(object.promotion) : 0,
      rank: isSet(object.rank) ? Number(object.rank) : 0,
      skilltreeList: Array.isArray(object?.skilltreeList)
        ? object.skilltreeList.map((e: any) => AvatarSkillTree.fromJSON(e))
        : [],
      equipmentUniqueId: isSet(object.equipmentUniqueId)
        ? Number(object.equipmentUniqueId)
        : 0,
      equipRelicList: Array.isArray(object?.equipRelicList)
        ? object.equipRelicList.map((e: any) => EquipRelic.fromJSON(e))
        : [],
    };
  },

  toJSON(message: Avatar): unknown {
    const obj: any = {};
    message.baseAvatarId !== undefined &&
      (obj.baseAvatarId = Math.round(message.baseAvatarId));
    message.exp !== undefined && (obj.exp = Math.round(message.exp));
    message.level !== undefined && (obj.level = Math.round(message.level));
    message.promotion !== undefined &&
      (obj.promotion = Math.round(message.promotion));
    message.rank !== undefined && (obj.rank = Math.round(message.rank));
    if (message.skilltreeList) {
      obj.skilltreeList = message.skilltreeList.map((e) =>
        e ? AvatarSkillTree.toJSON(e) : undefined
      );
    } else {
      obj.skilltreeList = [];
    }
    message.equipmentUniqueId !== undefined &&
      (obj.equipmentUniqueId = Math.round(message.equipmentUniqueId));
    if (message.equipRelicList) {
      obj.equipRelicList = message.equipRelicList.map((e) =>
        e ? EquipRelic.toJSON(e) : undefined
      );
    } else {
      obj.equipRelicList = [];
    }
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<Avatar>, I>>(object: I): Avatar {
    const message = createBaseAvatar();
    message.baseAvatarId = object.baseAvatarId ?? 0;
    message.exp = object.exp ?? 0;
    message.level = object.level ?? 0;
    message.promotion = object.promotion ?? 0;
    message.rank = object.rank ?? 0;
    message.skilltreeList =
      object.skilltreeList?.map((e) => AvatarSkillTree.fromPartial(e)) || [];
    message.equipmentUniqueId = object.equipmentUniqueId ?? 0;
    message.equipRelicList =
      object.equipRelicList?.map((e) => EquipRelic.fromPartial(e)) || [];
    return message;
  },
};

function createBaseGetAvatarDataScRsp(): GetAvatarDataScRsp {
  return { retcode: 0, avatarList: [], isAll: false };
}

export const GetAvatarDataScRsp = {
  encode(
    message: GetAvatarDataScRsp,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.retcode !== 0) {
      writer.uint32(8).uint32(message.retcode);
    }
    for (const v of message.avatarList) {
      Avatar.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    if (message.isAll === true) {
      writer.uint32(24).bool(message.isAll);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetAvatarDataScRsp {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetAvatarDataScRsp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.retcode = reader.uint32();
          break;
        case 2:
          message.avatarList.push(Avatar.decode(reader, reader.uint32()));
          break;
        case 3:
          message.isAll = reader.bool();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): GetAvatarDataScRsp {
    return {
      retcode: isSet(object.retcode) ? Number(object.retcode) : 0,
      avatarList: Array.isArray(object?.avatarList)
        ? object.avatarList.map((e: any) => Avatar.fromJSON(e))
        : [],
      isAll: isSet(object.isAll) ? Boolean(object.isAll) : false,
    };
  },

  toJSON(message: GetAvatarDataScRsp): unknown {
    const obj: any = {};
    message.retcode !== undefined &&
      (obj.retcode = Math.round(message.retcode));
    if (message.avatarList) {
      obj.avatarList = message.avatarList.map((e) =>
        e ? Avatar.toJSON(e) : undefined
      );
    } else {
      obj.avatarList = [];
    }
    message.isAll !== undefined && (obj.isAll = message.isAll);
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<GetAvatarDataScRsp>, I>>(
    object: I
  ): GetAvatarDataScRsp {
    const message = createBaseGetAvatarDataScRsp();
    message.retcode = object.retcode ?? 0;
    message.avatarList =
      object.avatarList?.map((e) => Avatar.fromPartial(e)) || [];
    message.isAll = object.isAll ?? false;
    return message;
  },
};

function createBaseAvatarExpUpCsReq(): AvatarExpUpCsReq {
  return { baseAvatarId: 0, itemCost: undefined };
}

export const AvatarExpUpCsReq = {
  encode(
    message: AvatarExpUpCsReq,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.baseAvatarId !== 0) {
      writer.uint32(8).uint32(message.baseAvatarId);
    }
    if (message.itemCost !== undefined) {
      ItemCostData.encode(message.itemCost, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): AvatarExpUpCsReq {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAvatarExpUpCsReq();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.baseAvatarId = reader.uint32();
          break;
        case 2:
          message.itemCost = ItemCostData.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): AvatarExpUpCsReq {
    return {
      baseAvatarId: isSet(object.baseAvatarId)
        ? Number(object.baseAvatarId)
        : 0,
      itemCost: isSet(object.itemCost)
        ? ItemCostData.fromJSON(object.itemCost)
        : undefined,
    };
  },

  toJSON(message: AvatarExpUpCsReq): unknown {
    const obj: any = {};
    message.baseAvatarId !== undefined &&
      (obj.baseAvatarId = Math.round(message.baseAvatarId));
    message.itemCost !== undefined &&
      (obj.itemCost = message.itemCost
        ? ItemCostData.toJSON(message.itemCost)
        : undefined);
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<AvatarExpUpCsReq>, I>>(
    object: I
  ): AvatarExpUpCsReq {
    const message = createBaseAvatarExpUpCsReq();
    message.baseAvatarId = object.baseAvatarId ?? 0;
    message.itemCost =
      object.itemCost !== undefined && object.itemCost !== null
        ? ItemCostData.fromPartial(object.itemCost)
        : undefined;
    return message;
  },
};

function createBaseAvatarExpUpScRsp(): AvatarExpUpScRsp {
  return { retcode: 0, returnItemList: [] };
}

export const AvatarExpUpScRsp = {
  encode(
    message: AvatarExpUpScRsp,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.retcode !== 0) {
      writer.uint32(8).uint32(message.retcode);
    }
    for (const v of message.returnItemList) {
      PileItem.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): AvatarExpUpScRsp {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAvatarExpUpScRsp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.retcode = reader.uint32();
          break;
        case 2:
          message.returnItemList.push(PileItem.decode(reader, reader.uint32()));
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): AvatarExpUpScRsp {
    return {
      retcode: isSet(object.retcode) ? Number(object.retcode) : 0,
      returnItemList: Array.isArray(object?.returnItemList)
        ? object.returnItemList.map((e: any) => PileItem.fromJSON(e))
        : [],
    };
  },

  toJSON(message: AvatarExpUpScRsp): unknown {
    const obj: any = {};
    message.retcode !== undefined &&
      (obj.retcode = Math.round(message.retcode));
    if (message.returnItemList) {
      obj.returnItemList = message.returnItemList.map((e) =>
        e ? PileItem.toJSON(e) : undefined
      );
    } else {
      obj.returnItemList = [];
    }
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<AvatarExpUpScRsp>, I>>(
    object: I
  ): AvatarExpUpScRsp {
    const message = createBaseAvatarExpUpScRsp();
    message.retcode = object.retcode ?? 0;
    message.returnItemList =
      object.returnItemList?.map((e) => PileItem.fromPartial(e)) || [];
    return message;
  },
};

function createBaseUnlockSkilltreeCsReq(): UnlockSkilltreeCsReq {
  return { pointId: 0, level: 0, itemList: [] };
}

export const UnlockSkilltreeCsReq = {
  encode(
    message: UnlockSkilltreeCsReq,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.pointId !== 0) {
      writer.uint32(8).uint32(message.pointId);
    }
    if (message.level !== 0) {
      writer.uint32(16).uint32(message.level);
    }
    for (const v of message.itemList) {
      ItemCost.encode(v!, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): UnlockSkilltreeCsReq {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUnlockSkilltreeCsReq();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.pointId = reader.uint32();
          break;
        case 2:
          message.level = reader.uint32();
          break;
        case 3:
          message.itemList.push(ItemCost.decode(reader, reader.uint32()));
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): UnlockSkilltreeCsReq {
    return {
      pointId: isSet(object.pointId) ? Number(object.pointId) : 0,
      level: isSet(object.level) ? Number(object.level) : 0,
      itemList: Array.isArray(object?.itemList)
        ? object.itemList.map((e: any) => ItemCost.fromJSON(e))
        : [],
    };
  },

  toJSON(message: UnlockSkilltreeCsReq): unknown {
    const obj: any = {};
    message.pointId !== undefined &&
      (obj.pointId = Math.round(message.pointId));
    message.level !== undefined && (obj.level = Math.round(message.level));
    if (message.itemList) {
      obj.itemList = message.itemList.map((e) =>
        e ? ItemCost.toJSON(e) : undefined
      );
    } else {
      obj.itemList = [];
    }
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<UnlockSkilltreeCsReq>, I>>(
    object: I
  ): UnlockSkilltreeCsReq {
    const message = createBaseUnlockSkilltreeCsReq();
    message.pointId = object.pointId ?? 0;
    message.level = object.level ?? 0;
    message.itemList =
      object.itemList?.map((e) => ItemCost.fromPartial(e)) || [];
    return message;
  },
};

function createBaseUnlockSkilltreeScRsp(): UnlockSkilltreeScRsp {
  return { retcode: 0, baseAvatarId: 0, pointId: 0, level: 0 };
}

export const UnlockSkilltreeScRsp = {
  encode(
    message: UnlockSkilltreeScRsp,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.retcode !== 0) {
      writer.uint32(8).uint32(message.retcode);
    }
    if (message.baseAvatarId !== 0) {
      writer.uint32(16).uint32(message.baseAvatarId);
    }
    if (message.pointId !== 0) {
      writer.uint32(24).uint32(message.pointId);
    }
    if (message.level !== 0) {
      writer.uint32(32).uint32(message.level);
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): UnlockSkilltreeScRsp {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUnlockSkilltreeScRsp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.retcode = reader.uint32();
          break;
        case 2:
          message.baseAvatarId = reader.uint32();
          break;
        case 3:
          message.pointId = reader.uint32();
          break;
        case 4:
          message.level = reader.uint32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): UnlockSkilltreeScRsp {
    return {
      retcode: isSet(object.retcode) ? Number(object.retcode) : 0,
      baseAvatarId: isSet(object.baseAvatarId)
        ? Number(object.baseAvatarId)
        : 0,
      pointId: isSet(object.pointId) ? Number(object.pointId) : 0,
      level: isSet(object.level) ? Number(object.level) : 0,
    };
  },

  toJSON(message: UnlockSkilltreeScRsp): unknown {
    const obj: any = {};
    message.retcode !== undefined &&
      (obj.retcode = Math.round(message.retcode));
    message.baseAvatarId !== undefined &&
      (obj.baseAvatarId = Math.round(message.baseAvatarId));
    message.pointId !== undefined &&
      (obj.pointId = Math.round(message.pointId));
    message.level !== undefined && (obj.level = Math.round(message.level));
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<UnlockSkilltreeScRsp>, I>>(
    object: I
  ): UnlockSkilltreeScRsp {
    const message = createBaseUnlockSkilltreeScRsp();
    message.retcode = object.retcode ?? 0;
    message.baseAvatarId = object.baseAvatarId ?? 0;
    message.pointId = object.pointId ?? 0;
    message.level = object.level ?? 0;
    return message;
  },
};

function createBasePromoteAvatarCsReq(): PromoteAvatarCsReq {
  return { baseAvatarId: 0, itemList: [] };
}

export const PromoteAvatarCsReq = {
  encode(
    message: PromoteAvatarCsReq,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.baseAvatarId !== 0) {
      writer.uint32(8).uint32(message.baseAvatarId);
    }
    for (const v of message.itemList) {
      ItemCost.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): PromoteAvatarCsReq {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePromoteAvatarCsReq();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.baseAvatarId = reader.uint32();
          break;
        case 2:
          message.itemList.push(ItemCost.decode(reader, reader.uint32()));
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): PromoteAvatarCsReq {
    return {
      baseAvatarId: isSet(object.baseAvatarId)
        ? Number(object.baseAvatarId)
        : 0,
      itemList: Array.isArray(object?.itemList)
        ? object.itemList.map((e: any) => ItemCost.fromJSON(e))
        : [],
    };
  },

  toJSON(message: PromoteAvatarCsReq): unknown {
    const obj: any = {};
    message.baseAvatarId !== undefined &&
      (obj.baseAvatarId = Math.round(message.baseAvatarId));
    if (message.itemList) {
      obj.itemList = message.itemList.map((e) =>
        e ? ItemCost.toJSON(e) : undefined
      );
    } else {
      obj.itemList = [];
    }
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<PromoteAvatarCsReq>, I>>(
    object: I
  ): PromoteAvatarCsReq {
    const message = createBasePromoteAvatarCsReq();
    message.baseAvatarId = object.baseAvatarId ?? 0;
    message.itemList =
      object.itemList?.map((e) => ItemCost.fromPartial(e)) || [];
    return message;
  },
};

function createBasePromoteAvatarScRsp(): PromoteAvatarScRsp {
  return { retcode: 0 };
}

export const PromoteAvatarScRsp = {
  encode(
    message: PromoteAvatarScRsp,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.retcode !== 0) {
      writer.uint32(8).uint32(message.retcode);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): PromoteAvatarScRsp {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePromoteAvatarScRsp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.retcode = reader.uint32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): PromoteAvatarScRsp {
    return {
      retcode: isSet(object.retcode) ? Number(object.retcode) : 0,
    };
  },

  toJSON(message: PromoteAvatarScRsp): unknown {
    const obj: any = {};
    message.retcode !== undefined &&
      (obj.retcode = Math.round(message.retcode));
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<PromoteAvatarScRsp>, I>>(
    object: I
  ): PromoteAvatarScRsp {
    const message = createBasePromoteAvatarScRsp();
    message.retcode = object.retcode ?? 0;
    return message;
  },
};

function createBaseDressAvatarCsReq(): DressAvatarCsReq {
  return { equipmentUniqueId: 0, baseAvatarId: 0 };
}

export const DressAvatarCsReq = {
  encode(
    message: DressAvatarCsReq,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.equipmentUniqueId !== 0) {
      writer.uint32(8).uint32(message.equipmentUniqueId);
    }
    if (message.baseAvatarId !== 0) {
      writer.uint32(16).uint32(message.baseAvatarId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): DressAvatarCsReq {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDressAvatarCsReq();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.equipmentUniqueId = reader.uint32();
          break;
        case 2:
          message.baseAvatarId = reader.uint32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): DressAvatarCsReq {
    return {
      equipmentUniqueId: isSet(object.equipmentUniqueId)
        ? Number(object.equipmentUniqueId)
        : 0,
      baseAvatarId: isSet(object.baseAvatarId)
        ? Number(object.baseAvatarId)
        : 0,
    };
  },

  toJSON(message: DressAvatarCsReq): unknown {
    const obj: any = {};
    message.equipmentUniqueId !== undefined &&
      (obj.equipmentUniqueId = Math.round(message.equipmentUniqueId));
    message.baseAvatarId !== undefined &&
      (obj.baseAvatarId = Math.round(message.baseAvatarId));
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<DressAvatarCsReq>, I>>(
    object: I
  ): DressAvatarCsReq {
    const message = createBaseDressAvatarCsReq();
    message.equipmentUniqueId = object.equipmentUniqueId ?? 0;
    message.baseAvatarId = object.baseAvatarId ?? 0;
    return message;
  },
};

function createBaseDressAvatarScRsp(): DressAvatarScRsp {
  return { retcode: 0 };
}

export const DressAvatarScRsp = {
  encode(
    message: DressAvatarScRsp,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.retcode !== 0) {
      writer.uint32(8).uint32(message.retcode);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): DressAvatarScRsp {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDressAvatarScRsp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.retcode = reader.uint32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): DressAvatarScRsp {
    return {
      retcode: isSet(object.retcode) ? Number(object.retcode) : 0,
    };
  },

  toJSON(message: DressAvatarScRsp): unknown {
    const obj: any = {};
    message.retcode !== undefined &&
      (obj.retcode = Math.round(message.retcode));
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<DressAvatarScRsp>, I>>(
    object: I
  ): DressAvatarScRsp {
    const message = createBaseDressAvatarScRsp();
    message.retcode = object.retcode ?? 0;
    return message;
  },
};

function createBaseTakeOffEquipmentCsReq(): TakeOffEquipmentCsReq {
  return { baseAvatarId: 0 };
}

export const TakeOffEquipmentCsReq = {
  encode(
    message: TakeOffEquipmentCsReq,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.baseAvatarId !== 0) {
      writer.uint32(8).uint32(message.baseAvatarId);
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): TakeOffEquipmentCsReq {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTakeOffEquipmentCsReq();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.baseAvatarId = reader.uint32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): TakeOffEquipmentCsReq {
    return {
      baseAvatarId: isSet(object.baseAvatarId)
        ? Number(object.baseAvatarId)
        : 0,
    };
  },

  toJSON(message: TakeOffEquipmentCsReq): unknown {
    const obj: any = {};
    message.baseAvatarId !== undefined &&
      (obj.baseAvatarId = Math.round(message.baseAvatarId));
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<TakeOffEquipmentCsReq>, I>>(
    object: I
  ): TakeOffEquipmentCsReq {
    const message = createBaseTakeOffEquipmentCsReq();
    message.baseAvatarId = object.baseAvatarId ?? 0;
    return message;
  },
};

function createBaseTakeOffEquipmentScRsp(): TakeOffEquipmentScRsp {
  return { retcode: 0 };
}

export const TakeOffEquipmentScRsp = {
  encode(
    message: TakeOffEquipmentScRsp,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.retcode !== 0) {
      writer.uint32(8).uint32(message.retcode);
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): TakeOffEquipmentScRsp {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTakeOffEquipmentScRsp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.retcode = reader.uint32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): TakeOffEquipmentScRsp {
    return {
      retcode: isSet(object.retcode) ? Number(object.retcode) : 0,
    };
  },

  toJSON(message: TakeOffEquipmentScRsp): unknown {
    const obj: any = {};
    message.retcode !== undefined &&
      (obj.retcode = Math.round(message.retcode));
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<TakeOffEquipmentScRsp>, I>>(
    object: I
  ): TakeOffEquipmentScRsp {
    const message = createBaseTakeOffEquipmentScRsp();
    message.retcode = object.retcode ?? 0;
    return message;
  },
};

function createBaseAddAvatarScNotify(): AddAvatarScNotify {
  return { baseAvatarId: 0, reward: undefined, src: 0 };
}

export const AddAvatarScNotify = {
  encode(
    message: AddAvatarScNotify,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.baseAvatarId !== 0) {
      writer.uint32(8).uint32(message.baseAvatarId);
    }
    if (message.reward !== undefined) {
      ItemList.encode(message.reward, writer.uint32(18).fork()).ldelim();
    }
    if (message.src !== 0) {
      writer.uint32(24).int32(message.src);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): AddAvatarScNotify {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAddAvatarScNotify();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.baseAvatarId = reader.uint32();
          break;
        case 2:
          message.reward = ItemList.decode(reader, reader.uint32());
          break;
        case 3:
          message.src = reader.int32() as any;
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): AddAvatarScNotify {
    return {
      baseAvatarId: isSet(object.baseAvatarId)
        ? Number(object.baseAvatarId)
        : 0,
      reward: isSet(object.reward)
        ? ItemList.fromJSON(object.reward)
        : undefined,
      src: isSet(object.src) ? addAvatarSrcFromJSON(object.src) : 0,
    };
  },

  toJSON(message: AddAvatarScNotify): unknown {
    const obj: any = {};
    message.baseAvatarId !== undefined &&
      (obj.baseAvatarId = Math.round(message.baseAvatarId));
    message.reward !== undefined &&
      (obj.reward = message.reward
        ? ItemList.toJSON(message.reward)
        : undefined);
    message.src !== undefined && (obj.src = addAvatarSrcToJSON(message.src));
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<AddAvatarScNotify>, I>>(
    object: I
  ): AddAvatarScNotify {
    const message = createBaseAddAvatarScNotify();
    message.baseAvatarId = object.baseAvatarId ?? 0;
    message.reward =
      object.reward !== undefined && object.reward !== null
        ? ItemList.fromPartial(object.reward)
        : undefined;
    message.src = object.src ?? 0;
    return message;
  },
};

function createBaseRankUpAvatarCsReq(): RankUpAvatarCsReq {
  return { baseAvatarId: 0, rank: 0, costData: undefined };
}

export const RankUpAvatarCsReq = {
  encode(
    message: RankUpAvatarCsReq,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.baseAvatarId !== 0) {
      writer.uint32(8).uint32(message.baseAvatarId);
    }
    if (message.rank !== 0) {
      writer.uint32(16).uint32(message.rank);
    }
    if (message.costData !== undefined) {
      ItemCostData.encode(message.costData, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): RankUpAvatarCsReq {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRankUpAvatarCsReq();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.baseAvatarId = reader.uint32();
          break;
        case 2:
          message.rank = reader.uint32();
          break;
        case 3:
          message.costData = ItemCostData.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): RankUpAvatarCsReq {
    return {
      baseAvatarId: isSet(object.baseAvatarId)
        ? Number(object.baseAvatarId)
        : 0,
      rank: isSet(object.rank) ? Number(object.rank) : 0,
      costData: isSet(object.costData)
        ? ItemCostData.fromJSON(object.costData)
        : undefined,
    };
  },

  toJSON(message: RankUpAvatarCsReq): unknown {
    const obj: any = {};
    message.baseAvatarId !== undefined &&
      (obj.baseAvatarId = Math.round(message.baseAvatarId));
    message.rank !== undefined && (obj.rank = Math.round(message.rank));
    message.costData !== undefined &&
      (obj.costData = message.costData
        ? ItemCostData.toJSON(message.costData)
        : undefined);
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<RankUpAvatarCsReq>, I>>(
    object: I
  ): RankUpAvatarCsReq {
    const message = createBaseRankUpAvatarCsReq();
    message.baseAvatarId = object.baseAvatarId ?? 0;
    message.rank = object.rank ?? 0;
    message.costData =
      object.costData !== undefined && object.costData !== null
        ? ItemCostData.fromPartial(object.costData)
        : undefined;
    return message;
  },
};

function createBaseRankUpAvatarScRsp(): RankUpAvatarScRsp {
  return { retcode: 0 };
}

export const RankUpAvatarScRsp = {
  encode(
    message: RankUpAvatarScRsp,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.retcode !== 0) {
      writer.uint32(8).uint32(message.retcode);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): RankUpAvatarScRsp {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRankUpAvatarScRsp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.retcode = reader.uint32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): RankUpAvatarScRsp {
    return {
      retcode: isSet(object.retcode) ? Number(object.retcode) : 0,
    };
  },

  toJSON(message: RankUpAvatarScRsp): unknown {
    const obj: any = {};
    message.retcode !== undefined &&
      (obj.retcode = Math.round(message.retcode));
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<RankUpAvatarScRsp>, I>>(
    object: I
  ): RankUpAvatarScRsp {
    const message = createBaseRankUpAvatarScRsp();
    message.retcode = object.retcode ?? 0;
    return message;
  },
};

function createBaseDressRelicAvatarCsReq(): DressRelicAvatarCsReq {
  return { relicType: 0, relicUniqueId: 0, baseAvatarId: 0 };
}

export const DressRelicAvatarCsReq = {
  encode(
    message: DressRelicAvatarCsReq,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.relicType !== 0) {
      writer.uint32(8).uint32(message.relicType);
    }
    if (message.relicUniqueId !== 0) {
      writer.uint32(16).uint32(message.relicUniqueId);
    }
    if (message.baseAvatarId !== 0) {
      writer.uint32(24).uint32(message.baseAvatarId);
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): DressRelicAvatarCsReq {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDressRelicAvatarCsReq();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.relicType = reader.uint32();
          break;
        case 2:
          message.relicUniqueId = reader.uint32();
          break;
        case 3:
          message.baseAvatarId = reader.uint32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): DressRelicAvatarCsReq {
    return {
      relicType: isSet(object.relicType) ? Number(object.relicType) : 0,
      relicUniqueId: isSet(object.relicUniqueId)
        ? Number(object.relicUniqueId)
        : 0,
      baseAvatarId: isSet(object.baseAvatarId)
        ? Number(object.baseAvatarId)
        : 0,
    };
  },

  toJSON(message: DressRelicAvatarCsReq): unknown {
    const obj: any = {};
    message.relicType !== undefined &&
      (obj.relicType = Math.round(message.relicType));
    message.relicUniqueId !== undefined &&
      (obj.relicUniqueId = Math.round(message.relicUniqueId));
    message.baseAvatarId !== undefined &&
      (obj.baseAvatarId = Math.round(message.baseAvatarId));
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<DressRelicAvatarCsReq>, I>>(
    object: I
  ): DressRelicAvatarCsReq {
    const message = createBaseDressRelicAvatarCsReq();
    message.relicType = object.relicType ?? 0;
    message.relicUniqueId = object.relicUniqueId ?? 0;
    message.baseAvatarId = object.baseAvatarId ?? 0;
    return message;
  },
};

function createBaseDressRelicAvatarScRsp(): DressRelicAvatarScRsp {
  return { retcode: 0 };
}

export const DressRelicAvatarScRsp = {
  encode(
    message: DressRelicAvatarScRsp,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.retcode !== 0) {
      writer.uint32(8).uint32(message.retcode);
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): DressRelicAvatarScRsp {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDressRelicAvatarScRsp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.retcode = reader.uint32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): DressRelicAvatarScRsp {
    return {
      retcode: isSet(object.retcode) ? Number(object.retcode) : 0,
    };
  },

  toJSON(message: DressRelicAvatarScRsp): unknown {
    const obj: any = {};
    message.retcode !== undefined &&
      (obj.retcode = Math.round(message.retcode));
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<DressRelicAvatarScRsp>, I>>(
    object: I
  ): DressRelicAvatarScRsp {
    const message = createBaseDressRelicAvatarScRsp();
    message.retcode = object.retcode ?? 0;
    return message;
  },
};

function createBaseTakeOffRelicCsReq(): TakeOffRelicCsReq {
  return { relicType: 0, baseAvatarId: 0 };
}

export const TakeOffRelicCsReq = {
  encode(
    message: TakeOffRelicCsReq,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.relicType !== 0) {
      writer.uint32(8).uint32(message.relicType);
    }
    if (message.baseAvatarId !== 0) {
      writer.uint32(16).uint32(message.baseAvatarId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): TakeOffRelicCsReq {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTakeOffRelicCsReq();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.relicType = reader.uint32();
          break;
        case 2:
          message.baseAvatarId = reader.uint32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): TakeOffRelicCsReq {
    return {
      relicType: isSet(object.relicType) ? Number(object.relicType) : 0,
      baseAvatarId: isSet(object.baseAvatarId)
        ? Number(object.baseAvatarId)
        : 0,
    };
  },

  toJSON(message: TakeOffRelicCsReq): unknown {
    const obj: any = {};
    message.relicType !== undefined &&
      (obj.relicType = Math.round(message.relicType));
    message.baseAvatarId !== undefined &&
      (obj.baseAvatarId = Math.round(message.baseAvatarId));
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<TakeOffRelicCsReq>, I>>(
    object: I
  ): TakeOffRelicCsReq {
    const message = createBaseTakeOffRelicCsReq();
    message.relicType = object.relicType ?? 0;
    message.baseAvatarId = object.baseAvatarId ?? 0;
    return message;
  },
};

function createBaseTakeOffRelicScRsp(): TakeOffRelicScRsp {
  return { retcode: 0 };
}

export const TakeOffRelicScRsp = {
  encode(
    message: TakeOffRelicScRsp,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.retcode !== 0) {
      writer.uint32(8).uint32(message.retcode);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): TakeOffRelicScRsp {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTakeOffRelicScRsp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.retcode = reader.uint32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): TakeOffRelicScRsp {
    return {
      retcode: isSet(object.retcode) ? Number(object.retcode) : 0,
    };
  },

  toJSON(message: TakeOffRelicScRsp): unknown {
    const obj: any = {};
    message.retcode !== undefined &&
      (obj.retcode = Math.round(message.retcode));
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<TakeOffRelicScRsp>, I>>(
    object: I
  ): TakeOffRelicScRsp {
    const message = createBaseTakeOffRelicScRsp();
    message.retcode = object.retcode ?? 0;
    return message;
  },
};

function createBasePVEBattleResultCsReq(): PVEBattleResultCsReq {
  return {
    stageId: 0,
    opList: [],
    turnSnapshotHash: new Uint8Array(),
    costTime: 0,
    debugExtraInfo: "",
    resVersion: 0,
    isAiConsiderUltraSkill: false,
    endStatus: 0,
    stt: undefined,
    battleId: 0,
  };
}

export const PVEBattleResultCsReq = {
  encode(
    message: PVEBattleResultCsReq,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.stageId !== 0) {
      writer.uint32(8).uint32(message.stageId);
    }
    for (const v of message.opList) {
      BattleOp.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    if (message.turnSnapshotHash.length !== 0) {
      writer.uint32(26).bytes(message.turnSnapshotHash);
    }
    if (message.costTime !== 0) {
      writer.uint32(32).uint32(message.costTime);
    }
    if (message.debugExtraInfo !== "") {
      writer.uint32(42).string(message.debugExtraInfo);
    }
    if (message.resVersion !== 0) {
      writer.uint32(48).uint32(message.resVersion);
    }
    if (message.isAiConsiderUltraSkill === true) {
      writer.uint32(56).bool(message.isAiConsiderUltraSkill);
    }
    if (message.endStatus !== 0) {
      writer.uint32(64).int32(message.endStatus);
    }
    if (message.stt !== undefined) {
      BattleStatistics.encode(message.stt, writer.uint32(74).fork()).ldelim();
    }
    if (message.battleId !== 0) {
      writer.uint32(80).uint32(message.battleId);
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): PVEBattleResultCsReq {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePVEBattleResultCsReq();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.stageId = reader.uint32();
          break;
        case 2:
          message.opList.push(BattleOp.decode(reader, reader.uint32()));
          break;
        case 3:
          message.turnSnapshotHash = reader.bytes();
          break;
        case 4:
          message.costTime = reader.uint32();
          break;
        case 5:
          message.debugExtraInfo = reader.string();
          break;
        case 6:
          message.resVersion = reader.uint32();
          break;
        case 7:
          message.isAiConsiderUltraSkill = reader.bool();
          break;
        case 8:
          message.endStatus = reader.int32() as any;
          break;
        case 9:
          message.stt = BattleStatistics.decode(reader, reader.uint32());
          break;
        case 10:
          message.battleId = reader.uint32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): PVEBattleResultCsReq {
    return {
      stageId: isSet(object.stageId) ? Number(object.stageId) : 0,
      opList: Array.isArray(object?.opList)
        ? object.opList.map((e: any) => BattleOp.fromJSON(e))
        : [],
      turnSnapshotHash: isSet(object.turnSnapshotHash)
        ? bytesFromBase64(object.turnSnapshotHash)
        : new Uint8Array(),
      costTime: isSet(object.costTime) ? Number(object.costTime) : 0,
      debugExtraInfo: isSet(object.debugExtraInfo)
        ? String(object.debugExtraInfo)
        : "",
      resVersion: isSet(object.resVersion) ? Number(object.resVersion) : 0,
      isAiConsiderUltraSkill: isSet(object.isAiConsiderUltraSkill)
        ? Boolean(object.isAiConsiderUltraSkill)
        : false,
      endStatus: isSet(object.endStatus)
        ? battleEndStatusFromJSON(object.endStatus)
        : 0,
      stt: isSet(object.stt)
        ? BattleStatistics.fromJSON(object.stt)
        : undefined,
      battleId: isSet(object.battleId) ? Number(object.battleId) : 0,
    };
  },

  toJSON(message: PVEBattleResultCsReq): unknown {
    const obj: any = {};
    message.stageId !== undefined &&
      (obj.stageId = Math.round(message.stageId));
    if (message.opList) {
      obj.opList = message.opList.map((e) =>
        e ? BattleOp.toJSON(e) : undefined
      );
    } else {
      obj.opList = [];
    }
    message.turnSnapshotHash !== undefined &&
      (obj.turnSnapshotHash = base64FromBytes(
        message.turnSnapshotHash !== undefined
          ? message.turnSnapshotHash
          : new Uint8Array()
      ));
    message.costTime !== undefined &&
      (obj.costTime = Math.round(message.costTime));
    message.debugExtraInfo !== undefined &&
      (obj.debugExtraInfo = message.debugExtraInfo);
    message.resVersion !== undefined &&
      (obj.resVersion = Math.round(message.resVersion));
    message.isAiConsiderUltraSkill !== undefined &&
      (obj.isAiConsiderUltraSkill = message.isAiConsiderUltraSkill);
    message.endStatus !== undefined &&
      (obj.endStatus = battleEndStatusToJSON(message.endStatus));
    message.stt !== undefined &&
      (obj.stt = message.stt
        ? BattleStatistics.toJSON(message.stt)
        : undefined);
    message.battleId !== undefined &&
      (obj.battleId = Math.round(message.battleId));
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<PVEBattleResultCsReq>, I>>(
    object: I
  ): PVEBattleResultCsReq {
    const message = createBasePVEBattleResultCsReq();
    message.stageId = object.stageId ?? 0;
    message.opList = object.opList?.map((e) => BattleOp.fromPartial(e)) || [];
    message.turnSnapshotHash = object.turnSnapshotHash ?? new Uint8Array();
    message.costTime = object.costTime ?? 0;
    message.debugExtraInfo = object.debugExtraInfo ?? "";
    message.resVersion = object.resVersion ?? 0;
    message.isAiConsiderUltraSkill = object.isAiConsiderUltraSkill ?? false;
    message.endStatus = object.endStatus ?? 0;
    message.stt =
      object.stt !== undefined && object.stt !== null
        ? BattleStatistics.fromPartial(object.stt)
        : undefined;
    message.battleId = object.battleId ?? 0;
    return message;
  },
};

function createBasePVEBattleResultScRsp(): PVEBattleResultScRsp {
  return {
    retcode: 0,
    stageId: 0,
    curFinishChallenge: 0,
    dropData: undefined,
    avatarExpReward: 0,
    binVer: "",
    resVer: "",
    battleId: 0,
    endStatus: 0,
    extraDropData: undefined,
    checkIdentical: false,
    eventId: 0,
    mismatchTurnCount: 0,
  };
}

export const PVEBattleResultScRsp = {
  encode(
    message: PVEBattleResultScRsp,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.retcode !== 0) {
      writer.uint32(8).uint32(message.retcode);
    }
    if (message.stageId !== 0) {
      writer.uint32(16).uint32(message.stageId);
    }
    if (message.curFinishChallenge !== 0) {
      writer.uint32(24).uint32(message.curFinishChallenge);
    }
    if (message.dropData !== undefined) {
      ItemList.encode(message.dropData, writer.uint32(34).fork()).ldelim();
    }
    if (message.avatarExpReward !== 0) {
      writer.uint32(40).uint32(message.avatarExpReward);
    }
    if (message.binVer !== "") {
      writer.uint32(50).string(message.binVer);
    }
    if (message.resVer !== "") {
      writer.uint32(58).string(message.resVer);
    }
    if (message.battleId !== 0) {
      writer.uint32(64).uint32(message.battleId);
    }
    if (message.endStatus !== 0) {
      writer.uint32(72).int32(message.endStatus);
    }
    if (message.extraDropData !== undefined) {
      ItemList.encode(message.extraDropData, writer.uint32(82).fork()).ldelim();
    }
    if (message.checkIdentical === true) {
      writer.uint32(88).bool(message.checkIdentical);
    }
    if (message.eventId !== 0) {
      writer.uint32(96).uint32(message.eventId);
    }
    if (message.mismatchTurnCount !== 0) {
      writer.uint32(104).uint32(message.mismatchTurnCount);
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): PVEBattleResultScRsp {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePVEBattleResultScRsp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.retcode = reader.uint32();
          break;
        case 2:
          message.stageId = reader.uint32();
          break;
        case 3:
          message.curFinishChallenge = reader.uint32();
          break;
        case 4:
          message.dropData = ItemList.decode(reader, reader.uint32());
          break;
        case 5:
          message.avatarExpReward = reader.uint32();
          break;
        case 6:
          message.binVer = reader.string();
          break;
        case 7:
          message.resVer = reader.string();
          break;
        case 8:
          message.battleId = reader.uint32();
          break;
        case 9:
          message.endStatus = reader.int32() as any;
          break;
        case 10:
          message.extraDropData = ItemList.decode(reader, reader.uint32());
          break;
        case 11:
          message.checkIdentical = reader.bool();
          break;
        case 12:
          message.eventId = reader.uint32();
          break;
        case 13:
          message.mismatchTurnCount = reader.uint32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): PVEBattleResultScRsp {
    return {
      retcode: isSet(object.retcode) ? Number(object.retcode) : 0,
      stageId: isSet(object.stageId) ? Number(object.stageId) : 0,
      curFinishChallenge: isSet(object.curFinishChallenge)
        ? Number(object.curFinishChallenge)
        : 0,
      dropData: isSet(object.dropData)
        ? ItemList.fromJSON(object.dropData)
        : undefined,
      avatarExpReward: isSet(object.avatarExpReward)
        ? Number(object.avatarExpReward)
        : 0,
      binVer: isSet(object.binVer) ? String(object.binVer) : "",
      resVer: isSet(object.resVer) ? String(object.resVer) : "",
      battleId: isSet(object.battleId) ? Number(object.battleId) : 0,
      endStatus: isSet(object.endStatus)
        ? battleEndStatusFromJSON(object.endStatus)
        : 0,
      extraDropData: isSet(object.extraDropData)
        ? ItemList.fromJSON(object.extraDropData)
        : undefined,
      checkIdentical: isSet(object.checkIdentical)
        ? Boolean(object.checkIdentical)
        : false,
      eventId: isSet(object.eventId) ? Number(object.eventId) : 0,
      mismatchTurnCount: isSet(object.mismatchTurnCount)
        ? Number(object.mismatchTurnCount)
        : 0,
    };
  },

  toJSON(message: PVEBattleResultScRsp): unknown {
    const obj: any = {};
    message.retcode !== undefined &&
      (obj.retcode = Math.round(message.retcode));
    message.stageId !== undefined &&
      (obj.stageId = Math.round(message.stageId));
    message.curFinishChallenge !== undefined &&
      (obj.curFinishChallenge = Math.round(message.curFinishChallenge));
    message.dropData !== undefined &&
      (obj.dropData = message.dropData
        ? ItemList.toJSON(message.dropData)
        : undefined);
    message.avatarExpReward !== undefined &&
      (obj.avatarExpReward = Math.round(message.avatarExpReward));
    message.binVer !== undefined && (obj.binVer = message.binVer);
    message.resVer !== undefined && (obj.resVer = message.resVer);
    message.battleId !== undefined &&
      (obj.battleId = Math.round(message.battleId));
    message.endStatus !== undefined &&
      (obj.endStatus = battleEndStatusToJSON(message.endStatus));
    message.extraDropData !== undefined &&
      (obj.extraDropData = message.extraDropData
        ? ItemList.toJSON(message.extraDropData)
        : undefined);
    message.checkIdentical !== undefined &&
      (obj.checkIdentical = message.checkIdentical);
    message.eventId !== undefined &&
      (obj.eventId = Math.round(message.eventId));
    message.mismatchTurnCount !== undefined &&
      (obj.mismatchTurnCount = Math.round(message.mismatchTurnCount));
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<PVEBattleResultScRsp>, I>>(
    object: I
  ): PVEBattleResultScRsp {
    const message = createBasePVEBattleResultScRsp();
    message.retcode = object.retcode ?? 0;
    message.stageId = object.stageId ?? 0;
    message.curFinishChallenge = object.curFinishChallenge ?? 0;
    message.dropData =
      object.dropData !== undefined && object.dropData !== null
        ? ItemList.fromPartial(object.dropData)
        : undefined;
    message.avatarExpReward = object.avatarExpReward ?? 0;
    message.binVer = object.binVer ?? "";
    message.resVer = object.resVer ?? "";
    message.battleId = object.battleId ?? 0;
    message.endStatus = object.endStatus ?? 0;
    message.extraDropData =
      object.extraDropData !== undefined && object.extraDropData !== null
        ? ItemList.fromPartial(object.extraDropData)
        : undefined;
    message.checkIdentical = object.checkIdentical ?? false;
    message.eventId = object.eventId ?? 0;
    message.mismatchTurnCount = object.mismatchTurnCount ?? 0;
    return message;
  },
};

function createBaseQuitBattleCsReq(): QuitBattleCsReq {
  return {};
}

export const QuitBattleCsReq = {
  encode(
    _: QuitBattleCsReq,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): QuitBattleCsReq {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQuitBattleCsReq();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(_: any): QuitBattleCsReq {
    return {};
  },

  toJSON(_: QuitBattleCsReq): unknown {
    const obj: any = {};
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<QuitBattleCsReq>, I>>(
    _: I
  ): QuitBattleCsReq {
    const message = createBaseQuitBattleCsReq();
    return message;
  },
};

function createBaseQuitBattleScRsp(): QuitBattleScRsp {
  return { retcode: 0 };
}

export const QuitBattleScRsp = {
  encode(
    message: QuitBattleScRsp,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.retcode !== 0) {
      writer.uint32(8).uint32(message.retcode);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): QuitBattleScRsp {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQuitBattleScRsp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.retcode = reader.uint32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): QuitBattleScRsp {
    return {
      retcode: isSet(object.retcode) ? Number(object.retcode) : 0,
    };
  },

  toJSON(message: QuitBattleScRsp): unknown {
    const obj: any = {};
    message.retcode !== undefined &&
      (obj.retcode = Math.round(message.retcode));
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<QuitBattleScRsp>, I>>(
    object: I
  ): QuitBattleScRsp {
    const message = createBaseQuitBattleScRsp();
    message.retcode = object.retcode ?? 0;
    return message;
  },
};

function createBaseGetCurBattleInfoCsReq(): GetCurBattleInfoCsReq {
  return {};
}

export const GetCurBattleInfoCsReq = {
  encode(
    _: GetCurBattleInfoCsReq,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): GetCurBattleInfoCsReq {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetCurBattleInfoCsReq();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(_: any): GetCurBattleInfoCsReq {
    return {};
  },

  toJSON(_: GetCurBattleInfoCsReq): unknown {
    const obj: any = {};
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<GetCurBattleInfoCsReq>, I>>(
    _: I
  ): GetCurBattleInfoCsReq {
    const message = createBaseGetCurBattleInfoCsReq();
    return message;
  },
};

function createBaseGetCurBattleInfoScRsp(): GetCurBattleInfoScRsp {
  return {
    retcode: 0,
    stageId: 0,
    logicRandomSeed: 0,
    avatarList: [],
    battleInfo: undefined,
    lastEndStatus: 0,
    lastEventId: 0,
  };
}

export const GetCurBattleInfoScRsp = {
  encode(
    message: GetCurBattleInfoScRsp,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.retcode !== 0) {
      writer.uint32(8).uint32(message.retcode);
    }
    if (message.stageId !== 0) {
      writer.uint32(16).uint32(message.stageId);
    }
    if (message.logicRandomSeed !== 0) {
      writer.uint32(24).uint32(message.logicRandomSeed);
    }
    for (const v of message.avatarList) {
      BattleAvatar.encode(v!, writer.uint32(34).fork()).ldelim();
    }
    if (message.battleInfo !== undefined) {
      SceneBattleInfo.encode(
        message.battleInfo,
        writer.uint32(42).fork()
      ).ldelim();
    }
    if (message.lastEndStatus !== 0) {
      writer.uint32(48).int32(message.lastEndStatus);
    }
    if (message.lastEventId !== 0) {
      writer.uint32(56).uint32(message.lastEventId);
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): GetCurBattleInfoScRsp {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetCurBattleInfoScRsp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.retcode = reader.uint32();
          break;
        case 2:
          message.stageId = reader.uint32();
          break;
        case 3:
          message.logicRandomSeed = reader.uint32();
          break;
        case 4:
          message.avatarList.push(BattleAvatar.decode(reader, reader.uint32()));
          break;
        case 5:
          message.battleInfo = SceneBattleInfo.decode(reader, reader.uint32());
          break;
        case 6:
          message.lastEndStatus = reader.int32() as any;
          break;
        case 7:
          message.lastEventId = reader.uint32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): GetCurBattleInfoScRsp {
    return {
      retcode: isSet(object.retcode) ? Number(object.retcode) : 0,
      stageId: isSet(object.stageId) ? Number(object.stageId) : 0,
      logicRandomSeed: isSet(object.logicRandomSeed)
        ? Number(object.logicRandomSeed)
        : 0,
      avatarList: Array.isArray(object?.avatarList)
        ? object.avatarList.map((e: any) => BattleAvatar.fromJSON(e))
        : [],
      battleInfo: isSet(object.battleInfo)
        ? SceneBattleInfo.fromJSON(object.battleInfo)
        : undefined,
      lastEndStatus: isSet(object.lastEndStatus)
        ? battleEndStatusFromJSON(object.lastEndStatus)
        : 0,
      lastEventId: isSet(object.lastEventId) ? Number(object.lastEventId) : 0,
    };
  },

  toJSON(message: GetCurBattleInfoScRsp): unknown {
    const obj: any = {};
    message.retcode !== undefined &&
      (obj.retcode = Math.round(message.retcode));
    message.stageId !== undefined &&
      (obj.stageId = Math.round(message.stageId));
    message.logicRandomSeed !== undefined &&
      (obj.logicRandomSeed = Math.round(message.logicRandomSeed));
    if (message.avatarList) {
      obj.avatarList = message.avatarList.map((e) =>
        e ? BattleAvatar.toJSON(e) : undefined
      );
    } else {
      obj.avatarList = [];
    }
    message.battleInfo !== undefined &&
      (obj.battleInfo = message.battleInfo
        ? SceneBattleInfo.toJSON(message.battleInfo)
        : undefined);
    message.lastEndStatus !== undefined &&
      (obj.lastEndStatus = battleEndStatusToJSON(message.lastEndStatus));
    message.lastEventId !== undefined &&
      (obj.lastEventId = Math.round(message.lastEventId));
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<GetCurBattleInfoScRsp>, I>>(
    object: I
  ): GetCurBattleInfoScRsp {
    const message = createBaseGetCurBattleInfoScRsp();
    message.retcode = object.retcode ?? 0;
    message.stageId = object.stageId ?? 0;
    message.logicRandomSeed = object.logicRandomSeed ?? 0;
    message.avatarList =
      object.avatarList?.map((e) => BattleAvatar.fromPartial(e)) || [];
    message.battleInfo =
      object.battleInfo !== undefined && object.battleInfo !== null
        ? SceneBattleInfo.fromPartial(object.battleInfo)
        : undefined;
    message.lastEndStatus = object.lastEndStatus ?? 0;
    message.lastEventId = object.lastEventId ?? 0;
    return message;
  },
};

function createBaseSyncClientResVersionCsReq(): SyncClientResVersionCsReq {
  return { resVersion: 0 };
}

export const SyncClientResVersionCsReq = {
  encode(
    message: SyncClientResVersionCsReq,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.resVersion !== 0) {
      writer.uint32(8).uint32(message.resVersion);
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): SyncClientResVersionCsReq {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSyncClientResVersionCsReq();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.resVersion = reader.uint32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): SyncClientResVersionCsReq {
    return {
      resVersion: isSet(object.resVersion) ? Number(object.resVersion) : 0,
    };
  },

  toJSON(message: SyncClientResVersionCsReq): unknown {
    const obj: any = {};
    message.resVersion !== undefined &&
      (obj.resVersion = Math.round(message.resVersion));
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<SyncClientResVersionCsReq>, I>>(
    object: I
  ): SyncClientResVersionCsReq {
    const message = createBaseSyncClientResVersionCsReq();
    message.resVersion = object.resVersion ?? 0;
    return message;
  },
};

function createBaseSyncClientResVersionScRsp(): SyncClientResVersionScRsp {
  return { retcode: 0, resVersion: 0 };
}

export const SyncClientResVersionScRsp = {
  encode(
    message: SyncClientResVersionScRsp,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.retcode !== 0) {
      writer.uint32(8).uint32(message.retcode);
    }
    if (message.resVersion !== 0) {
      writer.uint32(16).uint32(message.resVersion);
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): SyncClientResVersionScRsp {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSyncClientResVersionScRsp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.retcode = reader.uint32();
          break;
        case 2:
          message.resVersion = reader.uint32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): SyncClientResVersionScRsp {
    return {
      retcode: isSet(object.retcode) ? Number(object.retcode) : 0,
      resVersion: isSet(object.resVersion) ? Number(object.resVersion) : 0,
    };
  },

  toJSON(message: SyncClientResVersionScRsp): unknown {
    const obj: any = {};
    message.retcode !== undefined &&
      (obj.retcode = Math.round(message.retcode));
    message.resVersion !== undefined &&
      (obj.resVersion = Math.round(message.resVersion));
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<SyncClientResVersionScRsp>, I>>(
    object: I
  ): SyncClientResVersionScRsp {
    const message = createBaseSyncClientResVersionScRsp();
    message.retcode = object.retcode ?? 0;
    message.resVersion = object.resVersion ?? 0;
    return message;
  },
};

function createBaseQuitBattleScNotify(): QuitBattleScNotify {
  return {};
}

export const QuitBattleScNotify = {
  encode(
    _: QuitBattleScNotify,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): QuitBattleScNotify {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQuitBattleScNotify();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(_: any): QuitBattleScNotify {
    return {};
  },

  toJSON(_: QuitBattleScNotify): unknown {
    const obj: any = {};
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<QuitBattleScNotify>, I>>(
    _: I
  ): QuitBattleScNotify {
    const message = createBaseQuitBattleScNotify();
    return message;
  },
};

function createBaseChallenge(): Challenge {
  return { challengeId: 0, stars: 0, takenReward: 0 };
}

export const Challenge = {
  encode(
    message: Challenge,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.challengeId !== 0) {
      writer.uint32(8).uint32(message.challengeId);
    }
    if (message.stars !== 0) {
      writer.uint32(16).uint32(message.stars);
    }
    if (message.takenReward !== 0) {
      writer.uint32(24).uint32(message.takenReward);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Challenge {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseChallenge();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.challengeId = reader.uint32();
          break;
        case 2:
          message.stars = reader.uint32();
          break;
        case 3:
          message.takenReward = reader.uint32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): Challenge {
    return {
      challengeId: isSet(object.challengeId) ? Number(object.challengeId) : 0,
      stars: isSet(object.stars) ? Number(object.stars) : 0,
      takenReward: isSet(object.takenReward) ? Number(object.takenReward) : 0,
    };
  },

  toJSON(message: Challenge): unknown {
    const obj: any = {};
    message.challengeId !== undefined &&
      (obj.challengeId = Math.round(message.challengeId));
    message.stars !== undefined && (obj.stars = Math.round(message.stars));
    message.takenReward !== undefined &&
      (obj.takenReward = Math.round(message.takenReward));
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<Challenge>, I>>(
    object: I
  ): Challenge {
    const message = createBaseChallenge();
    message.challengeId = object.challengeId ?? 0;
    message.stars = object.stars ?? 0;
    message.takenReward = object.takenReward ?? 0;
    return message;
  },
};

function createBaseGetChallengeCsReq(): GetChallengeCsReq {
  return {};
}

export const GetChallengeCsReq = {
  encode(
    _: GetChallengeCsReq,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetChallengeCsReq {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetChallengeCsReq();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(_: any): GetChallengeCsReq {
    return {};
  },

  toJSON(_: GetChallengeCsReq): unknown {
    const obj: any = {};
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<GetChallengeCsReq>, I>>(
    _: I
  ): GetChallengeCsReq {
    const message = createBaseGetChallengeCsReq();
    return message;
  },
};

function createBaseGetChallengeScRsp(): GetChallengeScRsp {
  return { retcode: 0, challengeList: [] };
}

export const GetChallengeScRsp = {
  encode(
    message: GetChallengeScRsp,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.retcode !== 0) {
      writer.uint32(8).uint32(message.retcode);
    }
    for (const v of message.challengeList) {
      Challenge.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetChallengeScRsp {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetChallengeScRsp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.retcode = reader.uint32();
          break;
        case 2:
          message.challengeList.push(Challenge.decode(reader, reader.uint32()));
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): GetChallengeScRsp {
    return {
      retcode: isSet(object.retcode) ? Number(object.retcode) : 0,
      challengeList: Array.isArray(object?.challengeList)
        ? object.challengeList.map((e: any) => Challenge.fromJSON(e))
        : [],
    };
  },

  toJSON(message: GetChallengeScRsp): unknown {
    const obj: any = {};
    message.retcode !== undefined &&
      (obj.retcode = Math.round(message.retcode));
    if (message.challengeList) {
      obj.challengeList = message.challengeList.map((e) =>
        e ? Challenge.toJSON(e) : undefined
      );
    } else {
      obj.challengeList = [];
    }
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<GetChallengeScRsp>, I>>(
    object: I
  ): GetChallengeScRsp {
    const message = createBaseGetChallengeScRsp();
    message.retcode = object.retcode ?? 0;
    message.challengeList =
      object.challengeList?.map((e) => Challenge.fromPartial(e)) || [];
    return message;
  },
};

function createBaseStartChallengeCsReq(): StartChallengeCsReq {
  return { challengeId: 0 };
}

export const StartChallengeCsReq = {
  encode(
    message: StartChallengeCsReq,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.challengeId !== 0) {
      writer.uint32(8).uint32(message.challengeId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): StartChallengeCsReq {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStartChallengeCsReq();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.challengeId = reader.uint32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): StartChallengeCsReq {
    return {
      challengeId: isSet(object.challengeId) ? Number(object.challengeId) : 0,
    };
  },

  toJSON(message: StartChallengeCsReq): unknown {
    const obj: any = {};
    message.challengeId !== undefined &&
      (obj.challengeId = Math.round(message.challengeId));
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<StartChallengeCsReq>, I>>(
    object: I
  ): StartChallengeCsReq {
    const message = createBaseStartChallengeCsReq();
    message.challengeId = object.challengeId ?? 0;
    return message;
  },
};

function createBaseStartChallengeScRsp(): StartChallengeScRsp {
  return { retcode: 0, maze: undefined, curChallenge: undefined };
}

export const StartChallengeScRsp = {
  encode(
    message: StartChallengeScRsp,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.retcode !== 0) {
      writer.uint32(8).uint32(message.retcode);
    }
    if (message.maze !== undefined) {
      Maze.encode(message.maze, writer.uint32(18).fork()).ldelim();
    }
    if (message.curChallenge !== undefined) {
      CurChallenge.encode(
        message.curChallenge,
        writer.uint32(26).fork()
      ).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): StartChallengeScRsp {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStartChallengeScRsp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.retcode = reader.uint32();
          break;
        case 2:
          message.maze = Maze.decode(reader, reader.uint32());
          break;
        case 3:
          message.curChallenge = CurChallenge.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): StartChallengeScRsp {
    return {
      retcode: isSet(object.retcode) ? Number(object.retcode) : 0,
      maze: isSet(object.maze) ? Maze.fromJSON(object.maze) : undefined,
      curChallenge: isSet(object.curChallenge)
        ? CurChallenge.fromJSON(object.curChallenge)
        : undefined,
    };
  },

  toJSON(message: StartChallengeScRsp): unknown {
    const obj: any = {};
    message.retcode !== undefined &&
      (obj.retcode = Math.round(message.retcode));
    message.maze !== undefined &&
      (obj.maze = message.maze ? Maze.toJSON(message.maze) : undefined);
    message.curChallenge !== undefined &&
      (obj.curChallenge = message.curChallenge
        ? CurChallenge.toJSON(message.curChallenge)
        : undefined);
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<StartChallengeScRsp>, I>>(
    object: I
  ): StartChallengeScRsp {
    const message = createBaseStartChallengeScRsp();
    message.retcode = object.retcode ?? 0;
    message.maze =
      object.maze !== undefined && object.maze !== null
        ? Maze.fromPartial(object.maze)
        : undefined;
    message.curChallenge =
      object.curChallenge !== undefined && object.curChallenge !== null
        ? CurChallenge.fromPartial(object.curChallenge)
        : undefined;
    return message;
  },
};

function createBaseLeaveChallengeCsReq(): LeaveChallengeCsReq {
  return {};
}

export const LeaveChallengeCsReq = {
  encode(
    _: LeaveChallengeCsReq,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): LeaveChallengeCsReq {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLeaveChallengeCsReq();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(_: any): LeaveChallengeCsReq {
    return {};
  },

  toJSON(_: LeaveChallengeCsReq): unknown {
    const obj: any = {};
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<LeaveChallengeCsReq>, I>>(
    _: I
  ): LeaveChallengeCsReq {
    const message = createBaseLeaveChallengeCsReq();
    return message;
  },
};

function createBaseLeaveChallengeScRsp(): LeaveChallengeScRsp {
  return { retcode: 0, maze: undefined };
}

export const LeaveChallengeScRsp = {
  encode(
    message: LeaveChallengeScRsp,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.retcode !== 0) {
      writer.uint32(8).uint32(message.retcode);
    }
    if (message.maze !== undefined) {
      Maze.encode(message.maze, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): LeaveChallengeScRsp {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLeaveChallengeScRsp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.retcode = reader.uint32();
          break;
        case 2:
          message.maze = Maze.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): LeaveChallengeScRsp {
    return {
      retcode: isSet(object.retcode) ? Number(object.retcode) : 0,
      maze: isSet(object.maze) ? Maze.fromJSON(object.maze) : undefined,
    };
  },

  toJSON(message: LeaveChallengeScRsp): unknown {
    const obj: any = {};
    message.retcode !== undefined &&
      (obj.retcode = Math.round(message.retcode));
    message.maze !== undefined &&
      (obj.maze = message.maze ? Maze.toJSON(message.maze) : undefined);
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<LeaveChallengeScRsp>, I>>(
    object: I
  ): LeaveChallengeScRsp {
    const message = createBaseLeaveChallengeScRsp();
    message.retcode = object.retcode ?? 0;
    message.maze =
      object.maze !== undefined && object.maze !== null
        ? Maze.fromPartial(object.maze)
        : undefined;
    return message;
  },
};

function createBaseChallengeSettleNotify(): ChallengeSettleNotify {
  return { challengeId: 0, isWin: false, reward: undefined, stars: 0 };
}

export const ChallengeSettleNotify = {
  encode(
    message: ChallengeSettleNotify,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.challengeId !== 0) {
      writer.uint32(8).uint32(message.challengeId);
    }
    if (message.isWin === true) {
      writer.uint32(16).bool(message.isWin);
    }
    if (message.reward !== undefined) {
      ItemList.encode(message.reward, writer.uint32(26).fork()).ldelim();
    }
    if (message.stars !== 0) {
      writer.uint32(32).uint32(message.stars);
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): ChallengeSettleNotify {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseChallengeSettleNotify();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.challengeId = reader.uint32();
          break;
        case 2:
          message.isWin = reader.bool();
          break;
        case 3:
          message.reward = ItemList.decode(reader, reader.uint32());
          break;
        case 4:
          message.stars = reader.uint32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): ChallengeSettleNotify {
    return {
      challengeId: isSet(object.challengeId) ? Number(object.challengeId) : 0,
      isWin: isSet(object.isWin) ? Boolean(object.isWin) : false,
      reward: isSet(object.reward)
        ? ItemList.fromJSON(object.reward)
        : undefined,
      stars: isSet(object.stars) ? Number(object.stars) : 0,
    };
  },

  toJSON(message: ChallengeSettleNotify): unknown {
    const obj: any = {};
    message.challengeId !== undefined &&
      (obj.challengeId = Math.round(message.challengeId));
    message.isWin !== undefined && (obj.isWin = message.isWin);
    message.reward !== undefined &&
      (obj.reward = message.reward
        ? ItemList.toJSON(message.reward)
        : undefined);
    message.stars !== undefined && (obj.stars = Math.round(message.stars));
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<ChallengeSettleNotify>, I>>(
    object: I
  ): ChallengeSettleNotify {
    const message = createBaseChallengeSettleNotify();
    message.challengeId = object.challengeId ?? 0;
    message.isWin = object.isWin ?? false;
    message.reward =
      object.reward !== undefined && object.reward !== null
        ? ItemList.fromPartial(object.reward)
        : undefined;
    message.stars = object.stars ?? 0;
    return message;
  },
};

function createBaseFinishChallengeCsReq(): FinishChallengeCsReq {
  return { challengeId: 0 };
}

export const FinishChallengeCsReq = {
  encode(
    message: FinishChallengeCsReq,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.challengeId !== 0) {
      writer.uint32(8).uint32(message.challengeId);
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): FinishChallengeCsReq {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFinishChallengeCsReq();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.challengeId = reader.uint32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): FinishChallengeCsReq {
    return {
      challengeId: isSet(object.challengeId) ? Number(object.challengeId) : 0,
    };
  },

  toJSON(message: FinishChallengeCsReq): unknown {
    const obj: any = {};
    message.challengeId !== undefined &&
      (obj.challengeId = Math.round(message.challengeId));
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<FinishChallengeCsReq>, I>>(
    object: I
  ): FinishChallengeCsReq {
    const message = createBaseFinishChallengeCsReq();
    message.challengeId = object.challengeId ?? 0;
    return message;
  },
};

function createBaseFinishChallengeScRsp(): FinishChallengeScRsp {
  return { retcode: 0 };
}

export const FinishChallengeScRsp = {
  encode(
    message: FinishChallengeScRsp,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.retcode !== 0) {
      writer.uint32(8).uint32(message.retcode);
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): FinishChallengeScRsp {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFinishChallengeScRsp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.retcode = reader.uint32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): FinishChallengeScRsp {
    return {
      retcode: isSet(object.retcode) ? Number(object.retcode) : 0,
    };
  },

  toJSON(message: FinishChallengeScRsp): unknown {
    const obj: any = {};
    message.retcode !== undefined &&
      (obj.retcode = Math.round(message.retcode));
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<FinishChallengeScRsp>, I>>(
    object: I
  ): FinishChallengeScRsp {
    const message = createBaseFinishChallengeScRsp();
    message.retcode = object.retcode ?? 0;
    return message;
  },
};

function createBaseKillMonster(): KillMonster {
  return { monsterId: 0, killNum: 0 };
}

export const KillMonster = {
  encode(
    message: KillMonster,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.monsterId !== 0) {
      writer.uint32(8).uint32(message.monsterId);
    }
    if (message.killNum !== 0) {
      writer.uint32(16).uint32(message.killNum);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): KillMonster {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseKillMonster();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.monsterId = reader.uint32();
          break;
        case 2:
          message.killNum = reader.uint32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): KillMonster {
    return {
      monsterId: isSet(object.monsterId) ? Number(object.monsterId) : 0,
      killNum: isSet(object.killNum) ? Number(object.killNum) : 0,
    };
  },

  toJSON(message: KillMonster): unknown {
    const obj: any = {};
    message.monsterId !== undefined &&
      (obj.monsterId = Math.round(message.monsterId));
    message.killNum !== undefined &&
      (obj.killNum = Math.round(message.killNum));
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<KillMonster>, I>>(
    object: I
  ): KillMonster {
    const message = createBaseKillMonster();
    message.monsterId = object.monsterId ?? 0;
    message.killNum = object.killNum ?? 0;
    return message;
  },
};

function createBaseCurChallenge(): CurChallenge {
  return {
    challengeId: 0,
    rounds: 0,
    status: 0,
    extraLineupType: 0,
    killMonsterList: [],
    deadAvatarNum: 0,
  };
}

export const CurChallenge = {
  encode(
    message: CurChallenge,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.challengeId !== 0) {
      writer.uint32(8).uint32(message.challengeId);
    }
    if (message.rounds !== 0) {
      writer.uint32(16).uint32(message.rounds);
    }
    if (message.status !== 0) {
      writer.uint32(24).int32(message.status);
    }
    if (message.extraLineupType !== 0) {
      writer.uint32(32).int32(message.extraLineupType);
    }
    for (const v of message.killMonsterList) {
      KillMonster.encode(v!, writer.uint32(42).fork()).ldelim();
    }
    if (message.deadAvatarNum !== 0) {
      writer.uint32(48).uint32(message.deadAvatarNum);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CurChallenge {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCurChallenge();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.challengeId = reader.uint32();
          break;
        case 2:
          message.rounds = reader.uint32();
          break;
        case 3:
          message.status = reader.int32() as any;
          break;
        case 4:
          message.extraLineupType = reader.int32() as any;
          break;
        case 5:
          message.killMonsterList.push(
            KillMonster.decode(reader, reader.uint32())
          );
          break;
        case 6:
          message.deadAvatarNum = reader.uint32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): CurChallenge {
    return {
      challengeId: isSet(object.challengeId) ? Number(object.challengeId) : 0,
      rounds: isSet(object.rounds) ? Number(object.rounds) : 0,
      status: isSet(object.status) ? challengeStatusFromJSON(object.status) : 0,
      extraLineupType: isSet(object.extraLineupType)
        ? extraLineupTypeFromJSON(object.extraLineupType)
        : 0,
      killMonsterList: Array.isArray(object?.killMonsterList)
        ? object.killMonsterList.map((e: any) => KillMonster.fromJSON(e))
        : [],
      deadAvatarNum: isSet(object.deadAvatarNum)
        ? Number(object.deadAvatarNum)
        : 0,
    };
  },

  toJSON(message: CurChallenge): unknown {
    const obj: any = {};
    message.challengeId !== undefined &&
      (obj.challengeId = Math.round(message.challengeId));
    message.rounds !== undefined && (obj.rounds = Math.round(message.rounds));
    message.status !== undefined &&
      (obj.status = challengeStatusToJSON(message.status));
    message.extraLineupType !== undefined &&
      (obj.extraLineupType = extraLineupTypeToJSON(message.extraLineupType));
    if (message.killMonsterList) {
      obj.killMonsterList = message.killMonsterList.map((e) =>
        e ? KillMonster.toJSON(e) : undefined
      );
    } else {
      obj.killMonsterList = [];
    }
    message.deadAvatarNum !== undefined &&
      (obj.deadAvatarNum = Math.round(message.deadAvatarNum));
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<CurChallenge>, I>>(
    object: I
  ): CurChallenge {
    const message = createBaseCurChallenge();
    message.challengeId = object.challengeId ?? 0;
    message.rounds = object.rounds ?? 0;
    message.status = object.status ?? 0;
    message.extraLineupType = object.extraLineupType ?? 0;
    message.killMonsterList =
      object.killMonsterList?.map((e) => KillMonster.fromPartial(e)) || [];
    message.deadAvatarNum = object.deadAvatarNum ?? 0;
    return message;
  },
};

function createBaseGetCurChallengeCsReq(): GetCurChallengeCsReq {
  return {};
}

export const GetCurChallengeCsReq = {
  encode(
    _: GetCurChallengeCsReq,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): GetCurChallengeCsReq {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetCurChallengeCsReq();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(_: any): GetCurChallengeCsReq {
    return {};
  },

  toJSON(_: GetCurChallengeCsReq): unknown {
    const obj: any = {};
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<GetCurChallengeCsReq>, I>>(
    _: I
  ): GetCurChallengeCsReq {
    const message = createBaseGetCurChallengeCsReq();
    return message;
  },
};

function createBaseGetCurChallengeScRsp(): GetCurChallengeScRsp {
  return { retcode: 0, curChallenge: undefined };
}

export const GetCurChallengeScRsp = {
  encode(
    message: GetCurChallengeScRsp,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.retcode !== 0) {
      writer.uint32(8).uint32(message.retcode);
    }
    if (message.curChallenge !== undefined) {
      CurChallenge.encode(
        message.curChallenge,
        writer.uint32(18).fork()
      ).ldelim();
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): GetCurChallengeScRsp {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetCurChallengeScRsp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.retcode = reader.uint32();
          break;
        case 2:
          message.curChallenge = CurChallenge.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): GetCurChallengeScRsp {
    return {
      retcode: isSet(object.retcode) ? Number(object.retcode) : 0,
      curChallenge: isSet(object.curChallenge)
        ? CurChallenge.fromJSON(object.curChallenge)
        : undefined,
    };
  },

  toJSON(message: GetCurChallengeScRsp): unknown {
    const obj: any = {};
    message.retcode !== undefined &&
      (obj.retcode = Math.round(message.retcode));
    message.curChallenge !== undefined &&
      (obj.curChallenge = message.curChallenge
        ? CurChallenge.toJSON(message.curChallenge)
        : undefined);
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<GetCurChallengeScRsp>, I>>(
    object: I
  ): GetCurChallengeScRsp {
    const message = createBaseGetCurChallengeScRsp();
    message.retcode = object.retcode ?? 0;
    message.curChallenge =
      object.curChallenge !== undefined && object.curChallenge !== null
        ? CurChallenge.fromPartial(object.curChallenge)
        : undefined;
    return message;
  },
};

function createBaseChallengeLineupNotify(): ChallengeLineupNotify {
  return { extraLineupType: 0 };
}

export const ChallengeLineupNotify = {
  encode(
    message: ChallengeLineupNotify,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.extraLineupType !== 0) {
      writer.uint32(8).int32(message.extraLineupType);
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): ChallengeLineupNotify {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseChallengeLineupNotify();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.extraLineupType = reader.int32() as any;
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): ChallengeLineupNotify {
    return {
      extraLineupType: isSet(object.extraLineupType)
        ? extraLineupTypeFromJSON(object.extraLineupType)
        : 0,
    };
  },

  toJSON(message: ChallengeLineupNotify): unknown {
    const obj: any = {};
    message.extraLineupType !== undefined &&
      (obj.extraLineupType = extraLineupTypeToJSON(message.extraLineupType));
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<ChallengeLineupNotify>, I>>(
    object: I
  ): ChallengeLineupNotify {
    const message = createBaseChallengeLineupNotify();
    message.extraLineupType = object.extraLineupType ?? 0;
    return message;
  },
};

function createBaseTakeChallengeTargetRewardCsReq(): TakeChallengeTargetRewardCsReq {
  return { challengeId: 0, indexList: [] };
}

export const TakeChallengeTargetRewardCsReq = {
  encode(
    message: TakeChallengeTargetRewardCsReq,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.challengeId !== 0) {
      writer.uint32(8).uint32(message.challengeId);
    }
    writer.uint32(18).fork();
    for (const v of message.indexList) {
      writer.uint32(v);
    }
    writer.ldelim();
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): TakeChallengeTargetRewardCsReq {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTakeChallengeTargetRewardCsReq();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.challengeId = reader.uint32();
          break;
        case 2:
          if ((tag & 7) === 2) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.indexList.push(reader.uint32());
            }
          } else {
            message.indexList.push(reader.uint32());
          }
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): TakeChallengeTargetRewardCsReq {
    return {
      challengeId: isSet(object.challengeId) ? Number(object.challengeId) : 0,
      indexList: Array.isArray(object?.indexList)
        ? object.indexList.map((e: any) => Number(e))
        : [],
    };
  },

  toJSON(message: TakeChallengeTargetRewardCsReq): unknown {
    const obj: any = {};
    message.challengeId !== undefined &&
      (obj.challengeId = Math.round(message.challengeId));
    if (message.indexList) {
      obj.indexList = message.indexList.map((e) => Math.round(e));
    } else {
      obj.indexList = [];
    }
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<TakeChallengeTargetRewardCsReq>, I>>(
    object: I
  ): TakeChallengeTargetRewardCsReq {
    const message = createBaseTakeChallengeTargetRewardCsReq();
    message.challengeId = object.challengeId ?? 0;
    message.indexList = object.indexList?.map((e) => e) || [];
    return message;
  },
};

function createBaseTakeChallengeTargetRewardScRsp(): TakeChallengeTargetRewardScRsp {
  return { retcode: 0, challengeId: 0, takenIndexList: [], reward: undefined };
}

export const TakeChallengeTargetRewardScRsp = {
  encode(
    message: TakeChallengeTargetRewardScRsp,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.retcode !== 0) {
      writer.uint32(8).uint32(message.retcode);
    }
    if (message.challengeId !== 0) {
      writer.uint32(16).uint32(message.challengeId);
    }
    writer.uint32(26).fork();
    for (const v of message.takenIndexList) {
      writer.uint32(v);
    }
    writer.ldelim();
    if (message.reward !== undefined) {
      ItemList.encode(message.reward, writer.uint32(34).fork()).ldelim();
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): TakeChallengeTargetRewardScRsp {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTakeChallengeTargetRewardScRsp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.retcode = reader.uint32();
          break;
        case 2:
          message.challengeId = reader.uint32();
          break;
        case 3:
          if ((tag & 7) === 2) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.takenIndexList.push(reader.uint32());
            }
          } else {
            message.takenIndexList.push(reader.uint32());
          }
          break;
        case 4:
          message.reward = ItemList.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): TakeChallengeTargetRewardScRsp {
    return {
      retcode: isSet(object.retcode) ? Number(object.retcode) : 0,
      challengeId: isSet(object.challengeId) ? Number(object.challengeId) : 0,
      takenIndexList: Array.isArray(object?.takenIndexList)
        ? object.takenIndexList.map((e: any) => Number(e))
        : [],
      reward: isSet(object.reward)
        ? ItemList.fromJSON(object.reward)
        : undefined,
    };
  },

  toJSON(message: TakeChallengeTargetRewardScRsp): unknown {
    const obj: any = {};
    message.retcode !== undefined &&
      (obj.retcode = Math.round(message.retcode));
    message.challengeId !== undefined &&
      (obj.challengeId = Math.round(message.challengeId));
    if (message.takenIndexList) {
      obj.takenIndexList = message.takenIndexList.map((e) => Math.round(e));
    } else {
      obj.takenIndexList = [];
    }
    message.reward !== undefined &&
      (obj.reward = message.reward
        ? ItemList.toJSON(message.reward)
        : undefined);
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<TakeChallengeTargetRewardScRsp>, I>>(
    object: I
  ): TakeChallengeTargetRewardScRsp {
    const message = createBaseTakeChallengeTargetRewardScRsp();
    message.retcode = object.retcode ?? 0;
    message.challengeId = object.challengeId ?? 0;
    message.takenIndexList = object.takenIndexList?.map((e) => e) || [];
    message.reward =
      object.reward !== undefined && object.reward !== null
        ? ItemList.fromPartial(object.reward)
        : undefined;
    return message;
  },
};

function createBaseItem(): Item {
  return { itemId: 0, num: 0, level: 0, rank: 0, promotion: 0, uniqueId: 0 };
}

export const Item = {
  encode(message: Item, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.itemId !== 0) {
      writer.uint32(8).uint32(message.itemId);
    }
    if (message.num !== 0) {
      writer.uint32(16).uint32(message.num);
    }
    if (message.level !== 0) {
      writer.uint32(24).uint32(message.level);
    }
    if (message.rank !== 0) {
      writer.uint32(32).uint32(message.rank);
    }
    if (message.promotion !== 0) {
      writer.uint32(40).uint32(message.promotion);
    }
    if (message.uniqueId !== 0) {
      writer.uint32(48).uint32(message.uniqueId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Item {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseItem();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.itemId = reader.uint32();
          break;
        case 2:
          message.num = reader.uint32();
          break;
        case 3:
          message.level = reader.uint32();
          break;
        case 4:
          message.rank = reader.uint32();
          break;
        case 5:
          message.promotion = reader.uint32();
          break;
        case 6:
          message.uniqueId = reader.uint32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): Item {
    return {
      itemId: isSet(object.itemId) ? Number(object.itemId) : 0,
      num: isSet(object.num) ? Number(object.num) : 0,
      level: isSet(object.level) ? Number(object.level) : 0,
      rank: isSet(object.rank) ? Number(object.rank) : 0,
      promotion: isSet(object.promotion) ? Number(object.promotion) : 0,
      uniqueId: isSet(object.uniqueId) ? Number(object.uniqueId) : 0,
    };
  },

  toJSON(message: Item): unknown {
    const obj: any = {};
    message.itemId !== undefined && (obj.itemId = Math.round(message.itemId));
    message.num !== undefined && (obj.num = Math.round(message.num));
    message.level !== undefined && (obj.level = Math.round(message.level));
    message.rank !== undefined && (obj.rank = Math.round(message.rank));
    message.promotion !== undefined &&
      (obj.promotion = Math.round(message.promotion));
    message.uniqueId !== undefined &&
      (obj.uniqueId = Math.round(message.uniqueId));
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<Item>, I>>(object: I): Item {
    const message = createBaseItem();
    message.itemId = object.itemId ?? 0;
    message.num = object.num ?? 0;
    message.level = object.level ?? 0;
    message.rank = object.rank ?? 0;
    message.promotion = object.promotion ?? 0;
    message.uniqueId = object.uniqueId ?? 0;
    return message;
  },
};

function createBaseItemList(): ItemList {
  return { itemList: [] };
}

export const ItemList = {
  encode(
    message: ItemList,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    for (const v of message.itemList) {
      Item.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ItemList {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseItemList();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.itemList.push(Item.decode(reader, reader.uint32()));
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): ItemList {
    return {
      itemList: Array.isArray(object?.itemList)
        ? object.itemList.map((e: any) => Item.fromJSON(e))
        : [],
    };
  },

  toJSON(message: ItemList): unknown {
    const obj: any = {};
    if (message.itemList) {
      obj.itemList = message.itemList.map((e) =>
        e ? Item.toJSON(e) : undefined
      );
    } else {
      obj.itemList = [];
    }
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<ItemList>, I>>(object: I): ItemList {
    const message = createBaseItemList();
    message.itemList = object.itemList?.map((e) => Item.fromPartial(e)) || [];
    return message;
  },
};

function createBasePileItem(): PileItem {
  return { itemId: 0, itemNum: 0 };
}

export const PileItem = {
  encode(
    message: PileItem,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.itemId !== 0) {
      writer.uint32(8).uint32(message.itemId);
    }
    if (message.itemNum !== 0) {
      writer.uint32(16).uint32(message.itemNum);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): PileItem {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePileItem();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.itemId = reader.uint32();
          break;
        case 2:
          message.itemNum = reader.uint32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): PileItem {
    return {
      itemId: isSet(object.itemId) ? Number(object.itemId) : 0,
      itemNum: isSet(object.itemNum) ? Number(object.itemNum) : 0,
    };
  },

  toJSON(message: PileItem): unknown {
    const obj: any = {};
    message.itemId !== undefined && (obj.itemId = Math.round(message.itemId));
    message.itemNum !== undefined &&
      (obj.itemNum = Math.round(message.itemNum));
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<PileItem>, I>>(object: I): PileItem {
    const message = createBasePileItem();
    message.itemId = object.itemId ?? 0;
    message.itemNum = object.itemNum ?? 0;
    return message;
  },
};

function createBaseItemCost(): ItemCost {
  return {
    pileItem: undefined,
    equipmentUniqueId: undefined,
    relicUniqueId: undefined,
  };
}

export const ItemCost = {
  encode(
    message: ItemCost,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.pileItem !== undefined) {
      PileItem.encode(message.pileItem, writer.uint32(10).fork()).ldelim();
    }
    if (message.equipmentUniqueId !== undefined) {
      writer.uint32(16).uint32(message.equipmentUniqueId);
    }
    if (message.relicUniqueId !== undefined) {
      writer.uint32(24).uint32(message.relicUniqueId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ItemCost {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseItemCost();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.pileItem = PileItem.decode(reader, reader.uint32());
          break;
        case 2:
          message.equipmentUniqueId = reader.uint32();
          break;
        case 3:
          message.relicUniqueId = reader.uint32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): ItemCost {
    return {
      pileItem: isSet(object.pileItem)
        ? PileItem.fromJSON(object.pileItem)
        : undefined,
      equipmentUniqueId: isSet(object.equipmentUniqueId)
        ? Number(object.equipmentUniqueId)
        : undefined,
      relicUniqueId: isSet(object.relicUniqueId)
        ? Number(object.relicUniqueId)
        : undefined,
    };
  },

  toJSON(message: ItemCost): unknown {
    const obj: any = {};
    message.pileItem !== undefined &&
      (obj.pileItem = message.pileItem
        ? PileItem.toJSON(message.pileItem)
        : undefined);
    message.equipmentUniqueId !== undefined &&
      (obj.equipmentUniqueId = Math.round(message.equipmentUniqueId));
    message.relicUniqueId !== undefined &&
      (obj.relicUniqueId = Math.round(message.relicUniqueId));
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<ItemCost>, I>>(object: I): ItemCost {
    const message = createBaseItemCost();
    message.pileItem =
      object.pileItem !== undefined && object.pileItem !== null
        ? PileItem.fromPartial(object.pileItem)
        : undefined;
    message.equipmentUniqueId = object.equipmentUniqueId ?? undefined;
    message.relicUniqueId = object.relicUniqueId ?? undefined;
    return message;
  },
};

function createBaseItemCostData(): ItemCostData {
  return { itemList: [] };
}

export const ItemCostData = {
  encode(
    message: ItemCostData,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    for (const v of message.itemList) {
      ItemCost.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ItemCostData {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseItemCostData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.itemList.push(ItemCost.decode(reader, reader.uint32()));
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): ItemCostData {
    return {
      itemList: Array.isArray(object?.itemList)
        ? object.itemList.map((e: any) => ItemCost.fromJSON(e))
        : [],
    };
  },

  toJSON(message: ItemCostData): unknown {
    const obj: any = {};
    if (message.itemList) {
      obj.itemList = message.itemList.map((e) =>
        e ? ItemCost.toJSON(e) : undefined
      );
    } else {
      obj.itemList = [];
    }
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<ItemCostData>, I>>(
    object: I
  ): ItemCostData {
    const message = createBaseItemCostData();
    message.itemList =
      object.itemList?.map((e) => ItemCost.fromPartial(e)) || [];
    return message;
  },
};

function createBaseSceneMonsterWave(): SceneMonsterWave {
  return { monsterIdList: [], dropList: [] };
}

export const SceneMonsterWave = {
  encode(
    message: SceneMonsterWave,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    writer.uint32(10).fork();
    for (const v of message.monsterIdList) {
      writer.uint32(v);
    }
    writer.ldelim();
    for (const v of message.dropList) {
      ItemList.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SceneMonsterWave {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSceneMonsterWave();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if ((tag & 7) === 2) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.monsterIdList.push(reader.uint32());
            }
          } else {
            message.monsterIdList.push(reader.uint32());
          }
          break;
        case 2:
          message.dropList.push(ItemList.decode(reader, reader.uint32()));
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): SceneMonsterWave {
    return {
      monsterIdList: Array.isArray(object?.monsterIdList)
        ? object.monsterIdList.map((e: any) => Number(e))
        : [],
      dropList: Array.isArray(object?.dropList)
        ? object.dropList.map((e: any) => ItemList.fromJSON(e))
        : [],
    };
  },

  toJSON(message: SceneMonsterWave): unknown {
    const obj: any = {};
    if (message.monsterIdList) {
      obj.monsterIdList = message.monsterIdList.map((e) => Math.round(e));
    } else {
      obj.monsterIdList = [];
    }
    if (message.dropList) {
      obj.dropList = message.dropList.map((e) =>
        e ? ItemList.toJSON(e) : undefined
      );
    } else {
      obj.dropList = [];
    }
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<SceneMonsterWave>, I>>(
    object: I
  ): SceneMonsterWave {
    const message = createBaseSceneMonsterWave();
    message.monsterIdList = object.monsterIdList?.map((e) => e) || [];
    message.dropList =
      object.dropList?.map((e) => ItemList.fromPartial(e)) || [];
    return message;
  },
};

function createBaseSceneBattleInfo(): SceneBattleInfo {
  return {
    logicRandomSeed: 0,
    stageId: 0,
    monsterWaveList: [],
    battleAvatarList: [],
    buffList: [],
    battleId: 0,
    heroPathList: [],
    roundsLimit: 0,
  };
}

export const SceneBattleInfo = {
  encode(
    message: SceneBattleInfo,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.logicRandomSeed !== 0) {
      writer.uint32(8).uint32(message.logicRandomSeed);
    }
    if (message.stageId !== 0) {
      writer.uint32(16).uint32(message.stageId);
    }
    for (const v of message.monsterWaveList) {
      SceneMonsterWave.encode(v!, writer.uint32(26).fork()).ldelim();
    }
    for (const v of message.battleAvatarList) {
      BattleAvatar.encode(v!, writer.uint32(34).fork()).ldelim();
    }
    for (const v of message.buffList) {
      BattleBuff.encode(v!, writer.uint32(42).fork()).ldelim();
    }
    if (message.battleId !== 0) {
      writer.uint32(48).uint32(message.battleId);
    }
    for (const v of message.heroPathList) {
      HeroPath.encode(v!, writer.uint32(58).fork()).ldelim();
    }
    if (message.roundsLimit !== 0) {
      writer.uint32(64).uint32(message.roundsLimit);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SceneBattleInfo {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSceneBattleInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.logicRandomSeed = reader.uint32();
          break;
        case 2:
          message.stageId = reader.uint32();
          break;
        case 3:
          message.monsterWaveList.push(
            SceneMonsterWave.decode(reader, reader.uint32())
          );
          break;
        case 4:
          message.battleAvatarList.push(
            BattleAvatar.decode(reader, reader.uint32())
          );
          break;
        case 5:
          message.buffList.push(BattleBuff.decode(reader, reader.uint32()));
          break;
        case 6:
          message.battleId = reader.uint32();
          break;
        case 7:
          message.heroPathList.push(HeroPath.decode(reader, reader.uint32()));
          break;
        case 8:
          message.roundsLimit = reader.uint32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): SceneBattleInfo {
    return {
      logicRandomSeed: isSet(object.logicRandomSeed)
        ? Number(object.logicRandomSeed)
        : 0,
      stageId: isSet(object.stageId) ? Number(object.stageId) : 0,
      monsterWaveList: Array.isArray(object?.monsterWaveList)
        ? object.monsterWaveList.map((e: any) => SceneMonsterWave.fromJSON(e))
        : [],
      battleAvatarList: Array.isArray(object?.battleAvatarList)
        ? object.battleAvatarList.map((e: any) => BattleAvatar.fromJSON(e))
        : [],
      buffList: Array.isArray(object?.buffList)
        ? object.buffList.map((e: any) => BattleBuff.fromJSON(e))
        : [],
      battleId: isSet(object.battleId) ? Number(object.battleId) : 0,
      heroPathList: Array.isArray(object?.heroPathList)
        ? object.heroPathList.map((e: any) => HeroPath.fromJSON(e))
        : [],
      roundsLimit: isSet(object.roundsLimit) ? Number(object.roundsLimit) : 0,
    };
  },

  toJSON(message: SceneBattleInfo): unknown {
    const obj: any = {};
    message.logicRandomSeed !== undefined &&
      (obj.logicRandomSeed = Math.round(message.logicRandomSeed));
    message.stageId !== undefined &&
      (obj.stageId = Math.round(message.stageId));
    if (message.monsterWaveList) {
      obj.monsterWaveList = message.monsterWaveList.map((e) =>
        e ? SceneMonsterWave.toJSON(e) : undefined
      );
    } else {
      obj.monsterWaveList = [];
    }
    if (message.battleAvatarList) {
      obj.battleAvatarList = message.battleAvatarList.map((e) =>
        e ? BattleAvatar.toJSON(e) : undefined
      );
    } else {
      obj.battleAvatarList = [];
    }
    if (message.buffList) {
      obj.buffList = message.buffList.map((e) =>
        e ? BattleBuff.toJSON(e) : undefined
      );
    } else {
      obj.buffList = [];
    }
    message.battleId !== undefined &&
      (obj.battleId = Math.round(message.battleId));
    if (message.heroPathList) {
      obj.heroPathList = message.heroPathList.map((e) =>
        e ? HeroPath.toJSON(e) : undefined
      );
    } else {
      obj.heroPathList = [];
    }
    message.roundsLimit !== undefined &&
      (obj.roundsLimit = Math.round(message.roundsLimit));
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<SceneBattleInfo>, I>>(
    object: I
  ): SceneBattleInfo {
    const message = createBaseSceneBattleInfo();
    message.logicRandomSeed = object.logicRandomSeed ?? 0;
    message.stageId = object.stageId ?? 0;
    message.monsterWaveList =
      object.monsterWaveList?.map((e) => SceneMonsterWave.fromPartial(e)) || [];
    message.battleAvatarList =
      object.battleAvatarList?.map((e) => BattleAvatar.fromPartial(e)) || [];
    message.buffList =
      object.buffList?.map((e) => BattleBuff.fromPartial(e)) || [];
    message.battleId = object.battleId ?? 0;
    message.heroPathList =
      object.heroPathList?.map((e) => HeroPath.fromPartial(e)) || [];
    message.roundsLimit = object.roundsLimit ?? 0;
    return message;
  },
};

function createBaseDialogueEvent(): DialogueEvent {
  return { dialogueGroupId: 0, dialogueEventIdList: [] };
}

export const DialogueEvent = {
  encode(
    message: DialogueEvent,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.dialogueGroupId !== 0) {
      writer.uint32(8).uint32(message.dialogueGroupId);
    }
    writer.uint32(18).fork();
    for (const v of message.dialogueEventIdList) {
      writer.uint32(v);
    }
    writer.ldelim();
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): DialogueEvent {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDialogueEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.dialogueGroupId = reader.uint32();
          break;
        case 2:
          if ((tag & 7) === 2) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.dialogueEventIdList.push(reader.uint32());
            }
          } else {
            message.dialogueEventIdList.push(reader.uint32());
          }
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): DialogueEvent {
    return {
      dialogueGroupId: isSet(object.dialogueGroupId)
        ? Number(object.dialogueGroupId)
        : 0,
      dialogueEventIdList: Array.isArray(object?.dialogueEventIdList)
        ? object.dialogueEventIdList.map((e: any) => Number(e))
        : [],
    };
  },

  toJSON(message: DialogueEvent): unknown {
    const obj: any = {};
    message.dialogueGroupId !== undefined &&
      (obj.dialogueGroupId = Math.round(message.dialogueGroupId));
    if (message.dialogueEventIdList) {
      obj.dialogueEventIdList = message.dialogueEventIdList.map((e) =>
        Math.round(e)
      );
    } else {
      obj.dialogueEventIdList = [];
    }
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<DialogueEvent>, I>>(
    object: I
  ): DialogueEvent {
    const message = createBaseDialogueEvent();
    message.dialogueGroupId = object.dialogueGroupId ?? 0;
    message.dialogueEventIdList =
      object.dialogueEventIdList?.map((e) => e) || [];
    return message;
  },
};

function createBaseDialogueResultInfo(): DialogueResultInfo {
  return { itemResult: undefined, rogueBuffResult: undefined };
}

export const DialogueResultInfo = {
  encode(
    message: DialogueResultInfo,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.itemResult !== undefined) {
      ItemList.encode(message.itemResult, writer.uint32(10).fork()).ldelim();
    }
    if (message.rogueBuffResult !== undefined) {
      RogueBuffList.encode(
        message.rogueBuffResult,
        writer.uint32(18).fork()
      ).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): DialogueResultInfo {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDialogueResultInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.itemResult = ItemList.decode(reader, reader.uint32());
          break;
        case 2:
          message.rogueBuffResult = RogueBuffList.decode(
            reader,
            reader.uint32()
          );
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): DialogueResultInfo {
    return {
      itemResult: isSet(object.itemResult)
        ? ItemList.fromJSON(object.itemResult)
        : undefined,
      rogueBuffResult: isSet(object.rogueBuffResult)
        ? RogueBuffList.fromJSON(object.rogueBuffResult)
        : undefined,
    };
  },

  toJSON(message: DialogueResultInfo): unknown {
    const obj: any = {};
    message.itemResult !== undefined &&
      (obj.itemResult = message.itemResult
        ? ItemList.toJSON(message.itemResult)
        : undefined);
    message.rogueBuffResult !== undefined &&
      (obj.rogueBuffResult = message.rogueBuffResult
        ? RogueBuffList.toJSON(message.rogueBuffResult)
        : undefined);
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<DialogueResultInfo>, I>>(
    object: I
  ): DialogueResultInfo {
    const message = createBaseDialogueResultInfo();
    message.itemResult =
      object.itemResult !== undefined && object.itemResult !== null
        ? ItemList.fromPartial(object.itemResult)
        : undefined;
    message.rogueBuffResult =
      object.rogueBuffResult !== undefined && object.rogueBuffResult !== null
        ? RogueBuffList.fromPartial(object.rogueBuffResult)
        : undefined;
    return message;
  },
};

function createBaseGetDialogueEventDataCsReq(): GetDialogueEventDataCsReq {
  return {};
}

export const GetDialogueEventDataCsReq = {
  encode(
    _: GetDialogueEventDataCsReq,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): GetDialogueEventDataCsReq {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetDialogueEventDataCsReq();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(_: any): GetDialogueEventDataCsReq {
    return {};
  },

  toJSON(_: GetDialogueEventDataCsReq): unknown {
    const obj: any = {};
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<GetDialogueEventDataCsReq>, I>>(
    _: I
  ): GetDialogueEventDataCsReq {
    const message = createBaseGetDialogueEventDataCsReq();
    return message;
  },
};

function createBaseGetDialogueEventDataScRsp(): GetDialogueEventDataScRsp {
  return { retcode: 0, dialogueEventList: [] };
}

export const GetDialogueEventDataScRsp = {
  encode(
    message: GetDialogueEventDataScRsp,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.retcode !== 0) {
      writer.uint32(8).uint32(message.retcode);
    }
    for (const v of message.dialogueEventList) {
      DialogueEvent.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): GetDialogueEventDataScRsp {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetDialogueEventDataScRsp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.retcode = reader.uint32();
          break;
        case 2:
          message.dialogueEventList.push(
            DialogueEvent.decode(reader, reader.uint32())
          );
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): GetDialogueEventDataScRsp {
    return {
      retcode: isSet(object.retcode) ? Number(object.retcode) : 0,
      dialogueEventList: Array.isArray(object?.dialogueEventList)
        ? object.dialogueEventList.map((e: any) => DialogueEvent.fromJSON(e))
        : [],
    };
  },

  toJSON(message: GetDialogueEventDataScRsp): unknown {
    const obj: any = {};
    message.retcode !== undefined &&
      (obj.retcode = Math.round(message.retcode));
    if (message.dialogueEventList) {
      obj.dialogueEventList = message.dialogueEventList.map((e) =>
        e ? DialogueEvent.toJSON(e) : undefined
      );
    } else {
      obj.dialogueEventList = [];
    }
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<GetDialogueEventDataScRsp>, I>>(
    object: I
  ): GetDialogueEventDataScRsp {
    const message = createBaseGetDialogueEventDataScRsp();
    message.retcode = object.retcode ?? 0;
    message.dialogueEventList =
      object.dialogueEventList?.map((e) => DialogueEvent.fromPartial(e)) || [];
    return message;
  },
};

function createBaseSelectDialogueEventCsReq(): SelectDialogueEventCsReq {
  return { dialogueGroupId: 0, dialogueEventId: 0 };
}

export const SelectDialogueEventCsReq = {
  encode(
    message: SelectDialogueEventCsReq,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.dialogueGroupId !== 0) {
      writer.uint32(8).uint32(message.dialogueGroupId);
    }
    if (message.dialogueEventId !== 0) {
      writer.uint32(16).uint32(message.dialogueEventId);
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): SelectDialogueEventCsReq {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSelectDialogueEventCsReq();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.dialogueGroupId = reader.uint32();
          break;
        case 2:
          message.dialogueEventId = reader.uint32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): SelectDialogueEventCsReq {
    return {
      dialogueGroupId: isSet(object.dialogueGroupId)
        ? Number(object.dialogueGroupId)
        : 0,
      dialogueEventId: isSet(object.dialogueEventId)
        ? Number(object.dialogueEventId)
        : 0,
    };
  },

  toJSON(message: SelectDialogueEventCsReq): unknown {
    const obj: any = {};
    message.dialogueGroupId !== undefined &&
      (obj.dialogueGroupId = Math.round(message.dialogueGroupId));
    message.dialogueEventId !== undefined &&
      (obj.dialogueEventId = Math.round(message.dialogueEventId));
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<SelectDialogueEventCsReq>, I>>(
    object: I
  ): SelectDialogueEventCsReq {
    const message = createBaseSelectDialogueEventCsReq();
    message.dialogueGroupId = object.dialogueGroupId ?? 0;
    message.dialogueEventId = object.dialogueEventId ?? 0;
    return message;
  },
};

function createBaseSelectDialogueEventScRsp(): SelectDialogueEventScRsp {
  return {
    retcode: 0,
    dialogueGroupId: 0,
    dialogueEventId: 0,
    resultInfo: undefined,
  };
}

export const SelectDialogueEventScRsp = {
  encode(
    message: SelectDialogueEventScRsp,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.retcode !== 0) {
      writer.uint32(8).uint32(message.retcode);
    }
    if (message.dialogueGroupId !== 0) {
      writer.uint32(16).uint32(message.dialogueGroupId);
    }
    if (message.dialogueEventId !== 0) {
      writer.uint32(24).uint32(message.dialogueEventId);
    }
    if (message.resultInfo !== undefined) {
      DialogueResultInfo.encode(
        message.resultInfo,
        writer.uint32(34).fork()
      ).ldelim();
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): SelectDialogueEventScRsp {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSelectDialogueEventScRsp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.retcode = reader.uint32();
          break;
        case 2:
          message.dialogueGroupId = reader.uint32();
          break;
        case 3:
          message.dialogueEventId = reader.uint32();
          break;
        case 4:
          message.resultInfo = DialogueResultInfo.decode(
            reader,
            reader.uint32()
          );
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): SelectDialogueEventScRsp {
    return {
      retcode: isSet(object.retcode) ? Number(object.retcode) : 0,
      dialogueGroupId: isSet(object.dialogueGroupId)
        ? Number(object.dialogueGroupId)
        : 0,
      dialogueEventId: isSet(object.dialogueEventId)
        ? Number(object.dialogueEventId)
        : 0,
      resultInfo: isSet(object.resultInfo)
        ? DialogueResultInfo.fromJSON(object.resultInfo)
        : undefined,
    };
  },

  toJSON(message: SelectDialogueEventScRsp): unknown {
    const obj: any = {};
    message.retcode !== undefined &&
      (obj.retcode = Math.round(message.retcode));
    message.dialogueGroupId !== undefined &&
      (obj.dialogueGroupId = Math.round(message.dialogueGroupId));
    message.dialogueEventId !== undefined &&
      (obj.dialogueEventId = Math.round(message.dialogueEventId));
    message.resultInfo !== undefined &&
      (obj.resultInfo = message.resultInfo
        ? DialogueResultInfo.toJSON(message.resultInfo)
        : undefined);
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<SelectDialogueEventScRsp>, I>>(
    object: I
  ): SelectDialogueEventScRsp {
    const message = createBaseSelectDialogueEventScRsp();
    message.retcode = object.retcode ?? 0;
    message.dialogueGroupId = object.dialogueGroupId ?? 0;
    message.dialogueEventId = object.dialogueEventId ?? 0;
    message.resultInfo =
      object.resultInfo !== undefined && object.resultInfo !== null
        ? DialogueResultInfo.fromPartial(object.resultInfo)
        : undefined;
    return message;
  },
};

function createBaseSyncDialogueEventDataScNotify(): SyncDialogueEventDataScNotify {
  return { dialogueEventList: [] };
}

export const SyncDialogueEventDataScNotify = {
  encode(
    message: SyncDialogueEventDataScNotify,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    for (const v of message.dialogueEventList) {
      DialogueEvent.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): SyncDialogueEventDataScNotify {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSyncDialogueEventDataScNotify();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.dialogueEventList.push(
            DialogueEvent.decode(reader, reader.uint32())
          );
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): SyncDialogueEventDataScNotify {
    return {
      dialogueEventList: Array.isArray(object?.dialogueEventList)
        ? object.dialogueEventList.map((e: any) => DialogueEvent.fromJSON(e))
        : [],
    };
  },

  toJSON(message: SyncDialogueEventDataScNotify): unknown {
    const obj: any = {};
    if (message.dialogueEventList) {
      obj.dialogueEventList = message.dialogueEventList.map((e) =>
        e ? DialogueEvent.toJSON(e) : undefined
      );
    } else {
      obj.dialogueEventList = [];
    }
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<SyncDialogueEventDataScNotify>, I>>(
    object: I
  ): SyncDialogueEventDataScNotify {
    const message = createBaseSyncDialogueEventDataScNotify();
    message.dialogueEventList =
      object.dialogueEventList?.map((e) => DialogueEvent.fromPartial(e)) || [];
    return message;
  },
};

function createBaseExpedition(): Expedition {
  return { id: 0, acceptTime: 0, duration: 0, avatarIdList: [] };
}

export const Expedition = {
  encode(
    message: Expedition,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.id !== 0) {
      writer.uint32(8).uint32(message.id);
    }
    if (message.acceptTime !== 0) {
      writer.uint32(16).uint32(message.acceptTime);
    }
    if (message.duration !== 0) {
      writer.uint32(24).uint32(message.duration);
    }
    writer.uint32(34).fork();
    for (const v of message.avatarIdList) {
      writer.uint32(v);
    }
    writer.ldelim();
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Expedition {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExpedition();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.id = reader.uint32();
          break;
        case 2:
          message.acceptTime = reader.uint32();
          break;
        case 3:
          message.duration = reader.uint32();
          break;
        case 4:
          if ((tag & 7) === 2) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.avatarIdList.push(reader.uint32());
            }
          } else {
            message.avatarIdList.push(reader.uint32());
          }
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): Expedition {
    return {
      id: isSet(object.id) ? Number(object.id) : 0,
      acceptTime: isSet(object.acceptTime) ? Number(object.acceptTime) : 0,
      duration: isSet(object.duration) ? Number(object.duration) : 0,
      avatarIdList: Array.isArray(object?.avatarIdList)
        ? object.avatarIdList.map((e: any) => Number(e))
        : [],
    };
  },

  toJSON(message: Expedition): unknown {
    const obj: any = {};
    message.id !== undefined && (obj.id = Math.round(message.id));
    message.acceptTime !== undefined &&
      (obj.acceptTime = Math.round(message.acceptTime));
    message.duration !== undefined &&
      (obj.duration = Math.round(message.duration));
    if (message.avatarIdList) {
      obj.avatarIdList = message.avatarIdList.map((e) => Math.round(e));
    } else {
      obj.avatarIdList = [];
    }
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<Expedition>, I>>(
    object: I
  ): Expedition {
    const message = createBaseExpedition();
    message.id = object.id ?? 0;
    message.acceptTime = object.acceptTime ?? 0;
    message.duration = object.duration ?? 0;
    message.avatarIdList = object.avatarIdList?.map((e) => e) || [];
    return message;
  },
};

function createBaseGetExpeditionDataCsReq(): GetExpeditionDataCsReq {
  return {};
}

export const GetExpeditionDataCsReq = {
  encode(
    _: GetExpeditionDataCsReq,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): GetExpeditionDataCsReq {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetExpeditionDataCsReq();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(_: any): GetExpeditionDataCsReq {
    return {};
  },

  toJSON(_: GetExpeditionDataCsReq): unknown {
    const obj: any = {};
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<GetExpeditionDataCsReq>, I>>(
    _: I
  ): GetExpeditionDataCsReq {
    const message = createBaseGetExpeditionDataCsReq();
    return message;
  },
};

function createBaseGetExpeditionDataScRsp(): GetExpeditionDataScRsp {
  return {
    retcode: 0,
    teamCount: 0,
    unlockedExpeditionIdList: [],
    expedtionList: [],
  };
}

export const GetExpeditionDataScRsp = {
  encode(
    message: GetExpeditionDataScRsp,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.retcode !== 0) {
      writer.uint32(8).uint32(message.retcode);
    }
    if (message.teamCount !== 0) {
      writer.uint32(16).uint32(message.teamCount);
    }
    writer.uint32(26).fork();
    for (const v of message.unlockedExpeditionIdList) {
      writer.uint32(v);
    }
    writer.ldelim();
    for (const v of message.expedtionList) {
      Expedition.encode(v!, writer.uint32(34).fork()).ldelim();
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): GetExpeditionDataScRsp {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetExpeditionDataScRsp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.retcode = reader.uint32();
          break;
        case 2:
          message.teamCount = reader.uint32();
          break;
        case 3:
          if ((tag & 7) === 2) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.unlockedExpeditionIdList.push(reader.uint32());
            }
          } else {
            message.unlockedExpeditionIdList.push(reader.uint32());
          }
          break;
        case 4:
          message.expedtionList.push(
            Expedition.decode(reader, reader.uint32())
          );
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): GetExpeditionDataScRsp {
    return {
      retcode: isSet(object.retcode) ? Number(object.retcode) : 0,
      teamCount: isSet(object.teamCount) ? Number(object.teamCount) : 0,
      unlockedExpeditionIdList: Array.isArray(object?.unlockedExpeditionIdList)
        ? object.unlockedExpeditionIdList.map((e: any) => Number(e))
        : [],
      expedtionList: Array.isArray(object?.expedtionList)
        ? object.expedtionList.map((e: any) => Expedition.fromJSON(e))
        : [],
    };
  },

  toJSON(message: GetExpeditionDataScRsp): unknown {
    const obj: any = {};
    message.retcode !== undefined &&
      (obj.retcode = Math.round(message.retcode));
    message.teamCount !== undefined &&
      (obj.teamCount = Math.round(message.teamCount));
    if (message.unlockedExpeditionIdList) {
      obj.unlockedExpeditionIdList = message.unlockedExpeditionIdList.map((e) =>
        Math.round(e)
      );
    } else {
      obj.unlockedExpeditionIdList = [];
    }
    if (message.expedtionList) {
      obj.expedtionList = message.expedtionList.map((e) =>
        e ? Expedition.toJSON(e) : undefined
      );
    } else {
      obj.expedtionList = [];
    }
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<GetExpeditionDataScRsp>, I>>(
    object: I
  ): GetExpeditionDataScRsp {
    const message = createBaseGetExpeditionDataScRsp();
    message.retcode = object.retcode ?? 0;
    message.teamCount = object.teamCount ?? 0;
    message.unlockedExpeditionIdList =
      object.unlockedExpeditionIdList?.map((e) => e) || [];
    message.expedtionList =
      object.expedtionList?.map((e) => Expedition.fromPartial(e)) || [];
    return message;
  },
};

function createBaseAcceptExpeditionCsReq(): AcceptExpeditionCsReq {
  return { expedition: undefined };
}

export const AcceptExpeditionCsReq = {
  encode(
    message: AcceptExpeditionCsReq,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.expedition !== undefined) {
      Expedition.encode(message.expedition, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): AcceptExpeditionCsReq {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAcceptExpeditionCsReq();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.expedition = Expedition.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): AcceptExpeditionCsReq {
    return {
      expedition: isSet(object.expedition)
        ? Expedition.fromJSON(object.expedition)
        : undefined,
    };
  },

  toJSON(message: AcceptExpeditionCsReq): unknown {
    const obj: any = {};
    message.expedition !== undefined &&
      (obj.expedition = message.expedition
        ? Expedition.toJSON(message.expedition)
        : undefined);
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<AcceptExpeditionCsReq>, I>>(
    object: I
  ): AcceptExpeditionCsReq {
    const message = createBaseAcceptExpeditionCsReq();
    message.expedition =
      object.expedition !== undefined && object.expedition !== null
        ? Expedition.fromPartial(object.expedition)
        : undefined;
    return message;
  },
};

function createBaseAcceptExpeditionScRsp(): AcceptExpeditionScRsp {
  return { retcode: 0, expedition: undefined };
}

export const AcceptExpeditionScRsp = {
  encode(
    message: AcceptExpeditionScRsp,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.retcode !== 0) {
      writer.uint32(8).uint32(message.retcode);
    }
    if (message.expedition !== undefined) {
      Expedition.encode(message.expedition, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): AcceptExpeditionScRsp {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAcceptExpeditionScRsp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.retcode = reader.uint32();
          break;
        case 2:
          message.expedition = Expedition.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): AcceptExpeditionScRsp {
    return {
      retcode: isSet(object.retcode) ? Number(object.retcode) : 0,
      expedition: isSet(object.expedition)
        ? Expedition.fromJSON(object.expedition)
        : undefined,
    };
  },

  toJSON(message: AcceptExpeditionScRsp): unknown {
    const obj: any = {};
    message.retcode !== undefined &&
      (obj.retcode = Math.round(message.retcode));
    message.expedition !== undefined &&
      (obj.expedition = message.expedition
        ? Expedition.toJSON(message.expedition)
        : undefined);
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<AcceptExpeditionScRsp>, I>>(
    object: I
  ): AcceptExpeditionScRsp {
    const message = createBaseAcceptExpeditionScRsp();
    message.retcode = object.retcode ?? 0;
    message.expedition =
      object.expedition !== undefined && object.expedition !== null
        ? Expedition.fromPartial(object.expedition)
        : undefined;
    return message;
  },
};

function createBaseCancelExpeditionCsReq(): CancelExpeditionCsReq {
  return { expeditionId: 0 };
}

export const CancelExpeditionCsReq = {
  encode(
    message: CancelExpeditionCsReq,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.expeditionId !== 0) {
      writer.uint32(8).uint32(message.expeditionId);
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): CancelExpeditionCsReq {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCancelExpeditionCsReq();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.expeditionId = reader.uint32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): CancelExpeditionCsReq {
    return {
      expeditionId: isSet(object.expeditionId)
        ? Number(object.expeditionId)
        : 0,
    };
  },

  toJSON(message: CancelExpeditionCsReq): unknown {
    const obj: any = {};
    message.expeditionId !== undefined &&
      (obj.expeditionId = Math.round(message.expeditionId));
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<CancelExpeditionCsReq>, I>>(
    object: I
  ): CancelExpeditionCsReq {
    const message = createBaseCancelExpeditionCsReq();
    message.expeditionId = object.expeditionId ?? 0;
    return message;
  },
};

function createBaseCancelExpeditionScRsp(): CancelExpeditionScRsp {
  return { retcode: 0, expeditionId: 0 };
}

export const CancelExpeditionScRsp = {
  encode(
    message: CancelExpeditionScRsp,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.retcode !== 0) {
      writer.uint32(8).uint32(message.retcode);
    }
    if (message.expeditionId !== 0) {
      writer.uint32(16).uint32(message.expeditionId);
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): CancelExpeditionScRsp {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCancelExpeditionScRsp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.retcode = reader.uint32();
          break;
        case 2:
          message.expeditionId = reader.uint32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): CancelExpeditionScRsp {
    return {
      retcode: isSet(object.retcode) ? Number(object.retcode) : 0,
      expeditionId: isSet(object.expeditionId)
        ? Number(object.expeditionId)
        : 0,
    };
  },

  toJSON(message: CancelExpeditionScRsp): unknown {
    const obj: any = {};
    message.retcode !== undefined &&
      (obj.retcode = Math.round(message.retcode));
    message.expeditionId !== undefined &&
      (obj.expeditionId = Math.round(message.expeditionId));
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<CancelExpeditionScRsp>, I>>(
    object: I
  ): CancelExpeditionScRsp {
    const message = createBaseCancelExpeditionScRsp();
    message.retcode = object.retcode ?? 0;
    message.expeditionId = object.expeditionId ?? 0;
    return message;
  },
};

function createBaseTakeExpeditionRewardCsReq(): TakeExpeditionRewardCsReq {
  return { expeditionId: 0 };
}

export const TakeExpeditionRewardCsReq = {
  encode(
    message: TakeExpeditionRewardCsReq,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.expeditionId !== 0) {
      writer.uint32(8).uint32(message.expeditionId);
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): TakeExpeditionRewardCsReq {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTakeExpeditionRewardCsReq();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.expeditionId = reader.uint32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): TakeExpeditionRewardCsReq {
    return {
      expeditionId: isSet(object.expeditionId)
        ? Number(object.expeditionId)
        : 0,
    };
  },

  toJSON(message: TakeExpeditionRewardCsReq): unknown {
    const obj: any = {};
    message.expeditionId !== undefined &&
      (obj.expeditionId = Math.round(message.expeditionId));
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<TakeExpeditionRewardCsReq>, I>>(
    object: I
  ): TakeExpeditionRewardCsReq {
    const message = createBaseTakeExpeditionRewardCsReq();
    message.expeditionId = object.expeditionId ?? 0;
    return message;
  },
};

function createBaseTakeExpeditionRewardScRsp(): TakeExpeditionRewardScRsp {
  return { retcode: 0, expeditionId: 0, reward: undefined };
}

export const TakeExpeditionRewardScRsp = {
  encode(
    message: TakeExpeditionRewardScRsp,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.retcode !== 0) {
      writer.uint32(8).uint32(message.retcode);
    }
    if (message.expeditionId !== 0) {
      writer.uint32(16).uint32(message.expeditionId);
    }
    if (message.reward !== undefined) {
      ItemList.encode(message.reward, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): TakeExpeditionRewardScRsp {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTakeExpeditionRewardScRsp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.retcode = reader.uint32();
          break;
        case 2:
          message.expeditionId = reader.uint32();
          break;
        case 3:
          message.reward = ItemList.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): TakeExpeditionRewardScRsp {
    return {
      retcode: isSet(object.retcode) ? Number(object.retcode) : 0,
      expeditionId: isSet(object.expeditionId)
        ? Number(object.expeditionId)
        : 0,
      reward: isSet(object.reward)
        ? ItemList.fromJSON(object.reward)
        : undefined,
    };
  },

  toJSON(message: TakeExpeditionRewardScRsp): unknown {
    const obj: any = {};
    message.retcode !== undefined &&
      (obj.retcode = Math.round(message.retcode));
    message.expeditionId !== undefined &&
      (obj.expeditionId = Math.round(message.expeditionId));
    message.reward !== undefined &&
      (obj.reward = message.reward
        ? ItemList.toJSON(message.reward)
        : undefined);
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<TakeExpeditionRewardScRsp>, I>>(
    object: I
  ): TakeExpeditionRewardScRsp {
    const message = createBaseTakeExpeditionRewardScRsp();
    message.retcode = object.retcode ?? 0;
    message.expeditionId = object.expeditionId ?? 0;
    message.reward =
      object.reward !== undefined && object.reward !== null
        ? ItemList.fromPartial(object.reward)
        : undefined;
    return message;
  },
};

function createBaseGetGachaInfoCsReq(): GetGachaInfoCsReq {
  return {};
}

export const GetGachaInfoCsReq = {
  encode(
    _: GetGachaInfoCsReq,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetGachaInfoCsReq {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetGachaInfoCsReq();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(_: any): GetGachaInfoCsReq {
    return {};
  },

  toJSON(_: GetGachaInfoCsReq): unknown {
    const obj: any = {};
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<GetGachaInfoCsReq>, I>>(
    _: I
  ): GetGachaInfoCsReq {
    const message = createBaseGetGachaInfoCsReq();
    return message;
  },
};

function createBaseGachaInfo(): GachaInfo {
  return {
    gachaId: 0,
    beginTime: 0,
    endTime: 0,
    detailWebview: "",
    newbieGachaCnt: 0,
    todayGachaCnt: 0,
  };
}

export const GachaInfo = {
  encode(
    message: GachaInfo,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.gachaId !== 0) {
      writer.uint32(8).uint32(message.gachaId);
    }
    if (message.beginTime !== 0) {
      writer.uint32(16).uint32(message.beginTime);
    }
    if (message.endTime !== 0) {
      writer.uint32(24).uint32(message.endTime);
    }
    if (message.detailWebview !== "") {
      writer.uint32(34).string(message.detailWebview);
    }
    if (message.newbieGachaCnt !== 0) {
      writer.uint32(40).uint32(message.newbieGachaCnt);
    }
    if (message.todayGachaCnt !== 0) {
      writer.uint32(48).uint32(message.todayGachaCnt);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GachaInfo {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGachaInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.gachaId = reader.uint32();
          break;
        case 2:
          message.beginTime = reader.uint32();
          break;
        case 3:
          message.endTime = reader.uint32();
          break;
        case 4:
          message.detailWebview = reader.string();
          break;
        case 5:
          message.newbieGachaCnt = reader.uint32();
          break;
        case 6:
          message.todayGachaCnt = reader.uint32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): GachaInfo {
    return {
      gachaId: isSet(object.gachaId) ? Number(object.gachaId) : 0,
      beginTime: isSet(object.beginTime) ? Number(object.beginTime) : 0,
      endTime: isSet(object.endTime) ? Number(object.endTime) : 0,
      detailWebview: isSet(object.detailWebview)
        ? String(object.detailWebview)
        : "",
      newbieGachaCnt: isSet(object.newbieGachaCnt)
        ? Number(object.newbieGachaCnt)
        : 0,
      todayGachaCnt: isSet(object.todayGachaCnt)
        ? Number(object.todayGachaCnt)
        : 0,
    };
  },

  toJSON(message: GachaInfo): unknown {
    const obj: any = {};
    message.gachaId !== undefined &&
      (obj.gachaId = Math.round(message.gachaId));
    message.beginTime !== undefined &&
      (obj.beginTime = Math.round(message.beginTime));
    message.endTime !== undefined &&
      (obj.endTime = Math.round(message.endTime));
    message.detailWebview !== undefined &&
      (obj.detailWebview = message.detailWebview);
    message.newbieGachaCnt !== undefined &&
      (obj.newbieGachaCnt = Math.round(message.newbieGachaCnt));
    message.todayGachaCnt !== undefined &&
      (obj.todayGachaCnt = Math.round(message.todayGachaCnt));
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<GachaInfo>, I>>(
    object: I
  ): GachaInfo {
    const message = createBaseGachaInfo();
    message.gachaId = object.gachaId ?? 0;
    message.beginTime = object.beginTime ?? 0;
    message.endTime = object.endTime ?? 0;
    message.detailWebview = object.detailWebview ?? "";
    message.newbieGachaCnt = object.newbieGachaCnt ?? 0;
    message.todayGachaCnt = object.todayGachaCnt ?? 0;
    return message;
  },
};

function createBaseGetGachaInfoScRsp(): GetGachaInfoScRsp {
  return {
    retcode: 0,
    gachaInfoList: [],
    gachaRandom: 0,
    todayTotalGachaCnt: 0,
    todaySingleGachaMaxCnt: 0,
    todayTotalGachaMaxCnt: 0,
  };
}

export const GetGachaInfoScRsp = {
  encode(
    message: GetGachaInfoScRsp,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.retcode !== 0) {
      writer.uint32(8).uint32(message.retcode);
    }
    for (const v of message.gachaInfoList) {
      GachaInfo.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    if (message.gachaRandom !== 0) {
      writer.uint32(24).uint32(message.gachaRandom);
    }
    if (message.todayTotalGachaCnt !== 0) {
      writer.uint32(32).uint32(message.todayTotalGachaCnt);
    }
    if (message.todaySingleGachaMaxCnt !== 0) {
      writer.uint32(40).uint32(message.todaySingleGachaMaxCnt);
    }
    if (message.todayTotalGachaMaxCnt !== 0) {
      writer.uint32(48).uint32(message.todayTotalGachaMaxCnt);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetGachaInfoScRsp {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetGachaInfoScRsp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.retcode = reader.uint32();
          break;
        case 2:
          message.gachaInfoList.push(GachaInfo.decode(reader, reader.uint32()));
          break;
        case 3:
          message.gachaRandom = reader.uint32();
          break;
        case 4:
          message.todayTotalGachaCnt = reader.uint32();
          break;
        case 5:
          message.todaySingleGachaMaxCnt = reader.uint32();
          break;
        case 6:
          message.todayTotalGachaMaxCnt = reader.uint32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): GetGachaInfoScRsp {
    return {
      retcode: isSet(object.retcode) ? Number(object.retcode) : 0,
      gachaInfoList: Array.isArray(object?.gachaInfoList)
        ? object.gachaInfoList.map((e: any) => GachaInfo.fromJSON(e))
        : [],
      gachaRandom: isSet(object.gachaRandom) ? Number(object.gachaRandom) : 0,
      todayTotalGachaCnt: isSet(object.todayTotalGachaCnt)
        ? Number(object.todayTotalGachaCnt)
        : 0,
      todaySingleGachaMaxCnt: isSet(object.todaySingleGachaMaxCnt)
        ? Number(object.todaySingleGachaMaxCnt)
        : 0,
      todayTotalGachaMaxCnt: isSet(object.todayTotalGachaMaxCnt)
        ? Number(object.todayTotalGachaMaxCnt)
        : 0,
    };
  },

  toJSON(message: GetGachaInfoScRsp): unknown {
    const obj: any = {};
    message.retcode !== undefined &&
      (obj.retcode = Math.round(message.retcode));
    if (message.gachaInfoList) {
      obj.gachaInfoList = message.gachaInfoList.map((e) =>
        e ? GachaInfo.toJSON(e) : undefined
      );
    } else {
      obj.gachaInfoList = [];
    }
    message.gachaRandom !== undefined &&
      (obj.gachaRandom = Math.round(message.gachaRandom));
    message.todayTotalGachaCnt !== undefined &&
      (obj.todayTotalGachaCnt = Math.round(message.todayTotalGachaCnt));
    message.todaySingleGachaMaxCnt !== undefined &&
      (obj.todaySingleGachaMaxCnt = Math.round(message.todaySingleGachaMaxCnt));
    message.todayTotalGachaMaxCnt !== undefined &&
      (obj.todayTotalGachaMaxCnt = Math.round(message.todayTotalGachaMaxCnt));
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<GetGachaInfoScRsp>, I>>(
    object: I
  ): GetGachaInfoScRsp {
    const message = createBaseGetGachaInfoScRsp();
    message.retcode = object.retcode ?? 0;
    message.gachaInfoList =
      object.gachaInfoList?.map((e) => GachaInfo.fromPartial(e)) || [];
    message.gachaRandom = object.gachaRandom ?? 0;
    message.todayTotalGachaCnt = object.todayTotalGachaCnt ?? 0;
    message.todaySingleGachaMaxCnt = object.todaySingleGachaMaxCnt ?? 0;
    message.todayTotalGachaMaxCnt = object.todayTotalGachaMaxCnt ?? 0;
    return message;
  },
};

function createBaseDoGachaCsReq(): DoGachaCsReq {
  return { gachaId: 0, gachaNum: 0, gachaRandom: 0, simulateMagic: 0 };
}

export const DoGachaCsReq = {
  encode(
    message: DoGachaCsReq,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.gachaId !== 0) {
      writer.uint32(8).uint32(message.gachaId);
    }
    if (message.gachaNum !== 0) {
      writer.uint32(16).uint32(message.gachaNum);
    }
    if (message.gachaRandom !== 0) {
      writer.uint32(24).uint32(message.gachaRandom);
    }
    if (message.simulateMagic !== 0) {
      writer.uint32(32).uint32(message.simulateMagic);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): DoGachaCsReq {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDoGachaCsReq();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.gachaId = reader.uint32();
          break;
        case 2:
          message.gachaNum = reader.uint32();
          break;
        case 3:
          message.gachaRandom = reader.uint32();
          break;
        case 4:
          message.simulateMagic = reader.uint32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): DoGachaCsReq {
    return {
      gachaId: isSet(object.gachaId) ? Number(object.gachaId) : 0,
      gachaNum: isSet(object.gachaNum) ? Number(object.gachaNum) : 0,
      gachaRandom: isSet(object.gachaRandom) ? Number(object.gachaRandom) : 0,
      simulateMagic: isSet(object.simulateMagic)
        ? Number(object.simulateMagic)
        : 0,
    };
  },

  toJSON(message: DoGachaCsReq): unknown {
    const obj: any = {};
    message.gachaId !== undefined &&
      (obj.gachaId = Math.round(message.gachaId));
    message.gachaNum !== undefined &&
      (obj.gachaNum = Math.round(message.gachaNum));
    message.gachaRandom !== undefined &&
      (obj.gachaRandom = Math.round(message.gachaRandom));
    message.simulateMagic !== undefined &&
      (obj.simulateMagic = Math.round(message.simulateMagic));
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<DoGachaCsReq>, I>>(
    object: I
  ): DoGachaCsReq {
    const message = createBaseDoGachaCsReq();
    message.gachaId = object.gachaId ?? 0;
    message.gachaNum = object.gachaNum ?? 0;
    message.gachaRandom = object.gachaRandom ?? 0;
    message.simulateMagic = object.simulateMagic ?? 0;
    return message;
  },
};

function createBaseGachaItem(): GachaItem {
  return {
    gachaItem: undefined,
    transferItemList: undefined,
    isNew: false,
    tokenItem: undefined,
  };
}

export const GachaItem = {
  encode(
    message: GachaItem,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.gachaItem !== undefined) {
      Item.encode(message.gachaItem, writer.uint32(10).fork()).ldelim();
    }
    if (message.transferItemList !== undefined) {
      ItemList.encode(
        message.transferItemList,
        writer.uint32(18).fork()
      ).ldelim();
    }
    if (message.isNew === true) {
      writer.uint32(24).bool(message.isNew);
    }
    if (message.tokenItem !== undefined) {
      ItemList.encode(message.tokenItem, writer.uint32(34).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GachaItem {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGachaItem();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.gachaItem = Item.decode(reader, reader.uint32());
          break;
        case 2:
          message.transferItemList = ItemList.decode(reader, reader.uint32());
          break;
        case 3:
          message.isNew = reader.bool();
          break;
        case 4:
          message.tokenItem = ItemList.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): GachaItem {
    return {
      gachaItem: isSet(object.gachaItem)
        ? Item.fromJSON(object.gachaItem)
        : undefined,
      transferItemList: isSet(object.transferItemList)
        ? ItemList.fromJSON(object.transferItemList)
        : undefined,
      isNew: isSet(object.isNew) ? Boolean(object.isNew) : false,
      tokenItem: isSet(object.tokenItem)
        ? ItemList.fromJSON(object.tokenItem)
        : undefined,
    };
  },

  toJSON(message: GachaItem): unknown {
    const obj: any = {};
    message.gachaItem !== undefined &&
      (obj.gachaItem = message.gachaItem
        ? Item.toJSON(message.gachaItem)
        : undefined);
    message.transferItemList !== undefined &&
      (obj.transferItemList = message.transferItemList
        ? ItemList.toJSON(message.transferItemList)
        : undefined);
    message.isNew !== undefined && (obj.isNew = message.isNew);
    message.tokenItem !== undefined &&
      (obj.tokenItem = message.tokenItem
        ? ItemList.toJSON(message.tokenItem)
        : undefined);
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<GachaItem>, I>>(
    object: I
  ): GachaItem {
    const message = createBaseGachaItem();
    message.gachaItem =
      object.gachaItem !== undefined && object.gachaItem !== null
        ? Item.fromPartial(object.gachaItem)
        : undefined;
    message.transferItemList =
      object.transferItemList !== undefined && object.transferItemList !== null
        ? ItemList.fromPartial(object.transferItemList)
        : undefined;
    message.isNew = object.isNew ?? false;
    message.tokenItem =
      object.tokenItem !== undefined && object.tokenItem !== null
        ? ItemList.fromPartial(object.tokenItem)
        : undefined;
    return message;
  },
};

function createBaseDoGachaScRsp(): DoGachaScRsp {
  return {
    retcode: 0,
    gachaId: 0,
    gachaNum: 0,
    gachaItemList: [],
    newGachaRandom: 0,
    newbieGachaCnt: 0,
    todayGachaCnt: 0,
    todayTotalGachaCnt: 0,
  };
}

export const DoGachaScRsp = {
  encode(
    message: DoGachaScRsp,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.retcode !== 0) {
      writer.uint32(8).uint32(message.retcode);
    }
    if (message.gachaId !== 0) {
      writer.uint32(16).uint32(message.gachaId);
    }
    if (message.gachaNum !== 0) {
      writer.uint32(24).uint32(message.gachaNum);
    }
    for (const v of message.gachaItemList) {
      GachaItem.encode(v!, writer.uint32(34).fork()).ldelim();
    }
    if (message.newGachaRandom !== 0) {
      writer.uint32(40).uint32(message.newGachaRandom);
    }
    if (message.newbieGachaCnt !== 0) {
      writer.uint32(48).uint32(message.newbieGachaCnt);
    }
    if (message.todayGachaCnt !== 0) {
      writer.uint32(56).uint32(message.todayGachaCnt);
    }
    if (message.todayTotalGachaCnt !== 0) {
      writer.uint32(64).uint32(message.todayTotalGachaCnt);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): DoGachaScRsp {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDoGachaScRsp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.retcode = reader.uint32();
          break;
        case 2:
          message.gachaId = reader.uint32();
          break;
        case 3:
          message.gachaNum = reader.uint32();
          break;
        case 4:
          message.gachaItemList.push(GachaItem.decode(reader, reader.uint32()));
          break;
        case 5:
          message.newGachaRandom = reader.uint32();
          break;
        case 6:
          message.newbieGachaCnt = reader.uint32();
          break;
        case 7:
          message.todayGachaCnt = reader.uint32();
          break;
        case 8:
          message.todayTotalGachaCnt = reader.uint32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): DoGachaScRsp {
    return {
      retcode: isSet(object.retcode) ? Number(object.retcode) : 0,
      gachaId: isSet(object.gachaId) ? Number(object.gachaId) : 0,
      gachaNum: isSet(object.gachaNum) ? Number(object.gachaNum) : 0,
      gachaItemList: Array.isArray(object?.gachaItemList)
        ? object.gachaItemList.map((e: any) => GachaItem.fromJSON(e))
        : [],
      newGachaRandom: isSet(object.newGachaRandom)
        ? Number(object.newGachaRandom)
        : 0,
      newbieGachaCnt: isSet(object.newbieGachaCnt)
        ? Number(object.newbieGachaCnt)
        : 0,
      todayGachaCnt: isSet(object.todayGachaCnt)
        ? Number(object.todayGachaCnt)
        : 0,
      todayTotalGachaCnt: isSet(object.todayTotalGachaCnt)
        ? Number(object.todayTotalGachaCnt)
        : 0,
    };
  },

  toJSON(message: DoGachaScRsp): unknown {
    const obj: any = {};
    message.retcode !== undefined &&
      (obj.retcode = Math.round(message.retcode));
    message.gachaId !== undefined &&
      (obj.gachaId = Math.round(message.gachaId));
    message.gachaNum !== undefined &&
      (obj.gachaNum = Math.round(message.gachaNum));
    if (message.gachaItemList) {
      obj.gachaItemList = message.gachaItemList.map((e) =>
        e ? GachaItem.toJSON(e) : undefined
      );
    } else {
      obj.gachaItemList = [];
    }
    message.newGachaRandom !== undefined &&
      (obj.newGachaRandom = Math.round(message.newGachaRandom));
    message.newbieGachaCnt !== undefined &&
      (obj.newbieGachaCnt = Math.round(message.newbieGachaCnt));
    message.todayGachaCnt !== undefined &&
      (obj.todayGachaCnt = Math.round(message.todayGachaCnt));
    message.todayTotalGachaCnt !== undefined &&
      (obj.todayTotalGachaCnt = Math.round(message.todayTotalGachaCnt));
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<DoGachaScRsp>, I>>(
    object: I
  ): DoGachaScRsp {
    const message = createBaseDoGachaScRsp();
    message.retcode = object.retcode ?? 0;
    message.gachaId = object.gachaId ?? 0;
    message.gachaNum = object.gachaNum ?? 0;
    message.gachaItemList =
      object.gachaItemList?.map((e) => GachaItem.fromPartial(e)) || [];
    message.newGachaRandom = object.newGachaRandom ?? 0;
    message.newbieGachaCnt = object.newbieGachaCnt ?? 0;
    message.todayGachaCnt = object.todayGachaCnt ?? 0;
    message.todayTotalGachaCnt = object.todayTotalGachaCnt ?? 0;
    return message;
  },
};

function createBaseGetBagCsReq(): GetBagCsReq {
  return {};
}

export const GetBagCsReq = {
  encode(_: GetBagCsReq, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetBagCsReq {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetBagCsReq();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(_: any): GetBagCsReq {
    return {};
  },

  toJSON(_: GetBagCsReq): unknown {
    const obj: any = {};
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<GetBagCsReq>, I>>(_: I): GetBagCsReq {
    const message = createBaseGetBagCsReq();
    return message;
  },
};

function createBaseEquipment(): Equipment {
  return {
    uniqueId: 0,
    tid: 0,
    level: 0,
    exp: 0,
    rank: 0,
    baseAvatarId: 0,
    isProtected: false,
    promotion: 0,
  };
}

export const Equipment = {
  encode(
    message: Equipment,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.uniqueId !== 0) {
      writer.uint32(8).uint32(message.uniqueId);
    }
    if (message.tid !== 0) {
      writer.uint32(16).uint32(message.tid);
    }
    if (message.level !== 0) {
      writer.uint32(24).uint32(message.level);
    }
    if (message.exp !== 0) {
      writer.uint32(32).uint32(message.exp);
    }
    if (message.rank !== 0) {
      writer.uint32(40).uint32(message.rank);
    }
    if (message.baseAvatarId !== 0) {
      writer.uint32(48).uint32(message.baseAvatarId);
    }
    if (message.isProtected === true) {
      writer.uint32(56).bool(message.isProtected);
    }
    if (message.promotion !== 0) {
      writer.uint32(64).uint32(message.promotion);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Equipment {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEquipment();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.uniqueId = reader.uint32();
          break;
        case 2:
          message.tid = reader.uint32();
          break;
        case 3:
          message.level = reader.uint32();
          break;
        case 4:
          message.exp = reader.uint32();
          break;
        case 5:
          message.rank = reader.uint32();
          break;
        case 6:
          message.baseAvatarId = reader.uint32();
          break;
        case 7:
          message.isProtected = reader.bool();
          break;
        case 8:
          message.promotion = reader.uint32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): Equipment {
    return {
      uniqueId: isSet(object.uniqueId) ? Number(object.uniqueId) : 0,
      tid: isSet(object.tid) ? Number(object.tid) : 0,
      level: isSet(object.level) ? Number(object.level) : 0,
      exp: isSet(object.exp) ? Number(object.exp) : 0,
      rank: isSet(object.rank) ? Number(object.rank) : 0,
      baseAvatarId: isSet(object.baseAvatarId)
        ? Number(object.baseAvatarId)
        : 0,
      isProtected: isSet(object.isProtected)
        ? Boolean(object.isProtected)
        : false,
      promotion: isSet(object.promotion) ? Number(object.promotion) : 0,
    };
  },

  toJSON(message: Equipment): unknown {
    const obj: any = {};
    message.uniqueId !== undefined &&
      (obj.uniqueId = Math.round(message.uniqueId));
    message.tid !== undefined && (obj.tid = Math.round(message.tid));
    message.level !== undefined && (obj.level = Math.round(message.level));
    message.exp !== undefined && (obj.exp = Math.round(message.exp));
    message.rank !== undefined && (obj.rank = Math.round(message.rank));
    message.baseAvatarId !== undefined &&
      (obj.baseAvatarId = Math.round(message.baseAvatarId));
    message.isProtected !== undefined &&
      (obj.isProtected = message.isProtected);
    message.promotion !== undefined &&
      (obj.promotion = Math.round(message.promotion));
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<Equipment>, I>>(
    object: I
  ): Equipment {
    const message = createBaseEquipment();
    message.uniqueId = object.uniqueId ?? 0;
    message.tid = object.tid ?? 0;
    message.level = object.level ?? 0;
    message.exp = object.exp ?? 0;
    message.rank = object.rank ?? 0;
    message.baseAvatarId = object.baseAvatarId ?? 0;
    message.isProtected = object.isProtected ?? false;
    message.promotion = object.promotion ?? 0;
    return message;
  },
};

function createBaseRelic(): Relic {
  return {
    uniqueId: 0,
    tid: 0,
    level: 0,
    exp: 0,
    baseAvatarId: 0,
    isProtected: false,
    mainAffixId: 0,
    subAffixList: [],
  };
}

export const Relic = {
  encode(message: Relic, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.uniqueId !== 0) {
      writer.uint32(8).uint32(message.uniqueId);
    }
    if (message.tid !== 0) {
      writer.uint32(16).uint32(message.tid);
    }
    if (message.level !== 0) {
      writer.uint32(24).uint32(message.level);
    }
    if (message.exp !== 0) {
      writer.uint32(32).uint32(message.exp);
    }
    if (message.baseAvatarId !== 0) {
      writer.uint32(40).uint32(message.baseAvatarId);
    }
    if (message.isProtected === true) {
      writer.uint32(48).bool(message.isProtected);
    }
    if (message.mainAffixId !== 0) {
      writer.uint32(56).uint32(message.mainAffixId);
    }
    for (const v of message.subAffixList) {
      RelicAffix.encode(v!, writer.uint32(66).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Relic {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRelic();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.uniqueId = reader.uint32();
          break;
        case 2:
          message.tid = reader.uint32();
          break;
        case 3:
          message.level = reader.uint32();
          break;
        case 4:
          message.exp = reader.uint32();
          break;
        case 5:
          message.baseAvatarId = reader.uint32();
          break;
        case 6:
          message.isProtected = reader.bool();
          break;
        case 7:
          message.mainAffixId = reader.uint32();
          break;
        case 8:
          message.subAffixList.push(RelicAffix.decode(reader, reader.uint32()));
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): Relic {
    return {
      uniqueId: isSet(object.uniqueId) ? Number(object.uniqueId) : 0,
      tid: isSet(object.tid) ? Number(object.tid) : 0,
      level: isSet(object.level) ? Number(object.level) : 0,
      exp: isSet(object.exp) ? Number(object.exp) : 0,
      baseAvatarId: isSet(object.baseAvatarId)
        ? Number(object.baseAvatarId)
        : 0,
      isProtected: isSet(object.isProtected)
        ? Boolean(object.isProtected)
        : false,
      mainAffixId: isSet(object.mainAffixId) ? Number(object.mainAffixId) : 0,
      subAffixList: Array.isArray(object?.subAffixList)
        ? object.subAffixList.map((e: any) => RelicAffix.fromJSON(e))
        : [],
    };
  },

  toJSON(message: Relic): unknown {
    const obj: any = {};
    message.uniqueId !== undefined &&
      (obj.uniqueId = Math.round(message.uniqueId));
    message.tid !== undefined && (obj.tid = Math.round(message.tid));
    message.level !== undefined && (obj.level = Math.round(message.level));
    message.exp !== undefined && (obj.exp = Math.round(message.exp));
    message.baseAvatarId !== undefined &&
      (obj.baseAvatarId = Math.round(message.baseAvatarId));
    message.isProtected !== undefined &&
      (obj.isProtected = message.isProtected);
    message.mainAffixId !== undefined &&
      (obj.mainAffixId = Math.round(message.mainAffixId));
    if (message.subAffixList) {
      obj.subAffixList = message.subAffixList.map((e) =>
        e ? RelicAffix.toJSON(e) : undefined
      );
    } else {
      obj.subAffixList = [];
    }
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<Relic>, I>>(object: I): Relic {
    const message = createBaseRelic();
    message.uniqueId = object.uniqueId ?? 0;
    message.tid = object.tid ?? 0;
    message.level = object.level ?? 0;
    message.exp = object.exp ?? 0;
    message.baseAvatarId = object.baseAvatarId ?? 0;
    message.isProtected = object.isProtected ?? false;
    message.mainAffixId = object.mainAffixId ?? 0;
    message.subAffixList =
      object.subAffixList?.map((e) => RelicAffix.fromPartial(e)) || [];
    return message;
  },
};

function createBaseMaterial(): Material {
  return { tid: 0, num: 0 };
}

export const Material = {
  encode(
    message: Material,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.tid !== 0) {
      writer.uint32(8).uint32(message.tid);
    }
    if (message.num !== 0) {
      writer.uint32(16).uint32(message.num);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Material {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMaterial();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.tid = reader.uint32();
          break;
        case 2:
          message.num = reader.uint32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): Material {
    return {
      tid: isSet(object.tid) ? Number(object.tid) : 0,
      num: isSet(object.num) ? Number(object.num) : 0,
    };
  },

  toJSON(message: Material): unknown {
    const obj: any = {};
    message.tid !== undefined && (obj.tid = Math.round(message.tid));
    message.num !== undefined && (obj.num = Math.round(message.num));
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<Material>, I>>(object: I): Material {
    const message = createBaseMaterial();
    message.tid = object.tid ?? 0;
    message.num = object.num ?? 0;
    return message;
  },
};

function createBaseWaitDelResource(): WaitDelResource {
  return { tid: 0, num: 0 };
}

export const WaitDelResource = {
  encode(
    message: WaitDelResource,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.tid !== 0) {
      writer.uint32(8).uint32(message.tid);
    }
    if (message.num !== 0) {
      writer.uint32(16).uint32(message.num);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): WaitDelResource {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWaitDelResource();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.tid = reader.uint32();
          break;
        case 2:
          message.num = reader.uint32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): WaitDelResource {
    return {
      tid: isSet(object.tid) ? Number(object.tid) : 0,
      num: isSet(object.num) ? Number(object.num) : 0,
    };
  },

  toJSON(message: WaitDelResource): unknown {
    const obj: any = {};
    message.tid !== undefined && (obj.tid = Math.round(message.tid));
    message.num !== undefined && (obj.num = Math.round(message.num));
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<WaitDelResource>, I>>(
    object: I
  ): WaitDelResource {
    const message = createBaseWaitDelResource();
    message.tid = object.tid ?? 0;
    message.num = object.num ?? 0;
    return message;
  },
};

function createBaseGetBagScRsp(): GetBagScRsp {
  return {
    retcode: 0,
    equipmentList: [],
    materialList: [],
    relicList: [],
    rogueItemList: [],
    waitDelResourceList: [],
  };
}

export const GetBagScRsp = {
  encode(
    message: GetBagScRsp,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.retcode !== 0) {
      writer.uint32(8).uint32(message.retcode);
    }
    for (const v of message.equipmentList) {
      Equipment.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    for (const v of message.materialList) {
      Material.encode(v!, writer.uint32(26).fork()).ldelim();
    }
    for (const v of message.relicList) {
      Relic.encode(v!, writer.uint32(34).fork()).ldelim();
    }
    for (const v of message.rogueItemList) {
      Material.encode(v!, writer.uint32(42).fork()).ldelim();
    }
    for (const v of message.waitDelResourceList) {
      WaitDelResource.encode(v!, writer.uint32(50).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetBagScRsp {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetBagScRsp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.retcode = reader.uint32();
          break;
        case 2:
          message.equipmentList.push(Equipment.decode(reader, reader.uint32()));
          break;
        case 3:
          message.materialList.push(Material.decode(reader, reader.uint32()));
          break;
        case 4:
          message.relicList.push(Relic.decode(reader, reader.uint32()));
          break;
        case 5:
          message.rogueItemList.push(Material.decode(reader, reader.uint32()));
          break;
        case 6:
          message.waitDelResourceList.push(
            WaitDelResource.decode(reader, reader.uint32())
          );
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): GetBagScRsp {
    return {
      retcode: isSet(object.retcode) ? Number(object.retcode) : 0,
      equipmentList: Array.isArray(object?.equipmentList)
        ? object.equipmentList.map((e: any) => Equipment.fromJSON(e))
        : [],
      materialList: Array.isArray(object?.materialList)
        ? object.materialList.map((e: any) => Material.fromJSON(e))
        : [],
      relicList: Array.isArray(object?.relicList)
        ? object.relicList.map((e: any) => Relic.fromJSON(e))
        : [],
      rogueItemList: Array.isArray(object?.rogueItemList)
        ? object.rogueItemList.map((e: any) => Material.fromJSON(e))
        : [],
      waitDelResourceList: Array.isArray(object?.waitDelResourceList)
        ? object.waitDelResourceList.map((e: any) =>
            WaitDelResource.fromJSON(e)
          )
        : [],
    };
  },

  toJSON(message: GetBagScRsp): unknown {
    const obj: any = {};
    message.retcode !== undefined &&
      (obj.retcode = Math.round(message.retcode));
    if (message.equipmentList) {
      obj.equipmentList = message.equipmentList.map((e) =>
        e ? Equipment.toJSON(e) : undefined
      );
    } else {
      obj.equipmentList = [];
    }
    if (message.materialList) {
      obj.materialList = message.materialList.map((e) =>
        e ? Material.toJSON(e) : undefined
      );
    } else {
      obj.materialList = [];
    }
    if (message.relicList) {
      obj.relicList = message.relicList.map((e) =>
        e ? Relic.toJSON(e) : undefined
      );
    } else {
      obj.relicList = [];
    }
    if (message.rogueItemList) {
      obj.rogueItemList = message.rogueItemList.map((e) =>
        e ? Material.toJSON(e) : undefined
      );
    } else {
      obj.rogueItemList = [];
    }
    if (message.waitDelResourceList) {
      obj.waitDelResourceList = message.waitDelResourceList.map((e) =>
        e ? WaitDelResource.toJSON(e) : undefined
      );
    } else {
      obj.waitDelResourceList = [];
    }
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<GetBagScRsp>, I>>(
    object: I
  ): GetBagScRsp {
    const message = createBaseGetBagScRsp();
    message.retcode = object.retcode ?? 0;
    message.equipmentList =
      object.equipmentList?.map((e) => Equipment.fromPartial(e)) || [];
    message.materialList =
      object.materialList?.map((e) => Material.fromPartial(e)) || [];
    message.relicList =
      object.relicList?.map((e) => Relic.fromPartial(e)) || [];
    message.rogueItemList =
      object.rogueItemList?.map((e) => Material.fromPartial(e)) || [];
    message.waitDelResourceList =
      object.waitDelResourceList?.map((e) => WaitDelResource.fromPartial(e)) ||
      [];
    return message;
  },
};

function createBasePromoteEquipmentCsReq(): PromoteEquipmentCsReq {
  return { equipmentUniqueId: 0, costData: undefined };
}

export const PromoteEquipmentCsReq = {
  encode(
    message: PromoteEquipmentCsReq,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.equipmentUniqueId !== 0) {
      writer.uint32(8).uint32(message.equipmentUniqueId);
    }
    if (message.costData !== undefined) {
      ItemCostData.encode(message.costData, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): PromoteEquipmentCsReq {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePromoteEquipmentCsReq();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.equipmentUniqueId = reader.uint32();
          break;
        case 2:
          message.costData = ItemCostData.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): PromoteEquipmentCsReq {
    return {
      equipmentUniqueId: isSet(object.equipmentUniqueId)
        ? Number(object.equipmentUniqueId)
        : 0,
      costData: isSet(object.costData)
        ? ItemCostData.fromJSON(object.costData)
        : undefined,
    };
  },

  toJSON(message: PromoteEquipmentCsReq): unknown {
    const obj: any = {};
    message.equipmentUniqueId !== undefined &&
      (obj.equipmentUniqueId = Math.round(message.equipmentUniqueId));
    message.costData !== undefined &&
      (obj.costData = message.costData
        ? ItemCostData.toJSON(message.costData)
        : undefined);
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<PromoteEquipmentCsReq>, I>>(
    object: I
  ): PromoteEquipmentCsReq {
    const message = createBasePromoteEquipmentCsReq();
    message.equipmentUniqueId = object.equipmentUniqueId ?? 0;
    message.costData =
      object.costData !== undefined && object.costData !== null
        ? ItemCostData.fromPartial(object.costData)
        : undefined;
    return message;
  },
};

function createBasePromoteEquipmentScRsp(): PromoteEquipmentScRsp {
  return { retcode: 0 };
}

export const PromoteEquipmentScRsp = {
  encode(
    message: PromoteEquipmentScRsp,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.retcode !== 0) {
      writer.uint32(8).uint32(message.retcode);
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): PromoteEquipmentScRsp {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePromoteEquipmentScRsp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.retcode = reader.uint32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): PromoteEquipmentScRsp {
    return {
      retcode: isSet(object.retcode) ? Number(object.retcode) : 0,
    };
  },

  toJSON(message: PromoteEquipmentScRsp): unknown {
    const obj: any = {};
    message.retcode !== undefined &&
      (obj.retcode = Math.round(message.retcode));
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<PromoteEquipmentScRsp>, I>>(
    object: I
  ): PromoteEquipmentScRsp {
    const message = createBasePromoteEquipmentScRsp();
    message.retcode = object.retcode ?? 0;
    return message;
  },
};

function createBaseLockEquipmentCsReq(): LockEquipmentCsReq {
  return { equipmentUniqueId: 0, isLock: false };
}

export const LockEquipmentCsReq = {
  encode(
    message: LockEquipmentCsReq,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.equipmentUniqueId !== 0) {
      writer.uint32(8).uint32(message.equipmentUniqueId);
    }
    if (message.isLock === true) {
      writer.uint32(16).bool(message.isLock);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): LockEquipmentCsReq {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLockEquipmentCsReq();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.equipmentUniqueId = reader.uint32();
          break;
        case 2:
          message.isLock = reader.bool();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): LockEquipmentCsReq {
    return {
      equipmentUniqueId: isSet(object.equipmentUniqueId)
        ? Number(object.equipmentUniqueId)
        : 0,
      isLock: isSet(object.isLock) ? Boolean(object.isLock) : false,
    };
  },

  toJSON(message: LockEquipmentCsReq): unknown {
    const obj: any = {};
    message.equipmentUniqueId !== undefined &&
      (obj.equipmentUniqueId = Math.round(message.equipmentUniqueId));
    message.isLock !== undefined && (obj.isLock = message.isLock);
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<LockEquipmentCsReq>, I>>(
    object: I
  ): LockEquipmentCsReq {
    const message = createBaseLockEquipmentCsReq();
    message.equipmentUniqueId = object.equipmentUniqueId ?? 0;
    message.isLock = object.isLock ?? false;
    return message;
  },
};

function createBaseLockEquipmentScRsp(): LockEquipmentScRsp {
  return { retcode: 0, equipmentUniqueId: 0 };
}

export const LockEquipmentScRsp = {
  encode(
    message: LockEquipmentScRsp,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.retcode !== 0) {
      writer.uint32(8).uint32(message.retcode);
    }
    if (message.equipmentUniqueId !== 0) {
      writer.uint32(16).uint32(message.equipmentUniqueId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): LockEquipmentScRsp {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLockEquipmentScRsp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.retcode = reader.uint32();
          break;
        case 2:
          message.equipmentUniqueId = reader.uint32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): LockEquipmentScRsp {
    return {
      retcode: isSet(object.retcode) ? Number(object.retcode) : 0,
      equipmentUniqueId: isSet(object.equipmentUniqueId)
        ? Number(object.equipmentUniqueId)
        : 0,
    };
  },

  toJSON(message: LockEquipmentScRsp): unknown {
    const obj: any = {};
    message.retcode !== undefined &&
      (obj.retcode = Math.round(message.retcode));
    message.equipmentUniqueId !== undefined &&
      (obj.equipmentUniqueId = Math.round(message.equipmentUniqueId));
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<LockEquipmentScRsp>, I>>(
    object: I
  ): LockEquipmentScRsp {
    const message = createBaseLockEquipmentScRsp();
    message.retcode = object.retcode ?? 0;
    message.equipmentUniqueId = object.equipmentUniqueId ?? 0;
    return message;
  },
};

function createBaseUseItemCsReq(): UseItemCsReq {
  return {
    useItemId: 0,
    useItemCount: 0,
    baseAvatarId: 0,
    useAvatarType: 0,
    optionalRewardId: 0,
  };
}

export const UseItemCsReq = {
  encode(
    message: UseItemCsReq,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.useItemId !== 0) {
      writer.uint32(8).uint32(message.useItemId);
    }
    if (message.useItemCount !== 0) {
      writer.uint32(16).uint32(message.useItemCount);
    }
    if (message.baseAvatarId !== 0) {
      writer.uint32(24).uint32(message.baseAvatarId);
    }
    if (message.useAvatarType !== 0) {
      writer.uint32(32).int32(message.useAvatarType);
    }
    if (message.optionalRewardId !== 0) {
      writer.uint32(40).uint32(message.optionalRewardId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): UseItemCsReq {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUseItemCsReq();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.useItemId = reader.uint32();
          break;
        case 2:
          message.useItemCount = reader.uint32();
          break;
        case 3:
          message.baseAvatarId = reader.uint32();
          break;
        case 4:
          message.useAvatarType = reader.int32() as any;
          break;
        case 5:
          message.optionalRewardId = reader.uint32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): UseItemCsReq {
    return {
      useItemId: isSet(object.useItemId) ? Number(object.useItemId) : 0,
      useItemCount: isSet(object.useItemCount)
        ? Number(object.useItemCount)
        : 0,
      baseAvatarId: isSet(object.baseAvatarId)
        ? Number(object.baseAvatarId)
        : 0,
      useAvatarType: isSet(object.useAvatarType)
        ? avatarTypeFromJSON(object.useAvatarType)
        : 0,
      optionalRewardId: isSet(object.optionalRewardId)
        ? Number(object.optionalRewardId)
        : 0,
    };
  },

  toJSON(message: UseItemCsReq): unknown {
    const obj: any = {};
    message.useItemId !== undefined &&
      (obj.useItemId = Math.round(message.useItemId));
    message.useItemCount !== undefined &&
      (obj.useItemCount = Math.round(message.useItemCount));
    message.baseAvatarId !== undefined &&
      (obj.baseAvatarId = Math.round(message.baseAvatarId));
    message.useAvatarType !== undefined &&
      (obj.useAvatarType = avatarTypeToJSON(message.useAvatarType));
    message.optionalRewardId !== undefined &&
      (obj.optionalRewardId = Math.round(message.optionalRewardId));
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<UseItemCsReq>, I>>(
    object: I
  ): UseItemCsReq {
    const message = createBaseUseItemCsReq();
    message.useItemId = object.useItemId ?? 0;
    message.useItemCount = object.useItemCount ?? 0;
    message.baseAvatarId = object.baseAvatarId ?? 0;
    message.useAvatarType = object.useAvatarType ?? 0;
    message.optionalRewardId = object.optionalRewardId ?? 0;
    return message;
  },
};

function createBaseUseItemScRsp(): UseItemScRsp {
  return { retcode: 0, useItemId: 0, useItemCount: 0, returnData: undefined };
}

export const UseItemScRsp = {
  encode(
    message: UseItemScRsp,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.retcode !== 0) {
      writer.uint32(8).uint32(message.retcode);
    }
    if (message.useItemId !== 0) {
      writer.uint32(16).uint32(message.useItemId);
    }
    if (message.useItemCount !== 0) {
      writer.uint32(24).uint32(message.useItemCount);
    }
    if (message.returnData !== undefined) {
      ItemList.encode(message.returnData, writer.uint32(34).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): UseItemScRsp {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUseItemScRsp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.retcode = reader.uint32();
          break;
        case 2:
          message.useItemId = reader.uint32();
          break;
        case 3:
          message.useItemCount = reader.uint32();
          break;
        case 4:
          message.returnData = ItemList.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): UseItemScRsp {
    return {
      retcode: isSet(object.retcode) ? Number(object.retcode) : 0,
      useItemId: isSet(object.useItemId) ? Number(object.useItemId) : 0,
      useItemCount: isSet(object.useItemCount)
        ? Number(object.useItemCount)
        : 0,
      returnData: isSet(object.returnData)
        ? ItemList.fromJSON(object.returnData)
        : undefined,
    };
  },

  toJSON(message: UseItemScRsp): unknown {
    const obj: any = {};
    message.retcode !== undefined &&
      (obj.retcode = Math.round(message.retcode));
    message.useItemId !== undefined &&
      (obj.useItemId = Math.round(message.useItemId));
    message.useItemCount !== undefined &&
      (obj.useItemCount = Math.round(message.useItemCount));
    message.returnData !== undefined &&
      (obj.returnData = message.returnData
        ? ItemList.toJSON(message.returnData)
        : undefined);
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<UseItemScRsp>, I>>(
    object: I
  ): UseItemScRsp {
    const message = createBaseUseItemScRsp();
    message.retcode = object.retcode ?? 0;
    message.useItemId = object.useItemId ?? 0;
    message.useItemCount = object.useItemCount ?? 0;
    message.returnData =
      object.returnData !== undefined && object.returnData !== null
        ? ItemList.fromPartial(object.returnData)
        : undefined;
    return message;
  },
};

function createBaseRankUpEquipmentCsReq(): RankUpEquipmentCsReq {
  return { equipmentUniqueId: 0, equipmentIdList: [] };
}

export const RankUpEquipmentCsReq = {
  encode(
    message: RankUpEquipmentCsReq,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.equipmentUniqueId !== 0) {
      writer.uint32(8).uint32(message.equipmentUniqueId);
    }
    writer.uint32(18).fork();
    for (const v of message.equipmentIdList) {
      writer.uint32(v);
    }
    writer.ldelim();
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): RankUpEquipmentCsReq {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRankUpEquipmentCsReq();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.equipmentUniqueId = reader.uint32();
          break;
        case 2:
          if ((tag & 7) === 2) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.equipmentIdList.push(reader.uint32());
            }
          } else {
            message.equipmentIdList.push(reader.uint32());
          }
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): RankUpEquipmentCsReq {
    return {
      equipmentUniqueId: isSet(object.equipmentUniqueId)
        ? Number(object.equipmentUniqueId)
        : 0,
      equipmentIdList: Array.isArray(object?.equipmentIdList)
        ? object.equipmentIdList.map((e: any) => Number(e))
        : [],
    };
  },

  toJSON(message: RankUpEquipmentCsReq): unknown {
    const obj: any = {};
    message.equipmentUniqueId !== undefined &&
      (obj.equipmentUniqueId = Math.round(message.equipmentUniqueId));
    if (message.equipmentIdList) {
      obj.equipmentIdList = message.equipmentIdList.map((e) => Math.round(e));
    } else {
      obj.equipmentIdList = [];
    }
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<RankUpEquipmentCsReq>, I>>(
    object: I
  ): RankUpEquipmentCsReq {
    const message = createBaseRankUpEquipmentCsReq();
    message.equipmentUniqueId = object.equipmentUniqueId ?? 0;
    message.equipmentIdList = object.equipmentIdList?.map((e) => e) || [];
    return message;
  },
};

function createBaseRankUpEquipmentScRsp(): RankUpEquipmentScRsp {
  return { retcode: 0 };
}

export const RankUpEquipmentScRsp = {
  encode(
    message: RankUpEquipmentScRsp,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.retcode !== 0) {
      writer.uint32(8).uint32(message.retcode);
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): RankUpEquipmentScRsp {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRankUpEquipmentScRsp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.retcode = reader.uint32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): RankUpEquipmentScRsp {
    return {
      retcode: isSet(object.retcode) ? Number(object.retcode) : 0,
    };
  },

  toJSON(message: RankUpEquipmentScRsp): unknown {
    const obj: any = {};
    message.retcode !== undefined &&
      (obj.retcode = Math.round(message.retcode));
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<RankUpEquipmentScRsp>, I>>(
    object: I
  ): RankUpEquipmentScRsp {
    const message = createBaseRankUpEquipmentScRsp();
    message.retcode = object.retcode ?? 0;
    return message;
  },
};

function createBaseExpUpEquipmentCsReq(): ExpUpEquipmentCsReq {
  return { equipmentUniqueId: 0, costData: undefined };
}

export const ExpUpEquipmentCsReq = {
  encode(
    message: ExpUpEquipmentCsReq,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.equipmentUniqueId !== 0) {
      writer.uint32(8).uint32(message.equipmentUniqueId);
    }
    if (message.costData !== undefined) {
      ItemCostData.encode(message.costData, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ExpUpEquipmentCsReq {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExpUpEquipmentCsReq();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.equipmentUniqueId = reader.uint32();
          break;
        case 2:
          message.costData = ItemCostData.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): ExpUpEquipmentCsReq {
    return {
      equipmentUniqueId: isSet(object.equipmentUniqueId)
        ? Number(object.equipmentUniqueId)
        : 0,
      costData: isSet(object.costData)
        ? ItemCostData.fromJSON(object.costData)
        : undefined,
    };
  },

  toJSON(message: ExpUpEquipmentCsReq): unknown {
    const obj: any = {};
    message.equipmentUniqueId !== undefined &&
      (obj.equipmentUniqueId = Math.round(message.equipmentUniqueId));
    message.costData !== undefined &&
      (obj.costData = message.costData
        ? ItemCostData.toJSON(message.costData)
        : undefined);
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<ExpUpEquipmentCsReq>, I>>(
    object: I
  ): ExpUpEquipmentCsReq {
    const message = createBaseExpUpEquipmentCsReq();
    message.equipmentUniqueId = object.equipmentUniqueId ?? 0;
    message.costData =
      object.costData !== undefined && object.costData !== null
        ? ItemCostData.fromPartial(object.costData)
        : undefined;
    return message;
  },
};

function createBaseExpUpEquipmentScRsp(): ExpUpEquipmentScRsp {
  return { retcode: 0, returnItemList: [] };
}

export const ExpUpEquipmentScRsp = {
  encode(
    message: ExpUpEquipmentScRsp,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.retcode !== 0) {
      writer.uint32(8).uint32(message.retcode);
    }
    for (const v of message.returnItemList) {
      PileItem.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ExpUpEquipmentScRsp {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExpUpEquipmentScRsp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.retcode = reader.uint32();
          break;
        case 2:
          message.returnItemList.push(PileItem.decode(reader, reader.uint32()));
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): ExpUpEquipmentScRsp {
    return {
      retcode: isSet(object.retcode) ? Number(object.retcode) : 0,
      returnItemList: Array.isArray(object?.returnItemList)
        ? object.returnItemList.map((e: any) => PileItem.fromJSON(e))
        : [],
    };
  },

  toJSON(message: ExpUpEquipmentScRsp): unknown {
    const obj: any = {};
    message.retcode !== undefined &&
      (obj.retcode = Math.round(message.retcode));
    if (message.returnItemList) {
      obj.returnItemList = message.returnItemList.map((e) =>
        e ? PileItem.toJSON(e) : undefined
      );
    } else {
      obj.returnItemList = [];
    }
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<ExpUpEquipmentScRsp>, I>>(
    object: I
  ): ExpUpEquipmentScRsp {
    const message = createBaseExpUpEquipmentScRsp();
    message.retcode = object.retcode ?? 0;
    message.returnItemList =
      object.returnItemList?.map((e) => PileItem.fromPartial(e)) || [];
    return message;
  },
};

function createBaseComposeItemCsReq(): ComposeItemCsReq {
  return { composeId: 0, count: 0 };
}

export const ComposeItemCsReq = {
  encode(
    message: ComposeItemCsReq,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.composeId !== 0) {
      writer.uint32(8).uint32(message.composeId);
    }
    if (message.count !== 0) {
      writer.uint32(16).uint32(message.count);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ComposeItemCsReq {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseComposeItemCsReq();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.composeId = reader.uint32();
          break;
        case 2:
          message.count = reader.uint32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): ComposeItemCsReq {
    return {
      composeId: isSet(object.composeId) ? Number(object.composeId) : 0,
      count: isSet(object.count) ? Number(object.count) : 0,
    };
  },

  toJSON(message: ComposeItemCsReq): unknown {
    const obj: any = {};
    message.composeId !== undefined &&
      (obj.composeId = Math.round(message.composeId));
    message.count !== undefined && (obj.count = Math.round(message.count));
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<ComposeItemCsReq>, I>>(
    object: I
  ): ComposeItemCsReq {
    const message = createBaseComposeItemCsReq();
    message.composeId = object.composeId ?? 0;
    message.count = object.count ?? 0;
    return message;
  },
};

function createBaseComposeItemScRsp(): ComposeItemScRsp {
  return { retcode: 0, composeId: 0, count: 0, returnItemList: undefined };
}

export const ComposeItemScRsp = {
  encode(
    message: ComposeItemScRsp,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.retcode !== 0) {
      writer.uint32(8).uint32(message.retcode);
    }
    if (message.composeId !== 0) {
      writer.uint32(16).uint32(message.composeId);
    }
    if (message.count !== 0) {
      writer.uint32(24).uint32(message.count);
    }
    if (message.returnItemList !== undefined) {
      ItemList.encode(
        message.returnItemList,
        writer.uint32(34).fork()
      ).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ComposeItemScRsp {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseComposeItemScRsp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.retcode = reader.uint32();
          break;
        case 2:
          message.composeId = reader.uint32();
          break;
        case 3:
          message.count = reader.uint32();
          break;
        case 4:
          message.returnItemList = ItemList.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): ComposeItemScRsp {
    return {
      retcode: isSet(object.retcode) ? Number(object.retcode) : 0,
      composeId: isSet(object.composeId) ? Number(object.composeId) : 0,
      count: isSet(object.count) ? Number(object.count) : 0,
      returnItemList: isSet(object.returnItemList)
        ? ItemList.fromJSON(object.returnItemList)
        : undefined,
    };
  },

  toJSON(message: ComposeItemScRsp): unknown {
    const obj: any = {};
    message.retcode !== undefined &&
      (obj.retcode = Math.round(message.retcode));
    message.composeId !== undefined &&
      (obj.composeId = Math.round(message.composeId));
    message.count !== undefined && (obj.count = Math.round(message.count));
    message.returnItemList !== undefined &&
      (obj.returnItemList = message.returnItemList
        ? ItemList.toJSON(message.returnItemList)
        : undefined);
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<ComposeItemScRsp>, I>>(
    object: I
  ): ComposeItemScRsp {
    const message = createBaseComposeItemScRsp();
    message.retcode = object.retcode ?? 0;
    message.composeId = object.composeId ?? 0;
    message.count = object.count ?? 0;
    message.returnItemList =
      object.returnItemList !== undefined && object.returnItemList !== null
        ? ItemList.fromPartial(object.returnItemList)
        : undefined;
    return message;
  },
};

function createBaseExpUpRelicCsReq(): ExpUpRelicCsReq {
  return { relicUniqueId: 0, costData: undefined };
}

export const ExpUpRelicCsReq = {
  encode(
    message: ExpUpRelicCsReq,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.relicUniqueId !== 0) {
      writer.uint32(8).uint32(message.relicUniqueId);
    }
    if (message.costData !== undefined) {
      ItemCostData.encode(message.costData, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ExpUpRelicCsReq {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExpUpRelicCsReq();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.relicUniqueId = reader.uint32();
          break;
        case 2:
          message.costData = ItemCostData.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): ExpUpRelicCsReq {
    return {
      relicUniqueId: isSet(object.relicUniqueId)
        ? Number(object.relicUniqueId)
        : 0,
      costData: isSet(object.costData)
        ? ItemCostData.fromJSON(object.costData)
        : undefined,
    };
  },

  toJSON(message: ExpUpRelicCsReq): unknown {
    const obj: any = {};
    message.relicUniqueId !== undefined &&
      (obj.relicUniqueId = Math.round(message.relicUniqueId));
    message.costData !== undefined &&
      (obj.costData = message.costData
        ? ItemCostData.toJSON(message.costData)
        : undefined);
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<ExpUpRelicCsReq>, I>>(
    object: I
  ): ExpUpRelicCsReq {
    const message = createBaseExpUpRelicCsReq();
    message.relicUniqueId = object.relicUniqueId ?? 0;
    message.costData =
      object.costData !== undefined && object.costData !== null
        ? ItemCostData.fromPartial(object.costData)
        : undefined;
    return message;
  },
};

function createBaseExpUpRelicScRsp(): ExpUpRelicScRsp {
  return { retcode: 0, returnItemList: [] };
}

export const ExpUpRelicScRsp = {
  encode(
    message: ExpUpRelicScRsp,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.retcode !== 0) {
      writer.uint32(8).uint32(message.retcode);
    }
    for (const v of message.returnItemList) {
      PileItem.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ExpUpRelicScRsp {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExpUpRelicScRsp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.retcode = reader.uint32();
          break;
        case 2:
          message.returnItemList.push(PileItem.decode(reader, reader.uint32()));
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): ExpUpRelicScRsp {
    return {
      retcode: isSet(object.retcode) ? Number(object.retcode) : 0,
      returnItemList: Array.isArray(object?.returnItemList)
        ? object.returnItemList.map((e: any) => PileItem.fromJSON(e))
        : [],
    };
  },

  toJSON(message: ExpUpRelicScRsp): unknown {
    const obj: any = {};
    message.retcode !== undefined &&
      (obj.retcode = Math.round(message.retcode));
    if (message.returnItemList) {
      obj.returnItemList = message.returnItemList.map((e) =>
        e ? PileItem.toJSON(e) : undefined
      );
    } else {
      obj.returnItemList = [];
    }
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<ExpUpRelicScRsp>, I>>(
    object: I
  ): ExpUpRelicScRsp {
    const message = createBaseExpUpRelicScRsp();
    message.retcode = object.retcode ?? 0;
    message.returnItemList =
      object.returnItemList?.map((e) => PileItem.fromPartial(e)) || [];
    return message;
  },
};

function createBaseLockRelicCsReq(): LockRelicCsReq {
  return { relicUniqueId: 0, isLock: false };
}

export const LockRelicCsReq = {
  encode(
    message: LockRelicCsReq,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.relicUniqueId !== 0) {
      writer.uint32(8).uint32(message.relicUniqueId);
    }
    if (message.isLock === true) {
      writer.uint32(16).bool(message.isLock);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): LockRelicCsReq {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLockRelicCsReq();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.relicUniqueId = reader.uint32();
          break;
        case 2:
          message.isLock = reader.bool();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): LockRelicCsReq {
    return {
      relicUniqueId: isSet(object.relicUniqueId)
        ? Number(object.relicUniqueId)
        : 0,
      isLock: isSet(object.isLock) ? Boolean(object.isLock) : false,
    };
  },

  toJSON(message: LockRelicCsReq): unknown {
    const obj: any = {};
    message.relicUniqueId !== undefined &&
      (obj.relicUniqueId = Math.round(message.relicUniqueId));
    message.isLock !== undefined && (obj.isLock = message.isLock);
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<LockRelicCsReq>, I>>(
    object: I
  ): LockRelicCsReq {
    const message = createBaseLockRelicCsReq();
    message.relicUniqueId = object.relicUniqueId ?? 0;
    message.isLock = object.isLock ?? false;
    return message;
  },
};

function createBaseLockRelicScRsp(): LockRelicScRsp {
  return { retcode: 0, relicUniqueId: 0 };
}

export const LockRelicScRsp = {
  encode(
    message: LockRelicScRsp,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.retcode !== 0) {
      writer.uint32(8).uint32(message.retcode);
    }
    if (message.relicUniqueId !== 0) {
      writer.uint32(16).uint32(message.relicUniqueId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): LockRelicScRsp {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLockRelicScRsp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.retcode = reader.uint32();
          break;
        case 2:
          message.relicUniqueId = reader.uint32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): LockRelicScRsp {
    return {
      retcode: isSet(object.retcode) ? Number(object.retcode) : 0,
      relicUniqueId: isSet(object.relicUniqueId)
        ? Number(object.relicUniqueId)
        : 0,
    };
  },

  toJSON(message: LockRelicScRsp): unknown {
    const obj: any = {};
    message.retcode !== undefined &&
      (obj.retcode = Math.round(message.retcode));
    message.relicUniqueId !== undefined &&
      (obj.relicUniqueId = Math.round(message.relicUniqueId));
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<LockRelicScRsp>, I>>(
    object: I
  ): LockRelicScRsp {
    const message = createBaseLockRelicScRsp();
    message.retcode = object.retcode ?? 0;
    message.relicUniqueId = object.relicUniqueId ?? 0;
    return message;
  },
};

function createBaseSellItemCsReq(): SellItemCsReq {
  return { costData: undefined };
}

export const SellItemCsReq = {
  encode(
    message: SellItemCsReq,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.costData !== undefined) {
      ItemCostData.encode(message.costData, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SellItemCsReq {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSellItemCsReq();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.costData = ItemCostData.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): SellItemCsReq {
    return {
      costData: isSet(object.costData)
        ? ItemCostData.fromJSON(object.costData)
        : undefined,
    };
  },

  toJSON(message: SellItemCsReq): unknown {
    const obj: any = {};
    message.costData !== undefined &&
      (obj.costData = message.costData
        ? ItemCostData.toJSON(message.costData)
        : undefined);
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<SellItemCsReq>, I>>(
    object: I
  ): SellItemCsReq {
    const message = createBaseSellItemCsReq();
    message.costData =
      object.costData !== undefined && object.costData !== null
        ? ItemCostData.fromPartial(object.costData)
        : undefined;
    return message;
  },
};

function createBaseSellItemScRsp(): SellItemScRsp {
  return { retcode: 0, returnItemList: undefined };
}

export const SellItemScRsp = {
  encode(
    message: SellItemScRsp,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.retcode !== 0) {
      writer.uint32(8).uint32(message.retcode);
    }
    if (message.returnItemList !== undefined) {
      ItemList.encode(
        message.returnItemList,
        writer.uint32(18).fork()
      ).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SellItemScRsp {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSellItemScRsp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.retcode = reader.uint32();
          break;
        case 2:
          message.returnItemList = ItemList.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): SellItemScRsp {
    return {
      retcode: isSet(object.retcode) ? Number(object.retcode) : 0,
      returnItemList: isSet(object.returnItemList)
        ? ItemList.fromJSON(object.returnItemList)
        : undefined,
    };
  },

  toJSON(message: SellItemScRsp): unknown {
    const obj: any = {};
    message.retcode !== undefined &&
      (obj.retcode = Math.round(message.retcode));
    message.returnItemList !== undefined &&
      (obj.returnItemList = message.returnItemList
        ? ItemList.toJSON(message.returnItemList)
        : undefined);
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<SellItemScRsp>, I>>(
    object: I
  ): SellItemScRsp {
    const message = createBaseSellItemScRsp();
    message.retcode = object.retcode ?? 0;
    message.returnItemList =
      object.returnItemList !== undefined && object.returnItemList !== null
        ? ItemList.fromPartial(object.returnItemList)
        : undefined;
    return message;
  },
};

function createBaseRechargeSuccNotify(): RechargeSuccNotify {
  return { itemList: undefined };
}

export const RechargeSuccNotify = {
  encode(
    message: RechargeSuccNotify,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.itemList !== undefined) {
      ItemList.encode(message.itemList, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): RechargeSuccNotify {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRechargeSuccNotify();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.itemList = ItemList.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): RechargeSuccNotify {
    return {
      itemList: isSet(object.itemList)
        ? ItemList.fromJSON(object.itemList)
        : undefined,
    };
  },

  toJSON(message: RechargeSuccNotify): unknown {
    const obj: any = {};
    message.itemList !== undefined &&
      (obj.itemList = message.itemList
        ? ItemList.toJSON(message.itemList)
        : undefined);
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<RechargeSuccNotify>, I>>(
    object: I
  ): RechargeSuccNotify {
    const message = createBaseRechargeSuccNotify();
    message.itemList =
      object.itemList !== undefined && object.itemList !== null
        ? ItemList.fromPartial(object.itemList)
        : undefined;
    return message;
  },
};

function createBaseGetStageLineupCsReq(): GetStageLineupCsReq {
  return {};
}

export const GetStageLineupCsReq = {
  encode(
    _: GetStageLineupCsReq,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetStageLineupCsReq {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetStageLineupCsReq();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(_: any): GetStageLineupCsReq {
    return {};
  },

  toJSON(_: GetStageLineupCsReq): unknown {
    const obj: any = {};
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<GetStageLineupCsReq>, I>>(
    _: I
  ): GetStageLineupCsReq {
    const message = createBaseGetStageLineupCsReq();
    return message;
  },
};

function createBaseStageLineup(): StageLineup {
  return { stageType: 0, lineupIndex: 0 };
}

export const StageLineup = {
  encode(
    message: StageLineup,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.stageType !== 0) {
      writer.uint32(8).uint32(message.stageType);
    }
    if (message.lineupIndex !== 0) {
      writer.uint32(16).uint32(message.lineupIndex);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): StageLineup {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStageLineup();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.stageType = reader.uint32();
          break;
        case 2:
          message.lineupIndex = reader.uint32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): StageLineup {
    return {
      stageType: isSet(object.stageType) ? Number(object.stageType) : 0,
      lineupIndex: isSet(object.lineupIndex) ? Number(object.lineupIndex) : 0,
    };
  },

  toJSON(message: StageLineup): unknown {
    const obj: any = {};
    message.stageType !== undefined &&
      (obj.stageType = Math.round(message.stageType));
    message.lineupIndex !== undefined &&
      (obj.lineupIndex = Math.round(message.lineupIndex));
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<StageLineup>, I>>(
    object: I
  ): StageLineup {
    const message = createBaseStageLineup();
    message.stageType = object.stageType ?? 0;
    message.lineupIndex = object.lineupIndex ?? 0;
    return message;
  },
};

function createBaseGetStageLineupScRsp(): GetStageLineupScRsp {
  return { retcode: 0, stageLineupList: [] };
}

export const GetStageLineupScRsp = {
  encode(
    message: GetStageLineupScRsp,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.retcode !== 0) {
      writer.uint32(8).uint32(message.retcode);
    }
    for (const v of message.stageLineupList) {
      StageLineup.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetStageLineupScRsp {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetStageLineupScRsp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.retcode = reader.uint32();
          break;
        case 2:
          message.stageLineupList.push(
            StageLineup.decode(reader, reader.uint32())
          );
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): GetStageLineupScRsp {
    return {
      retcode: isSet(object.retcode) ? Number(object.retcode) : 0,
      stageLineupList: Array.isArray(object?.stageLineupList)
        ? object.stageLineupList.map((e: any) => StageLineup.fromJSON(e))
        : [],
    };
  },

  toJSON(message: GetStageLineupScRsp): unknown {
    const obj: any = {};
    message.retcode !== undefined &&
      (obj.retcode = Math.round(message.retcode));
    if (message.stageLineupList) {
      obj.stageLineupList = message.stageLineupList.map((e) =>
        e ? StageLineup.toJSON(e) : undefined
      );
    } else {
      obj.stageLineupList = [];
    }
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<GetStageLineupScRsp>, I>>(
    object: I
  ): GetStageLineupScRsp {
    const message = createBaseGetStageLineupScRsp();
    message.retcode = object.retcode ?? 0;
    message.stageLineupList =
      object.stageLineupList?.map((e) => StageLineup.fromPartial(e)) || [];
    return message;
  },
};

function createBaseLineupAvatar(): LineupAvatar {
  return { slot: 0, avatarType: 0, id: 0, hp: 0, sp: 0, satiety: 0 };
}

export const LineupAvatar = {
  encode(
    message: LineupAvatar,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.slot !== 0) {
      writer.uint32(8).uint32(message.slot);
    }
    if (message.avatarType !== 0) {
      writer.uint32(16).int32(message.avatarType);
    }
    if (message.id !== 0) {
      writer.uint32(24).uint32(message.id);
    }
    if (message.hp !== 0) {
      writer.uint32(32).uint32(message.hp);
    }
    if (message.sp !== 0) {
      writer.uint32(40).uint32(message.sp);
    }
    if (message.satiety !== 0) {
      writer.uint32(48).uint32(message.satiety);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): LineupAvatar {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLineupAvatar();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.slot = reader.uint32();
          break;
        case 2:
          message.avatarType = reader.int32() as any;
          break;
        case 3:
          message.id = reader.uint32();
          break;
        case 4:
          message.hp = reader.uint32();
          break;
        case 5:
          message.sp = reader.uint32();
          break;
        case 6:
          message.satiety = reader.uint32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): LineupAvatar {
    return {
      slot: isSet(object.slot) ? Number(object.slot) : 0,
      avatarType: isSet(object.avatarType)
        ? avatarTypeFromJSON(object.avatarType)
        : 0,
      id: isSet(object.id) ? Number(object.id) : 0,
      hp: isSet(object.hp) ? Number(object.hp) : 0,
      sp: isSet(object.sp) ? Number(object.sp) : 0,
      satiety: isSet(object.satiety) ? Number(object.satiety) : 0,
    };
  },

  toJSON(message: LineupAvatar): unknown {
    const obj: any = {};
    message.slot !== undefined && (obj.slot = Math.round(message.slot));
    message.avatarType !== undefined &&
      (obj.avatarType = avatarTypeToJSON(message.avatarType));
    message.id !== undefined && (obj.id = Math.round(message.id));
    message.hp !== undefined && (obj.hp = Math.round(message.hp));
    message.sp !== undefined && (obj.sp = Math.round(message.sp));
    message.satiety !== undefined &&
      (obj.satiety = Math.round(message.satiety));
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<LineupAvatar>, I>>(
    object: I
  ): LineupAvatar {
    const message = createBaseLineupAvatar();
    message.slot = object.slot ?? 0;
    message.avatarType = object.avatarType ?? 0;
    message.id = object.id ?? 0;
    message.hp = object.hp ?? 0;
    message.sp = object.sp ?? 0;
    message.satiety = object.satiety ?? 0;
    return message;
  },
};

function createBaseLineupInfo(): LineupInfo {
  return {
    avatarList: [],
    isVirtual: false,
    planeId: 0,
    mp: 0,
    leaderSlot: 0,
    index: 0,
    extraLineupType: 0,
    name: "",
  };
}

export const LineupInfo = {
  encode(
    message: LineupInfo,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    for (const v of message.avatarList) {
      LineupAvatar.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    if (message.isVirtual === true) {
      writer.uint32(16).bool(message.isVirtual);
    }
    if (message.planeId !== 0) {
      writer.uint32(24).uint32(message.planeId);
    }
    if (message.mp !== 0) {
      writer.uint32(32).uint32(message.mp);
    }
    if (message.leaderSlot !== 0) {
      writer.uint32(40).uint32(message.leaderSlot);
    }
    if (message.index !== 0) {
      writer.uint32(48).uint32(message.index);
    }
    if (message.extraLineupType !== 0) {
      writer.uint32(56).int32(message.extraLineupType);
    }
    if (message.name !== "") {
      writer.uint32(66).string(message.name);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): LineupInfo {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLineupInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.avatarList.push(LineupAvatar.decode(reader, reader.uint32()));
          break;
        case 2:
          message.isVirtual = reader.bool();
          break;
        case 3:
          message.planeId = reader.uint32();
          break;
        case 4:
          message.mp = reader.uint32();
          break;
        case 5:
          message.leaderSlot = reader.uint32();
          break;
        case 6:
          message.index = reader.uint32();
          break;
        case 7:
          message.extraLineupType = reader.int32() as any;
          break;
        case 8:
          message.name = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): LineupInfo {
    return {
      avatarList: Array.isArray(object?.avatarList)
        ? object.avatarList.map((e: any) => LineupAvatar.fromJSON(e))
        : [],
      isVirtual: isSet(object.isVirtual) ? Boolean(object.isVirtual) : false,
      planeId: isSet(object.planeId) ? Number(object.planeId) : 0,
      mp: isSet(object.mp) ? Number(object.mp) : 0,
      leaderSlot: isSet(object.leaderSlot) ? Number(object.leaderSlot) : 0,
      index: isSet(object.index) ? Number(object.index) : 0,
      extraLineupType: isSet(object.extraLineupType)
        ? extraLineupTypeFromJSON(object.extraLineupType)
        : 0,
      name: isSet(object.name) ? String(object.name) : "",
    };
  },

  toJSON(message: LineupInfo): unknown {
    const obj: any = {};
    if (message.avatarList) {
      obj.avatarList = message.avatarList.map((e) =>
        e ? LineupAvatar.toJSON(e) : undefined
      );
    } else {
      obj.avatarList = [];
    }
    message.isVirtual !== undefined && (obj.isVirtual = message.isVirtual);
    message.planeId !== undefined &&
      (obj.planeId = Math.round(message.planeId));
    message.mp !== undefined && (obj.mp = Math.round(message.mp));
    message.leaderSlot !== undefined &&
      (obj.leaderSlot = Math.round(message.leaderSlot));
    message.index !== undefined && (obj.index = Math.round(message.index));
    message.extraLineupType !== undefined &&
      (obj.extraLineupType = extraLineupTypeToJSON(message.extraLineupType));
    message.name !== undefined && (obj.name = message.name);
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<LineupInfo>, I>>(
    object: I
  ): LineupInfo {
    const message = createBaseLineupInfo();
    message.avatarList =
      object.avatarList?.map((e) => LineupAvatar.fromPartial(e)) || [];
    message.isVirtual = object.isVirtual ?? false;
    message.planeId = object.planeId ?? 0;
    message.mp = object.mp ?? 0;
    message.leaderSlot = object.leaderSlot ?? 0;
    message.index = object.index ?? 0;
    message.extraLineupType = object.extraLineupType ?? 0;
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseGetCurLineupDataCsReq(): GetCurLineupDataCsReq {
  return {};
}

export const GetCurLineupDataCsReq = {
  encode(
    _: GetCurLineupDataCsReq,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): GetCurLineupDataCsReq {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetCurLineupDataCsReq();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(_: any): GetCurLineupDataCsReq {
    return {};
  },

  toJSON(_: GetCurLineupDataCsReq): unknown {
    const obj: any = {};
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<GetCurLineupDataCsReq>, I>>(
    _: I
  ): GetCurLineupDataCsReq {
    const message = createBaseGetCurLineupDataCsReq();
    return message;
  },
};

function createBaseGetCurLineupDataScRsp(): GetCurLineupDataScRsp {
  return { retcode: 0, lineup: undefined };
}

export const GetCurLineupDataScRsp = {
  encode(
    message: GetCurLineupDataScRsp,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.retcode !== 0) {
      writer.uint32(8).uint32(message.retcode);
    }
    if (message.lineup !== undefined) {
      LineupInfo.encode(message.lineup, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): GetCurLineupDataScRsp {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetCurLineupDataScRsp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.retcode = reader.uint32();
          break;
        case 2:
          message.lineup = LineupInfo.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): GetCurLineupDataScRsp {
    return {
      retcode: isSet(object.retcode) ? Number(object.retcode) : 0,
      lineup: isSet(object.lineup)
        ? LineupInfo.fromJSON(object.lineup)
        : undefined,
    };
  },

  toJSON(message: GetCurLineupDataScRsp): unknown {
    const obj: any = {};
    message.retcode !== undefined &&
      (obj.retcode = Math.round(message.retcode));
    message.lineup !== undefined &&
      (obj.lineup = message.lineup
        ? LineupInfo.toJSON(message.lineup)
        : undefined);
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<GetCurLineupDataScRsp>, I>>(
    object: I
  ): GetCurLineupDataScRsp {
    const message = createBaseGetCurLineupDataScRsp();
    message.retcode = object.retcode ?? 0;
    message.lineup =
      object.lineup !== undefined && object.lineup !== null
        ? LineupInfo.fromPartial(object.lineup)
        : undefined;
    return message;
  },
};

function createBaseJoinLineupCsReq(): JoinLineupCsReq {
  return {
    baseAvatarId: 0,
    isVirtual: false,
    planeId: 0,
    slot: 0,
    index: 0,
    extraLineupType: 0,
  };
}

export const JoinLineupCsReq = {
  encode(
    message: JoinLineupCsReq,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.baseAvatarId !== 0) {
      writer.uint32(8).uint32(message.baseAvatarId);
    }
    if (message.isVirtual === true) {
      writer.uint32(16).bool(message.isVirtual);
    }
    if (message.planeId !== 0) {
      writer.uint32(24).uint32(message.planeId);
    }
    if (message.slot !== 0) {
      writer.uint32(32).uint32(message.slot);
    }
    if (message.index !== 0) {
      writer.uint32(40).uint32(message.index);
    }
    if (message.extraLineupType !== 0) {
      writer.uint32(48).int32(message.extraLineupType);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): JoinLineupCsReq {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseJoinLineupCsReq();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.baseAvatarId = reader.uint32();
          break;
        case 2:
          message.isVirtual = reader.bool();
          break;
        case 3:
          message.planeId = reader.uint32();
          break;
        case 4:
          message.slot = reader.uint32();
          break;
        case 5:
          message.index = reader.uint32();
          break;
        case 6:
          message.extraLineupType = reader.int32() as any;
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): JoinLineupCsReq {
    return {
      baseAvatarId: isSet(object.baseAvatarId)
        ? Number(object.baseAvatarId)
        : 0,
      isVirtual: isSet(object.isVirtual) ? Boolean(object.isVirtual) : false,
      planeId: isSet(object.planeId) ? Number(object.planeId) : 0,
      slot: isSet(object.slot) ? Number(object.slot) : 0,
      index: isSet(object.index) ? Number(object.index) : 0,
      extraLineupType: isSet(object.extraLineupType)
        ? extraLineupTypeFromJSON(object.extraLineupType)
        : 0,
    };
  },

  toJSON(message: JoinLineupCsReq): unknown {
    const obj: any = {};
    message.baseAvatarId !== undefined &&
      (obj.baseAvatarId = Math.round(message.baseAvatarId));
    message.isVirtual !== undefined && (obj.isVirtual = message.isVirtual);
    message.planeId !== undefined &&
      (obj.planeId = Math.round(message.planeId));
    message.slot !== undefined && (obj.slot = Math.round(message.slot));
    message.index !== undefined && (obj.index = Math.round(message.index));
    message.extraLineupType !== undefined &&
      (obj.extraLineupType = extraLineupTypeToJSON(message.extraLineupType));
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<JoinLineupCsReq>, I>>(
    object: I
  ): JoinLineupCsReq {
    const message = createBaseJoinLineupCsReq();
    message.baseAvatarId = object.baseAvatarId ?? 0;
    message.isVirtual = object.isVirtual ?? false;
    message.planeId = object.planeId ?? 0;
    message.slot = object.slot ?? 0;
    message.index = object.index ?? 0;
    message.extraLineupType = object.extraLineupType ?? 0;
    return message;
  },
};

function createBaseJoinLineupScRsp(): JoinLineupScRsp {
  return { retcode: 0 };
}

export const JoinLineupScRsp = {
  encode(
    message: JoinLineupScRsp,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.retcode !== 0) {
      writer.uint32(8).uint32(message.retcode);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): JoinLineupScRsp {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseJoinLineupScRsp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.retcode = reader.uint32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): JoinLineupScRsp {
    return {
      retcode: isSet(object.retcode) ? Number(object.retcode) : 0,
    };
  },

  toJSON(message: JoinLineupScRsp): unknown {
    const obj: any = {};
    message.retcode !== undefined &&
      (obj.retcode = Math.round(message.retcode));
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<JoinLineupScRsp>, I>>(
    object: I
  ): JoinLineupScRsp {
    const message = createBaseJoinLineupScRsp();
    message.retcode = object.retcode ?? 0;
    return message;
  },
};

function createBaseQuitLineupCsReq(): QuitLineupCsReq {
  return {
    baseAvatarId: 0,
    isVirtual: false,
    planeId: 0,
    index: 0,
    extraLineupType: 0,
  };
}

export const QuitLineupCsReq = {
  encode(
    message: QuitLineupCsReq,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.baseAvatarId !== 0) {
      writer.uint32(8).uint32(message.baseAvatarId);
    }
    if (message.isVirtual === true) {
      writer.uint32(16).bool(message.isVirtual);
    }
    if (message.planeId !== 0) {
      writer.uint32(24).uint32(message.planeId);
    }
    if (message.index !== 0) {
      writer.uint32(32).uint32(message.index);
    }
    if (message.extraLineupType !== 0) {
      writer.uint32(40).int32(message.extraLineupType);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): QuitLineupCsReq {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQuitLineupCsReq();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.baseAvatarId = reader.uint32();
          break;
        case 2:
          message.isVirtual = reader.bool();
          break;
        case 3:
          message.planeId = reader.uint32();
          break;
        case 4:
          message.index = reader.uint32();
          break;
        case 5:
          message.extraLineupType = reader.int32() as any;
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): QuitLineupCsReq {
    return {
      baseAvatarId: isSet(object.baseAvatarId)
        ? Number(object.baseAvatarId)
        : 0,
      isVirtual: isSet(object.isVirtual) ? Boolean(object.isVirtual) : false,
      planeId: isSet(object.planeId) ? Number(object.planeId) : 0,
      index: isSet(object.index) ? Number(object.index) : 0,
      extraLineupType: isSet(object.extraLineupType)
        ? extraLineupTypeFromJSON(object.extraLineupType)
        : 0,
    };
  },

  toJSON(message: QuitLineupCsReq): unknown {
    const obj: any = {};
    message.baseAvatarId !== undefined &&
      (obj.baseAvatarId = Math.round(message.baseAvatarId));
    message.isVirtual !== undefined && (obj.isVirtual = message.isVirtual);
    message.planeId !== undefined &&
      (obj.planeId = Math.round(message.planeId));
    message.index !== undefined && (obj.index = Math.round(message.index));
    message.extraLineupType !== undefined &&
      (obj.extraLineupType = extraLineupTypeToJSON(message.extraLineupType));
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<QuitLineupCsReq>, I>>(
    object: I
  ): QuitLineupCsReq {
    const message = createBaseQuitLineupCsReq();
    message.baseAvatarId = object.baseAvatarId ?? 0;
    message.isVirtual = object.isVirtual ?? false;
    message.planeId = object.planeId ?? 0;
    message.index = object.index ?? 0;
    message.extraLineupType = object.extraLineupType ?? 0;
    return message;
  },
};

function createBaseQuitLineupScRsp(): QuitLineupScRsp {
  return {
    retcode: 0,
    baseAvatarId: 0,
    isMainline: false,
    planeId: 0,
    isVirtual: false,
  };
}

export const QuitLineupScRsp = {
  encode(
    message: QuitLineupScRsp,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.retcode !== 0) {
      writer.uint32(8).uint32(message.retcode);
    }
    if (message.baseAvatarId !== 0) {
      writer.uint32(16).uint32(message.baseAvatarId);
    }
    if (message.isMainline === true) {
      writer.uint32(24).bool(message.isMainline);
    }
    if (message.planeId !== 0) {
      writer.uint32(32).uint32(message.planeId);
    }
    if (message.isVirtual === true) {
      writer.uint32(40).bool(message.isVirtual);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): QuitLineupScRsp {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQuitLineupScRsp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.retcode = reader.uint32();
          break;
        case 2:
          message.baseAvatarId = reader.uint32();
          break;
        case 3:
          message.isMainline = reader.bool();
          break;
        case 4:
          message.planeId = reader.uint32();
          break;
        case 5:
          message.isVirtual = reader.bool();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): QuitLineupScRsp {
    return {
      retcode: isSet(object.retcode) ? Number(object.retcode) : 0,
      baseAvatarId: isSet(object.baseAvatarId)
        ? Number(object.baseAvatarId)
        : 0,
      isMainline: isSet(object.isMainline) ? Boolean(object.isMainline) : false,
      planeId: isSet(object.planeId) ? Number(object.planeId) : 0,
      isVirtual: isSet(object.isVirtual) ? Boolean(object.isVirtual) : false,
    };
  },

  toJSON(message: QuitLineupScRsp): unknown {
    const obj: any = {};
    message.retcode !== undefined &&
      (obj.retcode = Math.round(message.retcode));
    message.baseAvatarId !== undefined &&
      (obj.baseAvatarId = Math.round(message.baseAvatarId));
    message.isMainline !== undefined && (obj.isMainline = message.isMainline);
    message.planeId !== undefined &&
      (obj.planeId = Math.round(message.planeId));
    message.isVirtual !== undefined && (obj.isVirtual = message.isVirtual);
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<QuitLineupScRsp>, I>>(
    object: I
  ): QuitLineupScRsp {
    const message = createBaseQuitLineupScRsp();
    message.retcode = object.retcode ?? 0;
    message.baseAvatarId = object.baseAvatarId ?? 0;
    message.isMainline = object.isMainline ?? false;
    message.planeId = object.planeId ?? 0;
    message.isVirtual = object.isVirtual ?? false;
    return message;
  },
};

function createBaseSwapLineupCsReq(): SwapLineupCsReq {
  return {
    isVirtual: false,
    planeId: 0,
    srcSlot: 0,
    dstSlot: 0,
    index: 0,
    extraLineupType: 0,
  };
}

export const SwapLineupCsReq = {
  encode(
    message: SwapLineupCsReq,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.isVirtual === true) {
      writer.uint32(8).bool(message.isVirtual);
    }
    if (message.planeId !== 0) {
      writer.uint32(16).uint32(message.planeId);
    }
    if (message.srcSlot !== 0) {
      writer.uint32(24).uint32(message.srcSlot);
    }
    if (message.dstSlot !== 0) {
      writer.uint32(32).uint32(message.dstSlot);
    }
    if (message.index !== 0) {
      writer.uint32(40).uint32(message.index);
    }
    if (message.extraLineupType !== 0) {
      writer.uint32(48).int32(message.extraLineupType);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SwapLineupCsReq {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSwapLineupCsReq();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.isVirtual = reader.bool();
          break;
        case 2:
          message.planeId = reader.uint32();
          break;
        case 3:
          message.srcSlot = reader.uint32();
          break;
        case 4:
          message.dstSlot = reader.uint32();
          break;
        case 5:
          message.index = reader.uint32();
          break;
        case 6:
          message.extraLineupType = reader.int32() as any;
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): SwapLineupCsReq {
    return {
      isVirtual: isSet(object.isVirtual) ? Boolean(object.isVirtual) : false,
      planeId: isSet(object.planeId) ? Number(object.planeId) : 0,
      srcSlot: isSet(object.srcSlot) ? Number(object.srcSlot) : 0,
      dstSlot: isSet(object.dstSlot) ? Number(object.dstSlot) : 0,
      index: isSet(object.index) ? Number(object.index) : 0,
      extraLineupType: isSet(object.extraLineupType)
        ? extraLineupTypeFromJSON(object.extraLineupType)
        : 0,
    };
  },

  toJSON(message: SwapLineupCsReq): unknown {
    const obj: any = {};
    message.isVirtual !== undefined && (obj.isVirtual = message.isVirtual);
    message.planeId !== undefined &&
      (obj.planeId = Math.round(message.planeId));
    message.srcSlot !== undefined &&
      (obj.srcSlot = Math.round(message.srcSlot));
    message.dstSlot !== undefined &&
      (obj.dstSlot = Math.round(message.dstSlot));
    message.index !== undefined && (obj.index = Math.round(message.index));
    message.extraLineupType !== undefined &&
      (obj.extraLineupType = extraLineupTypeToJSON(message.extraLineupType));
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<SwapLineupCsReq>, I>>(
    object: I
  ): SwapLineupCsReq {
    const message = createBaseSwapLineupCsReq();
    message.isVirtual = object.isVirtual ?? false;
    message.planeId = object.planeId ?? 0;
    message.srcSlot = object.srcSlot ?? 0;
    message.dstSlot = object.dstSlot ?? 0;
    message.index = object.index ?? 0;
    message.extraLineupType = object.extraLineupType ?? 0;
    return message;
  },
};

function createBaseSwapLineupScRsp(): SwapLineupScRsp {
  return { retcode: 0 };
}

export const SwapLineupScRsp = {
  encode(
    message: SwapLineupScRsp,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.retcode !== 0) {
      writer.uint32(8).uint32(message.retcode);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SwapLineupScRsp {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSwapLineupScRsp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.retcode = reader.uint32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): SwapLineupScRsp {
    return {
      retcode: isSet(object.retcode) ? Number(object.retcode) : 0,
    };
  },

  toJSON(message: SwapLineupScRsp): unknown {
    const obj: any = {};
    message.retcode !== undefined &&
      (obj.retcode = Math.round(message.retcode));
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<SwapLineupScRsp>, I>>(
    object: I
  ): SwapLineupScRsp {
    const message = createBaseSwapLineupScRsp();
    message.retcode = object.retcode ?? 0;
    return message;
  },
};

function createBaseSyncLineupNotify(): SyncLineupNotify {
  return { lineup: undefined, reasonList: [] };
}

export const SyncLineupNotify = {
  encode(
    message: SyncLineupNotify,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.lineup !== undefined) {
      LineupInfo.encode(message.lineup, writer.uint32(10).fork()).ldelim();
    }
    writer.uint32(18).fork();
    for (const v of message.reasonList) {
      writer.int32(v);
    }
    writer.ldelim();
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SyncLineupNotify {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSyncLineupNotify();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.lineup = LineupInfo.decode(reader, reader.uint32());
          break;
        case 2:
          if ((tag & 7) === 2) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.reasonList.push(reader.int32() as any);
            }
          } else {
            message.reasonList.push(reader.int32() as any);
          }
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): SyncLineupNotify {
    return {
      lineup: isSet(object.lineup)
        ? LineupInfo.fromJSON(object.lineup)
        : undefined,
      reasonList: Array.isArray(object?.reasonList)
        ? object.reasonList.map((e: any) => syncLineupReasonFromJSON(e))
        : [],
    };
  },

  toJSON(message: SyncLineupNotify): unknown {
    const obj: any = {};
    message.lineup !== undefined &&
      (obj.lineup = message.lineup
        ? LineupInfo.toJSON(message.lineup)
        : undefined);
    if (message.reasonList) {
      obj.reasonList = message.reasonList.map((e) => syncLineupReasonToJSON(e));
    } else {
      obj.reasonList = [];
    }
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<SyncLineupNotify>, I>>(
    object: I
  ): SyncLineupNotify {
    const message = createBaseSyncLineupNotify();
    message.lineup =
      object.lineup !== undefined && object.lineup !== null
        ? LineupInfo.fromPartial(object.lineup)
        : undefined;
    message.reasonList = object.reasonList?.map((e) => e) || [];
    return message;
  },
};

function createBaseGetLineupAvatarDataCsReq(): GetLineupAvatarDataCsReq {
  return {};
}

export const GetLineupAvatarDataCsReq = {
  encode(
    _: GetLineupAvatarDataCsReq,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): GetLineupAvatarDataCsReq {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetLineupAvatarDataCsReq();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(_: any): GetLineupAvatarDataCsReq {
    return {};
  },

  toJSON(_: GetLineupAvatarDataCsReq): unknown {
    const obj: any = {};
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<GetLineupAvatarDataCsReq>, I>>(
    _: I
  ): GetLineupAvatarDataCsReq {
    const message = createBaseGetLineupAvatarDataCsReq();
    return message;
  },
};

function createBaseLineupAvatarData(): LineupAvatarData {
  return { avatarType: 0, id: 0, hp: 0 };
}

export const LineupAvatarData = {
  encode(
    message: LineupAvatarData,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.avatarType !== 0) {
      writer.uint32(8).int32(message.avatarType);
    }
    if (message.id !== 0) {
      writer.uint32(16).uint32(message.id);
    }
    if (message.hp !== 0) {
      writer.uint32(24).uint32(message.hp);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): LineupAvatarData {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLineupAvatarData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.avatarType = reader.int32() as any;
          break;
        case 2:
          message.id = reader.uint32();
          break;
        case 3:
          message.hp = reader.uint32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): LineupAvatarData {
    return {
      avatarType: isSet(object.avatarType)
        ? avatarTypeFromJSON(object.avatarType)
        : 0,
      id: isSet(object.id) ? Number(object.id) : 0,
      hp: isSet(object.hp) ? Number(object.hp) : 0,
    };
  },

  toJSON(message: LineupAvatarData): unknown {
    const obj: any = {};
    message.avatarType !== undefined &&
      (obj.avatarType = avatarTypeToJSON(message.avatarType));
    message.id !== undefined && (obj.id = Math.round(message.id));
    message.hp !== undefined && (obj.hp = Math.round(message.hp));
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<LineupAvatarData>, I>>(
    object: I
  ): LineupAvatarData {
    const message = createBaseLineupAvatarData();
    message.avatarType = object.avatarType ?? 0;
    message.id = object.id ?? 0;
    message.hp = object.hp ?? 0;
    return message;
  },
};

function createBaseGetLineupAvatarDataScRsp(): GetLineupAvatarDataScRsp {
  return { retcode: 0, avatarDataList: [] };
}

export const GetLineupAvatarDataScRsp = {
  encode(
    message: GetLineupAvatarDataScRsp,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.retcode !== 0) {
      writer.uint32(8).uint32(message.retcode);
    }
    for (const v of message.avatarDataList) {
      LineupAvatarData.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): GetLineupAvatarDataScRsp {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetLineupAvatarDataScRsp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.retcode = reader.uint32();
          break;
        case 2:
          message.avatarDataList.push(
            LineupAvatarData.decode(reader, reader.uint32())
          );
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): GetLineupAvatarDataScRsp {
    return {
      retcode: isSet(object.retcode) ? Number(object.retcode) : 0,
      avatarDataList: Array.isArray(object?.avatarDataList)
        ? object.avatarDataList.map((e: any) => LineupAvatarData.fromJSON(e))
        : [],
    };
  },

  toJSON(message: GetLineupAvatarDataScRsp): unknown {
    const obj: any = {};
    message.retcode !== undefined &&
      (obj.retcode = Math.round(message.retcode));
    if (message.avatarDataList) {
      obj.avatarDataList = message.avatarDataList.map((e) =>
        e ? LineupAvatarData.toJSON(e) : undefined
      );
    } else {
      obj.avatarDataList = [];
    }
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<GetLineupAvatarDataScRsp>, I>>(
    object: I
  ): GetLineupAvatarDataScRsp {
    const message = createBaseGetLineupAvatarDataScRsp();
    message.retcode = object.retcode ?? 0;
    message.avatarDataList =
      object.avatarDataList?.map((e) => LineupAvatarData.fromPartial(e)) || [];
    return message;
  },
};

function createBaseChangeLineupLeaderCsReq(): ChangeLineupLeaderCsReq {
  return { slot: 0 };
}

export const ChangeLineupLeaderCsReq = {
  encode(
    message: ChangeLineupLeaderCsReq,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.slot !== 0) {
      writer.uint32(8).uint32(message.slot);
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): ChangeLineupLeaderCsReq {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseChangeLineupLeaderCsReq();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.slot = reader.uint32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): ChangeLineupLeaderCsReq {
    return {
      slot: isSet(object.slot) ? Number(object.slot) : 0,
    };
  },

  toJSON(message: ChangeLineupLeaderCsReq): unknown {
    const obj: any = {};
    message.slot !== undefined && (obj.slot = Math.round(message.slot));
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<ChangeLineupLeaderCsReq>, I>>(
    object: I
  ): ChangeLineupLeaderCsReq {
    const message = createBaseChangeLineupLeaderCsReq();
    message.slot = object.slot ?? 0;
    return message;
  },
};

function createBaseChangeLineupLeaderScRsp(): ChangeLineupLeaderScRsp {
  return { retcode: 0, slot: 0 };
}

export const ChangeLineupLeaderScRsp = {
  encode(
    message: ChangeLineupLeaderScRsp,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.retcode !== 0) {
      writer.uint32(8).uint32(message.retcode);
    }
    if (message.slot !== 0) {
      writer.uint32(16).uint32(message.slot);
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): ChangeLineupLeaderScRsp {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseChangeLineupLeaderScRsp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.retcode = reader.uint32();
          break;
        case 2:
          message.slot = reader.uint32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): ChangeLineupLeaderScRsp {
    return {
      retcode: isSet(object.retcode) ? Number(object.retcode) : 0,
      slot: isSet(object.slot) ? Number(object.slot) : 0,
    };
  },

  toJSON(message: ChangeLineupLeaderScRsp): unknown {
    const obj: any = {};
    message.retcode !== undefined &&
      (obj.retcode = Math.round(message.retcode));
    message.slot !== undefined && (obj.slot = Math.round(message.slot));
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<ChangeLineupLeaderScRsp>, I>>(
    object: I
  ): ChangeLineupLeaderScRsp {
    const message = createBaseChangeLineupLeaderScRsp();
    message.retcode = object.retcode ?? 0;
    message.slot = object.slot ?? 0;
    return message;
  },
};

function createBaseSwitchLineupIndexCsReq(): SwitchLineupIndexCsReq {
  return { index: 0 };
}

export const SwitchLineupIndexCsReq = {
  encode(
    message: SwitchLineupIndexCsReq,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.index !== 0) {
      writer.uint32(8).uint32(message.index);
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): SwitchLineupIndexCsReq {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSwitchLineupIndexCsReq();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.index = reader.uint32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): SwitchLineupIndexCsReq {
    return {
      index: isSet(object.index) ? Number(object.index) : 0,
    };
  },

  toJSON(message: SwitchLineupIndexCsReq): unknown {
    const obj: any = {};
    message.index !== undefined && (obj.index = Math.round(message.index));
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<SwitchLineupIndexCsReq>, I>>(
    object: I
  ): SwitchLineupIndexCsReq {
    const message = createBaseSwitchLineupIndexCsReq();
    message.index = object.index ?? 0;
    return message;
  },
};

function createBaseSwitchLineupIndexScRsp(): SwitchLineupIndexScRsp {
  return { retcode: 0, index: 0 };
}

export const SwitchLineupIndexScRsp = {
  encode(
    message: SwitchLineupIndexScRsp,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.retcode !== 0) {
      writer.uint32(8).uint32(message.retcode);
    }
    if (message.index !== 0) {
      writer.uint32(16).uint32(message.index);
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): SwitchLineupIndexScRsp {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSwitchLineupIndexScRsp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.retcode = reader.uint32();
          break;
        case 2:
          message.index = reader.uint32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): SwitchLineupIndexScRsp {
    return {
      retcode: isSet(object.retcode) ? Number(object.retcode) : 0,
      index: isSet(object.index) ? Number(object.index) : 0,
    };
  },

  toJSON(message: SwitchLineupIndexScRsp): unknown {
    const obj: any = {};
    message.retcode !== undefined &&
      (obj.retcode = Math.round(message.retcode));
    message.index !== undefined && (obj.index = Math.round(message.index));
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<SwitchLineupIndexScRsp>, I>>(
    object: I
  ): SwitchLineupIndexScRsp {
    const message = createBaseSwitchLineupIndexScRsp();
    message.retcode = object.retcode ?? 0;
    message.index = object.index ?? 0;
    return message;
  },
};

function createBaseSetLineupNameCsReq(): SetLineupNameCsReq {
  return { name: "", index: 0 };
}

export const SetLineupNameCsReq = {
  encode(
    message: SetLineupNameCsReq,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.index !== 0) {
      writer.uint32(16).uint32(message.index);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SetLineupNameCsReq {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSetLineupNameCsReq();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.name = reader.string();
          break;
        case 2:
          message.index = reader.uint32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): SetLineupNameCsReq {
    return {
      name: isSet(object.name) ? String(object.name) : "",
      index: isSet(object.index) ? Number(object.index) : 0,
    };
  },

  toJSON(message: SetLineupNameCsReq): unknown {
    const obj: any = {};
    message.name !== undefined && (obj.name = message.name);
    message.index !== undefined && (obj.index = Math.round(message.index));
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<SetLineupNameCsReq>, I>>(
    object: I
  ): SetLineupNameCsReq {
    const message = createBaseSetLineupNameCsReq();
    message.name = object.name ?? "";
    message.index = object.index ?? 0;
    return message;
  },
};

function createBaseSetLineupNameScRsp(): SetLineupNameScRsp {
  return { retcode: 0, name: "", index: 0 };
}

export const SetLineupNameScRsp = {
  encode(
    message: SetLineupNameScRsp,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.retcode !== 0) {
      writer.uint32(8).uint32(message.retcode);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.index !== 0) {
      writer.uint32(24).uint32(message.index);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SetLineupNameScRsp {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSetLineupNameScRsp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.retcode = reader.uint32();
          break;
        case 2:
          message.name = reader.string();
          break;
        case 3:
          message.index = reader.uint32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): SetLineupNameScRsp {
    return {
      retcode: isSet(object.retcode) ? Number(object.retcode) : 0,
      name: isSet(object.name) ? String(object.name) : "",
      index: isSet(object.index) ? Number(object.index) : 0,
    };
  },

  toJSON(message: SetLineupNameScRsp): unknown {
    const obj: any = {};
    message.retcode !== undefined &&
      (obj.retcode = Math.round(message.retcode));
    message.name !== undefined && (obj.name = message.name);
    message.index !== undefined && (obj.index = Math.round(message.index));
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<SetLineupNameScRsp>, I>>(
    object: I
  ): SetLineupNameScRsp {
    const message = createBaseSetLineupNameScRsp();
    message.retcode = object.retcode ?? 0;
    message.name = object.name ?? "";
    message.index = object.index ?? 0;
    return message;
  },
};

function createBaseGetAllLineupDataCsReq(): GetAllLineupDataCsReq {
  return {};
}

export const GetAllLineupDataCsReq = {
  encode(
    _: GetAllLineupDataCsReq,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): GetAllLineupDataCsReq {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetAllLineupDataCsReq();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(_: any): GetAllLineupDataCsReq {
    return {};
  },

  toJSON(_: GetAllLineupDataCsReq): unknown {
    const obj: any = {};
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<GetAllLineupDataCsReq>, I>>(
    _: I
  ): GetAllLineupDataCsReq {
    const message = createBaseGetAllLineupDataCsReq();
    return message;
  },
};

function createBaseGetAllLineupDataScRsp(): GetAllLineupDataScRsp {
  return { retcode: 0, curIndex: 0, lineupList: [] };
}

export const GetAllLineupDataScRsp = {
  encode(
    message: GetAllLineupDataScRsp,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.retcode !== 0) {
      writer.uint32(8).uint32(message.retcode);
    }
    if (message.curIndex !== 0) {
      writer.uint32(16).uint32(message.curIndex);
    }
    for (const v of message.lineupList) {
      LineupInfo.encode(v!, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): GetAllLineupDataScRsp {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetAllLineupDataScRsp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.retcode = reader.uint32();
          break;
        case 2:
          message.curIndex = reader.uint32();
          break;
        case 3:
          message.lineupList.push(LineupInfo.decode(reader, reader.uint32()));
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): GetAllLineupDataScRsp {
    return {
      retcode: isSet(object.retcode) ? Number(object.retcode) : 0,
      curIndex: isSet(object.curIndex) ? Number(object.curIndex) : 0,
      lineupList: Array.isArray(object?.lineupList)
        ? object.lineupList.map((e: any) => LineupInfo.fromJSON(e))
        : [],
    };
  },

  toJSON(message: GetAllLineupDataScRsp): unknown {
    const obj: any = {};
    message.retcode !== undefined &&
      (obj.retcode = Math.round(message.retcode));
    message.curIndex !== undefined &&
      (obj.curIndex = Math.round(message.curIndex));
    if (message.lineupList) {
      obj.lineupList = message.lineupList.map((e) =>
        e ? LineupInfo.toJSON(e) : undefined
      );
    } else {
      obj.lineupList = [];
    }
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<GetAllLineupDataScRsp>, I>>(
    object: I
  ): GetAllLineupDataScRsp {
    const message = createBaseGetAllLineupDataScRsp();
    message.retcode = object.retcode ?? 0;
    message.curIndex = object.curIndex ?? 0;
    message.lineupList =
      object.lineupList?.map((e) => LineupInfo.fromPartial(e)) || [];
    return message;
  },
};

function createBaseVirtualLineupDestroyNotify(): VirtualLineupDestroyNotify {
  return { planeId: 0 };
}

export const VirtualLineupDestroyNotify = {
  encode(
    message: VirtualLineupDestroyNotify,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.planeId !== 0) {
      writer.uint32(8).uint32(message.planeId);
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): VirtualLineupDestroyNotify {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVirtualLineupDestroyNotify();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.planeId = reader.uint32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): VirtualLineupDestroyNotify {
    return {
      planeId: isSet(object.planeId) ? Number(object.planeId) : 0,
    };
  },

  toJSON(message: VirtualLineupDestroyNotify): unknown {
    const obj: any = {};
    message.planeId !== undefined &&
      (obj.planeId = Math.round(message.planeId));
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<VirtualLineupDestroyNotify>, I>>(
    object: I
  ): VirtualLineupDestroyNotify {
    const message = createBaseVirtualLineupDestroyNotify();
    message.planeId = object.planeId ?? 0;
    return message;
  },
};

function createBaseGetMailCsReq(): GetMailCsReq {
  return { start: 0, stop: 0 };
}

export const GetMailCsReq = {
  encode(
    message: GetMailCsReq,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.start !== 0) {
      writer.uint32(8).uint32(message.start);
    }
    if (message.stop !== 0) {
      writer.uint32(16).uint32(message.stop);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetMailCsReq {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetMailCsReq();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.start = reader.uint32();
          break;
        case 2:
          message.stop = reader.uint32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): GetMailCsReq {
    return {
      start: isSet(object.start) ? Number(object.start) : 0,
      stop: isSet(object.stop) ? Number(object.stop) : 0,
    };
  },

  toJSON(message: GetMailCsReq): unknown {
    const obj: any = {};
    message.start !== undefined && (obj.start = Math.round(message.start));
    message.stop !== undefined && (obj.stop = Math.round(message.stop));
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<GetMailCsReq>, I>>(
    object: I
  ): GetMailCsReq {
    const message = createBaseGetMailCsReq();
    message.start = object.start ?? 0;
    message.stop = object.stop ?? 0;
    return message;
  },
};

function createBaseClientMail(): ClientMail {
  return {
    id: 0,
    templateId: 0,
    title: "",
    content: "",
    sender: "",
    time: 0,
    attachment: undefined,
    isRead: false,
    expireTime: 0,
    paraList: [],
  };
}

export const ClientMail = {
  encode(
    message: ClientMail,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.id !== 0) {
      writer.uint32(8).uint32(message.id);
    }
    if (message.templateId !== 0) {
      writer.uint32(16).uint32(message.templateId);
    }
    if (message.title !== "") {
      writer.uint32(26).string(message.title);
    }
    if (message.content !== "") {
      writer.uint32(34).string(message.content);
    }
    if (message.sender !== "") {
      writer.uint32(42).string(message.sender);
    }
    if (message.time !== 0) {
      writer.uint32(48).uint32(message.time);
    }
    if (message.attachment !== undefined) {
      ItemList.encode(message.attachment, writer.uint32(58).fork()).ldelim();
    }
    if (message.isRead === true) {
      writer.uint32(64).bool(message.isRead);
    }
    if (message.expireTime !== 0) {
      writer.uint32(72).uint32(message.expireTime);
    }
    for (const v of message.paraList) {
      writer.uint32(82).string(v!);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ClientMail {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseClientMail();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.id = reader.uint32();
          break;
        case 2:
          message.templateId = reader.uint32();
          break;
        case 3:
          message.title = reader.string();
          break;
        case 4:
          message.content = reader.string();
          break;
        case 5:
          message.sender = reader.string();
          break;
        case 6:
          message.time = reader.uint32();
          break;
        case 7:
          message.attachment = ItemList.decode(reader, reader.uint32());
          break;
        case 8:
          message.isRead = reader.bool();
          break;
        case 9:
          message.expireTime = reader.uint32();
          break;
        case 10:
          message.paraList.push(reader.string());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): ClientMail {
    return {
      id: isSet(object.id) ? Number(object.id) : 0,
      templateId: isSet(object.templateId) ? Number(object.templateId) : 0,
      title: isSet(object.title) ? String(object.title) : "",
      content: isSet(object.content) ? String(object.content) : "",
      sender: isSet(object.sender) ? String(object.sender) : "",
      time: isSet(object.time) ? Number(object.time) : 0,
      attachment: isSet(object.attachment)
        ? ItemList.fromJSON(object.attachment)
        : undefined,
      isRead: isSet(object.isRead) ? Boolean(object.isRead) : false,
      expireTime: isSet(object.expireTime) ? Number(object.expireTime) : 0,
      paraList: Array.isArray(object?.paraList)
        ? object.paraList.map((e: any) => String(e))
        : [],
    };
  },

  toJSON(message: ClientMail): unknown {
    const obj: any = {};
    message.id !== undefined && (obj.id = Math.round(message.id));
    message.templateId !== undefined &&
      (obj.templateId = Math.round(message.templateId));
    message.title !== undefined && (obj.title = message.title);
    message.content !== undefined && (obj.content = message.content);
    message.sender !== undefined && (obj.sender = message.sender);
    message.time !== undefined && (obj.time = Math.round(message.time));
    message.attachment !== undefined &&
      (obj.attachment = message.attachment
        ? ItemList.toJSON(message.attachment)
        : undefined);
    message.isRead !== undefined && (obj.isRead = message.isRead);
    message.expireTime !== undefined &&
      (obj.expireTime = Math.round(message.expireTime));
    if (message.paraList) {
      obj.paraList = message.paraList.map((e) => e);
    } else {
      obj.paraList = [];
    }
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<ClientMail>, I>>(
    object: I
  ): ClientMail {
    const message = createBaseClientMail();
    message.id = object.id ?? 0;
    message.templateId = object.templateId ?? 0;
    message.title = object.title ?? "";
    message.content = object.content ?? "";
    message.sender = object.sender ?? "";
    message.time = object.time ?? 0;
    message.attachment =
      object.attachment !== undefined && object.attachment !== null
        ? ItemList.fromPartial(object.attachment)
        : undefined;
    message.isRead = object.isRead ?? false;
    message.expireTime = object.expireTime ?? 0;
    message.paraList = object.paraList?.map((e) => e) || [];
    return message;
  },
};

function createBaseGetMailScRsp(): GetMailScRsp {
  return {
    retcode: 0,
    mailList: [],
    isEnd: false,
    totalNum: 0,
    start: 0,
    noticeMailList: [],
  };
}

export const GetMailScRsp = {
  encode(
    message: GetMailScRsp,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.retcode !== 0) {
      writer.uint32(8).uint32(message.retcode);
    }
    for (const v of message.mailList) {
      ClientMail.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    if (message.isEnd === true) {
      writer.uint32(24).bool(message.isEnd);
    }
    if (message.totalNum !== 0) {
      writer.uint32(32).uint32(message.totalNum);
    }
    if (message.start !== 0) {
      writer.uint32(40).uint32(message.start);
    }
    for (const v of message.noticeMailList) {
      ClientMail.encode(v!, writer.uint32(50).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetMailScRsp {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetMailScRsp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.retcode = reader.uint32();
          break;
        case 2:
          message.mailList.push(ClientMail.decode(reader, reader.uint32()));
          break;
        case 3:
          message.isEnd = reader.bool();
          break;
        case 4:
          message.totalNum = reader.uint32();
          break;
        case 5:
          message.start = reader.uint32();
          break;
        case 6:
          message.noticeMailList.push(
            ClientMail.decode(reader, reader.uint32())
          );
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): GetMailScRsp {
    return {
      retcode: isSet(object.retcode) ? Number(object.retcode) : 0,
      mailList: Array.isArray(object?.mailList)
        ? object.mailList.map((e: any) => ClientMail.fromJSON(e))
        : [],
      isEnd: isSet(object.isEnd) ? Boolean(object.isEnd) : false,
      totalNum: isSet(object.totalNum) ? Number(object.totalNum) : 0,
      start: isSet(object.start) ? Number(object.start) : 0,
      noticeMailList: Array.isArray(object?.noticeMailList)
        ? object.noticeMailList.map((e: any) => ClientMail.fromJSON(e))
        : [],
    };
  },

  toJSON(message: GetMailScRsp): unknown {
    const obj: any = {};
    message.retcode !== undefined &&
      (obj.retcode = Math.round(message.retcode));
    if (message.mailList) {
      obj.mailList = message.mailList.map((e) =>
        e ? ClientMail.toJSON(e) : undefined
      );
    } else {
      obj.mailList = [];
    }
    message.isEnd !== undefined && (obj.isEnd = message.isEnd);
    message.totalNum !== undefined &&
      (obj.totalNum = Math.round(message.totalNum));
    message.start !== undefined && (obj.start = Math.round(message.start));
    if (message.noticeMailList) {
      obj.noticeMailList = message.noticeMailList.map((e) =>
        e ? ClientMail.toJSON(e) : undefined
      );
    } else {
      obj.noticeMailList = [];
    }
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<GetMailScRsp>, I>>(
    object: I
  ): GetMailScRsp {
    const message = createBaseGetMailScRsp();
    message.retcode = object.retcode ?? 0;
    message.mailList =
      object.mailList?.map((e) => ClientMail.fromPartial(e)) || [];
    message.isEnd = object.isEnd ?? false;
    message.totalNum = object.totalNum ?? 0;
    message.start = object.start ?? 0;
    message.noticeMailList =
      object.noticeMailList?.map((e) => ClientMail.fromPartial(e)) || [];
    return message;
  },
};

function createBaseMarkReadMailCsReq(): MarkReadMailCsReq {
  return { id: 0 };
}

export const MarkReadMailCsReq = {
  encode(
    message: MarkReadMailCsReq,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.id !== 0) {
      writer.uint32(8).uint32(message.id);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MarkReadMailCsReq {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMarkReadMailCsReq();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.id = reader.uint32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): MarkReadMailCsReq {
    return {
      id: isSet(object.id) ? Number(object.id) : 0,
    };
  },

  toJSON(message: MarkReadMailCsReq): unknown {
    const obj: any = {};
    message.id !== undefined && (obj.id = Math.round(message.id));
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<MarkReadMailCsReq>, I>>(
    object: I
  ): MarkReadMailCsReq {
    const message = createBaseMarkReadMailCsReq();
    message.id = object.id ?? 0;
    return message;
  },
};

function createBaseMarkReadMailScRsp(): MarkReadMailScRsp {
  return { retcode: 0, id: 0 };
}

export const MarkReadMailScRsp = {
  encode(
    message: MarkReadMailScRsp,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.retcode !== 0) {
      writer.uint32(8).uint32(message.retcode);
    }
    if (message.id !== 0) {
      writer.uint32(16).uint32(message.id);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MarkReadMailScRsp {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMarkReadMailScRsp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.retcode = reader.uint32();
          break;
        case 2:
          message.id = reader.uint32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): MarkReadMailScRsp {
    return {
      retcode: isSet(object.retcode) ? Number(object.retcode) : 0,
      id: isSet(object.id) ? Number(object.id) : 0,
    };
  },

  toJSON(message: MarkReadMailScRsp): unknown {
    const obj: any = {};
    message.retcode !== undefined &&
      (obj.retcode = Math.round(message.retcode));
    message.id !== undefined && (obj.id = Math.round(message.id));
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<MarkReadMailScRsp>, I>>(
    object: I
  ): MarkReadMailScRsp {
    const message = createBaseMarkReadMailScRsp();
    message.retcode = object.retcode ?? 0;
    message.id = object.id ?? 0;
    return message;
  },
};

function createBaseDelMailCsReq(): DelMailCsReq {
  return { idList: [] };
}

export const DelMailCsReq = {
  encode(
    message: DelMailCsReq,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    writer.uint32(10).fork();
    for (const v of message.idList) {
      writer.uint32(v);
    }
    writer.ldelim();
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): DelMailCsReq {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDelMailCsReq();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if ((tag & 7) === 2) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.idList.push(reader.uint32());
            }
          } else {
            message.idList.push(reader.uint32());
          }
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): DelMailCsReq {
    return {
      idList: Array.isArray(object?.idList)
        ? object.idList.map((e: any) => Number(e))
        : [],
    };
  },

  toJSON(message: DelMailCsReq): unknown {
    const obj: any = {};
    if (message.idList) {
      obj.idList = message.idList.map((e) => Math.round(e));
    } else {
      obj.idList = [];
    }
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<DelMailCsReq>, I>>(
    object: I
  ): DelMailCsReq {
    const message = createBaseDelMailCsReq();
    message.idList = object.idList?.map((e) => e) || [];
    return message;
  },
};

function createBaseDelMailScRsp(): DelMailScRsp {
  return { retcode: 0, idList: [] };
}

export const DelMailScRsp = {
  encode(
    message: DelMailScRsp,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.retcode !== 0) {
      writer.uint32(8).uint32(message.retcode);
    }
    writer.uint32(18).fork();
    for (const v of message.idList) {
      writer.uint32(v);
    }
    writer.ldelim();
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): DelMailScRsp {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDelMailScRsp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.retcode = reader.uint32();
          break;
        case 2:
          if ((tag & 7) === 2) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.idList.push(reader.uint32());
            }
          } else {
            message.idList.push(reader.uint32());
          }
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): DelMailScRsp {
    return {
      retcode: isSet(object.retcode) ? Number(object.retcode) : 0,
      idList: Array.isArray(object?.idList)
        ? object.idList.map((e: any) => Number(e))
        : [],
    };
  },

  toJSON(message: DelMailScRsp): unknown {
    const obj: any = {};
    message.retcode !== undefined &&
      (obj.retcode = Math.round(message.retcode));
    if (message.idList) {
      obj.idList = message.idList.map((e) => Math.round(e));
    } else {
      obj.idList = [];
    }
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<DelMailScRsp>, I>>(
    object: I
  ): DelMailScRsp {
    const message = createBaseDelMailScRsp();
    message.retcode = object.retcode ?? 0;
    message.idList = object.idList?.map((e) => e) || [];
    return message;
  },
};

function createBaseTakeMailAttachmentCsReq(): TakeMailAttachmentCsReq {
  return { mailIdList: [] };
}

export const TakeMailAttachmentCsReq = {
  encode(
    message: TakeMailAttachmentCsReq,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    writer.uint32(10).fork();
    for (const v of message.mailIdList) {
      writer.uint32(v);
    }
    writer.ldelim();
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): TakeMailAttachmentCsReq {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTakeMailAttachmentCsReq();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if ((tag & 7) === 2) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.mailIdList.push(reader.uint32());
            }
          } else {
            message.mailIdList.push(reader.uint32());
          }
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): TakeMailAttachmentCsReq {
    return {
      mailIdList: Array.isArray(object?.mailIdList)
        ? object.mailIdList.map((e: any) => Number(e))
        : [],
    };
  },

  toJSON(message: TakeMailAttachmentCsReq): unknown {
    const obj: any = {};
    if (message.mailIdList) {
      obj.mailIdList = message.mailIdList.map((e) => Math.round(e));
    } else {
      obj.mailIdList = [];
    }
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<TakeMailAttachmentCsReq>, I>>(
    object: I
  ): TakeMailAttachmentCsReq {
    const message = createBaseTakeMailAttachmentCsReq();
    message.mailIdList = object.mailIdList?.map((e) => e) || [];
    return message;
  },
};

function createBaseClientMailAttachmentItem(): ClientMailAttachmentItem {
  return { mailId: 0, itemId: 0 };
}

export const ClientMailAttachmentItem = {
  encode(
    message: ClientMailAttachmentItem,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.mailId !== 0) {
      writer.uint32(8).uint32(message.mailId);
    }
    if (message.itemId !== 0) {
      writer.uint32(16).uint32(message.itemId);
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): ClientMailAttachmentItem {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseClientMailAttachmentItem();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.mailId = reader.uint32();
          break;
        case 2:
          message.itemId = reader.uint32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): ClientMailAttachmentItem {
    return {
      mailId: isSet(object.mailId) ? Number(object.mailId) : 0,
      itemId: isSet(object.itemId) ? Number(object.itemId) : 0,
    };
  },

  toJSON(message: ClientMailAttachmentItem): unknown {
    const obj: any = {};
    message.mailId !== undefined && (obj.mailId = Math.round(message.mailId));
    message.itemId !== undefined && (obj.itemId = Math.round(message.itemId));
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<ClientMailAttachmentItem>, I>>(
    object: I
  ): ClientMailAttachmentItem {
    const message = createBaseClientMailAttachmentItem();
    message.mailId = object.mailId ?? 0;
    message.itemId = object.itemId ?? 0;
    return message;
  },
};

function createBaseTakeMailAttachmentScRsp(): TakeMailAttachmentScRsp {
  return {
    retcode: 0,
    succMailIdList: [],
    attachment: undefined,
    failMailList: [],
  };
}

export const TakeMailAttachmentScRsp = {
  encode(
    message: TakeMailAttachmentScRsp,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.retcode !== 0) {
      writer.uint32(8).uint32(message.retcode);
    }
    writer.uint32(18).fork();
    for (const v of message.succMailIdList) {
      writer.uint32(v);
    }
    writer.ldelim();
    if (message.attachment !== undefined) {
      ItemList.encode(message.attachment, writer.uint32(26).fork()).ldelim();
    }
    for (const v of message.failMailList) {
      ClientMailAttachmentItem.encode(v!, writer.uint32(34).fork()).ldelim();
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): TakeMailAttachmentScRsp {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTakeMailAttachmentScRsp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.retcode = reader.uint32();
          break;
        case 2:
          if ((tag & 7) === 2) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.succMailIdList.push(reader.uint32());
            }
          } else {
            message.succMailIdList.push(reader.uint32());
          }
          break;
        case 3:
          message.attachment = ItemList.decode(reader, reader.uint32());
          break;
        case 4:
          message.failMailList.push(
            ClientMailAttachmentItem.decode(reader, reader.uint32())
          );
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): TakeMailAttachmentScRsp {
    return {
      retcode: isSet(object.retcode) ? Number(object.retcode) : 0,
      succMailIdList: Array.isArray(object?.succMailIdList)
        ? object.succMailIdList.map((e: any) => Number(e))
        : [],
      attachment: isSet(object.attachment)
        ? ItemList.fromJSON(object.attachment)
        : undefined,
      failMailList: Array.isArray(object?.failMailList)
        ? object.failMailList.map((e: any) =>
            ClientMailAttachmentItem.fromJSON(e)
          )
        : [],
    };
  },

  toJSON(message: TakeMailAttachmentScRsp): unknown {
    const obj: any = {};
    message.retcode !== undefined &&
      (obj.retcode = Math.round(message.retcode));
    if (message.succMailIdList) {
      obj.succMailIdList = message.succMailIdList.map((e) => Math.round(e));
    } else {
      obj.succMailIdList = [];
    }
    message.attachment !== undefined &&
      (obj.attachment = message.attachment
        ? ItemList.toJSON(message.attachment)
        : undefined);
    if (message.failMailList) {
      obj.failMailList = message.failMailList.map((e) =>
        e ? ClientMailAttachmentItem.toJSON(e) : undefined
      );
    } else {
      obj.failMailList = [];
    }
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<TakeMailAttachmentScRsp>, I>>(
    object: I
  ): TakeMailAttachmentScRsp {
    const message = createBaseTakeMailAttachmentScRsp();
    message.retcode = object.retcode ?? 0;
    message.succMailIdList = object.succMailIdList?.map((e) => e) || [];
    message.attachment =
      object.attachment !== undefined && object.attachment !== null
        ? ItemList.fromPartial(object.attachment)
        : undefined;
    message.failMailList =
      object.failMailList?.map((e) =>
        ClientMailAttachmentItem.fromPartial(e)
      ) || [];
    return message;
  },
};

function createBaseNewMailScNotify(): NewMailScNotify {
  return { mailIdList: [] };
}

export const NewMailScNotify = {
  encode(
    message: NewMailScNotify,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    writer.uint32(10).fork();
    for (const v of message.mailIdList) {
      writer.uint32(v);
    }
    writer.ldelim();
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): NewMailScNotify {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNewMailScNotify();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if ((tag & 7) === 2) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.mailIdList.push(reader.uint32());
            }
          } else {
            message.mailIdList.push(reader.uint32());
          }
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): NewMailScNotify {
    return {
      mailIdList: Array.isArray(object?.mailIdList)
        ? object.mailIdList.map((e: any) => Number(e))
        : [],
    };
  },

  toJSON(message: NewMailScNotify): unknown {
    const obj: any = {};
    if (message.mailIdList) {
      obj.mailIdList = message.mailIdList.map((e) => Math.round(e));
    } else {
      obj.mailIdList = [];
    }
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<NewMailScNotify>, I>>(
    object: I
  ): NewMailScNotify {
    const message = createBaseNewMailScNotify();
    message.mailIdList = object.mailIdList?.map((e) => e) || [];
    return message;
  },
};

function createBaseMazeFloor(): MazeFloor {
  return { floorId: 0, scene: undefined };
}

export const MazeFloor = {
  encode(
    message: MazeFloor,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.floorId !== 0) {
      writer.uint32(8).uint32(message.floorId);
    }
    if (message.scene !== undefined) {
      SceneInfo.encode(message.scene, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MazeFloor {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMazeFloor();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.floorId = reader.uint32();
          break;
        case 2:
          message.scene = SceneInfo.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): MazeFloor {
    return {
      floorId: isSet(object.floorId) ? Number(object.floorId) : 0,
      scene: isSet(object.scene) ? SceneInfo.fromJSON(object.scene) : undefined,
    };
  },

  toJSON(message: MazeFloor): unknown {
    const obj: any = {};
    message.floorId !== undefined &&
      (obj.floorId = Math.round(message.floorId));
    message.scene !== undefined &&
      (obj.scene = message.scene ? SceneInfo.toJSON(message.scene) : undefined);
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<MazeFloor>, I>>(
    object: I
  ): MazeFloor {
    const message = createBaseMazeFloor();
    message.floorId = object.floorId ?? 0;
    message.scene =
      object.scene !== undefined && object.scene !== null
        ? SceneInfo.fromPartial(object.scene)
        : undefined;
    return message;
  },
};

function createBaseMaze(): Maze {
  return { id: 0, floor: undefined, mapEntryId: 0 };
}

export const Maze = {
  encode(message: Maze, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== 0) {
      writer.uint32(8).uint32(message.id);
    }
    if (message.floor !== undefined) {
      MazeFloor.encode(message.floor, writer.uint32(18).fork()).ldelim();
    }
    if (message.mapEntryId !== 0) {
      writer.uint32(24).uint32(message.mapEntryId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Maze {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMaze();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.id = reader.uint32();
          break;
        case 2:
          message.floor = MazeFloor.decode(reader, reader.uint32());
          break;
        case 3:
          message.mapEntryId = reader.uint32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): Maze {
    return {
      id: isSet(object.id) ? Number(object.id) : 0,
      floor: isSet(object.floor) ? MazeFloor.fromJSON(object.floor) : undefined,
      mapEntryId: isSet(object.mapEntryId) ? Number(object.mapEntryId) : 0,
    };
  },

  toJSON(message: Maze): unknown {
    const obj: any = {};
    message.id !== undefined && (obj.id = Math.round(message.id));
    message.floor !== undefined &&
      (obj.floor = message.floor ? MazeFloor.toJSON(message.floor) : undefined);
    message.mapEntryId !== undefined &&
      (obj.mapEntryId = Math.round(message.mapEntryId));
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<Maze>, I>>(object: I): Maze {
    const message = createBaseMaze();
    message.id = object.id ?? 0;
    message.floor =
      object.floor !== undefined && object.floor !== null
        ? MazeFloor.fromPartial(object.floor)
        : undefined;
    message.mapEntryId = object.mapEntryId ?? 0;
    return message;
  },
};

function createBaseMazeAvatar(): MazeAvatar {
  return { baseAvatarId: 0, leftHp: 0, sp: 0 };
}

export const MazeAvatar = {
  encode(
    message: MazeAvatar,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.baseAvatarId !== 0) {
      writer.uint32(8).uint32(message.baseAvatarId);
    }
    if (message.leftHp !== 0) {
      writer.uint32(16).uint32(message.leftHp);
    }
    if (message.sp !== 0) {
      writer.uint32(24).uint32(message.sp);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MazeAvatar {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMazeAvatar();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.baseAvatarId = reader.uint32();
          break;
        case 2:
          message.leftHp = reader.uint32();
          break;
        case 3:
          message.sp = reader.uint32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): MazeAvatar {
    return {
      baseAvatarId: isSet(object.baseAvatarId)
        ? Number(object.baseAvatarId)
        : 0,
      leftHp: isSet(object.leftHp) ? Number(object.leftHp) : 0,
      sp: isSet(object.sp) ? Number(object.sp) : 0,
    };
  },

  toJSON(message: MazeAvatar): unknown {
    const obj: any = {};
    message.baseAvatarId !== undefined &&
      (obj.baseAvatarId = Math.round(message.baseAvatarId));
    message.leftHp !== undefined && (obj.leftHp = Math.round(message.leftHp));
    message.sp !== undefined && (obj.sp = Math.round(message.sp));
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<MazeAvatar>, I>>(
    object: I
  ): MazeAvatar {
    const message = createBaseMazeAvatar();
    message.baseAvatarId = object.baseAvatarId ?? 0;
    message.leftHp = object.leftHp ?? 0;
    message.sp = object.sp ?? 0;
    return message;
  },
};

function createBaseMazeMission(): MazeMission {
  return { subMissionId: 0, status: 0 };
}

export const MazeMission = {
  encode(
    message: MazeMission,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.subMissionId !== 0) {
      writer.uint32(8).uint32(message.subMissionId);
    }
    if (message.status !== 0) {
      writer.uint32(16).int32(message.status);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MazeMission {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMazeMission();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.subMissionId = reader.uint32();
          break;
        case 2:
          message.status = reader.int32() as any;
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): MazeMission {
    return {
      subMissionId: isSet(object.subMissionId)
        ? Number(object.subMissionId)
        : 0,
      status: isSet(object.status) ? missionStatusFromJSON(object.status) : 0,
    };
  },

  toJSON(message: MazeMission): unknown {
    const obj: any = {};
    message.subMissionId !== undefined &&
      (obj.subMissionId = Math.round(message.subMissionId));
    message.status !== undefined &&
      (obj.status = missionStatusToJSON(message.status));
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<MazeMission>, I>>(
    object: I
  ): MazeMission {
    const message = createBaseMazeMission();
    message.subMissionId = object.subMissionId ?? 0;
    message.status = object.status ?? 0;
    return message;
  },
};

function createBaseGetMazeCsReq(): GetMazeCsReq {
  return {};
}

export const GetMazeCsReq = {
  encode(
    _: GetMazeCsReq,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetMazeCsReq {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetMazeCsReq();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(_: any): GetMazeCsReq {
    return {};
  },

  toJSON(_: GetMazeCsReq): unknown {
    const obj: any = {};
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<GetMazeCsReq>, I>>(
    _: I
  ): GetMazeCsReq {
    const message = createBaseGetMazeCsReq();
    return message;
  },
};

function createBaseGetMazeScRsp(): GetMazeScRsp {
  return {
    retcode: 0,
    mazeList: [],
    curSeriesId: 0,
    finishedPlaneList: [],
    waitPlaneList: [],
    takenRewardList: [],
    avatarList: [],
    chosenAbilityList: [],
    candidateAbilityList: [],
    mazeMissionList: [],
  };
}

export const GetMazeScRsp = {
  encode(
    message: GetMazeScRsp,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.retcode !== 0) {
      writer.uint32(8).uint32(message.retcode);
    }
    for (const v of message.mazeList) {
      Maze.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    if (message.curSeriesId !== 0) {
      writer.uint32(24).uint32(message.curSeriesId);
    }
    writer.uint32(34).fork();
    for (const v of message.finishedPlaneList) {
      writer.uint32(v);
    }
    writer.ldelim();
    writer.uint32(42).fork();
    for (const v of message.waitPlaneList) {
      writer.uint32(v);
    }
    writer.ldelim();
    writer.uint32(50).fork();
    for (const v of message.takenRewardList) {
      writer.uint32(v);
    }
    writer.ldelim();
    for (const v of message.avatarList) {
      MazeAvatar.encode(v!, writer.uint32(58).fork()).ldelim();
    }
    writer.uint32(66).fork();
    for (const v of message.chosenAbilityList) {
      writer.uint32(v);
    }
    writer.ldelim();
    writer.uint32(74).fork();
    for (const v of message.candidateAbilityList) {
      writer.uint32(v);
    }
    writer.ldelim();
    for (const v of message.mazeMissionList) {
      MazeMission.encode(v!, writer.uint32(82).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetMazeScRsp {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetMazeScRsp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.retcode = reader.uint32();
          break;
        case 2:
          message.mazeList.push(Maze.decode(reader, reader.uint32()));
          break;
        case 3:
          message.curSeriesId = reader.uint32();
          break;
        case 4:
          if ((tag & 7) === 2) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.finishedPlaneList.push(reader.uint32());
            }
          } else {
            message.finishedPlaneList.push(reader.uint32());
          }
          break;
        case 5:
          if ((tag & 7) === 2) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.waitPlaneList.push(reader.uint32());
            }
          } else {
            message.waitPlaneList.push(reader.uint32());
          }
          break;
        case 6:
          if ((tag & 7) === 2) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.takenRewardList.push(reader.uint32());
            }
          } else {
            message.takenRewardList.push(reader.uint32());
          }
          break;
        case 7:
          message.avatarList.push(MazeAvatar.decode(reader, reader.uint32()));
          break;
        case 8:
          if ((tag & 7) === 2) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.chosenAbilityList.push(reader.uint32());
            }
          } else {
            message.chosenAbilityList.push(reader.uint32());
          }
          break;
        case 9:
          if ((tag & 7) === 2) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.candidateAbilityList.push(reader.uint32());
            }
          } else {
            message.candidateAbilityList.push(reader.uint32());
          }
          break;
        case 10:
          message.mazeMissionList.push(
            MazeMission.decode(reader, reader.uint32())
          );
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): GetMazeScRsp {
    return {
      retcode: isSet(object.retcode) ? Number(object.retcode) : 0,
      mazeList: Array.isArray(object?.mazeList)
        ? object.mazeList.map((e: any) => Maze.fromJSON(e))
        : [],
      curSeriesId: isSet(object.curSeriesId) ? Number(object.curSeriesId) : 0,
      finishedPlaneList: Array.isArray(object?.finishedPlaneList)
        ? object.finishedPlaneList.map((e: any) => Number(e))
        : [],
      waitPlaneList: Array.isArray(object?.waitPlaneList)
        ? object.waitPlaneList.map((e: any) => Number(e))
        : [],
      takenRewardList: Array.isArray(object?.takenRewardList)
        ? object.takenRewardList.map((e: any) => Number(e))
        : [],
      avatarList: Array.isArray(object?.avatarList)
        ? object.avatarList.map((e: any) => MazeAvatar.fromJSON(e))
        : [],
      chosenAbilityList: Array.isArray(object?.chosenAbilityList)
        ? object.chosenAbilityList.map((e: any) => Number(e))
        : [],
      candidateAbilityList: Array.isArray(object?.candidateAbilityList)
        ? object.candidateAbilityList.map((e: any) => Number(e))
        : [],
      mazeMissionList: Array.isArray(object?.mazeMissionList)
        ? object.mazeMissionList.map((e: any) => MazeMission.fromJSON(e))
        : [],
    };
  },

  toJSON(message: GetMazeScRsp): unknown {
    const obj: any = {};
    message.retcode !== undefined &&
      (obj.retcode = Math.round(message.retcode));
    if (message.mazeList) {
      obj.mazeList = message.mazeList.map((e) =>
        e ? Maze.toJSON(e) : undefined
      );
    } else {
      obj.mazeList = [];
    }
    message.curSeriesId !== undefined &&
      (obj.curSeriesId = Math.round(message.curSeriesId));
    if (message.finishedPlaneList) {
      obj.finishedPlaneList = message.finishedPlaneList.map((e) =>
        Math.round(e)
      );
    } else {
      obj.finishedPlaneList = [];
    }
    if (message.waitPlaneList) {
      obj.waitPlaneList = message.waitPlaneList.map((e) => Math.round(e));
    } else {
      obj.waitPlaneList = [];
    }
    if (message.takenRewardList) {
      obj.takenRewardList = message.takenRewardList.map((e) => Math.round(e));
    } else {
      obj.takenRewardList = [];
    }
    if (message.avatarList) {
      obj.avatarList = message.avatarList.map((e) =>
        e ? MazeAvatar.toJSON(e) : undefined
      );
    } else {
      obj.avatarList = [];
    }
    if (message.chosenAbilityList) {
      obj.chosenAbilityList = message.chosenAbilityList.map((e) =>
        Math.round(e)
      );
    } else {
      obj.chosenAbilityList = [];
    }
    if (message.candidateAbilityList) {
      obj.candidateAbilityList = message.candidateAbilityList.map((e) =>
        Math.round(e)
      );
    } else {
      obj.candidateAbilityList = [];
    }
    if (message.mazeMissionList) {
      obj.mazeMissionList = message.mazeMissionList.map((e) =>
        e ? MazeMission.toJSON(e) : undefined
      );
    } else {
      obj.mazeMissionList = [];
    }
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<GetMazeScRsp>, I>>(
    object: I
  ): GetMazeScRsp {
    const message = createBaseGetMazeScRsp();
    message.retcode = object.retcode ?? 0;
    message.mazeList = object.mazeList?.map((e) => Maze.fromPartial(e)) || [];
    message.curSeriesId = object.curSeriesId ?? 0;
    message.finishedPlaneList = object.finishedPlaneList?.map((e) => e) || [];
    message.waitPlaneList = object.waitPlaneList?.map((e) => e) || [];
    message.takenRewardList = object.takenRewardList?.map((e) => e) || [];
    message.avatarList =
      object.avatarList?.map((e) => MazeAvatar.fromPartial(e)) || [];
    message.chosenAbilityList = object.chosenAbilityList?.map((e) => e) || [];
    message.candidateAbilityList =
      object.candidateAbilityList?.map((e) => e) || [];
    message.mazeMissionList =
      object.mazeMissionList?.map((e) => MazeMission.fromPartial(e)) || [];
    return message;
  },
};

function createBaseChooseMazeSeriesCsReq(): ChooseMazeSeriesCsReq {
  return { seriesId: 0 };
}

export const ChooseMazeSeriesCsReq = {
  encode(
    message: ChooseMazeSeriesCsReq,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.seriesId !== 0) {
      writer.uint32(8).uint32(message.seriesId);
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): ChooseMazeSeriesCsReq {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseChooseMazeSeriesCsReq();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.seriesId = reader.uint32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): ChooseMazeSeriesCsReq {
    return {
      seriesId: isSet(object.seriesId) ? Number(object.seriesId) : 0,
    };
  },

  toJSON(message: ChooseMazeSeriesCsReq): unknown {
    const obj: any = {};
    message.seriesId !== undefined &&
      (obj.seriesId = Math.round(message.seriesId));
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<ChooseMazeSeriesCsReq>, I>>(
    object: I
  ): ChooseMazeSeriesCsReq {
    const message = createBaseChooseMazeSeriesCsReq();
    message.seriesId = object.seriesId ?? 0;
    return message;
  },
};

function createBaseChooseMazeSeriesScRsp(): ChooseMazeSeriesScRsp {
  return { retcode: 0, seriesId: 0 };
}

export const ChooseMazeSeriesScRsp = {
  encode(
    message: ChooseMazeSeriesScRsp,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.retcode !== 0) {
      writer.uint32(8).uint32(message.retcode);
    }
    if (message.seriesId !== 0) {
      writer.uint32(16).uint32(message.seriesId);
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): ChooseMazeSeriesScRsp {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseChooseMazeSeriesScRsp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.retcode = reader.uint32();
          break;
        case 2:
          message.seriesId = reader.uint32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): ChooseMazeSeriesScRsp {
    return {
      retcode: isSet(object.retcode) ? Number(object.retcode) : 0,
      seriesId: isSet(object.seriesId) ? Number(object.seriesId) : 0,
    };
  },

  toJSON(message: ChooseMazeSeriesScRsp): unknown {
    const obj: any = {};
    message.retcode !== undefined &&
      (obj.retcode = Math.round(message.retcode));
    message.seriesId !== undefined &&
      (obj.seriesId = Math.round(message.seriesId));
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<ChooseMazeSeriesScRsp>, I>>(
    object: I
  ): ChooseMazeSeriesScRsp {
    const message = createBaseChooseMazeSeriesScRsp();
    message.retcode = object.retcode ?? 0;
    message.seriesId = object.seriesId ?? 0;
    return message;
  },
};

function createBaseChooseMazeAbilityCsReq(): ChooseMazeAbilityCsReq {
  return { abilityId: 0 };
}

export const ChooseMazeAbilityCsReq = {
  encode(
    message: ChooseMazeAbilityCsReq,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.abilityId !== 0) {
      writer.uint32(8).uint32(message.abilityId);
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): ChooseMazeAbilityCsReq {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseChooseMazeAbilityCsReq();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.abilityId = reader.uint32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): ChooseMazeAbilityCsReq {
    return {
      abilityId: isSet(object.abilityId) ? Number(object.abilityId) : 0,
    };
  },

  toJSON(message: ChooseMazeAbilityCsReq): unknown {
    const obj: any = {};
    message.abilityId !== undefined &&
      (obj.abilityId = Math.round(message.abilityId));
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<ChooseMazeAbilityCsReq>, I>>(
    object: I
  ): ChooseMazeAbilityCsReq {
    const message = createBaseChooseMazeAbilityCsReq();
    message.abilityId = object.abilityId ?? 0;
    return message;
  },
};

function createBaseChooseMazeAbilityScRsp(): ChooseMazeAbilityScRsp {
  return { retcode: 0, abilityList: [] };
}

export const ChooseMazeAbilityScRsp = {
  encode(
    message: ChooseMazeAbilityScRsp,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.retcode !== 0) {
      writer.uint32(8).uint32(message.retcode);
    }
    writer.uint32(18).fork();
    for (const v of message.abilityList) {
      writer.uint32(v);
    }
    writer.ldelim();
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): ChooseMazeAbilityScRsp {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseChooseMazeAbilityScRsp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.retcode = reader.uint32();
          break;
        case 2:
          if ((tag & 7) === 2) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.abilityList.push(reader.uint32());
            }
          } else {
            message.abilityList.push(reader.uint32());
          }
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): ChooseMazeAbilityScRsp {
    return {
      retcode: isSet(object.retcode) ? Number(object.retcode) : 0,
      abilityList: Array.isArray(object?.abilityList)
        ? object.abilityList.map((e: any) => Number(e))
        : [],
    };
  },

  toJSON(message: ChooseMazeAbilityScRsp): unknown {
    const obj: any = {};
    message.retcode !== undefined &&
      (obj.retcode = Math.round(message.retcode));
    if (message.abilityList) {
      obj.abilityList = message.abilityList.map((e) => Math.round(e));
    } else {
      obj.abilityList = [];
    }
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<ChooseMazeAbilityScRsp>, I>>(
    object: I
  ): ChooseMazeAbilityScRsp {
    const message = createBaseChooseMazeAbilityScRsp();
    message.retcode = object.retcode ?? 0;
    message.abilityList = object.abilityList?.map((e) => e) || [];
    return message;
  },
};

function createBaseEnterMazeCsReq(): EnterMazeCsReq {
  return { entryId: 0, teleportId: 0 };
}

export const EnterMazeCsReq = {
  encode(
    message: EnterMazeCsReq,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.entryId !== 0) {
      writer.uint32(8).uint32(message.entryId);
    }
    if (message.teleportId !== 0) {
      writer.uint32(16).uint32(message.teleportId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): EnterMazeCsReq {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEnterMazeCsReq();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.entryId = reader.uint32();
          break;
        case 2:
          message.teleportId = reader.uint32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): EnterMazeCsReq {
    return {
      entryId: isSet(object.entryId) ? Number(object.entryId) : 0,
      teleportId: isSet(object.teleportId) ? Number(object.teleportId) : 0,
    };
  },

  toJSON(message: EnterMazeCsReq): unknown {
    const obj: any = {};
    message.entryId !== undefined &&
      (obj.entryId = Math.round(message.entryId));
    message.teleportId !== undefined &&
      (obj.teleportId = Math.round(message.teleportId));
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<EnterMazeCsReq>, I>>(
    object: I
  ): EnterMazeCsReq {
    const message = createBaseEnterMazeCsReq();
    message.entryId = object.entryId ?? 0;
    message.teleportId = object.teleportId ?? 0;
    return message;
  },
};

function createBaseEnterMazeScRsp(): EnterMazeScRsp {
  return { retcode: 0, maze: undefined };
}

export const EnterMazeScRsp = {
  encode(
    message: EnterMazeScRsp,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.retcode !== 0) {
      writer.uint32(8).uint32(message.retcode);
    }
    if (message.maze !== undefined) {
      Maze.encode(message.maze, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): EnterMazeScRsp {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEnterMazeScRsp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.retcode = reader.uint32();
          break;
        case 2:
          message.maze = Maze.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): EnterMazeScRsp {
    return {
      retcode: isSet(object.retcode) ? Number(object.retcode) : 0,
      maze: isSet(object.maze) ? Maze.fromJSON(object.maze) : undefined,
    };
  },

  toJSON(message: EnterMazeScRsp): unknown {
    const obj: any = {};
    message.retcode !== undefined &&
      (obj.retcode = Math.round(message.retcode));
    message.maze !== undefined &&
      (obj.maze = message.maze ? Maze.toJSON(message.maze) : undefined);
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<EnterMazeScRsp>, I>>(
    object: I
  ): EnterMazeScRsp {
    const message = createBaseEnterMazeScRsp();
    message.retcode = object.retcode ?? 0;
    message.maze =
      object.maze !== undefined && object.maze !== null
        ? Maze.fromPartial(object.maze)
        : undefined;
    return message;
  },
};

function createBaseMazeBuffScNotify(): MazeBuffScNotify {
  return { buffId: 0, op: 0 };
}

export const MazeBuffScNotify = {
  encode(
    message: MazeBuffScNotify,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.buffId !== 0) {
      writer.uint32(8).uint32(message.buffId);
    }
    if (message.op !== 0) {
      writer.uint32(16).int32(message.op);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MazeBuffScNotify {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMazeBuffScNotify();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.buffId = reader.uint32();
          break;
        case 2:
          message.op = reader.int32() as any;
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): MazeBuffScNotify {
    return {
      buffId: isSet(object.buffId) ? Number(object.buffId) : 0,
      op: isSet(object.op) ? mazeBuffOpFromJSON(object.op) : 0,
    };
  },

  toJSON(message: MazeBuffScNotify): unknown {
    const obj: any = {};
    message.buffId !== undefined && (obj.buffId = Math.round(message.buffId));
    message.op !== undefined && (obj.op = mazeBuffOpToJSON(message.op));
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<MazeBuffScNotify>, I>>(
    object: I
  ): MazeBuffScNotify {
    const message = createBaseMazeBuffScNotify();
    message.buffId = object.buffId ?? 0;
    message.op = object.op ?? 0;
    return message;
  },
};

function createBaseCastMazeSkillCsReq(): CastMazeSkillCsReq {
  return { skillId: 0 };
}

export const CastMazeSkillCsReq = {
  encode(
    message: CastMazeSkillCsReq,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.skillId !== 0) {
      writer.uint32(8).uint32(message.skillId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CastMazeSkillCsReq {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCastMazeSkillCsReq();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.skillId = reader.uint32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): CastMazeSkillCsReq {
    return {
      skillId: isSet(object.skillId) ? Number(object.skillId) : 0,
    };
  },

  toJSON(message: CastMazeSkillCsReq): unknown {
    const obj: any = {};
    message.skillId !== undefined &&
      (obj.skillId = Math.round(message.skillId));
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<CastMazeSkillCsReq>, I>>(
    object: I
  ): CastMazeSkillCsReq {
    const message = createBaseCastMazeSkillCsReq();
    message.skillId = object.skillId ?? 0;
    return message;
  },
};

function createBaseCastMazeSkillScRsp(): CastMazeSkillScRsp {
  return { retcode: 0 };
}

export const CastMazeSkillScRsp = {
  encode(
    message: CastMazeSkillScRsp,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.retcode !== 0) {
      writer.uint32(8).uint32(message.retcode);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CastMazeSkillScRsp {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCastMazeSkillScRsp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.retcode = reader.uint32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): CastMazeSkillScRsp {
    return {
      retcode: isSet(object.retcode) ? Number(object.retcode) : 0,
    };
  },

  toJSON(message: CastMazeSkillScRsp): unknown {
    const obj: any = {};
    message.retcode !== undefined &&
      (obj.retcode = Math.round(message.retcode));
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<CastMazeSkillScRsp>, I>>(
    object: I
  ): CastMazeSkillScRsp {
    const message = createBaseCastMazeSkillScRsp();
    message.retcode = object.retcode ?? 0;
    return message;
  },
};

function createBaseMazePlaneEventScNotify(): MazePlaneEventScNotify {
  return { itemData: undefined };
}

export const MazePlaneEventScNotify = {
  encode(
    message: MazePlaneEventScNotify,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.itemData !== undefined) {
      ItemList.encode(message.itemData, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): MazePlaneEventScNotify {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMazePlaneEventScNotify();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.itemData = ItemList.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): MazePlaneEventScNotify {
    return {
      itemData: isSet(object.itemData)
        ? ItemList.fromJSON(object.itemData)
        : undefined,
    };
  },

  toJSON(message: MazePlaneEventScNotify): unknown {
    const obj: any = {};
    message.itemData !== undefined &&
      (obj.itemData = message.itemData
        ? ItemList.toJSON(message.itemData)
        : undefined);
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<MazePlaneEventScNotify>, I>>(
    object: I
  ): MazePlaneEventScNotify {
    const message = createBaseMazePlaneEventScNotify();
    message.itemData =
      object.itemData !== undefined && object.itemData !== null
        ? ItemList.fromPartial(object.itemData)
        : undefined;
    return message;
  },
};

function createBaseEnterMazeByServerScNotify(): EnterMazeByServerScNotify {
  return { maze: undefined, reason: 0 };
}

export const EnterMazeByServerScNotify = {
  encode(
    message: EnterMazeByServerScNotify,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.maze !== undefined) {
      Maze.encode(message.maze, writer.uint32(10).fork()).ldelim();
    }
    if (message.reason !== 0) {
      writer.uint32(16).int32(message.reason);
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): EnterMazeByServerScNotify {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEnterMazeByServerScNotify();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.maze = Maze.decode(reader, reader.uint32());
          break;
        case 2:
          message.reason = reader.int32() as any;
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): EnterMazeByServerScNotify {
    return {
      maze: isSet(object.maze) ? Maze.fromJSON(object.maze) : undefined,
      reason: isSet(object.reason) ? enterMazeReasonFromJSON(object.reason) : 0,
    };
  },

  toJSON(message: EnterMazeByServerScNotify): unknown {
    const obj: any = {};
    message.maze !== undefined &&
      (obj.maze = message.maze ? Maze.toJSON(message.maze) : undefined);
    message.reason !== undefined &&
      (obj.reason = enterMazeReasonToJSON(message.reason));
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<EnterMazeByServerScNotify>, I>>(
    object: I
  ): EnterMazeByServerScNotify {
    const message = createBaseEnterMazeByServerScNotify();
    message.maze =
      object.maze !== undefined && object.maze !== null
        ? Maze.fromPartial(object.maze)
        : undefined;
    message.reason = object.reason ?? 0;
    return message;
  },
};

function createBaseMazePropState(): MazePropState {
  return { groupId: 0, configId: 0, state: 0 };
}

export const MazePropState = {
  encode(
    message: MazePropState,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.groupId !== 0) {
      writer.uint32(8).uint32(message.groupId);
    }
    if (message.configId !== 0) {
      writer.uint32(16).uint32(message.configId);
    }
    if (message.state !== 0) {
      writer.uint32(24).uint32(message.state);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MazePropState {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMazePropState();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.groupId = reader.uint32();
          break;
        case 2:
          message.configId = reader.uint32();
          break;
        case 3:
          message.state = reader.uint32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): MazePropState {
    return {
      groupId: isSet(object.groupId) ? Number(object.groupId) : 0,
      configId: isSet(object.configId) ? Number(object.configId) : 0,
      state: isSet(object.state) ? Number(object.state) : 0,
    };
  },

  toJSON(message: MazePropState): unknown {
    const obj: any = {};
    message.groupId !== undefined &&
      (obj.groupId = Math.round(message.groupId));
    message.configId !== undefined &&
      (obj.configId = Math.round(message.configId));
    message.state !== undefined && (obj.state = Math.round(message.state));
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<MazePropState>, I>>(
    object: I
  ): MazePropState {
    const message = createBaseMazePropState();
    message.groupId = object.groupId ?? 0;
    message.configId = object.configId ?? 0;
    message.state = object.state ?? 0;
    return message;
  },
};

function createBaseMazeGroup(): MazeGroup {
  return { groupId: 0, modifyTime: 0 };
}

export const MazeGroup = {
  encode(
    message: MazeGroup,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.groupId !== 0) {
      writer.uint32(8).uint32(message.groupId);
    }
    if (message.modifyTime !== 0) {
      writer.uint32(16).uint32(message.modifyTime);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MazeGroup {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMazeGroup();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.groupId = reader.uint32();
          break;
        case 2:
          message.modifyTime = reader.uint32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): MazeGroup {
    return {
      groupId: isSet(object.groupId) ? Number(object.groupId) : 0,
      modifyTime: isSet(object.modifyTime) ? Number(object.modifyTime) : 0,
    };
  },

  toJSON(message: MazeGroup): unknown {
    const obj: any = {};
    message.groupId !== undefined &&
      (obj.groupId = Math.round(message.groupId));
    message.modifyTime !== undefined &&
      (obj.modifyTime = Math.round(message.modifyTime));
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<MazeGroup>, I>>(
    object: I
  ): MazeGroup {
    const message = createBaseMazeGroup();
    message.groupId = object.groupId ?? 0;
    message.modifyTime = object.modifyTime ?? 0;
    return message;
  },
};

function createBaseGetMazeMapInfoCsReq(): GetMazeMapInfoCsReq {
  return { entryId: 0 };
}

export const GetMazeMapInfoCsReq = {
  encode(
    message: GetMazeMapInfoCsReq,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.entryId !== 0) {
      writer.uint32(8).uint32(message.entryId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetMazeMapInfoCsReq {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetMazeMapInfoCsReq();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.entryId = reader.uint32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): GetMazeMapInfoCsReq {
    return {
      entryId: isSet(object.entryId) ? Number(object.entryId) : 0,
    };
  },

  toJSON(message: GetMazeMapInfoCsReq): unknown {
    const obj: any = {};
    message.entryId !== undefined &&
      (obj.entryId = Math.round(message.entryId));
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<GetMazeMapInfoCsReq>, I>>(
    object: I
  ): GetMazeMapInfoCsReq {
    const message = createBaseGetMazeMapInfoCsReq();
    message.entryId = object.entryId ?? 0;
    return message;
  },
};

function createBaseGetMazeMapInfoScRsp(): GetMazeMapInfoScRsp {
  return {
    retcode: 0,
    entryId: 0,
    lightenSectionList: [],
    mazePropList: [],
    mazeGroupList: [],
    opendChestNum: 0,
    unlockTeleportList: [],
  };
}

export const GetMazeMapInfoScRsp = {
  encode(
    message: GetMazeMapInfoScRsp,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.retcode !== 0) {
      writer.uint32(8).uint32(message.retcode);
    }
    if (message.entryId !== 0) {
      writer.uint32(16).uint32(message.entryId);
    }
    writer.uint32(26).fork();
    for (const v of message.lightenSectionList) {
      writer.uint32(v);
    }
    writer.ldelim();
    for (const v of message.mazePropList) {
      MazePropState.encode(v!, writer.uint32(34).fork()).ldelim();
    }
    for (const v of message.mazeGroupList) {
      MazeGroup.encode(v!, writer.uint32(42).fork()).ldelim();
    }
    if (message.opendChestNum !== 0) {
      writer.uint32(48).uint32(message.opendChestNum);
    }
    writer.uint32(58).fork();
    for (const v of message.unlockTeleportList) {
      writer.uint32(v);
    }
    writer.ldelim();
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetMazeMapInfoScRsp {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetMazeMapInfoScRsp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.retcode = reader.uint32();
          break;
        case 2:
          message.entryId = reader.uint32();
          break;
        case 3:
          if ((tag & 7) === 2) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.lightenSectionList.push(reader.uint32());
            }
          } else {
            message.lightenSectionList.push(reader.uint32());
          }
          break;
        case 4:
          message.mazePropList.push(
            MazePropState.decode(reader, reader.uint32())
          );
          break;
        case 5:
          message.mazeGroupList.push(MazeGroup.decode(reader, reader.uint32()));
          break;
        case 6:
          message.opendChestNum = reader.uint32();
          break;
        case 7:
          if ((tag & 7) === 2) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.unlockTeleportList.push(reader.uint32());
            }
          } else {
            message.unlockTeleportList.push(reader.uint32());
          }
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): GetMazeMapInfoScRsp {
    return {
      retcode: isSet(object.retcode) ? Number(object.retcode) : 0,
      entryId: isSet(object.entryId) ? Number(object.entryId) : 0,
      lightenSectionList: Array.isArray(object?.lightenSectionList)
        ? object.lightenSectionList.map((e: any) => Number(e))
        : [],
      mazePropList: Array.isArray(object?.mazePropList)
        ? object.mazePropList.map((e: any) => MazePropState.fromJSON(e))
        : [],
      mazeGroupList: Array.isArray(object?.mazeGroupList)
        ? object.mazeGroupList.map((e: any) => MazeGroup.fromJSON(e))
        : [],
      opendChestNum: isSet(object.opendChestNum)
        ? Number(object.opendChestNum)
        : 0,
      unlockTeleportList: Array.isArray(object?.unlockTeleportList)
        ? object.unlockTeleportList.map((e: any) => Number(e))
        : [],
    };
  },

  toJSON(message: GetMazeMapInfoScRsp): unknown {
    const obj: any = {};
    message.retcode !== undefined &&
      (obj.retcode = Math.round(message.retcode));
    message.entryId !== undefined &&
      (obj.entryId = Math.round(message.entryId));
    if (message.lightenSectionList) {
      obj.lightenSectionList = message.lightenSectionList.map((e) =>
        Math.round(e)
      );
    } else {
      obj.lightenSectionList = [];
    }
    if (message.mazePropList) {
      obj.mazePropList = message.mazePropList.map((e) =>
        e ? MazePropState.toJSON(e) : undefined
      );
    } else {
      obj.mazePropList = [];
    }
    if (message.mazeGroupList) {
      obj.mazeGroupList = message.mazeGroupList.map((e) =>
        e ? MazeGroup.toJSON(e) : undefined
      );
    } else {
      obj.mazeGroupList = [];
    }
    message.opendChestNum !== undefined &&
      (obj.opendChestNum = Math.round(message.opendChestNum));
    if (message.unlockTeleportList) {
      obj.unlockTeleportList = message.unlockTeleportList.map((e) =>
        Math.round(e)
      );
    } else {
      obj.unlockTeleportList = [];
    }
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<GetMazeMapInfoScRsp>, I>>(
    object: I
  ): GetMazeMapInfoScRsp {
    const message = createBaseGetMazeMapInfoScRsp();
    message.retcode = object.retcode ?? 0;
    message.entryId = object.entryId ?? 0;
    message.lightenSectionList = object.lightenSectionList?.map((e) => e) || [];
    message.mazePropList =
      object.mazePropList?.map((e) => MazePropState.fromPartial(e)) || [];
    message.mazeGroupList =
      object.mazeGroupList?.map((e) => MazeGroup.fromPartial(e)) || [];
    message.opendChestNum = object.opendChestNum ?? 0;
    message.unlockTeleportList = object.unlockTeleportList?.map((e) => e) || [];
    return message;
  },
};

function createBaseGetMazeTimeOfDayCsReq(): GetMazeTimeOfDayCsReq {
  return {};
}

export const GetMazeTimeOfDayCsReq = {
  encode(
    _: GetMazeTimeOfDayCsReq,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): GetMazeTimeOfDayCsReq {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetMazeTimeOfDayCsReq();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(_: any): GetMazeTimeOfDayCsReq {
    return {};
  },

  toJSON(_: GetMazeTimeOfDayCsReq): unknown {
    const obj: any = {};
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<GetMazeTimeOfDayCsReq>, I>>(
    _: I
  ): GetMazeTimeOfDayCsReq {
    const message = createBaseGetMazeTimeOfDayCsReq();
    return message;
  },
};

function createBaseGetMazeTimeOfDayScRsp(): GetMazeTimeOfDayScRsp {
  return { retcode: 0, mazeTimeOfDayMap: {} };
}

export const GetMazeTimeOfDayScRsp = {
  encode(
    message: GetMazeTimeOfDayScRsp,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.retcode !== 0) {
      writer.uint32(8).uint32(message.retcode);
    }
    Object.entries(message.mazeTimeOfDayMap).forEach(([key, value]) => {
      GetMazeTimeOfDayScRsp_MazeTimeOfDayMapEntry.encode(
        { key: key as any, value },
        writer.uint32(18).fork()
      ).ldelim();
    });
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): GetMazeTimeOfDayScRsp {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetMazeTimeOfDayScRsp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.retcode = reader.uint32();
          break;
        case 2:
          const entry2 = GetMazeTimeOfDayScRsp_MazeTimeOfDayMapEntry.decode(
            reader,
            reader.uint32()
          );
          if (entry2.value !== undefined) {
            message.mazeTimeOfDayMap[entry2.key] = entry2.value;
          }
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): GetMazeTimeOfDayScRsp {
    return {
      retcode: isSet(object.retcode) ? Number(object.retcode) : 0,
      mazeTimeOfDayMap: isObject(object.mazeTimeOfDayMap)
        ? Object.entries(object.mazeTimeOfDayMap).reduce<{
            [key: number]: number;
          }>((acc, [key, value]) => {
            acc[Number(key)] = Number(value);
            return acc;
          }, {})
        : {},
    };
  },

  toJSON(message: GetMazeTimeOfDayScRsp): unknown {
    const obj: any = {};
    message.retcode !== undefined &&
      (obj.retcode = Math.round(message.retcode));
    obj.mazeTimeOfDayMap = {};
    if (message.mazeTimeOfDayMap) {
      Object.entries(message.mazeTimeOfDayMap).forEach(([k, v]) => {
        obj.mazeTimeOfDayMap[k] = Math.round(v);
      });
    }
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<GetMazeTimeOfDayScRsp>, I>>(
    object: I
  ): GetMazeTimeOfDayScRsp {
    const message = createBaseGetMazeTimeOfDayScRsp();
    message.retcode = object.retcode ?? 0;
    message.mazeTimeOfDayMap = Object.entries(
      object.mazeTimeOfDayMap ?? {}
    ).reduce<{ [key: number]: number }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[Number(key)] = Number(value);
      }
      return acc;
    }, {});
    return message;
  },
};

function createBaseGetMazeTimeOfDayScRsp_MazeTimeOfDayMapEntry(): GetMazeTimeOfDayScRsp_MazeTimeOfDayMapEntry {
  return { key: 0, value: 0 };
}

export const GetMazeTimeOfDayScRsp_MazeTimeOfDayMapEntry = {
  encode(
    message: GetMazeTimeOfDayScRsp_MazeTimeOfDayMapEntry,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.key !== 0) {
      writer.uint32(8).uint32(message.key);
    }
    if (message.value !== 0) {
      writer.uint32(16).uint32(message.value);
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): GetMazeTimeOfDayScRsp_MazeTimeOfDayMapEntry {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetMazeTimeOfDayScRsp_MazeTimeOfDayMapEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.key = reader.uint32();
          break;
        case 2:
          message.value = reader.uint32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): GetMazeTimeOfDayScRsp_MazeTimeOfDayMapEntry {
    return {
      key: isSet(object.key) ? Number(object.key) : 0,
      value: isSet(object.value) ? Number(object.value) : 0,
    };
  },

  toJSON(message: GetMazeTimeOfDayScRsp_MazeTimeOfDayMapEntry): unknown {
    const obj: any = {};
    message.key !== undefined && (obj.key = Math.round(message.key));
    message.value !== undefined && (obj.value = Math.round(message.value));
    return obj;
  },

  fromPartial<
    I extends Exact<DeepPartial<GetMazeTimeOfDayScRsp_MazeTimeOfDayMapEntry>, I>
  >(object: I): GetMazeTimeOfDayScRsp_MazeTimeOfDayMapEntry {
    const message = createBaseGetMazeTimeOfDayScRsp_MazeTimeOfDayMapEntry();
    message.key = object.key ?? 0;
    message.value = object.value ?? 0;
    return message;
  },
};

function createBaseSetMazeTimeOfDayCsReq(): SetMazeTimeOfDayCsReq {
  return { planeId: 0, timeOfDayType: 0 };
}

export const SetMazeTimeOfDayCsReq = {
  encode(
    message: SetMazeTimeOfDayCsReq,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.planeId !== 0) {
      writer.uint32(8).uint32(message.planeId);
    }
    if (message.timeOfDayType !== 0) {
      writer.uint32(16).uint32(message.timeOfDayType);
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): SetMazeTimeOfDayCsReq {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSetMazeTimeOfDayCsReq();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.planeId = reader.uint32();
          break;
        case 2:
          message.timeOfDayType = reader.uint32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): SetMazeTimeOfDayCsReq {
    return {
      planeId: isSet(object.planeId) ? Number(object.planeId) : 0,
      timeOfDayType: isSet(object.timeOfDayType)
        ? Number(object.timeOfDayType)
        : 0,
    };
  },

  toJSON(message: SetMazeTimeOfDayCsReq): unknown {
    const obj: any = {};
    message.planeId !== undefined &&
      (obj.planeId = Math.round(message.planeId));
    message.timeOfDayType !== undefined &&
      (obj.timeOfDayType = Math.round(message.timeOfDayType));
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<SetMazeTimeOfDayCsReq>, I>>(
    object: I
  ): SetMazeTimeOfDayCsReq {
    const message = createBaseSetMazeTimeOfDayCsReq();
    message.planeId = object.planeId ?? 0;
    message.timeOfDayType = object.timeOfDayType ?? 0;
    return message;
  },
};

function createBaseSetMazeTimeOfDayScRsp(): SetMazeTimeOfDayScRsp {
  return { retcode: 0, planeId: 0, timeOfDayType: 0 };
}

export const SetMazeTimeOfDayScRsp = {
  encode(
    message: SetMazeTimeOfDayScRsp,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.retcode !== 0) {
      writer.uint32(8).uint32(message.retcode);
    }
    if (message.planeId !== 0) {
      writer.uint32(16).uint32(message.planeId);
    }
    if (message.timeOfDayType !== 0) {
      writer.uint32(24).uint32(message.timeOfDayType);
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): SetMazeTimeOfDayScRsp {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSetMazeTimeOfDayScRsp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.retcode = reader.uint32();
          break;
        case 2:
          message.planeId = reader.uint32();
          break;
        case 3:
          message.timeOfDayType = reader.uint32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): SetMazeTimeOfDayScRsp {
    return {
      retcode: isSet(object.retcode) ? Number(object.retcode) : 0,
      planeId: isSet(object.planeId) ? Number(object.planeId) : 0,
      timeOfDayType: isSet(object.timeOfDayType)
        ? Number(object.timeOfDayType)
        : 0,
    };
  },

  toJSON(message: SetMazeTimeOfDayScRsp): unknown {
    const obj: any = {};
    message.retcode !== undefined &&
      (obj.retcode = Math.round(message.retcode));
    message.planeId !== undefined &&
      (obj.planeId = Math.round(message.planeId));
    message.timeOfDayType !== undefined &&
      (obj.timeOfDayType = Math.round(message.timeOfDayType));
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<SetMazeTimeOfDayScRsp>, I>>(
    object: I
  ): SetMazeTimeOfDayScRsp {
    const message = createBaseSetMazeTimeOfDayScRsp();
    message.retcode = object.retcode ?? 0;
    message.planeId = object.planeId ?? 0;
    message.timeOfDayType = object.timeOfDayType ?? 0;
    return message;
  },
};

function createBaseDelMazeTimeOfDayCsReq(): DelMazeTimeOfDayCsReq {
  return { planeId: 0 };
}

export const DelMazeTimeOfDayCsReq = {
  encode(
    message: DelMazeTimeOfDayCsReq,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.planeId !== 0) {
      writer.uint32(8).uint32(message.planeId);
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): DelMazeTimeOfDayCsReq {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDelMazeTimeOfDayCsReq();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.planeId = reader.uint32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): DelMazeTimeOfDayCsReq {
    return {
      planeId: isSet(object.planeId) ? Number(object.planeId) : 0,
    };
  },

  toJSON(message: DelMazeTimeOfDayCsReq): unknown {
    const obj: any = {};
    message.planeId !== undefined &&
      (obj.planeId = Math.round(message.planeId));
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<DelMazeTimeOfDayCsReq>, I>>(
    object: I
  ): DelMazeTimeOfDayCsReq {
    const message = createBaseDelMazeTimeOfDayCsReq();
    message.planeId = object.planeId ?? 0;
    return message;
  },
};

function createBaseDelMazeTimeOfDayScRsp(): DelMazeTimeOfDayScRsp {
  return { retcode: 0, planeId: 0 };
}

export const DelMazeTimeOfDayScRsp = {
  encode(
    message: DelMazeTimeOfDayScRsp,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.retcode !== 0) {
      writer.uint32(8).uint32(message.retcode);
    }
    if (message.planeId !== 0) {
      writer.uint32(16).uint32(message.planeId);
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): DelMazeTimeOfDayScRsp {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDelMazeTimeOfDayScRsp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.retcode = reader.uint32();
          break;
        case 2:
          message.planeId = reader.uint32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): DelMazeTimeOfDayScRsp {
    return {
      retcode: isSet(object.retcode) ? Number(object.retcode) : 0,
      planeId: isSet(object.planeId) ? Number(object.planeId) : 0,
    };
  },

  toJSON(message: DelMazeTimeOfDayScRsp): unknown {
    const obj: any = {};
    message.retcode !== undefined &&
      (obj.retcode = Math.round(message.retcode));
    message.planeId !== undefined &&
      (obj.planeId = Math.round(message.planeId));
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<DelMazeTimeOfDayScRsp>, I>>(
    object: I
  ): DelMazeTimeOfDayScRsp {
    const message = createBaseDelMazeTimeOfDayScRsp();
    message.retcode = object.retcode ?? 0;
    message.planeId = object.planeId ?? 0;
    return message;
  },
};

function createBaseReturnStartAnchorCsReq(): ReturnStartAnchorCsReq {
  return { entryId: 0 };
}

export const ReturnStartAnchorCsReq = {
  encode(
    message: ReturnStartAnchorCsReq,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.entryId !== 0) {
      writer.uint32(8).uint32(message.entryId);
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): ReturnStartAnchorCsReq {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReturnStartAnchorCsReq();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.entryId = reader.uint32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): ReturnStartAnchorCsReq {
    return {
      entryId: isSet(object.entryId) ? Number(object.entryId) : 0,
    };
  },

  toJSON(message: ReturnStartAnchorCsReq): unknown {
    const obj: any = {};
    message.entryId !== undefined &&
      (obj.entryId = Math.round(message.entryId));
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<ReturnStartAnchorCsReq>, I>>(
    object: I
  ): ReturnStartAnchorCsReq {
    const message = createBaseReturnStartAnchorCsReq();
    message.entryId = object.entryId ?? 0;
    return message;
  },
};

function createBaseReturnStartAnchorScRsp(): ReturnStartAnchorScRsp {
  return { retcode: 0 };
}

export const ReturnStartAnchorScRsp = {
  encode(
    message: ReturnStartAnchorScRsp,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.retcode !== 0) {
      writer.uint32(8).uint32(message.retcode);
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): ReturnStartAnchorScRsp {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReturnStartAnchorScRsp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.retcode = reader.uint32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): ReturnStartAnchorScRsp {
    return {
      retcode: isSet(object.retcode) ? Number(object.retcode) : 0,
    };
  },

  toJSON(message: ReturnStartAnchorScRsp): unknown {
    const obj: any = {};
    message.retcode !== undefined &&
      (obj.retcode = Math.round(message.retcode));
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<ReturnStartAnchorScRsp>, I>>(
    object: I
  ): ReturnStartAnchorScRsp {
    const message = createBaseReturnStartAnchorScRsp();
    message.retcode = object.retcode ?? 0;
    return message;
  },
};

function createBaseGetNpcMessageGroupCsReq(): GetNpcMessageGroupCsReq {
  return { contactIdList: [] };
}

export const GetNpcMessageGroupCsReq = {
  encode(
    message: GetNpcMessageGroupCsReq,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    writer.uint32(10).fork();
    for (const v of message.contactIdList) {
      writer.uint32(v);
    }
    writer.ldelim();
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): GetNpcMessageGroupCsReq {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetNpcMessageGroupCsReq();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if ((tag & 7) === 2) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.contactIdList.push(reader.uint32());
            }
          } else {
            message.contactIdList.push(reader.uint32());
          }
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): GetNpcMessageGroupCsReq {
    return {
      contactIdList: Array.isArray(object?.contactIdList)
        ? object.contactIdList.map((e: any) => Number(e))
        : [],
    };
  },

  toJSON(message: GetNpcMessageGroupCsReq): unknown {
    const obj: any = {};
    if (message.contactIdList) {
      obj.contactIdList = message.contactIdList.map((e) => Math.round(e));
    } else {
      obj.contactIdList = [];
    }
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<GetNpcMessageGroupCsReq>, I>>(
    object: I
  ): GetNpcMessageGroupCsReq {
    const message = createBaseGetNpcMessageGroupCsReq();
    message.contactIdList = object.contactIdList?.map((e) => e) || [];
    return message;
  },
};

function createBaseMessageItem(): MessageItem {
  return { itemId: 0, textId: 0 };
}

export const MessageItem = {
  encode(
    message: MessageItem,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.itemId !== 0) {
      writer.uint32(8).uint32(message.itemId);
    }
    if (message.textId !== 0) {
      writer.uint32(16).uint32(message.textId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MessageItem {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMessageItem();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.itemId = reader.uint32();
          break;
        case 2:
          message.textId = reader.uint32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): MessageItem {
    return {
      itemId: isSet(object.itemId) ? Number(object.itemId) : 0,
      textId: isSet(object.textId) ? Number(object.textId) : 0,
    };
  },

  toJSON(message: MessageItem): unknown {
    const obj: any = {};
    message.itemId !== undefined && (obj.itemId = Math.round(message.itemId));
    message.textId !== undefined && (obj.textId = Math.round(message.textId));
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<MessageItem>, I>>(
    object: I
  ): MessageItem {
    const message = createBaseMessageItem();
    message.itemId = object.itemId ?? 0;
    message.textId = object.textId ?? 0;
    return message;
  },
};

function createBaseMessageSection(): MessageSection {
  return { id: 0, messageItemId: 0, status: 0, itemList: [] };
}

export const MessageSection = {
  encode(
    message: MessageSection,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.id !== 0) {
      writer.uint32(8).uint32(message.id);
    }
    if (message.messageItemId !== 0) {
      writer.uint32(16).uint32(message.messageItemId);
    }
    if (message.status !== 0) {
      writer.uint32(24).int32(message.status);
    }
    for (const v of message.itemList) {
      MessageItem.encode(v!, writer.uint32(34).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MessageSection {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMessageSection();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.id = reader.uint32();
          break;
        case 2:
          message.messageItemId = reader.uint32();
          break;
        case 3:
          message.status = reader.int32() as any;
          break;
        case 4:
          message.itemList.push(MessageItem.decode(reader, reader.uint32()));
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): MessageSection {
    return {
      id: isSet(object.id) ? Number(object.id) : 0,
      messageItemId: isSet(object.messageItemId)
        ? Number(object.messageItemId)
        : 0,
      status: isSet(object.status)
        ? messageSectionStatusFromJSON(object.status)
        : 0,
      itemList: Array.isArray(object?.itemList)
        ? object.itemList.map((e: any) => MessageItem.fromJSON(e))
        : [],
    };
  },

  toJSON(message: MessageSection): unknown {
    const obj: any = {};
    message.id !== undefined && (obj.id = Math.round(message.id));
    message.messageItemId !== undefined &&
      (obj.messageItemId = Math.round(message.messageItemId));
    message.status !== undefined &&
      (obj.status = messageSectionStatusToJSON(message.status));
    if (message.itemList) {
      obj.itemList = message.itemList.map((e) =>
        e ? MessageItem.toJSON(e) : undefined
      );
    } else {
      obj.itemList = [];
    }
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<MessageSection>, I>>(
    object: I
  ): MessageSection {
    const message = createBaseMessageSection();
    message.id = object.id ?? 0;
    message.messageItemId = object.messageItemId ?? 0;
    message.status = object.status ?? 0;
    message.itemList =
      object.itemList?.map((e) => MessageItem.fromPartial(e)) || [];
    return message;
  },
};

function createBaseMessageGroup(): MessageGroup {
  return {
    id: 0,
    messageSectionId: 0,
    status: 0,
    refreshTime: 0,
    messageSectionList: [],
  };
}

export const MessageGroup = {
  encode(
    message: MessageGroup,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.id !== 0) {
      writer.uint32(8).uint32(message.id);
    }
    if (message.messageSectionId !== 0) {
      writer.uint32(16).uint32(message.messageSectionId);
    }
    if (message.status !== 0) {
      writer.uint32(24).int32(message.status);
    }
    if (message.refreshTime !== 0) {
      writer.uint32(32).uint32(message.refreshTime);
    }
    for (const v of message.messageSectionList) {
      MessageSection.encode(v!, writer.uint32(42).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MessageGroup {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMessageGroup();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.id = reader.uint32();
          break;
        case 2:
          message.messageSectionId = reader.uint32();
          break;
        case 3:
          message.status = reader.int32() as any;
          break;
        case 4:
          message.refreshTime = reader.uint32();
          break;
        case 5:
          message.messageSectionList.push(
            MessageSection.decode(reader, reader.uint32())
          );
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): MessageGroup {
    return {
      id: isSet(object.id) ? Number(object.id) : 0,
      messageSectionId: isSet(object.messageSectionId)
        ? Number(object.messageSectionId)
        : 0,
      status: isSet(object.status)
        ? messageGroupStatusFromJSON(object.status)
        : 0,
      refreshTime: isSet(object.refreshTime) ? Number(object.refreshTime) : 0,
      messageSectionList: Array.isArray(object?.messageSectionList)
        ? object.messageSectionList.map((e: any) => MessageSection.fromJSON(e))
        : [],
    };
  },

  toJSON(message: MessageGroup): unknown {
    const obj: any = {};
    message.id !== undefined && (obj.id = Math.round(message.id));
    message.messageSectionId !== undefined &&
      (obj.messageSectionId = Math.round(message.messageSectionId));
    message.status !== undefined &&
      (obj.status = messageGroupStatusToJSON(message.status));
    message.refreshTime !== undefined &&
      (obj.refreshTime = Math.round(message.refreshTime));
    if (message.messageSectionList) {
      obj.messageSectionList = message.messageSectionList.map((e) =>
        e ? MessageSection.toJSON(e) : undefined
      );
    } else {
      obj.messageSectionList = [];
    }
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<MessageGroup>, I>>(
    object: I
  ): MessageGroup {
    const message = createBaseMessageGroup();
    message.id = object.id ?? 0;
    message.messageSectionId = object.messageSectionId ?? 0;
    message.status = object.status ?? 0;
    message.refreshTime = object.refreshTime ?? 0;
    message.messageSectionList =
      object.messageSectionList?.map((e) => MessageSection.fromPartial(e)) ||
      [];
    return message;
  },
};

function createBaseGetNpcMessageGroupScRsp(): GetNpcMessageGroupScRsp {
  return { retcode: 0, messageGroupList: [] };
}

export const GetNpcMessageGroupScRsp = {
  encode(
    message: GetNpcMessageGroupScRsp,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.retcode !== 0) {
      writer.uint32(8).uint32(message.retcode);
    }
    for (const v of message.messageGroupList) {
      MessageGroup.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): GetNpcMessageGroupScRsp {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetNpcMessageGroupScRsp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.retcode = reader.uint32();
          break;
        case 2:
          message.messageGroupList.push(
            MessageGroup.decode(reader, reader.uint32())
          );
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): GetNpcMessageGroupScRsp {
    return {
      retcode: isSet(object.retcode) ? Number(object.retcode) : 0,
      messageGroupList: Array.isArray(object?.messageGroupList)
        ? object.messageGroupList.map((e: any) => MessageGroup.fromJSON(e))
        : [],
    };
  },

  toJSON(message: GetNpcMessageGroupScRsp): unknown {
    const obj: any = {};
    message.retcode !== undefined &&
      (obj.retcode = Math.round(message.retcode));
    if (message.messageGroupList) {
      obj.messageGroupList = message.messageGroupList.map((e) =>
        e ? MessageGroup.toJSON(e) : undefined
      );
    } else {
      obj.messageGroupList = [];
    }
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<GetNpcMessageGroupScRsp>, I>>(
    object: I
  ): GetNpcMessageGroupScRsp {
    const message = createBaseGetNpcMessageGroupScRsp();
    message.retcode = object.retcode ?? 0;
    message.messageGroupList =
      object.messageGroupList?.map((e) => MessageGroup.fromPartial(e)) || [];
    return message;
  },
};

function createBaseGetNpcStatusCsReq(): GetNpcStatusCsReq {
  return {};
}

export const GetNpcStatusCsReq = {
  encode(
    _: GetNpcStatusCsReq,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetNpcStatusCsReq {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetNpcStatusCsReq();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(_: any): GetNpcStatusCsReq {
    return {};
  },

  toJSON(_: GetNpcStatusCsReq): unknown {
    const obj: any = {};
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<GetNpcStatusCsReq>, I>>(
    _: I
  ): GetNpcStatusCsReq {
    const message = createBaseGetNpcStatusCsReq();
    return message;
  },
};

function createBaseNpcStatus(): NpcStatus {
  return { npcId: 0, isFinish: false };
}

export const NpcStatus = {
  encode(
    message: NpcStatus,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.npcId !== 0) {
      writer.uint32(8).uint32(message.npcId);
    }
    if (message.isFinish === true) {
      writer.uint32(16).bool(message.isFinish);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): NpcStatus {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNpcStatus();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.npcId = reader.uint32();
          break;
        case 2:
          message.isFinish = reader.bool();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): NpcStatus {
    return {
      npcId: isSet(object.npcId) ? Number(object.npcId) : 0,
      isFinish: isSet(object.isFinish) ? Boolean(object.isFinish) : false,
    };
  },

  toJSON(message: NpcStatus): unknown {
    const obj: any = {};
    message.npcId !== undefined && (obj.npcId = Math.round(message.npcId));
    message.isFinish !== undefined && (obj.isFinish = message.isFinish);
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<NpcStatus>, I>>(
    object: I
  ): NpcStatus {
    const message = createBaseNpcStatus();
    message.npcId = object.npcId ?? 0;
    message.isFinish = object.isFinish ?? false;
    return message;
  },
};

function createBaseGroupStatus(): GroupStatus {
  return { groupId: 0, groupStatus: 0, refreshTime: 0 };
}

export const GroupStatus = {
  encode(
    message: GroupStatus,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.groupId !== 0) {
      writer.uint32(8).uint32(message.groupId);
    }
    if (message.groupStatus !== 0) {
      writer.uint32(16).int32(message.groupStatus);
    }
    if (message.refreshTime !== 0) {
      writer.uint32(24).uint32(message.refreshTime);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GroupStatus {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGroupStatus();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.groupId = reader.uint32();
          break;
        case 2:
          message.groupStatus = reader.int32() as any;
          break;
        case 3:
          message.refreshTime = reader.uint32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): GroupStatus {
    return {
      groupId: isSet(object.groupId) ? Number(object.groupId) : 0,
      groupStatus: isSet(object.groupStatus)
        ? messageGroupStatusFromJSON(object.groupStatus)
        : 0,
      refreshTime: isSet(object.refreshTime) ? Number(object.refreshTime) : 0,
    };
  },

  toJSON(message: GroupStatus): unknown {
    const obj: any = {};
    message.groupId !== undefined &&
      (obj.groupId = Math.round(message.groupId));
    message.groupStatus !== undefined &&
      (obj.groupStatus = messageGroupStatusToJSON(message.groupStatus));
    message.refreshTime !== undefined &&
      (obj.refreshTime = Math.round(message.refreshTime));
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<GroupStatus>, I>>(
    object: I
  ): GroupStatus {
    const message = createBaseGroupStatus();
    message.groupId = object.groupId ?? 0;
    message.groupStatus = object.groupStatus ?? 0;
    message.refreshTime = object.refreshTime ?? 0;
    return message;
  },
};

function createBaseSectionStatus(): SectionStatus {
  return { sectionId: 0, sectionStatus: 0 };
}

export const SectionStatus = {
  encode(
    message: SectionStatus,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.sectionId !== 0) {
      writer.uint32(8).uint32(message.sectionId);
    }
    if (message.sectionStatus !== 0) {
      writer.uint32(16).int32(message.sectionStatus);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SectionStatus {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSectionStatus();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.sectionId = reader.uint32();
          break;
        case 2:
          message.sectionStatus = reader.int32() as any;
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): SectionStatus {
    return {
      sectionId: isSet(object.sectionId) ? Number(object.sectionId) : 0,
      sectionStatus: isSet(object.sectionStatus)
        ? messageSectionStatusFromJSON(object.sectionStatus)
        : 0,
    };
  },

  toJSON(message: SectionStatus): unknown {
    const obj: any = {};
    message.sectionId !== undefined &&
      (obj.sectionId = Math.round(message.sectionId));
    message.sectionStatus !== undefined &&
      (obj.sectionStatus = messageSectionStatusToJSON(message.sectionStatus));
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<SectionStatus>, I>>(
    object: I
  ): SectionStatus {
    const message = createBaseSectionStatus();
    message.sectionId = object.sectionId ?? 0;
    message.sectionStatus = object.sectionStatus ?? 0;
    return message;
  },
};

function createBaseGetNpcStatusScRsp(): GetNpcStatusScRsp {
  return { retcode: 0, messageStatusList: [] };
}

export const GetNpcStatusScRsp = {
  encode(
    message: GetNpcStatusScRsp,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.retcode !== 0) {
      writer.uint32(8).uint32(message.retcode);
    }
    for (const v of message.messageStatusList) {
      NpcStatus.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetNpcStatusScRsp {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetNpcStatusScRsp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.retcode = reader.uint32();
          break;
        case 2:
          message.messageStatusList.push(
            NpcStatus.decode(reader, reader.uint32())
          );
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): GetNpcStatusScRsp {
    return {
      retcode: isSet(object.retcode) ? Number(object.retcode) : 0,
      messageStatusList: Array.isArray(object?.messageStatusList)
        ? object.messageStatusList.map((e: any) => NpcStatus.fromJSON(e))
        : [],
    };
  },

  toJSON(message: GetNpcStatusScRsp): unknown {
    const obj: any = {};
    message.retcode !== undefined &&
      (obj.retcode = Math.round(message.retcode));
    if (message.messageStatusList) {
      obj.messageStatusList = message.messageStatusList.map((e) =>
        e ? NpcStatus.toJSON(e) : undefined
      );
    } else {
      obj.messageStatusList = [];
    }
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<GetNpcStatusScRsp>, I>>(
    object: I
  ): GetNpcStatusScRsp {
    const message = createBaseGetNpcStatusScRsp();
    message.retcode = object.retcode ?? 0;
    message.messageStatusList =
      object.messageStatusList?.map((e) => NpcStatus.fromPartial(e)) || [];
    return message;
  },
};

function createBaseFinishItemIdCsReq(): FinishItemIdCsReq {
  return { itemId: 0, textId: 0 };
}

export const FinishItemIdCsReq = {
  encode(
    message: FinishItemIdCsReq,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.itemId !== 0) {
      writer.uint32(8).uint32(message.itemId);
    }
    if (message.textId !== 0) {
      writer.uint32(16).uint32(message.textId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): FinishItemIdCsReq {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFinishItemIdCsReq();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.itemId = reader.uint32();
          break;
        case 2:
          message.textId = reader.uint32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): FinishItemIdCsReq {
    return {
      itemId: isSet(object.itemId) ? Number(object.itemId) : 0,
      textId: isSet(object.textId) ? Number(object.textId) : 0,
    };
  },

  toJSON(message: FinishItemIdCsReq): unknown {
    const obj: any = {};
    message.itemId !== undefined && (obj.itemId = Math.round(message.itemId));
    message.textId !== undefined && (obj.textId = Math.round(message.textId));
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<FinishItemIdCsReq>, I>>(
    object: I
  ): FinishItemIdCsReq {
    const message = createBaseFinishItemIdCsReq();
    message.itemId = object.itemId ?? 0;
    message.textId = object.textId ?? 0;
    return message;
  },
};

function createBaseFinishItemIdScRsp(): FinishItemIdScRsp {
  return { retcode: 0, itemId: 0, textId: 0 };
}

export const FinishItemIdScRsp = {
  encode(
    message: FinishItemIdScRsp,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.retcode !== 0) {
      writer.uint32(8).uint32(message.retcode);
    }
    if (message.itemId !== 0) {
      writer.uint32(16).uint32(message.itemId);
    }
    if (message.textId !== 0) {
      writer.uint32(24).uint32(message.textId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): FinishItemIdScRsp {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFinishItemIdScRsp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.retcode = reader.uint32();
          break;
        case 2:
          message.itemId = reader.uint32();
          break;
        case 3:
          message.textId = reader.uint32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): FinishItemIdScRsp {
    return {
      retcode: isSet(object.retcode) ? Number(object.retcode) : 0,
      itemId: isSet(object.itemId) ? Number(object.itemId) : 0,
      textId: isSet(object.textId) ? Number(object.textId) : 0,
    };
  },

  toJSON(message: FinishItemIdScRsp): unknown {
    const obj: any = {};
    message.retcode !== undefined &&
      (obj.retcode = Math.round(message.retcode));
    message.itemId !== undefined && (obj.itemId = Math.round(message.itemId));
    message.textId !== undefined && (obj.textId = Math.round(message.textId));
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<FinishItemIdScRsp>, I>>(
    object: I
  ): FinishItemIdScRsp {
    const message = createBaseFinishItemIdScRsp();
    message.retcode = object.retcode ?? 0;
    message.itemId = object.itemId ?? 0;
    message.textId = object.textId ?? 0;
    return message;
  },
};

function createBaseFinishSectionIdCsReq(): FinishSectionIdCsReq {
  return { sectionId: 0 };
}

export const FinishSectionIdCsReq = {
  encode(
    message: FinishSectionIdCsReq,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.sectionId !== 0) {
      writer.uint32(8).uint32(message.sectionId);
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): FinishSectionIdCsReq {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFinishSectionIdCsReq();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.sectionId = reader.uint32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): FinishSectionIdCsReq {
    return {
      sectionId: isSet(object.sectionId) ? Number(object.sectionId) : 0,
    };
  },

  toJSON(message: FinishSectionIdCsReq): unknown {
    const obj: any = {};
    message.sectionId !== undefined &&
      (obj.sectionId = Math.round(message.sectionId));
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<FinishSectionIdCsReq>, I>>(
    object: I
  ): FinishSectionIdCsReq {
    const message = createBaseFinishSectionIdCsReq();
    message.sectionId = object.sectionId ?? 0;
    return message;
  },
};

function createBaseFinishSectionIdScRsp(): FinishSectionIdScRsp {
  return { retcode: 0, sectionId: 0 };
}

export const FinishSectionIdScRsp = {
  encode(
    message: FinishSectionIdScRsp,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.retcode !== 0) {
      writer.uint32(8).uint32(message.retcode);
    }
    if (message.sectionId !== 0) {
      writer.uint32(16).uint32(message.sectionId);
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): FinishSectionIdScRsp {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFinishSectionIdScRsp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.retcode = reader.uint32();
          break;
        case 2:
          message.sectionId = reader.uint32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): FinishSectionIdScRsp {
    return {
      retcode: isSet(object.retcode) ? Number(object.retcode) : 0,
      sectionId: isSet(object.sectionId) ? Number(object.sectionId) : 0,
    };
  },

  toJSON(message: FinishSectionIdScRsp): unknown {
    const obj: any = {};
    message.retcode !== undefined &&
      (obj.retcode = Math.round(message.retcode));
    message.sectionId !== undefined &&
      (obj.sectionId = Math.round(message.sectionId));
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<FinishSectionIdScRsp>, I>>(
    object: I
  ): FinishSectionIdScRsp {
    const message = createBaseFinishSectionIdScRsp();
    message.retcode = object.retcode ?? 0;
    message.sectionId = object.sectionId ?? 0;
    return message;
  },
};

function createBaseGetMissionDataCsReq(): GetMissionDataCsReq {
  return {};
}

export const GetMissionDataCsReq = {
  encode(
    _: GetMissionDataCsReq,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetMissionDataCsReq {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetMissionDataCsReq();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(_: any): GetMissionDataCsReq {
    return {};
  },

  toJSON(_: GetMissionDataCsReq): unknown {
    const obj: any = {};
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<GetMissionDataCsReq>, I>>(
    _: I
  ): GetMissionDataCsReq {
    const message = createBaseGetMissionDataCsReq();
    return message;
  },
};

function createBaseMission(): Mission {
  return { id: 0, status: 0, progress: 0 };
}

export const Mission = {
  encode(
    message: Mission,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.id !== 0) {
      writer.uint32(8).uint32(message.id);
    }
    if (message.status !== 0) {
      writer.uint32(16).int32(message.status);
    }
    if (message.progress !== 0) {
      writer.uint32(24).uint32(message.progress);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Mission {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMission();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.id = reader.uint32();
          break;
        case 2:
          message.status = reader.int32() as any;
          break;
        case 3:
          message.progress = reader.uint32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): Mission {
    return {
      id: isSet(object.id) ? Number(object.id) : 0,
      status: isSet(object.status) ? missionStatusFromJSON(object.status) : 0,
      progress: isSet(object.progress) ? Number(object.progress) : 0,
    };
  },

  toJSON(message: Mission): unknown {
    const obj: any = {};
    message.id !== undefined && (obj.id = Math.round(message.id));
    message.status !== undefined &&
      (obj.status = missionStatusToJSON(message.status));
    message.progress !== undefined &&
      (obj.progress = Math.round(message.progress));
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<Mission>, I>>(object: I): Mission {
    const message = createBaseMission();
    message.id = object.id ?? 0;
    message.status = object.status ?? 0;
    message.progress = object.progress ?? 0;
    return message;
  },
};

function createBaseGetMissionDataScRsp(): GetMissionDataScRsp {
  return { retcode: 0, missionList: [] };
}

export const GetMissionDataScRsp = {
  encode(
    message: GetMissionDataScRsp,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.retcode !== 0) {
      writer.uint32(8).uint32(message.retcode);
    }
    for (const v of message.missionList) {
      Mission.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetMissionDataScRsp {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetMissionDataScRsp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.retcode = reader.uint32();
          break;
        case 2:
          message.missionList.push(Mission.decode(reader, reader.uint32()));
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): GetMissionDataScRsp {
    return {
      retcode: isSet(object.retcode) ? Number(object.retcode) : 0,
      missionList: Array.isArray(object?.missionList)
        ? object.missionList.map((e: any) => Mission.fromJSON(e))
        : [],
    };
  },

  toJSON(message: GetMissionDataScRsp): unknown {
    const obj: any = {};
    message.retcode !== undefined &&
      (obj.retcode = Math.round(message.retcode));
    if (message.missionList) {
      obj.missionList = message.missionList.map((e) =>
        e ? Mission.toJSON(e) : undefined
      );
    } else {
      obj.missionList = [];
    }
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<GetMissionDataScRsp>, I>>(
    object: I
  ): GetMissionDataScRsp {
    const message = createBaseGetMissionDataScRsp();
    message.retcode = object.retcode ?? 0;
    message.missionList =
      object.missionList?.map((e) => Mission.fromPartial(e)) || [];
    return message;
  },
};

function createBaseFinishTalkMissionCsReq(): FinishTalkMissionCsReq {
  return { talkStr: "" };
}

export const FinishTalkMissionCsReq = {
  encode(
    message: FinishTalkMissionCsReq,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.talkStr !== "") {
      writer.uint32(10).string(message.talkStr);
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): FinishTalkMissionCsReq {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFinishTalkMissionCsReq();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.talkStr = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): FinishTalkMissionCsReq {
    return {
      talkStr: isSet(object.talkStr) ? String(object.talkStr) : "",
    };
  },

  toJSON(message: FinishTalkMissionCsReq): unknown {
    const obj: any = {};
    message.talkStr !== undefined && (obj.talkStr = message.talkStr);
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<FinishTalkMissionCsReq>, I>>(
    object: I
  ): FinishTalkMissionCsReq {
    const message = createBaseFinishTalkMissionCsReq();
    message.talkStr = object.talkStr ?? "";
    return message;
  },
};

function createBaseFinishTalkMissionScRsp(): FinishTalkMissionScRsp {
  return { retcode: 0, talkStr: "" };
}

export const FinishTalkMissionScRsp = {
  encode(
    message: FinishTalkMissionScRsp,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.retcode !== 0) {
      writer.uint32(8).uint32(message.retcode);
    }
    if (message.talkStr !== "") {
      writer.uint32(18).string(message.talkStr);
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): FinishTalkMissionScRsp {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFinishTalkMissionScRsp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.retcode = reader.uint32();
          break;
        case 2:
          message.talkStr = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): FinishTalkMissionScRsp {
    return {
      retcode: isSet(object.retcode) ? Number(object.retcode) : 0,
      talkStr: isSet(object.talkStr) ? String(object.talkStr) : "",
    };
  },

  toJSON(message: FinishTalkMissionScRsp): unknown {
    const obj: any = {};
    message.retcode !== undefined &&
      (obj.retcode = Math.round(message.retcode));
    message.talkStr !== undefined && (obj.talkStr = message.talkStr);
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<FinishTalkMissionScRsp>, I>>(
    object: I
  ): FinishTalkMissionScRsp {
    const message = createBaseFinishTalkMissionScRsp();
    message.retcode = object.retcode ?? 0;
    message.talkStr = object.talkStr ?? "";
    return message;
  },
};

function createBaseMissionRewardScNotify(): MissionRewardScNotify {
  return { mainMissionId: 0, reward: undefined };
}

export const MissionRewardScNotify = {
  encode(
    message: MissionRewardScNotify,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.mainMissionId !== 0) {
      writer.uint32(8).uint32(message.mainMissionId);
    }
    if (message.reward !== undefined) {
      ItemList.encode(message.reward, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): MissionRewardScNotify {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMissionRewardScNotify();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.mainMissionId = reader.uint32();
          break;
        case 2:
          message.reward = ItemList.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): MissionRewardScNotify {
    return {
      mainMissionId: isSet(object.mainMissionId)
        ? Number(object.mainMissionId)
        : 0,
      reward: isSet(object.reward)
        ? ItemList.fromJSON(object.reward)
        : undefined,
    };
  },

  toJSON(message: MissionRewardScNotify): unknown {
    const obj: any = {};
    message.mainMissionId !== undefined &&
      (obj.mainMissionId = Math.round(message.mainMissionId));
    message.reward !== undefined &&
      (obj.reward = message.reward
        ? ItemList.toJSON(message.reward)
        : undefined);
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<MissionRewardScNotify>, I>>(
    object: I
  ): MissionRewardScNotify {
    const message = createBaseMissionRewardScNotify();
    message.mainMissionId = object.mainMissionId ?? 0;
    message.reward =
      object.reward !== undefined && object.reward !== null
        ? ItemList.fromPartial(object.reward)
        : undefined;
    return message;
  },
};

function createBaseSubMissionRewardScNotify(): SubMissionRewardScNotify {
  return { subMissionId: 0, reward: undefined };
}

export const SubMissionRewardScNotify = {
  encode(
    message: SubMissionRewardScNotify,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.subMissionId !== 0) {
      writer.uint32(8).uint32(message.subMissionId);
    }
    if (message.reward !== undefined) {
      ItemList.encode(message.reward, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): SubMissionRewardScNotify {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSubMissionRewardScNotify();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.subMissionId = reader.uint32();
          break;
        case 2:
          message.reward = ItemList.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): SubMissionRewardScNotify {
    return {
      subMissionId: isSet(object.subMissionId)
        ? Number(object.subMissionId)
        : 0,
      reward: isSet(object.reward)
        ? ItemList.fromJSON(object.reward)
        : undefined,
    };
  },

  toJSON(message: SubMissionRewardScNotify): unknown {
    const obj: any = {};
    message.subMissionId !== undefined &&
      (obj.subMissionId = Math.round(message.subMissionId));
    message.reward !== undefined &&
      (obj.reward = message.reward
        ? ItemList.toJSON(message.reward)
        : undefined);
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<SubMissionRewardScNotify>, I>>(
    object: I
  ): SubMissionRewardScNotify {
    const message = createBaseSubMissionRewardScNotify();
    message.subMissionId = object.subMissionId ?? 0;
    message.reward =
      object.reward !== undefined && object.reward !== null
        ? ItemList.fromPartial(object.reward)
        : undefined;
    return message;
  },
};

function createBaseSyncTaskCsReq(): SyncTaskCsReq {
  return { key: "" };
}

export const SyncTaskCsReq = {
  encode(
    message: SyncTaskCsReq,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SyncTaskCsReq {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSyncTaskCsReq();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.key = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): SyncTaskCsReq {
    return {
      key: isSet(object.key) ? String(object.key) : "",
    };
  },

  toJSON(message: SyncTaskCsReq): unknown {
    const obj: any = {};
    message.key !== undefined && (obj.key = message.key);
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<SyncTaskCsReq>, I>>(
    object: I
  ): SyncTaskCsReq {
    const message = createBaseSyncTaskCsReq();
    message.key = object.key ?? "";
    return message;
  },
};

function createBaseSyncTaskScRsp(): SyncTaskScRsp {
  return { retcode: 0, key: "" };
}

export const SyncTaskScRsp = {
  encode(
    message: SyncTaskScRsp,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.retcode !== 0) {
      writer.uint32(8).uint32(message.retcode);
    }
    if (message.key !== "") {
      writer.uint32(18).string(message.key);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SyncTaskScRsp {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSyncTaskScRsp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.retcode = reader.uint32();
          break;
        case 2:
          message.key = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): SyncTaskScRsp {
    return {
      retcode: isSet(object.retcode) ? Number(object.retcode) : 0,
      key: isSet(object.key) ? String(object.key) : "",
    };
  },

  toJSON(message: SyncTaskScRsp): unknown {
    const obj: any = {};
    message.retcode !== undefined &&
      (obj.retcode = Math.round(message.retcode));
    message.key !== undefined && (obj.key = message.key);
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<SyncTaskScRsp>, I>>(
    object: I
  ): SyncTaskScRsp {
    const message = createBaseSyncTaskScRsp();
    message.retcode = object.retcode ?? 0;
    message.key = object.key ?? "";
    return message;
  },
};

function createBaseDailyTask(): DailyTask {
  return { mainMissionId: 0, isFinished: false };
}

export const DailyTask = {
  encode(
    message: DailyTask,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.mainMissionId !== 0) {
      writer.uint32(8).uint32(message.mainMissionId);
    }
    if (message.isFinished === true) {
      writer.uint32(16).bool(message.isFinished);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): DailyTask {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDailyTask();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.mainMissionId = reader.uint32();
          break;
        case 2:
          message.isFinished = reader.bool();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): DailyTask {
    return {
      mainMissionId: isSet(object.mainMissionId)
        ? Number(object.mainMissionId)
        : 0,
      isFinished: isSet(object.isFinished) ? Boolean(object.isFinished) : false,
    };
  },

  toJSON(message: DailyTask): unknown {
    const obj: any = {};
    message.mainMissionId !== undefined &&
      (obj.mainMissionId = Math.round(message.mainMissionId));
    message.isFinished !== undefined && (obj.isFinished = message.isFinished);
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<DailyTask>, I>>(
    object: I
  ): DailyTask {
    const message = createBaseDailyTask();
    message.mainMissionId = object.mainMissionId ?? 0;
    message.isFinished = object.isFinished ?? false;
    return message;
  },
};

function createBaseDailyTaskDataScNotify(): DailyTaskDataScNotify {
  return { isTakenExtraReward: false, finishedNum: 0, dailyTaskList: [] };
}

export const DailyTaskDataScNotify = {
  encode(
    message: DailyTaskDataScNotify,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.isTakenExtraReward === true) {
      writer.uint32(8).bool(message.isTakenExtraReward);
    }
    if (message.finishedNum !== 0) {
      writer.uint32(16).uint32(message.finishedNum);
    }
    for (const v of message.dailyTaskList) {
      DailyTask.encode(v!, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): DailyTaskDataScNotify {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDailyTaskDataScNotify();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.isTakenExtraReward = reader.bool();
          break;
        case 2:
          message.finishedNum = reader.uint32();
          break;
        case 3:
          message.dailyTaskList.push(DailyTask.decode(reader, reader.uint32()));
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): DailyTaskDataScNotify {
    return {
      isTakenExtraReward: isSet(object.isTakenExtraReward)
        ? Boolean(object.isTakenExtraReward)
        : false,
      finishedNum: isSet(object.finishedNum) ? Number(object.finishedNum) : 0,
      dailyTaskList: Array.isArray(object?.dailyTaskList)
        ? object.dailyTaskList.map((e: any) => DailyTask.fromJSON(e))
        : [],
    };
  },

  toJSON(message: DailyTaskDataScNotify): unknown {
    const obj: any = {};
    message.isTakenExtraReward !== undefined &&
      (obj.isTakenExtraReward = message.isTakenExtraReward);
    message.finishedNum !== undefined &&
      (obj.finishedNum = Math.round(message.finishedNum));
    if (message.dailyTaskList) {
      obj.dailyTaskList = message.dailyTaskList.map((e) =>
        e ? DailyTask.toJSON(e) : undefined
      );
    } else {
      obj.dailyTaskList = [];
    }
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<DailyTaskDataScNotify>, I>>(
    object: I
  ): DailyTaskDataScNotify {
    const message = createBaseDailyTaskDataScNotify();
    message.isTakenExtraReward = object.isTakenExtraReward ?? false;
    message.finishedNum = object.finishedNum ?? 0;
    message.dailyTaskList =
      object.dailyTaskList?.map((e) => DailyTask.fromPartial(e)) || [];
    return message;
  },
};

function createBaseTakeDailyTaskExtraRewardCsReq(): TakeDailyTaskExtraRewardCsReq {
  return {};
}

export const TakeDailyTaskExtraRewardCsReq = {
  encode(
    _: TakeDailyTaskExtraRewardCsReq,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): TakeDailyTaskExtraRewardCsReq {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTakeDailyTaskExtraRewardCsReq();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(_: any): TakeDailyTaskExtraRewardCsReq {
    return {};
  },

  toJSON(_: TakeDailyTaskExtraRewardCsReq): unknown {
    const obj: any = {};
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<TakeDailyTaskExtraRewardCsReq>, I>>(
    _: I
  ): TakeDailyTaskExtraRewardCsReq {
    const message = createBaseTakeDailyTaskExtraRewardCsReq();
    return message;
  },
};

function createBaseTakeDailyTaskExtraRewardScRsp(): TakeDailyTaskExtraRewardScRsp {
  return { retcode: 0, reward: undefined };
}

export const TakeDailyTaskExtraRewardScRsp = {
  encode(
    message: TakeDailyTaskExtraRewardScRsp,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.retcode !== 0) {
      writer.uint32(8).uint32(message.retcode);
    }
    if (message.reward !== undefined) {
      ItemList.encode(message.reward, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): TakeDailyTaskExtraRewardScRsp {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTakeDailyTaskExtraRewardScRsp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.retcode = reader.uint32();
          break;
        case 2:
          message.reward = ItemList.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): TakeDailyTaskExtraRewardScRsp {
    return {
      retcode: isSet(object.retcode) ? Number(object.retcode) : 0,
      reward: isSet(object.reward)
        ? ItemList.fromJSON(object.reward)
        : undefined,
    };
  },

  toJSON(message: TakeDailyTaskExtraRewardScRsp): unknown {
    const obj: any = {};
    message.retcode !== undefined &&
      (obj.retcode = Math.round(message.retcode));
    message.reward !== undefined &&
      (obj.reward = message.reward
        ? ItemList.toJSON(message.reward)
        : undefined);
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<TakeDailyTaskExtraRewardScRsp>, I>>(
    object: I
  ): TakeDailyTaskExtraRewardScRsp {
    const message = createBaseTakeDailyTaskExtraRewardScRsp();
    message.retcode = object.retcode ?? 0;
    message.reward =
      object.reward !== undefined && object.reward !== null
        ? ItemList.fromPartial(object.reward)
        : undefined;
    return message;
  },
};

function createBaseDailyTaskRewardScNotify(): DailyTaskRewardScNotify {
  return { count: 0, reward: undefined };
}

export const DailyTaskRewardScNotify = {
  encode(
    message: DailyTaskRewardScNotify,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.count !== 0) {
      writer.uint32(8).uint32(message.count);
    }
    if (message.reward !== undefined) {
      ItemList.encode(message.reward, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): DailyTaskRewardScNotify {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDailyTaskRewardScNotify();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.count = reader.uint32();
          break;
        case 2:
          message.reward = ItemList.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): DailyTaskRewardScNotify {
    return {
      count: isSet(object.count) ? Number(object.count) : 0,
      reward: isSet(object.reward)
        ? ItemList.fromJSON(object.reward)
        : undefined,
    };
  },

  toJSON(message: DailyTaskRewardScNotify): unknown {
    const obj: any = {};
    message.count !== undefined && (obj.count = Math.round(message.count));
    message.reward !== undefined &&
      (obj.reward = message.reward
        ? ItemList.toJSON(message.reward)
        : undefined);
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<DailyTaskRewardScNotify>, I>>(
    object: I
  ): DailyTaskRewardScNotify {
    const message = createBaseDailyTaskRewardScNotify();
    message.count = object.count ?? 0;
    message.reward =
      object.reward !== undefined && object.reward !== null
        ? ItemList.fromPartial(object.reward)
        : undefined;
    return message;
  },
};

function createBaseMissionGroupWarnScNotify(): MissionGroupWarnScNotify {
  return { groupIdList: [] };
}

export const MissionGroupWarnScNotify = {
  encode(
    message: MissionGroupWarnScNotify,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    writer.uint32(10).fork();
    for (const v of message.groupIdList) {
      writer.uint32(v);
    }
    writer.ldelim();
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): MissionGroupWarnScNotify {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMissionGroupWarnScNotify();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if ((tag & 7) === 2) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.groupIdList.push(reader.uint32());
            }
          } else {
            message.groupIdList.push(reader.uint32());
          }
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): MissionGroupWarnScNotify {
    return {
      groupIdList: Array.isArray(object?.groupIdList)
        ? object.groupIdList.map((e: any) => Number(e))
        : [],
    };
  },

  toJSON(message: MissionGroupWarnScNotify): unknown {
    const obj: any = {};
    if (message.groupIdList) {
      obj.groupIdList = message.groupIdList.map((e) => Math.round(e));
    } else {
      obj.groupIdList = [];
    }
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<MissionGroupWarnScNotify>, I>>(
    object: I
  ): MissionGroupWarnScNotify {
    const message = createBaseMissionGroupWarnScNotify();
    message.groupIdList = object.groupIdList?.map((e) => e) || [];
    return message;
  },
};

function createBaseFinishCosumeItemMissionCsReq(): FinishCosumeItemMissionCsReq {
  return { subMissionId: 0 };
}

export const FinishCosumeItemMissionCsReq = {
  encode(
    message: FinishCosumeItemMissionCsReq,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.subMissionId !== 0) {
      writer.uint32(8).uint32(message.subMissionId);
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): FinishCosumeItemMissionCsReq {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFinishCosumeItemMissionCsReq();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.subMissionId = reader.uint32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): FinishCosumeItemMissionCsReq {
    return {
      subMissionId: isSet(object.subMissionId)
        ? Number(object.subMissionId)
        : 0,
    };
  },

  toJSON(message: FinishCosumeItemMissionCsReq): unknown {
    const obj: any = {};
    message.subMissionId !== undefined &&
      (obj.subMissionId = Math.round(message.subMissionId));
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<FinishCosumeItemMissionCsReq>, I>>(
    object: I
  ): FinishCosumeItemMissionCsReq {
    const message = createBaseFinishCosumeItemMissionCsReq();
    message.subMissionId = object.subMissionId ?? 0;
    return message;
  },
};

function createBaseFinishCosumeItemMissionScRsp(): FinishCosumeItemMissionScRsp {
  return { retcode: 0, subMissionId: 0 };
}

export const FinishCosumeItemMissionScRsp = {
  encode(
    message: FinishCosumeItemMissionScRsp,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.retcode !== 0) {
      writer.uint32(8).uint32(message.retcode);
    }
    if (message.subMissionId !== 0) {
      writer.uint32(16).uint32(message.subMissionId);
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): FinishCosumeItemMissionScRsp {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFinishCosumeItemMissionScRsp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.retcode = reader.uint32();
          break;
        case 2:
          message.subMissionId = reader.uint32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): FinishCosumeItemMissionScRsp {
    return {
      retcode: isSet(object.retcode) ? Number(object.retcode) : 0,
      subMissionId: isSet(object.subMissionId)
        ? Number(object.subMissionId)
        : 0,
    };
  },

  toJSON(message: FinishCosumeItemMissionScRsp): unknown {
    const obj: any = {};
    message.retcode !== undefined &&
      (obj.retcode = Math.round(message.retcode));
    message.subMissionId !== undefined &&
      (obj.subMissionId = Math.round(message.subMissionId));
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<FinishCosumeItemMissionScRsp>, I>>(
    object: I
  ): FinishCosumeItemMissionScRsp {
    const message = createBaseFinishCosumeItemMissionScRsp();
    message.retcode = object.retcode ?? 0;
    message.subMissionId = object.subMissionId ?? 0;
    return message;
  },
};

function createBaseGetMissionEventDataCsReq(): GetMissionEventDataCsReq {
  return {};
}

export const GetMissionEventDataCsReq = {
  encode(
    _: GetMissionEventDataCsReq,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): GetMissionEventDataCsReq {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetMissionEventDataCsReq();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(_: any): GetMissionEventDataCsReq {
    return {};
  },

  toJSON(_: GetMissionEventDataCsReq): unknown {
    const obj: any = {};
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<GetMissionEventDataCsReq>, I>>(
    _: I
  ): GetMissionEventDataCsReq {
    const message = createBaseGetMissionEventDataCsReq();
    return message;
  },
};

function createBaseGetMissionEventDataScRsp(): GetMissionEventDataScRsp {
  return { retcode: 0, missionEventList: [], challengeEventId: 0 };
}

export const GetMissionEventDataScRsp = {
  encode(
    message: GetMissionEventDataScRsp,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.retcode !== 0) {
      writer.uint32(8).uint32(message.retcode);
    }
    for (const v of message.missionEventList) {
      Mission.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    if (message.challengeEventId !== 0) {
      writer.uint32(24).uint32(message.challengeEventId);
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): GetMissionEventDataScRsp {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetMissionEventDataScRsp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.retcode = reader.uint32();
          break;
        case 2:
          message.missionEventList.push(
            Mission.decode(reader, reader.uint32())
          );
          break;
        case 3:
          message.challengeEventId = reader.uint32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): GetMissionEventDataScRsp {
    return {
      retcode: isSet(object.retcode) ? Number(object.retcode) : 0,
      missionEventList: Array.isArray(object?.missionEventList)
        ? object.missionEventList.map((e: any) => Mission.fromJSON(e))
        : [],
      challengeEventId: isSet(object.challengeEventId)
        ? Number(object.challengeEventId)
        : 0,
    };
  },

  toJSON(message: GetMissionEventDataScRsp): unknown {
    const obj: any = {};
    message.retcode !== undefined &&
      (obj.retcode = Math.round(message.retcode));
    if (message.missionEventList) {
      obj.missionEventList = message.missionEventList.map((e) =>
        e ? Mission.toJSON(e) : undefined
      );
    } else {
      obj.missionEventList = [];
    }
    message.challengeEventId !== undefined &&
      (obj.challengeEventId = Math.round(message.challengeEventId));
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<GetMissionEventDataScRsp>, I>>(
    object: I
  ): GetMissionEventDataScRsp {
    const message = createBaseGetMissionEventDataScRsp();
    message.retcode = object.retcode ?? 0;
    message.missionEventList =
      object.missionEventList?.map((e) => Mission.fromPartial(e)) || [];
    message.challengeEventId = object.challengeEventId ?? 0;
    return message;
  },
};

function createBaseMissionEventRewardScNotify(): MissionEventRewardScNotify {
  return { missionEventId: 0, reward: undefined };
}

export const MissionEventRewardScNotify = {
  encode(
    message: MissionEventRewardScNotify,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.missionEventId !== 0) {
      writer.uint32(8).uint32(message.missionEventId);
    }
    if (message.reward !== undefined) {
      ItemList.encode(message.reward, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): MissionEventRewardScNotify {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMissionEventRewardScNotify();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.missionEventId = reader.uint32();
          break;
        case 2:
          message.reward = ItemList.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): MissionEventRewardScNotify {
    return {
      missionEventId: isSet(object.missionEventId)
        ? Number(object.missionEventId)
        : 0,
      reward: isSet(object.reward)
        ? ItemList.fromJSON(object.reward)
        : undefined,
    };
  },

  toJSON(message: MissionEventRewardScNotify): unknown {
    const obj: any = {};
    message.missionEventId !== undefined &&
      (obj.missionEventId = Math.round(message.missionEventId));
    message.reward !== undefined &&
      (obj.reward = message.reward
        ? ItemList.toJSON(message.reward)
        : undefined);
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<MissionEventRewardScNotify>, I>>(
    object: I
  ): MissionEventRewardScNotify {
    const message = createBaseMissionEventRewardScNotify();
    message.missionEventId = object.missionEventId ?? 0;
    message.reward =
      object.reward !== undefined && object.reward !== null
        ? ItemList.fromPartial(object.reward)
        : undefined;
    return message;
  },
};

function createBaseAcceptMissionEventCsReq(): AcceptMissionEventCsReq {
  return { missionEventId: 0 };
}

export const AcceptMissionEventCsReq = {
  encode(
    message: AcceptMissionEventCsReq,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.missionEventId !== 0) {
      writer.uint32(8).uint32(message.missionEventId);
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): AcceptMissionEventCsReq {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAcceptMissionEventCsReq();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.missionEventId = reader.uint32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): AcceptMissionEventCsReq {
    return {
      missionEventId: isSet(object.missionEventId)
        ? Number(object.missionEventId)
        : 0,
    };
  },

  toJSON(message: AcceptMissionEventCsReq): unknown {
    const obj: any = {};
    message.missionEventId !== undefined &&
      (obj.missionEventId = Math.round(message.missionEventId));
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<AcceptMissionEventCsReq>, I>>(
    object: I
  ): AcceptMissionEventCsReq {
    const message = createBaseAcceptMissionEventCsReq();
    message.missionEventId = object.missionEventId ?? 0;
    return message;
  },
};

function createBaseAcceptMissionEventScRsp(): AcceptMissionEventScRsp {
  return { retcode: 0, missionEvent: undefined };
}

export const AcceptMissionEventScRsp = {
  encode(
    message: AcceptMissionEventScRsp,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.retcode !== 0) {
      writer.uint32(8).uint32(message.retcode);
    }
    if (message.missionEvent !== undefined) {
      Mission.encode(message.missionEvent, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): AcceptMissionEventScRsp {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAcceptMissionEventScRsp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.retcode = reader.uint32();
          break;
        case 2:
          message.missionEvent = Mission.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): AcceptMissionEventScRsp {
    return {
      retcode: isSet(object.retcode) ? Number(object.retcode) : 0,
      missionEvent: isSet(object.missionEvent)
        ? Mission.fromJSON(object.missionEvent)
        : undefined,
    };
  },

  toJSON(message: AcceptMissionEventScRsp): unknown {
    const obj: any = {};
    message.retcode !== undefined &&
      (obj.retcode = Math.round(message.retcode));
    message.missionEvent !== undefined &&
      (obj.missionEvent = message.missionEvent
        ? Mission.toJSON(message.missionEvent)
        : undefined);
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<AcceptMissionEventScRsp>, I>>(
    object: I
  ): AcceptMissionEventScRsp {
    const message = createBaseAcceptMissionEventScRsp();
    message.retcode = object.retcode ?? 0;
    message.missionEvent =
      object.missionEvent !== undefined && object.missionEvent !== null
        ? Mission.fromPartial(object.missionEvent)
        : undefined;
    return message;
  },
};

function createBaseGetMissionStatusCsReq(): GetMissionStatusCsReq {
  return {
    mainMissionIdList: [],
    subMissionIdList: [],
    missionEventIdList: [],
  };
}

export const GetMissionStatusCsReq = {
  encode(
    message: GetMissionStatusCsReq,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    writer.uint32(10).fork();
    for (const v of message.mainMissionIdList) {
      writer.uint32(v);
    }
    writer.ldelim();
    writer.uint32(18).fork();
    for (const v of message.subMissionIdList) {
      writer.uint32(v);
    }
    writer.ldelim();
    writer.uint32(26).fork();
    for (const v of message.missionEventIdList) {
      writer.uint32(v);
    }
    writer.ldelim();
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): GetMissionStatusCsReq {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetMissionStatusCsReq();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if ((tag & 7) === 2) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.mainMissionIdList.push(reader.uint32());
            }
          } else {
            message.mainMissionIdList.push(reader.uint32());
          }
          break;
        case 2:
          if ((tag & 7) === 2) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.subMissionIdList.push(reader.uint32());
            }
          } else {
            message.subMissionIdList.push(reader.uint32());
          }
          break;
        case 3:
          if ((tag & 7) === 2) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.missionEventIdList.push(reader.uint32());
            }
          } else {
            message.missionEventIdList.push(reader.uint32());
          }
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): GetMissionStatusCsReq {
    return {
      mainMissionIdList: Array.isArray(object?.mainMissionIdList)
        ? object.mainMissionIdList.map((e: any) => Number(e))
        : [],
      subMissionIdList: Array.isArray(object?.subMissionIdList)
        ? object.subMissionIdList.map((e: any) => Number(e))
        : [],
      missionEventIdList: Array.isArray(object?.missionEventIdList)
        ? object.missionEventIdList.map((e: any) => Number(e))
        : [],
    };
  },

  toJSON(message: GetMissionStatusCsReq): unknown {
    const obj: any = {};
    if (message.mainMissionIdList) {
      obj.mainMissionIdList = message.mainMissionIdList.map((e) =>
        Math.round(e)
      );
    } else {
      obj.mainMissionIdList = [];
    }
    if (message.subMissionIdList) {
      obj.subMissionIdList = message.subMissionIdList.map((e) => Math.round(e));
    } else {
      obj.subMissionIdList = [];
    }
    if (message.missionEventIdList) {
      obj.missionEventIdList = message.missionEventIdList.map((e) =>
        Math.round(e)
      );
    } else {
      obj.missionEventIdList = [];
    }
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<GetMissionStatusCsReq>, I>>(
    object: I
  ): GetMissionStatusCsReq {
    const message = createBaseGetMissionStatusCsReq();
    message.mainMissionIdList = object.mainMissionIdList?.map((e) => e) || [];
    message.subMissionIdList = object.subMissionIdList?.map((e) => e) || [];
    message.missionEventIdList = object.missionEventIdList?.map((e) => e) || [];
    return message;
  },
};

function createBaseGetMissionStatusScRsp(): GetMissionStatusScRsp {
  return {
    retcode: 0,
    finishedMainMissionIdList: [],
    unfinishedMainMissionIdList: [],
    subMissionStatusList: [],
    missionEventStatusList: [],
  };
}

export const GetMissionStatusScRsp = {
  encode(
    message: GetMissionStatusScRsp,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.retcode !== 0) {
      writer.uint32(8).uint32(message.retcode);
    }
    writer.uint32(18).fork();
    for (const v of message.finishedMainMissionIdList) {
      writer.uint32(v);
    }
    writer.ldelim();
    writer.uint32(26).fork();
    for (const v of message.unfinishedMainMissionIdList) {
      writer.uint32(v);
    }
    writer.ldelim();
    for (const v of message.subMissionStatusList) {
      Mission.encode(v!, writer.uint32(34).fork()).ldelim();
    }
    for (const v of message.missionEventStatusList) {
      Mission.encode(v!, writer.uint32(42).fork()).ldelim();
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): GetMissionStatusScRsp {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetMissionStatusScRsp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.retcode = reader.uint32();
          break;
        case 2:
          if ((tag & 7) === 2) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.finishedMainMissionIdList.push(reader.uint32());
            }
          } else {
            message.finishedMainMissionIdList.push(reader.uint32());
          }
          break;
        case 3:
          if ((tag & 7) === 2) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.unfinishedMainMissionIdList.push(reader.uint32());
            }
          } else {
            message.unfinishedMainMissionIdList.push(reader.uint32());
          }
          break;
        case 4:
          message.subMissionStatusList.push(
            Mission.decode(reader, reader.uint32())
          );
          break;
        case 5:
          message.missionEventStatusList.push(
            Mission.decode(reader, reader.uint32())
          );
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): GetMissionStatusScRsp {
    return {
      retcode: isSet(object.retcode) ? Number(object.retcode) : 0,
      finishedMainMissionIdList: Array.isArray(
        object?.finishedMainMissionIdList
      )
        ? object.finishedMainMissionIdList.map((e: any) => Number(e))
        : [],
      unfinishedMainMissionIdList: Array.isArray(
        object?.unfinishedMainMissionIdList
      )
        ? object.unfinishedMainMissionIdList.map((e: any) => Number(e))
        : [],
      subMissionStatusList: Array.isArray(object?.subMissionStatusList)
        ? object.subMissionStatusList.map((e: any) => Mission.fromJSON(e))
        : [],
      missionEventStatusList: Array.isArray(object?.missionEventStatusList)
        ? object.missionEventStatusList.map((e: any) => Mission.fromJSON(e))
        : [],
    };
  },

  toJSON(message: GetMissionStatusScRsp): unknown {
    const obj: any = {};
    message.retcode !== undefined &&
      (obj.retcode = Math.round(message.retcode));
    if (message.finishedMainMissionIdList) {
      obj.finishedMainMissionIdList = message.finishedMainMissionIdList.map(
        (e) => Math.round(e)
      );
    } else {
      obj.finishedMainMissionIdList = [];
    }
    if (message.unfinishedMainMissionIdList) {
      obj.unfinishedMainMissionIdList = message.unfinishedMainMissionIdList.map(
        (e) => Math.round(e)
      );
    } else {
      obj.unfinishedMainMissionIdList = [];
    }
    if (message.subMissionStatusList) {
      obj.subMissionStatusList = message.subMissionStatusList.map((e) =>
        e ? Mission.toJSON(e) : undefined
      );
    } else {
      obj.subMissionStatusList = [];
    }
    if (message.missionEventStatusList) {
      obj.missionEventStatusList = message.missionEventStatusList.map((e) =>
        e ? Mission.toJSON(e) : undefined
      );
    } else {
      obj.missionEventStatusList = [];
    }
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<GetMissionStatusScRsp>, I>>(
    object: I
  ): GetMissionStatusScRsp {
    const message = createBaseGetMissionStatusScRsp();
    message.retcode = object.retcode ?? 0;
    message.finishedMainMissionIdList =
      object.finishedMainMissionIdList?.map((e) => e) || [];
    message.unfinishedMainMissionIdList =
      object.unfinishedMainMissionIdList?.map((e) => e) || [];
    message.subMissionStatusList =
      object.subMissionStatusList?.map((e) => Mission.fromPartial(e)) || [];
    message.missionEventStatusList =
      object.missionEventStatusList?.map((e) => Mission.fromPartial(e)) || [];
    return message;
  },
};

function createBaseInterruptMissionEventCsReq(): InterruptMissionEventCsReq {
  return { missionEventId: 0 };
}

export const InterruptMissionEventCsReq = {
  encode(
    message: InterruptMissionEventCsReq,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.missionEventId !== 0) {
      writer.uint32(8).uint32(message.missionEventId);
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): InterruptMissionEventCsReq {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInterruptMissionEventCsReq();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.missionEventId = reader.uint32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): InterruptMissionEventCsReq {
    return {
      missionEventId: isSet(object.missionEventId)
        ? Number(object.missionEventId)
        : 0,
    };
  },

  toJSON(message: InterruptMissionEventCsReq): unknown {
    const obj: any = {};
    message.missionEventId !== undefined &&
      (obj.missionEventId = Math.round(message.missionEventId));
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<InterruptMissionEventCsReq>, I>>(
    object: I
  ): InterruptMissionEventCsReq {
    const message = createBaseInterruptMissionEventCsReq();
    message.missionEventId = object.missionEventId ?? 0;
    return message;
  },
};

function createBaseInterruptMissionEventScRsp(): InterruptMissionEventScRsp {
  return { retcode: 0, missionEventId: 0 };
}

export const InterruptMissionEventScRsp = {
  encode(
    message: InterruptMissionEventScRsp,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.retcode !== 0) {
      writer.uint32(8).uint32(message.retcode);
    }
    if (message.missionEventId !== 0) {
      writer.uint32(16).uint32(message.missionEventId);
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): InterruptMissionEventScRsp {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInterruptMissionEventScRsp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.retcode = reader.uint32();
          break;
        case 2:
          message.missionEventId = reader.uint32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): InterruptMissionEventScRsp {
    return {
      retcode: isSet(object.retcode) ? Number(object.retcode) : 0,
      missionEventId: isSet(object.missionEventId)
        ? Number(object.missionEventId)
        : 0,
    };
  },

  toJSON(message: InterruptMissionEventScRsp): unknown {
    const obj: any = {};
    message.retcode !== undefined &&
      (obj.retcode = Math.round(message.retcode));
    message.missionEventId !== undefined &&
      (obj.missionEventId = Math.round(message.missionEventId));
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<InterruptMissionEventScRsp>, I>>(
    object: I
  ): InterruptMissionEventScRsp {
    const message = createBaseInterruptMissionEventScRsp();
    message.retcode = object.retcode ?? 0;
    message.missionEventId = object.missionEventId ?? 0;
    return message;
  },
};

function createBaseSetMissionEventProgressCsReq(): SetMissionEventProgressCsReq {
  return { missionEventId: 0, progress: 0 };
}

export const SetMissionEventProgressCsReq = {
  encode(
    message: SetMissionEventProgressCsReq,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.missionEventId !== 0) {
      writer.uint32(8).uint32(message.missionEventId);
    }
    if (message.progress !== 0) {
      writer.uint32(16).uint32(message.progress);
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): SetMissionEventProgressCsReq {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSetMissionEventProgressCsReq();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.missionEventId = reader.uint32();
          break;
        case 2:
          message.progress = reader.uint32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): SetMissionEventProgressCsReq {
    return {
      missionEventId: isSet(object.missionEventId)
        ? Number(object.missionEventId)
        : 0,
      progress: isSet(object.progress) ? Number(object.progress) : 0,
    };
  },

  toJSON(message: SetMissionEventProgressCsReq): unknown {
    const obj: any = {};
    message.missionEventId !== undefined &&
      (obj.missionEventId = Math.round(message.missionEventId));
    message.progress !== undefined &&
      (obj.progress = Math.round(message.progress));
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<SetMissionEventProgressCsReq>, I>>(
    object: I
  ): SetMissionEventProgressCsReq {
    const message = createBaseSetMissionEventProgressCsReq();
    message.missionEventId = object.missionEventId ?? 0;
    message.progress = object.progress ?? 0;
    return message;
  },
};

function createBaseSetMissionEventProgressScRsp(): SetMissionEventProgressScRsp {
  return { retcode: 0 };
}

export const SetMissionEventProgressScRsp = {
  encode(
    message: SetMissionEventProgressScRsp,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.retcode !== 0) {
      writer.uint32(8).uint32(message.retcode);
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): SetMissionEventProgressScRsp {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSetMissionEventProgressScRsp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.retcode = reader.uint32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): SetMissionEventProgressScRsp {
    return {
      retcode: isSet(object.retcode) ? Number(object.retcode) : 0,
    };
  },

  toJSON(message: SetMissionEventProgressScRsp): unknown {
    const obj: any = {};
    message.retcode !== undefined &&
      (obj.retcode = Math.round(message.retcode));
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<SetMissionEventProgressScRsp>, I>>(
    object: I
  ): SetMissionEventProgressScRsp {
    const message = createBaseSetMissionEventProgressScRsp();
    message.retcode = object.retcode ?? 0;
    return message;
  },
};

function createBasePlayerLoginCsReq(): PlayerLoginCsReq {
  return {
    platform: 0,
    cps: "",
    deviceUuid: "",
    deviceInfo: "",
    systemInfo: "",
    clientVersion: "",
    language: 0,
    lastServerPacketId: 0,
    checkSum1: "",
    checkSum2: "",
    signature: "",
    resolution: "",
    loginRandom: 0,
    systemLanguage: "",
    resVersion: 0,
    clientTimeZone: "",
  };
}

export const PlayerLoginCsReq = {
  encode(
    message: PlayerLoginCsReq,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.platform !== 0) {
      writer.uint32(8).int32(message.platform);
    }
    if (message.cps !== "") {
      writer.uint32(18).string(message.cps);
    }
    if (message.deviceUuid !== "") {
      writer.uint32(26).string(message.deviceUuid);
    }
    if (message.deviceInfo !== "") {
      writer.uint32(34).string(message.deviceInfo);
    }
    if (message.systemInfo !== "") {
      writer.uint32(42).string(message.systemInfo);
    }
    if (message.clientVersion !== "") {
      writer.uint32(50).string(message.clientVersion);
    }
    if (message.language !== 0) {
      writer.uint32(56).int32(message.language);
    }
    if (message.lastServerPacketId !== 0) {
      writer.uint32(64).uint32(message.lastServerPacketId);
    }
    if (message.checkSum1 !== "") {
      writer.uint32(74).string(message.checkSum1);
    }
    if (message.checkSum2 !== "") {
      writer.uint32(82).string(message.checkSum2);
    }
    if (message.signature !== "") {
      writer.uint32(90).string(message.signature);
    }
    if (message.resolution !== "") {
      writer.uint32(98).string(message.resolution);
    }
    if (message.loginRandom !== 0) {
      writer.uint32(104).uint64(message.loginRandom);
    }
    if (message.systemLanguage !== "") {
      writer.uint32(114).string(message.systemLanguage);
    }
    if (message.resVersion !== 0) {
      writer.uint32(120).uint32(message.resVersion);
    }
    if (message.clientTimeZone !== "") {
      writer.uint32(130).string(message.clientTimeZone);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): PlayerLoginCsReq {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePlayerLoginCsReq();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.platform = reader.int32() as any;
          break;
        case 2:
          message.cps = reader.string();
          break;
        case 3:
          message.deviceUuid = reader.string();
          break;
        case 4:
          message.deviceInfo = reader.string();
          break;
        case 5:
          message.systemInfo = reader.string();
          break;
        case 6:
          message.clientVersion = reader.string();
          break;
        case 7:
          message.language = reader.int32() as any;
          break;
        case 8:
          message.lastServerPacketId = reader.uint32();
          break;
        case 9:
          message.checkSum1 = reader.string();
          break;
        case 10:
          message.checkSum2 = reader.string();
          break;
        case 11:
          message.signature = reader.string();
          break;
        case 12:
          message.resolution = reader.string();
          break;
        case 13:
          message.loginRandom = longToNumber(reader.uint64() as Long);
          break;
        case 14:
          message.systemLanguage = reader.string();
          break;
        case 15:
          message.resVersion = reader.uint32();
          break;
        case 16:
          message.clientTimeZone = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): PlayerLoginCsReq {
    return {
      platform: isSet(object.platform)
        ? platformTypeFromJSON(object.platform)
        : 0,
      cps: isSet(object.cps) ? String(object.cps) : "",
      deviceUuid: isSet(object.deviceUuid) ? String(object.deviceUuid) : "",
      deviceInfo: isSet(object.deviceInfo) ? String(object.deviceInfo) : "",
      systemInfo: isSet(object.systemInfo) ? String(object.systemInfo) : "",
      clientVersion: isSet(object.clientVersion)
        ? String(object.clientVersion)
        : "",
      language: isSet(object.language)
        ? languageTypeFromJSON(object.language)
        : 0,
      lastServerPacketId: isSet(object.lastServerPacketId)
        ? Number(object.lastServerPacketId)
        : 0,
      checkSum1: isSet(object.checkSum1) ? String(object.checkSum1) : "",
      checkSum2: isSet(object.checkSum2) ? String(object.checkSum2) : "",
      signature: isSet(object.signature) ? String(object.signature) : "",
      resolution: isSet(object.resolution) ? String(object.resolution) : "",
      loginRandom: isSet(object.loginRandom) ? Number(object.loginRandom) : 0,
      systemLanguage: isSet(object.systemLanguage)
        ? String(object.systemLanguage)
        : "",
      resVersion: isSet(object.resVersion) ? Number(object.resVersion) : 0,
      clientTimeZone: isSet(object.clientTimeZone)
        ? String(object.clientTimeZone)
        : "",
    };
  },

  toJSON(message: PlayerLoginCsReq): unknown {
    const obj: any = {};
    message.platform !== undefined &&
      (obj.platform = platformTypeToJSON(message.platform));
    message.cps !== undefined && (obj.cps = message.cps);
    message.deviceUuid !== undefined && (obj.deviceUuid = message.deviceUuid);
    message.deviceInfo !== undefined && (obj.deviceInfo = message.deviceInfo);
    message.systemInfo !== undefined && (obj.systemInfo = message.systemInfo);
    message.clientVersion !== undefined &&
      (obj.clientVersion = message.clientVersion);
    message.language !== undefined &&
      (obj.language = languageTypeToJSON(message.language));
    message.lastServerPacketId !== undefined &&
      (obj.lastServerPacketId = Math.round(message.lastServerPacketId));
    message.checkSum1 !== undefined && (obj.checkSum1 = message.checkSum1);
    message.checkSum2 !== undefined && (obj.checkSum2 = message.checkSum2);
    message.signature !== undefined && (obj.signature = message.signature);
    message.resolution !== undefined && (obj.resolution = message.resolution);
    message.loginRandom !== undefined &&
      (obj.loginRandom = Math.round(message.loginRandom));
    message.systemLanguage !== undefined &&
      (obj.systemLanguage = message.systemLanguage);
    message.resVersion !== undefined &&
      (obj.resVersion = Math.round(message.resVersion));
    message.clientTimeZone !== undefined &&
      (obj.clientTimeZone = message.clientTimeZone);
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<PlayerLoginCsReq>, I>>(
    object: I
  ): PlayerLoginCsReq {
    const message = createBasePlayerLoginCsReq();
    message.platform = object.platform ?? 0;
    message.cps = object.cps ?? "";
    message.deviceUuid = object.deviceUuid ?? "";
    message.deviceInfo = object.deviceInfo ?? "";
    message.systemInfo = object.systemInfo ?? "";
    message.clientVersion = object.clientVersion ?? "";
    message.language = object.language ?? 0;
    message.lastServerPacketId = object.lastServerPacketId ?? 0;
    message.checkSum1 = object.checkSum1 ?? "";
    message.checkSum2 = object.checkSum2 ?? "";
    message.signature = object.signature ?? "";
    message.resolution = object.resolution ?? "";
    message.loginRandom = object.loginRandom ?? 0;
    message.systemLanguage = object.systemLanguage ?? "";
    message.resVersion = object.resVersion ?? 0;
    message.clientTimeZone = object.clientTimeZone ?? "";
    return message;
  },
};

function createBasePlayerLoginScRsp(): PlayerLoginScRsp {
  return {
    retcode: 0,
    isNewPlayer: false,
    basicInfo: undefined,
    serverTimestampMs: 0,
    stamina: 0,
    isRelay: false,
    loginRandom: 0,
    curTimezone: 0,
    bsBinVersion: "",
  };
}

export const PlayerLoginScRsp = {
  encode(
    message: PlayerLoginScRsp,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.retcode !== 0) {
      writer.uint32(8).uint32(message.retcode);
    }
    if (message.isNewPlayer === true) {
      writer.uint32(16).bool(message.isNewPlayer);
    }
    if (message.basicInfo !== undefined) {
      PlayerBasicInfo.encode(
        message.basicInfo,
        writer.uint32(26).fork()
      ).ldelim();
    }
    if (message.serverTimestampMs !== 0) {
      writer.uint32(32).uint64(message.serverTimestampMs);
    }
    if (message.stamina !== 0) {
      writer.uint32(40).uint32(message.stamina);
    }
    if (message.isRelay === true) {
      writer.uint32(48).bool(message.isRelay);
    }
    if (message.loginRandom !== 0) {
      writer.uint32(56).uint64(message.loginRandom);
    }
    if (message.curTimezone !== 0) {
      writer.uint32(64).int32(message.curTimezone);
    }
    if (message.bsBinVersion !== "") {
      writer.uint32(82).string(message.bsBinVersion);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): PlayerLoginScRsp {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePlayerLoginScRsp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.retcode = reader.uint32();
          break;
        case 2:
          message.isNewPlayer = reader.bool();
          break;
        case 3:
          message.basicInfo = PlayerBasicInfo.decode(reader, reader.uint32());
          break;
        case 4:
          message.serverTimestampMs = longToNumber(reader.uint64() as Long);
          break;
        case 5:
          message.stamina = reader.uint32();
          break;
        case 6:
          message.isRelay = reader.bool();
          break;
        case 7:
          message.loginRandom = longToNumber(reader.uint64() as Long);
          break;
        case 8:
          message.curTimezone = reader.int32();
          break;
        case 10:
          message.bsBinVersion = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): PlayerLoginScRsp {
    return {
      retcode: isSet(object.retcode) ? Number(object.retcode) : 0,
      isNewPlayer: isSet(object.isNewPlayer)
        ? Boolean(object.isNewPlayer)
        : false,
      basicInfo: isSet(object.basicInfo)
        ? PlayerBasicInfo.fromJSON(object.basicInfo)
        : undefined,
      serverTimestampMs: isSet(object.serverTimestampMs)
        ? Number(object.serverTimestampMs)
        : 0,
      stamina: isSet(object.stamina) ? Number(object.stamina) : 0,
      isRelay: isSet(object.isRelay) ? Boolean(object.isRelay) : false,
      loginRandom: isSet(object.loginRandom) ? Number(object.loginRandom) : 0,
      curTimezone: isSet(object.curTimezone) ? Number(object.curTimezone) : 0,
      bsBinVersion: isSet(object.bsBinVersion)
        ? String(object.bsBinVersion)
        : "",
    };
  },

  toJSON(message: PlayerLoginScRsp): unknown {
    const obj: any = {};
    message.retcode !== undefined &&
      (obj.retcode = Math.round(message.retcode));
    message.isNewPlayer !== undefined &&
      (obj.isNewPlayer = message.isNewPlayer);
    message.basicInfo !== undefined &&
      (obj.basicInfo = message.basicInfo
        ? PlayerBasicInfo.toJSON(message.basicInfo)
        : undefined);
    message.serverTimestampMs !== undefined &&
      (obj.serverTimestampMs = Math.round(message.serverTimestampMs));
    message.stamina !== undefined &&
      (obj.stamina = Math.round(message.stamina));
    message.isRelay !== undefined && (obj.isRelay = message.isRelay);
    message.loginRandom !== undefined &&
      (obj.loginRandom = Math.round(message.loginRandom));
    message.curTimezone !== undefined &&
      (obj.curTimezone = Math.round(message.curTimezone));
    message.bsBinVersion !== undefined &&
      (obj.bsBinVersion = message.bsBinVersion);
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<PlayerLoginScRsp>, I>>(
    object: I
  ): PlayerLoginScRsp {
    const message = createBasePlayerLoginScRsp();
    message.retcode = object.retcode ?? 0;
    message.isNewPlayer = object.isNewPlayer ?? false;
    message.basicInfo =
      object.basicInfo !== undefined && object.basicInfo !== null
        ? PlayerBasicInfo.fromPartial(object.basicInfo)
        : undefined;
    message.serverTimestampMs = object.serverTimestampMs ?? 0;
    message.stamina = object.stamina ?? 0;
    message.isRelay = object.isRelay ?? false;
    message.loginRandom = object.loginRandom ?? 0;
    message.curTimezone = object.curTimezone ?? 0;
    message.bsBinVersion = object.bsBinVersion ?? "";
    return message;
  },
};

function createBasePlayerLogoutCsReq(): PlayerLogoutCsReq {
  return {};
}

export const PlayerLogoutCsReq = {
  encode(
    _: PlayerLogoutCsReq,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): PlayerLogoutCsReq {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePlayerLogoutCsReq();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(_: any): PlayerLogoutCsReq {
    return {};
  },

  toJSON(_: PlayerLogoutCsReq): unknown {
    const obj: any = {};
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<PlayerLogoutCsReq>, I>>(
    _: I
  ): PlayerLogoutCsReq {
    const message = createBasePlayerLogoutCsReq();
    return message;
  },
};

function createBasePlayerGetTokenCsReq(): PlayerGetTokenCsReq {
  return { channelId: 0, accountUid: "", token: "", uid: 0, device: "" };
}

export const PlayerGetTokenCsReq = {
  encode(
    message: PlayerGetTokenCsReq,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.channelId !== 0) {
      writer.uint32(8).uint32(message.channelId);
    }
    if (message.accountUid !== "") {
      writer.uint32(18).string(message.accountUid);
    }
    if (message.token !== "") {
      writer.uint32(26).string(message.token);
    }
    if (message.uid !== 0) {
      writer.uint32(32).uint32(message.uid);
    }
    if (message.device !== "") {
      writer.uint32(42).string(message.device);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): PlayerGetTokenCsReq {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePlayerGetTokenCsReq();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.channelId = reader.uint32();
          break;
        case 2:
          message.accountUid = reader.string();
          break;
        case 3:
          message.token = reader.string();
          break;
        case 4:
          message.uid = reader.uint32();
          break;
        case 5:
          message.device = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): PlayerGetTokenCsReq {
    return {
      channelId: isSet(object.channelId) ? Number(object.channelId) : 0,
      accountUid: isSet(object.accountUid) ? String(object.accountUid) : "",
      token: isSet(object.token) ? String(object.token) : "",
      uid: isSet(object.uid) ? Number(object.uid) : 0,
      device: isSet(object.device) ? String(object.device) : "",
    };
  },

  toJSON(message: PlayerGetTokenCsReq): unknown {
    const obj: any = {};
    message.channelId !== undefined &&
      (obj.channelId = Math.round(message.channelId));
    message.accountUid !== undefined && (obj.accountUid = message.accountUid);
    message.token !== undefined && (obj.token = message.token);
    message.uid !== undefined && (obj.uid = Math.round(message.uid));
    message.device !== undefined && (obj.device = message.device);
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<PlayerGetTokenCsReq>, I>>(
    object: I
  ): PlayerGetTokenCsReq {
    const message = createBasePlayerGetTokenCsReq();
    message.channelId = object.channelId ?? 0;
    message.accountUid = object.accountUid ?? "";
    message.token = object.token ?? "";
    message.uid = object.uid ?? 0;
    message.device = object.device ?? "";
    return message;
  },
};

function createBasePlayerGetTokenScRsp(): PlayerGetTokenScRsp {
  return {
    retcode: 0,
    uid: 0,
    blackInfo: undefined,
    msg: "",
    secretKeySeed: 0,
  };
}

export const PlayerGetTokenScRsp = {
  encode(
    message: PlayerGetTokenScRsp,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.retcode !== 0) {
      writer.uint32(8).uint32(message.retcode);
    }
    if (message.uid !== 0) {
      writer.uint32(16).uint32(message.uid);
    }
    if (message.blackInfo !== undefined) {
      BlackInfo.encode(message.blackInfo, writer.uint32(26).fork()).ldelim();
    }
    if (message.msg !== "") {
      writer.uint32(34).string(message.msg);
    }
    if (message.secretKeySeed !== 0) {
      writer.uint32(40).uint64(message.secretKeySeed);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): PlayerGetTokenScRsp {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePlayerGetTokenScRsp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.retcode = reader.uint32();
          break;
        case 2:
          message.uid = reader.uint32();
          break;
        case 3:
          message.blackInfo = BlackInfo.decode(reader, reader.uint32());
          break;
        case 4:
          message.msg = reader.string();
          break;
        case 5:
          message.secretKeySeed = longToNumber(reader.uint64() as Long);
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): PlayerGetTokenScRsp {
    return {
      retcode: isSet(object.retcode) ? Number(object.retcode) : 0,
      uid: isSet(object.uid) ? Number(object.uid) : 0,
      blackInfo: isSet(object.blackInfo)
        ? BlackInfo.fromJSON(object.blackInfo)
        : undefined,
      msg: isSet(object.msg) ? String(object.msg) : "",
      secretKeySeed: isSet(object.secretKeySeed)
        ? Number(object.secretKeySeed)
        : 0,
    };
  },

  toJSON(message: PlayerGetTokenScRsp): unknown {
    const obj: any = {};
    message.retcode !== undefined &&
      (obj.retcode = Math.round(message.retcode));
    message.uid !== undefined && (obj.uid = Math.round(message.uid));
    message.blackInfo !== undefined &&
      (obj.blackInfo = message.blackInfo
        ? BlackInfo.toJSON(message.blackInfo)
        : undefined);
    message.msg !== undefined && (obj.msg = message.msg);
    message.secretKeySeed !== undefined &&
      (obj.secretKeySeed = Math.round(message.secretKeySeed));
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<PlayerGetTokenScRsp>, I>>(
    object: I
  ): PlayerGetTokenScRsp {
    const message = createBasePlayerGetTokenScRsp();
    message.retcode = object.retcode ?? 0;
    message.uid = object.uid ?? 0;
    message.blackInfo =
      object.blackInfo !== undefined && object.blackInfo !== null
        ? BlackInfo.fromPartial(object.blackInfo)
        : undefined;
    message.msg = object.msg ?? "";
    message.secretKeySeed = object.secretKeySeed ?? 0;
    return message;
  },
};

function createBasePlayerKeepAliveNotify(): PlayerKeepAliveNotify {
  return { data: undefined };
}

export const PlayerKeepAliveNotify = {
  encode(
    message: PlayerKeepAliveNotify,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.data !== undefined) {
      ClientUploadData.encode(message.data, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): PlayerKeepAliveNotify {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePlayerKeepAliveNotify();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.data = ClientUploadData.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): PlayerKeepAliveNotify {
    return {
      data: isSet(object.data)
        ? ClientUploadData.fromJSON(object.data)
        : undefined,
    };
  },

  toJSON(message: PlayerKeepAliveNotify): unknown {
    const obj: any = {};
    message.data !== undefined &&
      (obj.data = message.data
        ? ClientUploadData.toJSON(message.data)
        : undefined);
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<PlayerKeepAliveNotify>, I>>(
    object: I
  ): PlayerKeepAliveNotify {
    const message = createBasePlayerKeepAliveNotify();
    message.data =
      object.data !== undefined && object.data !== null
        ? ClientUploadData.fromPartial(object.data)
        : undefined;
    return message;
  },
};

function createBaseGmTalkScNotify(): GmTalkScNotify {
  return { msg: "" };
}

export const GmTalkScNotify = {
  encode(
    message: GmTalkScNotify,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.msg !== "") {
      writer.uint32(10).string(message.msg);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GmTalkScNotify {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGmTalkScNotify();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.msg = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): GmTalkScNotify {
    return {
      msg: isSet(object.msg) ? String(object.msg) : "",
    };
  },

  toJSON(message: GmTalkScNotify): unknown {
    const obj: any = {};
    message.msg !== undefined && (obj.msg = message.msg);
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<GmTalkScNotify>, I>>(
    object: I
  ): GmTalkScNotify {
    const message = createBaseGmTalkScNotify();
    message.msg = object.msg ?? "";
    return message;
  },
};

function createBasePlayerKickOutScNotify(): PlayerKickOutScNotify {
  return { kickType: 0, blackInfo: undefined };
}

export const PlayerKickOutScNotify = {
  encode(
    message: PlayerKickOutScNotify,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.kickType !== 0) {
      writer.uint32(8).int32(message.kickType);
    }
    if (message.blackInfo !== undefined) {
      BlackInfo.encode(message.blackInfo, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): PlayerKickOutScNotify {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePlayerKickOutScNotify();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.kickType = reader.int32() as any;
          break;
        case 2:
          message.blackInfo = BlackInfo.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): PlayerKickOutScNotify {
    return {
      kickType: isSet(object.kickType)
        ? playerKickOutScNotify_KickTypeFromJSON(object.kickType)
        : 0,
      blackInfo: isSet(object.blackInfo)
        ? BlackInfo.fromJSON(object.blackInfo)
        : undefined,
    };
  },

  toJSON(message: PlayerKickOutScNotify): unknown {
    const obj: any = {};
    message.kickType !== undefined &&
      (obj.kickType = playerKickOutScNotify_KickTypeToJSON(message.kickType));
    message.blackInfo !== undefined &&
      (obj.blackInfo = message.blackInfo
        ? BlackInfo.toJSON(message.blackInfo)
        : undefined);
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<PlayerKickOutScNotify>, I>>(
    object: I
  ): PlayerKickOutScNotify {
    const message = createBasePlayerKickOutScNotify();
    message.kickType = object.kickType ?? 0;
    message.blackInfo =
      object.blackInfo !== undefined && object.blackInfo !== null
        ? BlackInfo.fromPartial(object.blackInfo)
        : undefined;
    return message;
  },
};

function createBaseGmTalkCsReq(): GmTalkCsReq {
  return { msg: "" };
}

export const GmTalkCsReq = {
  encode(
    message: GmTalkCsReq,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.msg !== "") {
      writer.uint32(10).string(message.msg);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GmTalkCsReq {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGmTalkCsReq();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.msg = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): GmTalkCsReq {
    return {
      msg: isSet(object.msg) ? String(object.msg) : "",
    };
  },

  toJSON(message: GmTalkCsReq): unknown {
    const obj: any = {};
    message.msg !== undefined && (obj.msg = message.msg);
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<GmTalkCsReq>, I>>(
    object: I
  ): GmTalkCsReq {
    const message = createBaseGmTalkCsReq();
    message.msg = object.msg ?? "";
    return message;
  },
};

function createBaseGmTalkScRsp(): GmTalkScRsp {
  return { retcode: 0, retmsg: "" };
}

export const GmTalkScRsp = {
  encode(
    message: GmTalkScRsp,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.retcode !== 0) {
      writer.uint32(8).uint32(message.retcode);
    }
    if (message.retmsg !== "") {
      writer.uint32(18).string(message.retmsg);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GmTalkScRsp {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGmTalkScRsp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.retcode = reader.uint32();
          break;
        case 2:
          message.retmsg = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): GmTalkScRsp {
    return {
      retcode: isSet(object.retcode) ? Number(object.retcode) : 0,
      retmsg: isSet(object.retmsg) ? String(object.retmsg) : "",
    };
  },

  toJSON(message: GmTalkScRsp): unknown {
    const obj: any = {};
    message.retcode !== undefined &&
      (obj.retcode = Math.round(message.retcode));
    message.retmsg !== undefined && (obj.retmsg = message.retmsg);
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<GmTalkScRsp>, I>>(
    object: I
  ): GmTalkScRsp {
    const message = createBaseGmTalkScRsp();
    message.retcode = object.retcode ?? 0;
    message.retmsg = object.retmsg ?? "";
    return message;
  },
};

function createBaseGetBasicInfoCsReq(): GetBasicInfoCsReq {
  return {};
}

export const GetBasicInfoCsReq = {
  encode(
    _: GetBasicInfoCsReq,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetBasicInfoCsReq {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetBasicInfoCsReq();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(_: any): GetBasicInfoCsReq {
    return {};
  },

  toJSON(_: GetBasicInfoCsReq): unknown {
    const obj: any = {};
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<GetBasicInfoCsReq>, I>>(
    _: I
  ): GetBasicInfoCsReq {
    const message = createBaseGetBasicInfoCsReq();
    return message;
  },
};

function createBaseGetBasicInfoScRsp(): GetBasicInfoScRsp {
  return {
    retcode: 0,
    nextRecoverTime: 0,
    exchangeTimes: 0,
    weekCocoonFinishedCount: 0,
    curDay: 0,
  };
}

export const GetBasicInfoScRsp = {
  encode(
    message: GetBasicInfoScRsp,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.retcode !== 0) {
      writer.uint32(8).uint32(message.retcode);
    }
    if (message.nextRecoverTime !== 0) {
      writer.uint32(16).uint32(message.nextRecoverTime);
    }
    if (message.exchangeTimes !== 0) {
      writer.uint32(24).uint32(message.exchangeTimes);
    }
    if (message.weekCocoonFinishedCount !== 0) {
      writer.uint32(32).uint32(message.weekCocoonFinishedCount);
    }
    if (message.curDay !== 0) {
      writer.uint32(40).uint32(message.curDay);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetBasicInfoScRsp {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetBasicInfoScRsp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.retcode = reader.uint32();
          break;
        case 2:
          message.nextRecoverTime = reader.uint32();
          break;
        case 3:
          message.exchangeTimes = reader.uint32();
          break;
        case 4:
          message.weekCocoonFinishedCount = reader.uint32();
          break;
        case 5:
          message.curDay = reader.uint32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): GetBasicInfoScRsp {
    return {
      retcode: isSet(object.retcode) ? Number(object.retcode) : 0,
      nextRecoverTime: isSet(object.nextRecoverTime)
        ? Number(object.nextRecoverTime)
        : 0,
      exchangeTimes: isSet(object.exchangeTimes)
        ? Number(object.exchangeTimes)
        : 0,
      weekCocoonFinishedCount: isSet(object.weekCocoonFinishedCount)
        ? Number(object.weekCocoonFinishedCount)
        : 0,
      curDay: isSet(object.curDay) ? Number(object.curDay) : 0,
    };
  },

  toJSON(message: GetBasicInfoScRsp): unknown {
    const obj: any = {};
    message.retcode !== undefined &&
      (obj.retcode = Math.round(message.retcode));
    message.nextRecoverTime !== undefined &&
      (obj.nextRecoverTime = Math.round(message.nextRecoverTime));
    message.exchangeTimes !== undefined &&
      (obj.exchangeTimes = Math.round(message.exchangeTimes));
    message.weekCocoonFinishedCount !== undefined &&
      (obj.weekCocoonFinishedCount = Math.round(
        message.weekCocoonFinishedCount
      ));
    message.curDay !== undefined && (obj.curDay = Math.round(message.curDay));
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<GetBasicInfoScRsp>, I>>(
    object: I
  ): GetBasicInfoScRsp {
    const message = createBaseGetBasicInfoScRsp();
    message.retcode = object.retcode ?? 0;
    message.nextRecoverTime = object.nextRecoverTime ?? 0;
    message.exchangeTimes = object.exchangeTimes ?? 0;
    message.weekCocoonFinishedCount = object.weekCocoonFinishedCount ?? 0;
    message.curDay = object.curDay ?? 0;
    return message;
  },
};

function createBaseExchangeStaminaCsReq(): ExchangeStaminaCsReq {
  return {};
}

export const ExchangeStaminaCsReq = {
  encode(
    _: ExchangeStaminaCsReq,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): ExchangeStaminaCsReq {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExchangeStaminaCsReq();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(_: any): ExchangeStaminaCsReq {
    return {};
  },

  toJSON(_: ExchangeStaminaCsReq): unknown {
    const obj: any = {};
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<ExchangeStaminaCsReq>, I>>(
    _: I
  ): ExchangeStaminaCsReq {
    const message = createBaseExchangeStaminaCsReq();
    return message;
  },
};

function createBaseExchangeStaminaScRsp(): ExchangeStaminaScRsp {
  return {
    retcode: 0,
    staminaAdd: 0,
    itemCostList: [],
    lastRecoverTime: 0,
    exchangeTimes: 0,
  };
}

export const ExchangeStaminaScRsp = {
  encode(
    message: ExchangeStaminaScRsp,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.retcode !== 0) {
      writer.uint32(8).uint32(message.retcode);
    }
    if (message.staminaAdd !== 0) {
      writer.uint32(16).uint32(message.staminaAdd);
    }
    for (const v of message.itemCostList) {
      ItemCost.encode(v!, writer.uint32(26).fork()).ldelim();
    }
    if (message.lastRecoverTime !== 0) {
      writer.uint32(32).uint32(message.lastRecoverTime);
    }
    if (message.exchangeTimes !== 0) {
      writer.uint32(40).uint32(message.exchangeTimes);
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): ExchangeStaminaScRsp {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExchangeStaminaScRsp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.retcode = reader.uint32();
          break;
        case 2:
          message.staminaAdd = reader.uint32();
          break;
        case 3:
          message.itemCostList.push(ItemCost.decode(reader, reader.uint32()));
          break;
        case 4:
          message.lastRecoverTime = reader.uint32();
          break;
        case 5:
          message.exchangeTimes = reader.uint32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): ExchangeStaminaScRsp {
    return {
      retcode: isSet(object.retcode) ? Number(object.retcode) : 0,
      staminaAdd: isSet(object.staminaAdd) ? Number(object.staminaAdd) : 0,
      itemCostList: Array.isArray(object?.itemCostList)
        ? object.itemCostList.map((e: any) => ItemCost.fromJSON(e))
        : [],
      lastRecoverTime: isSet(object.lastRecoverTime)
        ? Number(object.lastRecoverTime)
        : 0,
      exchangeTimes: isSet(object.exchangeTimes)
        ? Number(object.exchangeTimes)
        : 0,
    };
  },

  toJSON(message: ExchangeStaminaScRsp): unknown {
    const obj: any = {};
    message.retcode !== undefined &&
      (obj.retcode = Math.round(message.retcode));
    message.staminaAdd !== undefined &&
      (obj.staminaAdd = Math.round(message.staminaAdd));
    if (message.itemCostList) {
      obj.itemCostList = message.itemCostList.map((e) =>
        e ? ItemCost.toJSON(e) : undefined
      );
    } else {
      obj.itemCostList = [];
    }
    message.lastRecoverTime !== undefined &&
      (obj.lastRecoverTime = Math.round(message.lastRecoverTime));
    message.exchangeTimes !== undefined &&
      (obj.exchangeTimes = Math.round(message.exchangeTimes));
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<ExchangeStaminaScRsp>, I>>(
    object: I
  ): ExchangeStaminaScRsp {
    const message = createBaseExchangeStaminaScRsp();
    message.retcode = object.retcode ?? 0;
    message.staminaAdd = object.staminaAdd ?? 0;
    message.itemCostList =
      object.itemCostList?.map((e) => ItemCost.fromPartial(e)) || [];
    message.lastRecoverTime = object.lastRecoverTime ?? 0;
    message.exchangeTimes = object.exchangeTimes ?? 0;
    return message;
  },
};

function createBaseGetAuthkeyCsReq(): GetAuthkeyCsReq {
  return { authAppid: "", signType: 0, authkeyVer: 0 };
}

export const GetAuthkeyCsReq = {
  encode(
    message: GetAuthkeyCsReq,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.authAppid !== "") {
      writer.uint32(10).string(message.authAppid);
    }
    if (message.signType !== 0) {
      writer.uint32(16).uint32(message.signType);
    }
    if (message.authkeyVer !== 0) {
      writer.uint32(24).uint32(message.authkeyVer);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetAuthkeyCsReq {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetAuthkeyCsReq();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.authAppid = reader.string();
          break;
        case 2:
          message.signType = reader.uint32();
          break;
        case 3:
          message.authkeyVer = reader.uint32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): GetAuthkeyCsReq {
    return {
      authAppid: isSet(object.authAppid) ? String(object.authAppid) : "",
      signType: isSet(object.signType) ? Number(object.signType) : 0,
      authkeyVer: isSet(object.authkeyVer) ? Number(object.authkeyVer) : 0,
    };
  },

  toJSON(message: GetAuthkeyCsReq): unknown {
    const obj: any = {};
    message.authAppid !== undefined && (obj.authAppid = message.authAppid);
    message.signType !== undefined &&
      (obj.signType = Math.round(message.signType));
    message.authkeyVer !== undefined &&
      (obj.authkeyVer = Math.round(message.authkeyVer));
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<GetAuthkeyCsReq>, I>>(
    object: I
  ): GetAuthkeyCsReq {
    const message = createBaseGetAuthkeyCsReq();
    message.authAppid = object.authAppid ?? "";
    message.signType = object.signType ?? 0;
    message.authkeyVer = object.authkeyVer ?? 0;
    return message;
  },
};

function createBaseGetAuthkeyScRsp(): GetAuthkeyScRsp {
  return { retcode: 0, authkey: "", authAppid: "", signType: 0, authkeyVer: 0 };
}

export const GetAuthkeyScRsp = {
  encode(
    message: GetAuthkeyScRsp,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.retcode !== 0) {
      writer.uint32(8).uint32(message.retcode);
    }
    if (message.authkey !== "") {
      writer.uint32(18).string(message.authkey);
    }
    if (message.authAppid !== "") {
      writer.uint32(26).string(message.authAppid);
    }
    if (message.signType !== 0) {
      writer.uint32(32).uint32(message.signType);
    }
    if (message.authkeyVer !== 0) {
      writer.uint32(40).uint32(message.authkeyVer);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetAuthkeyScRsp {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetAuthkeyScRsp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.retcode = reader.uint32();
          break;
        case 2:
          message.authkey = reader.string();
          break;
        case 3:
          message.authAppid = reader.string();
          break;
        case 4:
          message.signType = reader.uint32();
          break;
        case 5:
          message.authkeyVer = reader.uint32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): GetAuthkeyScRsp {
    return {
      retcode: isSet(object.retcode) ? Number(object.retcode) : 0,
      authkey: isSet(object.authkey) ? String(object.authkey) : "",
      authAppid: isSet(object.authAppid) ? String(object.authAppid) : "",
      signType: isSet(object.signType) ? Number(object.signType) : 0,
      authkeyVer: isSet(object.authkeyVer) ? Number(object.authkeyVer) : 0,
    };
  },

  toJSON(message: GetAuthkeyScRsp): unknown {
    const obj: any = {};
    message.retcode !== undefined &&
      (obj.retcode = Math.round(message.retcode));
    message.authkey !== undefined && (obj.authkey = message.authkey);
    message.authAppid !== undefined && (obj.authAppid = message.authAppid);
    message.signType !== undefined &&
      (obj.signType = Math.round(message.signType));
    message.authkeyVer !== undefined &&
      (obj.authkeyVer = Math.round(message.authkeyVer));
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<GetAuthkeyScRsp>, I>>(
    object: I
  ): GetAuthkeyScRsp {
    const message = createBaseGetAuthkeyScRsp();
    message.retcode = object.retcode ?? 0;
    message.authkey = object.authkey ?? "";
    message.authAppid = object.authAppid ?? "";
    message.signType = object.signType ?? 0;
    message.authkeyVer = object.authkeyVer ?? 0;
    return message;
  },
};

function createBaseRegionStopScNotify(): RegionStopScNotify {
  return { stopBeginTime: 0, stopEndTime: 0 };
}

export const RegionStopScNotify = {
  encode(
    message: RegionStopScNotify,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.stopBeginTime !== 0) {
      writer.uint32(8).uint32(message.stopBeginTime);
    }
    if (message.stopEndTime !== 0) {
      writer.uint32(16).uint32(message.stopEndTime);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): RegionStopScNotify {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRegionStopScNotify();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.stopBeginTime = reader.uint32();
          break;
        case 2:
          message.stopEndTime = reader.uint32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): RegionStopScNotify {
    return {
      stopBeginTime: isSet(object.stopBeginTime)
        ? Number(object.stopBeginTime)
        : 0,
      stopEndTime: isSet(object.stopEndTime) ? Number(object.stopEndTime) : 0,
    };
  },

  toJSON(message: RegionStopScNotify): unknown {
    const obj: any = {};
    message.stopBeginTime !== undefined &&
      (obj.stopBeginTime = Math.round(message.stopBeginTime));
    message.stopEndTime !== undefined &&
      (obj.stopEndTime = Math.round(message.stopEndTime));
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<RegionStopScNotify>, I>>(
    object: I
  ): RegionStopScNotify {
    const message = createBaseRegionStopScNotify();
    message.stopBeginTime = object.stopBeginTime ?? 0;
    message.stopEndTime = object.stopEndTime ?? 0;
    return message;
  },
};

function createBaseAntiAddictScNotify(): AntiAddictScNotify {
  return { msgType: 0, msg: "", level: "" };
}

export const AntiAddictScNotify = {
  encode(
    message: AntiAddictScNotify,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.msgType !== 0) {
      writer.uint32(8).uint32(message.msgType);
    }
    if (message.msg !== "") {
      writer.uint32(18).string(message.msg);
    }
    if (message.level !== "") {
      writer.uint32(26).string(message.level);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): AntiAddictScNotify {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAntiAddictScNotify();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.msgType = reader.uint32();
          break;
        case 2:
          message.msg = reader.string();
          break;
        case 3:
          message.level = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): AntiAddictScNotify {
    return {
      msgType: isSet(object.msgType) ? Number(object.msgType) : 0,
      msg: isSet(object.msg) ? String(object.msg) : "",
      level: isSet(object.level) ? String(object.level) : "",
    };
  },

  toJSON(message: AntiAddictScNotify): unknown {
    const obj: any = {};
    message.msgType !== undefined &&
      (obj.msgType = Math.round(message.msgType));
    message.msg !== undefined && (obj.msg = message.msg);
    message.level !== undefined && (obj.level = message.level);
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<AntiAddictScNotify>, I>>(
    object: I
  ): AntiAddictScNotify {
    const message = createBaseAntiAddictScNotify();
    message.msgType = object.msgType ?? 0;
    message.msg = object.msg ?? "";
    message.level = object.level ?? "";
    return message;
  },
};

function createBaseSetNicknameCsReq(): SetNicknameCsReq {
  return { nickname: "", isModify: false };
}

export const SetNicknameCsReq = {
  encode(
    message: SetNicknameCsReq,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.nickname !== "") {
      writer.uint32(10).string(message.nickname);
    }
    if (message.isModify === true) {
      writer.uint32(16).bool(message.isModify);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SetNicknameCsReq {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSetNicknameCsReq();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.nickname = reader.string();
          break;
        case 2:
          message.isModify = reader.bool();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): SetNicknameCsReq {
    return {
      nickname: isSet(object.nickname) ? String(object.nickname) : "",
      isModify: isSet(object.isModify) ? Boolean(object.isModify) : false,
    };
  },

  toJSON(message: SetNicknameCsReq): unknown {
    const obj: any = {};
    message.nickname !== undefined && (obj.nickname = message.nickname);
    message.isModify !== undefined && (obj.isModify = message.isModify);
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<SetNicknameCsReq>, I>>(
    object: I
  ): SetNicknameCsReq {
    const message = createBaseSetNicknameCsReq();
    message.nickname = object.nickname ?? "";
    message.isModify = object.isModify ?? false;
    return message;
  },
};

function createBaseSetNicknameScRsp(): SetNicknameScRsp {
  return { retcode: 0, isModify: false };
}

export const SetNicknameScRsp = {
  encode(
    message: SetNicknameScRsp,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.retcode !== 0) {
      writer.uint32(8).uint32(message.retcode);
    }
    if (message.isModify === true) {
      writer.uint32(16).bool(message.isModify);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SetNicknameScRsp {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSetNicknameScRsp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.retcode = reader.uint32();
          break;
        case 2:
          message.isModify = reader.bool();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): SetNicknameScRsp {
    return {
      retcode: isSet(object.retcode) ? Number(object.retcode) : 0,
      isModify: isSet(object.isModify) ? Boolean(object.isModify) : false,
    };
  },

  toJSON(message: SetNicknameScRsp): unknown {
    const obj: any = {};
    message.retcode !== undefined &&
      (obj.retcode = Math.round(message.retcode));
    message.isModify !== undefined && (obj.isModify = message.isModify);
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<SetNicknameScRsp>, I>>(
    object: I
  ): SetNicknameScRsp {
    const message = createBaseSetNicknameScRsp();
    message.retcode = object.retcode ?? 0;
    message.isModify = object.isModify ?? false;
    return message;
  },
};

function createBaseGetLevelRewardTakenListCsReq(): GetLevelRewardTakenListCsReq {
  return {};
}

export const GetLevelRewardTakenListCsReq = {
  encode(
    _: GetLevelRewardTakenListCsReq,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): GetLevelRewardTakenListCsReq {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetLevelRewardTakenListCsReq();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(_: any): GetLevelRewardTakenListCsReq {
    return {};
  },

  toJSON(_: GetLevelRewardTakenListCsReq): unknown {
    const obj: any = {};
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<GetLevelRewardTakenListCsReq>, I>>(
    _: I
  ): GetLevelRewardTakenListCsReq {
    const message = createBaseGetLevelRewardTakenListCsReq();
    return message;
  },
};

function createBaseGetLevelRewardTakenListScRsp(): GetLevelRewardTakenListScRsp {
  return { retcode: 0, takenLevelList: [] };
}

export const GetLevelRewardTakenListScRsp = {
  encode(
    message: GetLevelRewardTakenListScRsp,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.retcode !== 0) {
      writer.uint32(8).uint32(message.retcode);
    }
    writer.uint32(18).fork();
    for (const v of message.takenLevelList) {
      writer.uint32(v);
    }
    writer.ldelim();
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): GetLevelRewardTakenListScRsp {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetLevelRewardTakenListScRsp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.retcode = reader.uint32();
          break;
        case 2:
          if ((tag & 7) === 2) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.takenLevelList.push(reader.uint32());
            }
          } else {
            message.takenLevelList.push(reader.uint32());
          }
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): GetLevelRewardTakenListScRsp {
    return {
      retcode: isSet(object.retcode) ? Number(object.retcode) : 0,
      takenLevelList: Array.isArray(object?.takenLevelList)
        ? object.takenLevelList.map((e: any) => Number(e))
        : [],
    };
  },

  toJSON(message: GetLevelRewardTakenListScRsp): unknown {
    const obj: any = {};
    message.retcode !== undefined &&
      (obj.retcode = Math.round(message.retcode));
    if (message.takenLevelList) {
      obj.takenLevelList = message.takenLevelList.map((e) => Math.round(e));
    } else {
      obj.takenLevelList = [];
    }
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<GetLevelRewardTakenListScRsp>, I>>(
    object: I
  ): GetLevelRewardTakenListScRsp {
    const message = createBaseGetLevelRewardTakenListScRsp();
    message.retcode = object.retcode ?? 0;
    message.takenLevelList = object.takenLevelList?.map((e) => e) || [];
    return message;
  },
};

function createBaseGetLevelRewardCsReq(): GetLevelRewardCsReq {
  return { level: 0 };
}

export const GetLevelRewardCsReq = {
  encode(
    message: GetLevelRewardCsReq,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.level !== 0) {
      writer.uint32(8).uint32(message.level);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetLevelRewardCsReq {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetLevelRewardCsReq();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.level = reader.uint32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): GetLevelRewardCsReq {
    return {
      level: isSet(object.level) ? Number(object.level) : 0,
    };
  },

  toJSON(message: GetLevelRewardCsReq): unknown {
    const obj: any = {};
    message.level !== undefined && (obj.level = Math.round(message.level));
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<GetLevelRewardCsReq>, I>>(
    object: I
  ): GetLevelRewardCsReq {
    const message = createBaseGetLevelRewardCsReq();
    message.level = object.level ?? 0;
    return message;
  },
};

function createBaseGetLevelRewardScRsp(): GetLevelRewardScRsp {
  return { retcode: 0, reward: undefined };
}

export const GetLevelRewardScRsp = {
  encode(
    message: GetLevelRewardScRsp,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.retcode !== 0) {
      writer.uint32(8).uint32(message.retcode);
    }
    if (message.reward !== undefined) {
      ItemList.encode(message.reward, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetLevelRewardScRsp {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetLevelRewardScRsp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.retcode = reader.uint32();
          break;
        case 2:
          message.reward = ItemList.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): GetLevelRewardScRsp {
    return {
      retcode: isSet(object.retcode) ? Number(object.retcode) : 0,
      reward: isSet(object.reward)
        ? ItemList.fromJSON(object.reward)
        : undefined,
    };
  },

  toJSON(message: GetLevelRewardScRsp): unknown {
    const obj: any = {};
    message.retcode !== undefined &&
      (obj.retcode = Math.round(message.retcode));
    message.reward !== undefined &&
      (obj.reward = message.reward
        ? ItemList.toJSON(message.reward)
        : undefined);
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<GetLevelRewardScRsp>, I>>(
    object: I
  ): GetLevelRewardScRsp {
    const message = createBaseGetLevelRewardScRsp();
    message.retcode = object.retcode ?? 0;
    message.reward =
      object.reward !== undefined && object.reward !== null
        ? ItemList.fromPartial(object.reward)
        : undefined;
    return message;
  },
};

function createBaseSyncTimeCsReq(): SyncTimeCsReq {
  return { clientTimeMs: 0 };
}

export const SyncTimeCsReq = {
  encode(
    message: SyncTimeCsReq,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.clientTimeMs !== 0) {
      writer.uint32(8).uint64(message.clientTimeMs);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SyncTimeCsReq {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSyncTimeCsReq();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.clientTimeMs = longToNumber(reader.uint64() as Long);
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): SyncTimeCsReq {
    return {
      clientTimeMs: isSet(object.clientTimeMs)
        ? Number(object.clientTimeMs)
        : 0,
    };
  },

  toJSON(message: SyncTimeCsReq): unknown {
    const obj: any = {};
    message.clientTimeMs !== undefined &&
      (obj.clientTimeMs = Math.round(message.clientTimeMs));
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<SyncTimeCsReq>, I>>(
    object: I
  ): SyncTimeCsReq {
    const message = createBaseSyncTimeCsReq();
    message.clientTimeMs = object.clientTimeMs ?? 0;
    return message;
  },
};

function createBaseSyncTimeScRsp(): SyncTimeScRsp {
  return {
    retcode: 0,
    clientTimeMs: 0,
    serverTimeMs: 0,
    downloadData: undefined,
  };
}

export const SyncTimeScRsp = {
  encode(
    message: SyncTimeScRsp,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.retcode !== 0) {
      writer.uint32(8).uint32(message.retcode);
    }
    if (message.clientTimeMs !== 0) {
      writer.uint32(16).uint64(message.clientTimeMs);
    }
    if (message.serverTimeMs !== 0) {
      writer.uint32(24).uint64(message.serverTimeMs);
    }
    if (message.downloadData !== undefined) {
      ClientDownloadData.encode(
        message.downloadData,
        writer.uint32(34).fork()
      ).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SyncTimeScRsp {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSyncTimeScRsp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.retcode = reader.uint32();
          break;
        case 2:
          message.clientTimeMs = longToNumber(reader.uint64() as Long);
          break;
        case 3:
          message.serverTimeMs = longToNumber(reader.uint64() as Long);
          break;
        case 4:
          message.downloadData = ClientDownloadData.decode(
            reader,
            reader.uint32()
          );
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): SyncTimeScRsp {
    return {
      retcode: isSet(object.retcode) ? Number(object.retcode) : 0,
      clientTimeMs: isSet(object.clientTimeMs)
        ? Number(object.clientTimeMs)
        : 0,
      serverTimeMs: isSet(object.serverTimeMs)
        ? Number(object.serverTimeMs)
        : 0,
      downloadData: isSet(object.downloadData)
        ? ClientDownloadData.fromJSON(object.downloadData)
        : undefined,
    };
  },

  toJSON(message: SyncTimeScRsp): unknown {
    const obj: any = {};
    message.retcode !== undefined &&
      (obj.retcode = Math.round(message.retcode));
    message.clientTimeMs !== undefined &&
      (obj.clientTimeMs = Math.round(message.clientTimeMs));
    message.serverTimeMs !== undefined &&
      (obj.serverTimeMs = Math.round(message.serverTimeMs));
    message.downloadData !== undefined &&
      (obj.downloadData = message.downloadData
        ? ClientDownloadData.toJSON(message.downloadData)
        : undefined);
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<SyncTimeScRsp>, I>>(
    object: I
  ): SyncTimeScRsp {
    const message = createBaseSyncTimeScRsp();
    message.retcode = object.retcode ?? 0;
    message.clientTimeMs = object.clientTimeMs ?? 0;
    message.serverTimeMs = object.serverTimeMs ?? 0;
    message.downloadData =
      object.downloadData !== undefined && object.downloadData !== null
        ? ClientDownloadData.fromPartial(object.downloadData)
        : undefined;
    return message;
  },
};

function createBaseSetLanguageCsReq(): SetLanguageCsReq {
  return { language: 0 };
}

export const SetLanguageCsReq = {
  encode(
    message: SetLanguageCsReq,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.language !== 0) {
      writer.uint32(8).int32(message.language);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SetLanguageCsReq {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSetLanguageCsReq();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.language = reader.int32() as any;
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): SetLanguageCsReq {
    return {
      language: isSet(object.language)
        ? languageTypeFromJSON(object.language)
        : 0,
    };
  },

  toJSON(message: SetLanguageCsReq): unknown {
    const obj: any = {};
    message.language !== undefined &&
      (obj.language = languageTypeToJSON(message.language));
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<SetLanguageCsReq>, I>>(
    object: I
  ): SetLanguageCsReq {
    const message = createBaseSetLanguageCsReq();
    message.language = object.language ?? 0;
    return message;
  },
};

function createBaseSetLanguageScRsp(): SetLanguageScRsp {
  return { retcode: 0, language: 0 };
}

export const SetLanguageScRsp = {
  encode(
    message: SetLanguageScRsp,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.retcode !== 0) {
      writer.uint32(8).uint32(message.retcode);
    }
    if (message.language !== 0) {
      writer.uint32(16).int32(message.language);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SetLanguageScRsp {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSetLanguageScRsp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.retcode = reader.uint32();
          break;
        case 2:
          message.language = reader.int32() as any;
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): SetLanguageScRsp {
    return {
      retcode: isSet(object.retcode) ? Number(object.retcode) : 0,
      language: isSet(object.language)
        ? languageTypeFromJSON(object.language)
        : 0,
    };
  },

  toJSON(message: SetLanguageScRsp): unknown {
    const obj: any = {};
    message.retcode !== undefined &&
      (obj.retcode = Math.round(message.retcode));
    message.language !== undefined &&
      (obj.language = languageTypeToJSON(message.language));
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<SetLanguageScRsp>, I>>(
    object: I
  ): SetLanguageScRsp {
    const message = createBaseSetLanguageScRsp();
    message.retcode = object.retcode ?? 0;
    message.language = object.language ?? 0;
    return message;
  },
};

function createBaseAnnounceData(): AnnounceData {
  return {
    configId: 0,
    beginTime: 0,
    endTime: 0,
    centerSystemText: "",
    countDownText: "",
    dungeonConfirmText: "",
    centerSystemFrequency: 0,
    countDownFrequency: 0,
    isCenterSystemLast5EveryMinutes: false,
  };
}

export const AnnounceData = {
  encode(
    message: AnnounceData,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.configId !== 0) {
      writer.uint32(8).uint32(message.configId);
    }
    if (message.beginTime !== 0) {
      writer.uint32(16).uint32(message.beginTime);
    }
    if (message.endTime !== 0) {
      writer.uint32(24).uint32(message.endTime);
    }
    if (message.centerSystemText !== "") {
      writer.uint32(34).string(message.centerSystemText);
    }
    if (message.countDownText !== "") {
      writer.uint32(42).string(message.countDownText);
    }
    if (message.dungeonConfirmText !== "") {
      writer.uint32(50).string(message.dungeonConfirmText);
    }
    if (message.centerSystemFrequency !== 0) {
      writer.uint32(56).uint32(message.centerSystemFrequency);
    }
    if (message.countDownFrequency !== 0) {
      writer.uint32(64).uint32(message.countDownFrequency);
    }
    if (message.isCenterSystemLast5EveryMinutes === true) {
      writer.uint32(72).bool(message.isCenterSystemLast5EveryMinutes);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): AnnounceData {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAnnounceData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.configId = reader.uint32();
          break;
        case 2:
          message.beginTime = reader.uint32();
          break;
        case 3:
          message.endTime = reader.uint32();
          break;
        case 4:
          message.centerSystemText = reader.string();
          break;
        case 5:
          message.countDownText = reader.string();
          break;
        case 6:
          message.dungeonConfirmText = reader.string();
          break;
        case 7:
          message.centerSystemFrequency = reader.uint32();
          break;
        case 8:
          message.countDownFrequency = reader.uint32();
          break;
        case 9:
          message.isCenterSystemLast5EveryMinutes = reader.bool();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): AnnounceData {
    return {
      configId: isSet(object.configId) ? Number(object.configId) : 0,
      beginTime: isSet(object.beginTime) ? Number(object.beginTime) : 0,
      endTime: isSet(object.endTime) ? Number(object.endTime) : 0,
      centerSystemText: isSet(object.centerSystemText)
        ? String(object.centerSystemText)
        : "",
      countDownText: isSet(object.countDownText)
        ? String(object.countDownText)
        : "",
      dungeonConfirmText: isSet(object.dungeonConfirmText)
        ? String(object.dungeonConfirmText)
        : "",
      centerSystemFrequency: isSet(object.centerSystemFrequency)
        ? Number(object.centerSystemFrequency)
        : 0,
      countDownFrequency: isSet(object.countDownFrequency)
        ? Number(object.countDownFrequency)
        : 0,
      isCenterSystemLast5EveryMinutes: isSet(
        object.isCenterSystemLast5EveryMinutes
      )
        ? Boolean(object.isCenterSystemLast5EveryMinutes)
        : false,
    };
  },

  toJSON(message: AnnounceData): unknown {
    const obj: any = {};
    message.configId !== undefined &&
      (obj.configId = Math.round(message.configId));
    message.beginTime !== undefined &&
      (obj.beginTime = Math.round(message.beginTime));
    message.endTime !== undefined &&
      (obj.endTime = Math.round(message.endTime));
    message.centerSystemText !== undefined &&
      (obj.centerSystemText = message.centerSystemText);
    message.countDownText !== undefined &&
      (obj.countDownText = message.countDownText);
    message.dungeonConfirmText !== undefined &&
      (obj.dungeonConfirmText = message.dungeonConfirmText);
    message.centerSystemFrequency !== undefined &&
      (obj.centerSystemFrequency = Math.round(message.centerSystemFrequency));
    message.countDownFrequency !== undefined &&
      (obj.countDownFrequency = Math.round(message.countDownFrequency));
    message.isCenterSystemLast5EveryMinutes !== undefined &&
      (obj.isCenterSystemLast5EveryMinutes =
        message.isCenterSystemLast5EveryMinutes);
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<AnnounceData>, I>>(
    object: I
  ): AnnounceData {
    const message = createBaseAnnounceData();
    message.configId = object.configId ?? 0;
    message.beginTime = object.beginTime ?? 0;
    message.endTime = object.endTime ?? 0;
    message.centerSystemText = object.centerSystemText ?? "";
    message.countDownText = object.countDownText ?? "";
    message.dungeonConfirmText = object.dungeonConfirmText ?? "";
    message.centerSystemFrequency = object.centerSystemFrequency ?? 0;
    message.countDownFrequency = object.countDownFrequency ?? 0;
    message.isCenterSystemLast5EveryMinutes =
      object.isCenterSystemLast5EveryMinutes ?? false;
    return message;
  },
};

function createBaseServerAnnounceNotify(): ServerAnnounceNotify {
  return { announceDataList: [] };
}

export const ServerAnnounceNotify = {
  encode(
    message: ServerAnnounceNotify,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    for (const v of message.announceDataList) {
      AnnounceData.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): ServerAnnounceNotify {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseServerAnnounceNotify();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.announceDataList.push(
            AnnounceData.decode(reader, reader.uint32())
          );
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): ServerAnnounceNotify {
    return {
      announceDataList: Array.isArray(object?.announceDataList)
        ? object.announceDataList.map((e: any) => AnnounceData.fromJSON(e))
        : [],
    };
  },

  toJSON(message: ServerAnnounceNotify): unknown {
    const obj: any = {};
    if (message.announceDataList) {
      obj.announceDataList = message.announceDataList.map((e) =>
        e ? AnnounceData.toJSON(e) : undefined
      );
    } else {
      obj.announceDataList = [];
    }
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<ServerAnnounceNotify>, I>>(
    object: I
  ): ServerAnnounceNotify {
    const message = createBaseServerAnnounceNotify();
    message.announceDataList =
      object.announceDataList?.map((e) => AnnounceData.fromPartial(e)) || [];
    return message;
  },
};

function createBaseGateserver(): Gateserver {
  return {
    retcode: 0,
    msg: "",
    regionName: "",
    ip: "",
    port: 0,
    stopBeginTime: 0,
    stopEndTime: 0,
    dataUseAssetBoundle: false,
    resUseAssetBoundle: false,
    assetBundleUrl: "",
    exResourceUrl: "",
    luaUrl: "",
    asbRelogin: 0,
    asbMemo: "",
    designDataRelogin: 0,
    designDataMemo: "",
    clientSecretKey: "",
    recordGameObjectUserData: "",
    useTcp: false,
    customServiceUrl: "",
    operationFeedbackUrl: "",
    privacyInGameUrl: "",
    clientRecordReplay: false,
    serverDescription: "",
  };
}

export const Gateserver = {
  encode(
    message: Gateserver,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.retcode !== 0) {
      writer.uint32(8).uint32(message.retcode);
    }
    if (message.msg !== "") {
      writer.uint32(18).string(message.msg);
    }
    if (message.regionName !== "") {
      writer.uint32(26).string(message.regionName);
    }
    if (message.ip !== "") {
      writer.uint32(34).string(message.ip);
    }
    if (message.port !== 0) {
      writer.uint32(40).uint32(message.port);
    }
    if (message.stopBeginTime !== 0) {
      writer.uint32(48).uint32(message.stopBeginTime);
    }
    if (message.stopEndTime !== 0) {
      writer.uint32(56).uint32(message.stopEndTime);
    }
    if (message.dataUseAssetBoundle === true) {
      writer.uint32(64).bool(message.dataUseAssetBoundle);
    }
    if (message.resUseAssetBoundle === true) {
      writer.uint32(72).bool(message.resUseAssetBoundle);
    }
    if (message.assetBundleUrl !== "") {
      writer.uint32(82).string(message.assetBundleUrl);
    }
    if (message.exResourceUrl !== "") {
      writer.uint32(90).string(message.exResourceUrl);
    }
    if (message.luaUrl !== "") {
      writer.uint32(98).string(message.luaUrl);
    }
    if (message.asbRelogin !== 0) {
      writer.uint32(104).uint32(message.asbRelogin);
    }
    if (message.asbMemo !== "") {
      writer.uint32(114).string(message.asbMemo);
    }
    if (message.designDataRelogin !== 0) {
      writer.uint32(120).uint32(message.designDataRelogin);
    }
    if (message.designDataMemo !== "") {
      writer.uint32(130).string(message.designDataMemo);
    }
    if (message.clientSecretKey !== "") {
      writer.uint32(138).string(message.clientSecretKey);
    }
    if (message.recordGameObjectUserData !== "") {
      writer.uint32(146).string(message.recordGameObjectUserData);
    }
    if (message.useTcp === true) {
      writer.uint32(152).bool(message.useTcp);
    }
    if (message.customServiceUrl !== "") {
      writer.uint32(162).string(message.customServiceUrl);
    }
    if (message.operationFeedbackUrl !== "") {
      writer.uint32(170).string(message.operationFeedbackUrl);
    }
    if (message.privacyInGameUrl !== "") {
      writer.uint32(178).string(message.privacyInGameUrl);
    }
    if (message.clientRecordReplay === true) {
      writer.uint32(184).bool(message.clientRecordReplay);
    }
    if (message.serverDescription !== "") {
      writer.uint32(194).string(message.serverDescription);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Gateserver {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGateserver();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.retcode = reader.uint32();
          break;
        case 2:
          message.msg = reader.string();
          break;
        case 3:
          message.regionName = reader.string();
          break;
        case 4:
          message.ip = reader.string();
          break;
        case 5:
          message.port = reader.uint32();
          break;
        case 6:
          message.stopBeginTime = reader.uint32();
          break;
        case 7:
          message.stopEndTime = reader.uint32();
          break;
        case 8:
          message.dataUseAssetBoundle = reader.bool();
          break;
        case 9:
          message.resUseAssetBoundle = reader.bool();
          break;
        case 10:
          message.assetBundleUrl = reader.string();
          break;
        case 11:
          message.exResourceUrl = reader.string();
          break;
        case 12:
          message.luaUrl = reader.string();
          break;
        case 13:
          message.asbRelogin = reader.uint32();
          break;
        case 14:
          message.asbMemo = reader.string();
          break;
        case 15:
          message.designDataRelogin = reader.uint32();
          break;
        case 16:
          message.designDataMemo = reader.string();
          break;
        case 17:
          message.clientSecretKey = reader.string();
          break;
        case 18:
          message.recordGameObjectUserData = reader.string();
          break;
        case 19:
          message.useTcp = reader.bool();
          break;
        case 20:
          message.customServiceUrl = reader.string();
          break;
        case 21:
          message.operationFeedbackUrl = reader.string();
          break;
        case 22:
          message.privacyInGameUrl = reader.string();
          break;
        case 23:
          message.clientRecordReplay = reader.bool();
          break;
        case 24:
          message.serverDescription = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): Gateserver {
    return {
      retcode: isSet(object.retcode) ? Number(object.retcode) : 0,
      msg: isSet(object.msg) ? String(object.msg) : "",
      regionName: isSet(object.regionName) ? String(object.regionName) : "",
      ip: isSet(object.ip) ? String(object.ip) : "",
      port: isSet(object.port) ? Number(object.port) : 0,
      stopBeginTime: isSet(object.stopBeginTime)
        ? Number(object.stopBeginTime)
        : 0,
      stopEndTime: isSet(object.stopEndTime) ? Number(object.stopEndTime) : 0,
      dataUseAssetBoundle: isSet(object.dataUseAssetBoundle)
        ? Boolean(object.dataUseAssetBoundle)
        : false,
      resUseAssetBoundle: isSet(object.resUseAssetBoundle)
        ? Boolean(object.resUseAssetBoundle)
        : false,
      assetBundleUrl: isSet(object.assetBundleUrl)
        ? String(object.assetBundleUrl)
        : "",
      exResourceUrl: isSet(object.exResourceUrl)
        ? String(object.exResourceUrl)
        : "",
      luaUrl: isSet(object.luaUrl) ? String(object.luaUrl) : "",
      asbRelogin: isSet(object.asbRelogin) ? Number(object.asbRelogin) : 0,
      asbMemo: isSet(object.asbMemo) ? String(object.asbMemo) : "",
      designDataRelogin: isSet(object.designDataRelogin)
        ? Number(object.designDataRelogin)
        : 0,
      designDataMemo: isSet(object.designDataMemo)
        ? String(object.designDataMemo)
        : "",
      clientSecretKey: isSet(object.clientSecretKey)
        ? String(object.clientSecretKey)
        : "",
      recordGameObjectUserData: isSet(object.recordGameObjectUserData)
        ? String(object.recordGameObjectUserData)
        : "",
      useTcp: isSet(object.useTcp) ? Boolean(object.useTcp) : false,
      customServiceUrl: isSet(object.customServiceUrl)
        ? String(object.customServiceUrl)
        : "",
      operationFeedbackUrl: isSet(object.operationFeedbackUrl)
        ? String(object.operationFeedbackUrl)
        : "",
      privacyInGameUrl: isSet(object.privacyInGameUrl)
        ? String(object.privacyInGameUrl)
        : "",
      clientRecordReplay: isSet(object.clientRecordReplay)
        ? Boolean(object.clientRecordReplay)
        : false,
      serverDescription: isSet(object.serverDescription)
        ? String(object.serverDescription)
        : "",
    };
  },

  toJSON(message: Gateserver): unknown {
    const obj: any = {};
    message.retcode !== undefined &&
      (obj.retcode = Math.round(message.retcode));
    message.msg !== undefined && (obj.msg = message.msg);
    message.regionName !== undefined && (obj.regionName = message.regionName);
    message.ip !== undefined && (obj.ip = message.ip);
    message.port !== undefined && (obj.port = Math.round(message.port));
    message.stopBeginTime !== undefined &&
      (obj.stopBeginTime = Math.round(message.stopBeginTime));
    message.stopEndTime !== undefined &&
      (obj.stopEndTime = Math.round(message.stopEndTime));
    message.dataUseAssetBoundle !== undefined &&
      (obj.dataUseAssetBoundle = message.dataUseAssetBoundle);
    message.resUseAssetBoundle !== undefined &&
      (obj.resUseAssetBoundle = message.resUseAssetBoundle);
    message.assetBundleUrl !== undefined &&
      (obj.assetBundleUrl = message.assetBundleUrl);
    message.exResourceUrl !== undefined &&
      (obj.exResourceUrl = message.exResourceUrl);
    message.luaUrl !== undefined && (obj.luaUrl = message.luaUrl);
    message.asbRelogin !== undefined &&
      (obj.asbRelogin = Math.round(message.asbRelogin));
    message.asbMemo !== undefined && (obj.asbMemo = message.asbMemo);
    message.designDataRelogin !== undefined &&
      (obj.designDataRelogin = Math.round(message.designDataRelogin));
    message.designDataMemo !== undefined &&
      (obj.designDataMemo = message.designDataMemo);
    message.clientSecretKey !== undefined &&
      (obj.clientSecretKey = message.clientSecretKey);
    message.recordGameObjectUserData !== undefined &&
      (obj.recordGameObjectUserData = message.recordGameObjectUserData);
    message.useTcp !== undefined && (obj.useTcp = message.useTcp);
    message.customServiceUrl !== undefined &&
      (obj.customServiceUrl = message.customServiceUrl);
    message.operationFeedbackUrl !== undefined &&
      (obj.operationFeedbackUrl = message.operationFeedbackUrl);
    message.privacyInGameUrl !== undefined &&
      (obj.privacyInGameUrl = message.privacyInGameUrl);
    message.clientRecordReplay !== undefined &&
      (obj.clientRecordReplay = message.clientRecordReplay);
    message.serverDescription !== undefined &&
      (obj.serverDescription = message.serverDescription);
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<Gateserver>, I>>(
    object: I
  ): Gateserver {
    const message = createBaseGateserver();
    message.retcode = object.retcode ?? 0;
    message.msg = object.msg ?? "";
    message.regionName = object.regionName ?? "";
    message.ip = object.ip ?? "";
    message.port = object.port ?? 0;
    message.stopBeginTime = object.stopBeginTime ?? 0;
    message.stopEndTime = object.stopEndTime ?? 0;
    message.dataUseAssetBoundle = object.dataUseAssetBoundle ?? false;
    message.resUseAssetBoundle = object.resUseAssetBoundle ?? false;
    message.assetBundleUrl = object.assetBundleUrl ?? "";
    message.exResourceUrl = object.exResourceUrl ?? "";
    message.luaUrl = object.luaUrl ?? "";
    message.asbRelogin = object.asbRelogin ?? 0;
    message.asbMemo = object.asbMemo ?? "";
    message.designDataRelogin = object.designDataRelogin ?? 0;
    message.designDataMemo = object.designDataMemo ?? "";
    message.clientSecretKey = object.clientSecretKey ?? "";
    message.recordGameObjectUserData = object.recordGameObjectUserData ?? "";
    message.useTcp = object.useTcp ?? false;
    message.customServiceUrl = object.customServiceUrl ?? "";
    message.operationFeedbackUrl = object.operationFeedbackUrl ?? "";
    message.privacyInGameUrl = object.privacyInGameUrl ?? "";
    message.clientRecordReplay = object.clientRecordReplay ?? false;
    message.serverDescription = object.serverDescription ?? "";
    return message;
  },
};

function createBaseSetHeroBasicTypeCsReq(): SetHeroBasicTypeCsReq {
  return { basicType: 0 };
}

export const SetHeroBasicTypeCsReq = {
  encode(
    message: SetHeroBasicTypeCsReq,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.basicType !== 0) {
      writer.uint32(8).int32(message.basicType);
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): SetHeroBasicTypeCsReq {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSetHeroBasicTypeCsReq();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.basicType = reader.int32() as any;
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): SetHeroBasicTypeCsReq {
    return {
      basicType: isSet(object.basicType)
        ? heroBasicTypeFromJSON(object.basicType)
        : 0,
    };
  },

  toJSON(message: SetHeroBasicTypeCsReq): unknown {
    const obj: any = {};
    message.basicType !== undefined &&
      (obj.basicType = heroBasicTypeToJSON(message.basicType));
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<SetHeroBasicTypeCsReq>, I>>(
    object: I
  ): SetHeroBasicTypeCsReq {
    const message = createBaseSetHeroBasicTypeCsReq();
    message.basicType = object.basicType ?? 0;
    return message;
  },
};

function createBaseSetHeroBasicTypeScRsp(): SetHeroBasicTypeScRsp {
  return { retcode: 0, basicType: 0 };
}

export const SetHeroBasicTypeScRsp = {
  encode(
    message: SetHeroBasicTypeScRsp,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.retcode !== 0) {
      writer.uint32(8).uint32(message.retcode);
    }
    if (message.basicType !== 0) {
      writer.uint32(16).int32(message.basicType);
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): SetHeroBasicTypeScRsp {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSetHeroBasicTypeScRsp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.retcode = reader.uint32();
          break;
        case 2:
          message.basicType = reader.int32() as any;
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): SetHeroBasicTypeScRsp {
    return {
      retcode: isSet(object.retcode) ? Number(object.retcode) : 0,
      basicType: isSet(object.basicType)
        ? heroBasicTypeFromJSON(object.basicType)
        : 0,
    };
  },

  toJSON(message: SetHeroBasicTypeScRsp): unknown {
    const obj: any = {};
    message.retcode !== undefined &&
      (obj.retcode = Math.round(message.retcode));
    message.basicType !== undefined &&
      (obj.basicType = heroBasicTypeToJSON(message.basicType));
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<SetHeroBasicTypeScRsp>, I>>(
    object: I
  ): SetHeroBasicTypeScRsp {
    const message = createBaseSetHeroBasicTypeScRsp();
    message.retcode = object.retcode ?? 0;
    message.basicType = object.basicType ?? 0;
    return message;
  },
};

function createBaseGetHeroBasicTypeInfoCsReq(): GetHeroBasicTypeInfoCsReq {
  return {};
}

export const GetHeroBasicTypeInfoCsReq = {
  encode(
    _: GetHeroBasicTypeInfoCsReq,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): GetHeroBasicTypeInfoCsReq {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetHeroBasicTypeInfoCsReq();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(_: any): GetHeroBasicTypeInfoCsReq {
    return {};
  },

  toJSON(_: GetHeroBasicTypeInfoCsReq): unknown {
    const obj: any = {};
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<GetHeroBasicTypeInfoCsReq>, I>>(
    _: I
  ): GetHeroBasicTypeInfoCsReq {
    const message = createBaseGetHeroBasicTypeInfoCsReq();
    return message;
  },
};

function createBaseHeroBasicTypeInfo(): HeroBasicTypeInfo {
  return { basicType: 0, rank: 0, skillTreeList: [] };
}

export const HeroBasicTypeInfo = {
  encode(
    message: HeroBasicTypeInfo,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.basicType !== 0) {
      writer.uint32(8).int32(message.basicType);
    }
    if (message.rank !== 0) {
      writer.uint32(16).uint32(message.rank);
    }
    for (const v of message.skillTreeList) {
      AvatarSkillTree.encode(v!, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): HeroBasicTypeInfo {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHeroBasicTypeInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.basicType = reader.int32() as any;
          break;
        case 2:
          message.rank = reader.uint32();
          break;
        case 3:
          message.skillTreeList.push(
            AvatarSkillTree.decode(reader, reader.uint32())
          );
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): HeroBasicTypeInfo {
    return {
      basicType: isSet(object.basicType)
        ? heroBasicTypeFromJSON(object.basicType)
        : 0,
      rank: isSet(object.rank) ? Number(object.rank) : 0,
      skillTreeList: Array.isArray(object?.skillTreeList)
        ? object.skillTreeList.map((e: any) => AvatarSkillTree.fromJSON(e))
        : [],
    };
  },

  toJSON(message: HeroBasicTypeInfo): unknown {
    const obj: any = {};
    message.basicType !== undefined &&
      (obj.basicType = heroBasicTypeToJSON(message.basicType));
    message.rank !== undefined && (obj.rank = Math.round(message.rank));
    if (message.skillTreeList) {
      obj.skillTreeList = message.skillTreeList.map((e) =>
        e ? AvatarSkillTree.toJSON(e) : undefined
      );
    } else {
      obj.skillTreeList = [];
    }
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<HeroBasicTypeInfo>, I>>(
    object: I
  ): HeroBasicTypeInfo {
    const message = createBaseHeroBasicTypeInfo();
    message.basicType = object.basicType ?? 0;
    message.rank = object.rank ?? 0;
    message.skillTreeList =
      object.skillTreeList?.map((e) => AvatarSkillTree.fromPartial(e)) || [];
    return message;
  },
};

function createBaseGetHeroBasicTypeInfoScRsp(): GetHeroBasicTypeInfoScRsp {
  return {
    retcode: 0,
    gender: 0,
    curBasicType: 0,
    basicTypeInfoList: [],
    heroPathList: [],
    isGenderModified: false,
    isPlayerInfoModified: false,
  };
}

export const GetHeroBasicTypeInfoScRsp = {
  encode(
    message: GetHeroBasicTypeInfoScRsp,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.retcode !== 0) {
      writer.uint32(8).uint32(message.retcode);
    }
    if (message.gender !== 0) {
      writer.uint32(16).int32(message.gender);
    }
    if (message.curBasicType !== 0) {
      writer.uint32(24).int32(message.curBasicType);
    }
    for (const v of message.basicTypeInfoList) {
      HeroBasicTypeInfo.encode(v!, writer.uint32(34).fork()).ldelim();
    }
    for (const v of message.heroPathList) {
      HeroPath.encode(v!, writer.uint32(42).fork()).ldelim();
    }
    if (message.isGenderModified === true) {
      writer.uint32(48).bool(message.isGenderModified);
    }
    if (message.isPlayerInfoModified === true) {
      writer.uint32(56).bool(message.isPlayerInfoModified);
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): GetHeroBasicTypeInfoScRsp {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetHeroBasicTypeInfoScRsp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.retcode = reader.uint32();
          break;
        case 2:
          message.gender = reader.int32() as any;
          break;
        case 3:
          message.curBasicType = reader.int32() as any;
          break;
        case 4:
          message.basicTypeInfoList.push(
            HeroBasicTypeInfo.decode(reader, reader.uint32())
          );
          break;
        case 5:
          message.heroPathList.push(HeroPath.decode(reader, reader.uint32()));
          break;
        case 6:
          message.isGenderModified = reader.bool();
          break;
        case 7:
          message.isPlayerInfoModified = reader.bool();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): GetHeroBasicTypeInfoScRsp {
    return {
      retcode: isSet(object.retcode) ? Number(object.retcode) : 0,
      gender: isSet(object.gender) ? genderFromJSON(object.gender) : 0,
      curBasicType: isSet(object.curBasicType)
        ? heroBasicTypeFromJSON(object.curBasicType)
        : 0,
      basicTypeInfoList: Array.isArray(object?.basicTypeInfoList)
        ? object.basicTypeInfoList.map((e: any) =>
            HeroBasicTypeInfo.fromJSON(e)
          )
        : [],
      heroPathList: Array.isArray(object?.heroPathList)
        ? object.heroPathList.map((e: any) => HeroPath.fromJSON(e))
        : [],
      isGenderModified: isSet(object.isGenderModified)
        ? Boolean(object.isGenderModified)
        : false,
      isPlayerInfoModified: isSet(object.isPlayerInfoModified)
        ? Boolean(object.isPlayerInfoModified)
        : false,
    };
  },

  toJSON(message: GetHeroBasicTypeInfoScRsp): unknown {
    const obj: any = {};
    message.retcode !== undefined &&
      (obj.retcode = Math.round(message.retcode));
    message.gender !== undefined && (obj.gender = genderToJSON(message.gender));
    message.curBasicType !== undefined &&
      (obj.curBasicType = heroBasicTypeToJSON(message.curBasicType));
    if (message.basicTypeInfoList) {
      obj.basicTypeInfoList = message.basicTypeInfoList.map((e) =>
        e ? HeroBasicTypeInfo.toJSON(e) : undefined
      );
    } else {
      obj.basicTypeInfoList = [];
    }
    if (message.heroPathList) {
      obj.heroPathList = message.heroPathList.map((e) =>
        e ? HeroPath.toJSON(e) : undefined
      );
    } else {
      obj.heroPathList = [];
    }
    message.isGenderModified !== undefined &&
      (obj.isGenderModified = message.isGenderModified);
    message.isPlayerInfoModified !== undefined &&
      (obj.isPlayerInfoModified = message.isPlayerInfoModified);
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<GetHeroBasicTypeInfoScRsp>, I>>(
    object: I
  ): GetHeroBasicTypeInfoScRsp {
    const message = createBaseGetHeroBasicTypeInfoScRsp();
    message.retcode = object.retcode ?? 0;
    message.gender = object.gender ?? 0;
    message.curBasicType = object.curBasicType ?? 0;
    message.basicTypeInfoList =
      object.basicTypeInfoList?.map((e) => HeroBasicTypeInfo.fromPartial(e)) ||
      [];
    message.heroPathList =
      object.heroPathList?.map((e) => HeroPath.fromPartial(e)) || [];
    message.isGenderModified = object.isGenderModified ?? false;
    message.isPlayerInfoModified = object.isPlayerInfoModified ?? false;
    return message;
  },
};

function createBaseGetHeroPathCsReq(): GetHeroPathCsReq {
  return {};
}

export const GetHeroPathCsReq = {
  encode(
    _: GetHeroPathCsReq,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetHeroPathCsReq {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetHeroPathCsReq();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(_: any): GetHeroPathCsReq {
    return {};
  },

  toJSON(_: GetHeroPathCsReq): unknown {
    const obj: any = {};
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<GetHeroPathCsReq>, I>>(
    _: I
  ): GetHeroPathCsReq {
    const message = createBaseGetHeroPathCsReq();
    return message;
  },
};

function createBaseGetHeroPathScRsp(): GetHeroPathScRsp {
  return { retcode: 0, heroPathList: [] };
}

export const GetHeroPathScRsp = {
  encode(
    message: GetHeroPathScRsp,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.retcode !== 0) {
      writer.uint32(8).uint32(message.retcode);
    }
    for (const v of message.heroPathList) {
      HeroPath.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetHeroPathScRsp {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetHeroPathScRsp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.retcode = reader.uint32();
          break;
        case 2:
          message.heroPathList.push(HeroPath.decode(reader, reader.uint32()));
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): GetHeroPathScRsp {
    return {
      retcode: isSet(object.retcode) ? Number(object.retcode) : 0,
      heroPathList: Array.isArray(object?.heroPathList)
        ? object.heroPathList.map((e: any) => HeroPath.fromJSON(e))
        : [],
    };
  },

  toJSON(message: GetHeroPathScRsp): unknown {
    const obj: any = {};
    message.retcode !== undefined &&
      (obj.retcode = Math.round(message.retcode));
    if (message.heroPathList) {
      obj.heroPathList = message.heroPathList.map((e) =>
        e ? HeroPath.toJSON(e) : undefined
      );
    } else {
      obj.heroPathList = [];
    }
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<GetHeroPathScRsp>, I>>(
    object: I
  ): GetHeroPathScRsp {
    const message = createBaseGetHeroPathScRsp();
    message.retcode = object.retcode ?? 0;
    message.heroPathList =
      object.heroPathList?.map((e) => HeroPath.fromPartial(e)) || [];
    return message;
  },
};

function createBaseHeroPathChangedNotify(): HeroPathChangedNotify {
  return { heroPath: undefined };
}

export const HeroPathChangedNotify = {
  encode(
    message: HeroPathChangedNotify,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.heroPath !== undefined) {
      HeroPath.encode(message.heroPath, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): HeroPathChangedNotify {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHeroPathChangedNotify();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.heroPath = HeroPath.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): HeroPathChangedNotify {
    return {
      heroPath: isSet(object.heroPath)
        ? HeroPath.fromJSON(object.heroPath)
        : undefined,
    };
  },

  toJSON(message: HeroPathChangedNotify): unknown {
    const obj: any = {};
    message.heroPath !== undefined &&
      (obj.heroPath = message.heroPath
        ? HeroPath.toJSON(message.heroPath)
        : undefined);
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<HeroPathChangedNotify>, I>>(
    object: I
  ): HeroPathChangedNotify {
    const message = createBaseHeroPathChangedNotify();
    message.heroPath =
      object.heroPath !== undefined && object.heroPath !== null
        ? HeroPath.fromPartial(object.heroPath)
        : undefined;
    return message;
  },
};

function createBaseSetGenderCsReq(): SetGenderCsReq {
  return { gender: 0 };
}

export const SetGenderCsReq = {
  encode(
    message: SetGenderCsReq,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.gender !== 0) {
      writer.uint32(8).int32(message.gender);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SetGenderCsReq {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSetGenderCsReq();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.gender = reader.int32() as any;
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): SetGenderCsReq {
    return {
      gender: isSet(object.gender) ? genderFromJSON(object.gender) : 0,
    };
  },

  toJSON(message: SetGenderCsReq): unknown {
    const obj: any = {};
    message.gender !== undefined && (obj.gender = genderToJSON(message.gender));
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<SetGenderCsReq>, I>>(
    object: I
  ): SetGenderCsReq {
    const message = createBaseSetGenderCsReq();
    message.gender = object.gender ?? 0;
    return message;
  },
};

function createBaseSetGenderScRsp(): SetGenderScRsp {
  return { retcode: 0, curBasicType: 0 };
}

export const SetGenderScRsp = {
  encode(
    message: SetGenderScRsp,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.retcode !== 0) {
      writer.uint32(8).uint32(message.retcode);
    }
    if (message.curBasicType !== 0) {
      writer.uint32(16).int32(message.curBasicType);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SetGenderScRsp {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSetGenderScRsp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.retcode = reader.uint32();
          break;
        case 2:
          message.curBasicType = reader.int32() as any;
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): SetGenderScRsp {
    return {
      retcode: isSet(object.retcode) ? Number(object.retcode) : 0,
      curBasicType: isSet(object.curBasicType)
        ? heroBasicTypeFromJSON(object.curBasicType)
        : 0,
    };
  },

  toJSON(message: SetGenderScRsp): unknown {
    const obj: any = {};
    message.retcode !== undefined &&
      (obj.retcode = Math.round(message.retcode));
    message.curBasicType !== undefined &&
      (obj.curBasicType = heroBasicTypeToJSON(message.curBasicType));
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<SetGenderScRsp>, I>>(
    object: I
  ): SetGenderScRsp {
    const message = createBaseSetGenderScRsp();
    message.retcode = object.retcode ?? 0;
    message.curBasicType = object.curBasicType ?? 0;
    return message;
  },
};

function createBaseSetPlayerInfoCsReq(): SetPlayerInfoCsReq {
  return { nickname: "", isModify: false, gender: 0 };
}

export const SetPlayerInfoCsReq = {
  encode(
    message: SetPlayerInfoCsReq,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.nickname !== "") {
      writer.uint32(10).string(message.nickname);
    }
    if (message.isModify === true) {
      writer.uint32(16).bool(message.isModify);
    }
    if (message.gender !== 0) {
      writer.uint32(24).int32(message.gender);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SetPlayerInfoCsReq {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSetPlayerInfoCsReq();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.nickname = reader.string();
          break;
        case 2:
          message.isModify = reader.bool();
          break;
        case 3:
          message.gender = reader.int32() as any;
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): SetPlayerInfoCsReq {
    return {
      nickname: isSet(object.nickname) ? String(object.nickname) : "",
      isModify: isSet(object.isModify) ? Boolean(object.isModify) : false,
      gender: isSet(object.gender) ? genderFromJSON(object.gender) : 0,
    };
  },

  toJSON(message: SetPlayerInfoCsReq): unknown {
    const obj: any = {};
    message.nickname !== undefined && (obj.nickname = message.nickname);
    message.isModify !== undefined && (obj.isModify = message.isModify);
    message.gender !== undefined && (obj.gender = genderToJSON(message.gender));
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<SetPlayerInfoCsReq>, I>>(
    object: I
  ): SetPlayerInfoCsReq {
    const message = createBaseSetPlayerInfoCsReq();
    message.nickname = object.nickname ?? "";
    message.isModify = object.isModify ?? false;
    message.gender = object.gender ?? 0;
    return message;
  },
};

function createBaseSetPlayerInfoScRsp(): SetPlayerInfoScRsp {
  return { retcode: 0, curBasicType: 0, isModify: false };
}

export const SetPlayerInfoScRsp = {
  encode(
    message: SetPlayerInfoScRsp,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.retcode !== 0) {
      writer.uint32(8).uint32(message.retcode);
    }
    if (message.curBasicType !== 0) {
      writer.uint32(16).int32(message.curBasicType);
    }
    if (message.isModify === true) {
      writer.uint32(24).bool(message.isModify);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SetPlayerInfoScRsp {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSetPlayerInfoScRsp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.retcode = reader.uint32();
          break;
        case 2:
          message.curBasicType = reader.int32() as any;
          break;
        case 3:
          message.isModify = reader.bool();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): SetPlayerInfoScRsp {
    return {
      retcode: isSet(object.retcode) ? Number(object.retcode) : 0,
      curBasicType: isSet(object.curBasicType)
        ? heroBasicTypeFromJSON(object.curBasicType)
        : 0,
      isModify: isSet(object.isModify) ? Boolean(object.isModify) : false,
    };
  },

  toJSON(message: SetPlayerInfoScRsp): unknown {
    const obj: any = {};
    message.retcode !== undefined &&
      (obj.retcode = Math.round(message.retcode));
    message.curBasicType !== undefined &&
      (obj.curBasicType = heroBasicTypeToJSON(message.curBasicType));
    message.isModify !== undefined && (obj.isModify = message.isModify);
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<SetPlayerInfoScRsp>, I>>(
    object: I
  ): SetPlayerInfoScRsp {
    const message = createBaseSetPlayerInfoScRsp();
    message.retcode = object.retcode ?? 0;
    message.curBasicType = object.curBasicType ?? 0;
    message.isModify = object.isModify ?? false;
    return message;
  },
};

function createBaseHeroBasicTypeChangedNotify(): HeroBasicTypeChangedNotify {
  return { curBasicType: 0 };
}

export const HeroBasicTypeChangedNotify = {
  encode(
    message: HeroBasicTypeChangedNotify,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.curBasicType !== 0) {
      writer.uint32(8).int32(message.curBasicType);
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): HeroBasicTypeChangedNotify {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHeroBasicTypeChangedNotify();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.curBasicType = reader.int32() as any;
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): HeroBasicTypeChangedNotify {
    return {
      curBasicType: isSet(object.curBasicType)
        ? heroBasicTypeFromJSON(object.curBasicType)
        : 0,
    };
  },

  toJSON(message: HeroBasicTypeChangedNotify): unknown {
    const obj: any = {};
    message.curBasicType !== undefined &&
      (obj.curBasicType = heroBasicTypeToJSON(message.curBasicType));
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<HeroBasicTypeChangedNotify>, I>>(
    object: I
  ): HeroBasicTypeChangedNotify {
    const message = createBaseHeroBasicTypeChangedNotify();
    message.curBasicType = object.curBasicType ?? 0;
    return message;
  },
};

function createBaseQueryProductInfoCsReq(): QueryProductInfoCsReq {
  return {};
}

export const QueryProductInfoCsReq = {
  encode(
    _: QueryProductInfoCsReq,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): QueryProductInfoCsReq {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryProductInfoCsReq();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(_: any): QueryProductInfoCsReq {
    return {};
  },

  toJSON(_: QueryProductInfoCsReq): unknown {
    const obj: any = {};
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<QueryProductInfoCsReq>, I>>(
    _: I
  ): QueryProductInfoCsReq {
    const message = createBaseQueryProductInfoCsReq();
    return message;
  },
};

function createBaseProduct(): Product {
  return { productId: "", priceTier: "" };
}

export const Product = {
  encode(
    message: Product,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.productId !== "") {
      writer.uint32(10).string(message.productId);
    }
    if (message.priceTier !== "") {
      writer.uint32(18).string(message.priceTier);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Product {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProduct();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.productId = reader.string();
          break;
        case 2:
          message.priceTier = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): Product {
    return {
      productId: isSet(object.productId) ? String(object.productId) : "",
      priceTier: isSet(object.priceTier) ? String(object.priceTier) : "",
    };
  },

  toJSON(message: Product): unknown {
    const obj: any = {};
    message.productId !== undefined && (obj.productId = message.productId);
    message.priceTier !== undefined && (obj.priceTier = message.priceTier);
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<Product>, I>>(object: I): Product {
    const message = createBaseProduct();
    message.productId = object.productId ?? "";
    message.priceTier = object.priceTier ?? "";
    return message;
  },
};

function createBaseQueryProductInfoScRsp(): QueryProductInfoScRsp {
  return { retcode: 0, productList: [] };
}

export const QueryProductInfoScRsp = {
  encode(
    message: QueryProductInfoScRsp,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.retcode !== 0) {
      writer.uint32(8).uint32(message.retcode);
    }
    for (const v of message.productList) {
      Product.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): QueryProductInfoScRsp {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryProductInfoScRsp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.retcode = reader.uint32();
          break;
        case 2:
          message.productList.push(Product.decode(reader, reader.uint32()));
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): QueryProductInfoScRsp {
    return {
      retcode: isSet(object.retcode) ? Number(object.retcode) : 0,
      productList: Array.isArray(object?.productList)
        ? object.productList.map((e: any) => Product.fromJSON(e))
        : [],
    };
  },

  toJSON(message: QueryProductInfoScRsp): unknown {
    const obj: any = {};
    message.retcode !== undefined &&
      (obj.retcode = Math.round(message.retcode));
    if (message.productList) {
      obj.productList = message.productList.map((e) =>
        e ? Product.toJSON(e) : undefined
      );
    } else {
      obj.productList = [];
    }
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<QueryProductInfoScRsp>, I>>(
    object: I
  ): QueryProductInfoScRsp {
    const message = createBaseQueryProductInfoScRsp();
    message.retcode = object.retcode ?? 0;
    message.productList =
      object.productList?.map((e) => Product.fromPartial(e)) || [];
    return message;
  },
};

function createBaseClientDownloadDataScNotify(): ClientDownloadDataScNotify {
  return { downloadData: undefined };
}

export const ClientDownloadDataScNotify = {
  encode(
    message: ClientDownloadDataScNotify,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.downloadData !== undefined) {
      ClientDownloadData.encode(
        message.downloadData,
        writer.uint32(10).fork()
      ).ldelim();
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): ClientDownloadDataScNotify {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseClientDownloadDataScNotify();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.downloadData = ClientDownloadData.decode(
            reader,
            reader.uint32()
          );
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): ClientDownloadDataScNotify {
    return {
      downloadData: isSet(object.downloadData)
        ? ClientDownloadData.fromJSON(object.downloadData)
        : undefined,
    };
  },

  toJSON(message: ClientDownloadDataScNotify): unknown {
    const obj: any = {};
    message.downloadData !== undefined &&
      (obj.downloadData = message.downloadData
        ? ClientDownloadData.toJSON(message.downloadData)
        : undefined);
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<ClientDownloadDataScNotify>, I>>(
    object: I
  ): ClientDownloadDataScNotify {
    const message = createBaseClientDownloadDataScNotify();
    message.downloadData =
      object.downloadData !== undefined && object.downloadData !== null
        ? ClientDownloadData.fromPartial(object.downloadData)
        : undefined;
    return message;
  },
};

function createBaseUpdateFeatureSwitchScNotify(): UpdateFeatureSwitchScNotify {
  return { switchInfoList: [] };
}

export const UpdateFeatureSwitchScNotify = {
  encode(
    message: UpdateFeatureSwitchScNotify,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    for (const v of message.switchInfoList) {
      FeatureSwitchInfo.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): UpdateFeatureSwitchScNotify {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateFeatureSwitchScNotify();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.switchInfoList.push(
            FeatureSwitchInfo.decode(reader, reader.uint32())
          );
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): UpdateFeatureSwitchScNotify {
    return {
      switchInfoList: Array.isArray(object?.switchInfoList)
        ? object.switchInfoList.map((e: any) => FeatureSwitchInfo.fromJSON(e))
        : [],
    };
  },

  toJSON(message: UpdateFeatureSwitchScNotify): unknown {
    const obj: any = {};
    if (message.switchInfoList) {
      obj.switchInfoList = message.switchInfoList.map((e) =>
        e ? FeatureSwitchInfo.toJSON(e) : undefined
      );
    } else {
      obj.switchInfoList = [];
    }
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<UpdateFeatureSwitchScNotify>, I>>(
    object: I
  ): UpdateFeatureSwitchScNotify {
    const message = createBaseUpdateFeatureSwitchScNotify();
    message.switchInfoList =
      object.switchInfoList?.map((e) => FeatureSwitchInfo.fromPartial(e)) || [];
    return message;
  },
};

function createBaseDailyRefreshNotify(): DailyRefreshNotify {
  return { curDay: 0 };
}

export const DailyRefreshNotify = {
  encode(
    message: DailyRefreshNotify,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.curDay !== 0) {
      writer.uint32(8).uint32(message.curDay);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): DailyRefreshNotify {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDailyRefreshNotify();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.curDay = reader.uint32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): DailyRefreshNotify {
    return {
      curDay: isSet(object.curDay) ? Number(object.curDay) : 0,
    };
  },

  toJSON(message: DailyRefreshNotify): unknown {
    const obj: any = {};
    message.curDay !== undefined && (obj.curDay = Math.round(message.curDay));
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<DailyRefreshNotify>, I>>(
    object: I
  ): DailyRefreshNotify {
    const message = createBaseDailyRefreshNotify();
    message.curDay = object.curDay ?? 0;
    return message;
  },
};

function createBaseFinishPlotCsReq(): FinishPlotCsReq {
  return { plotId: 0 };
}

export const FinishPlotCsReq = {
  encode(
    message: FinishPlotCsReq,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.plotId !== 0) {
      writer.uint32(8).uint32(message.plotId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): FinishPlotCsReq {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFinishPlotCsReq();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.plotId = reader.uint32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): FinishPlotCsReq {
    return {
      plotId: isSet(object.plotId) ? Number(object.plotId) : 0,
    };
  },

  toJSON(message: FinishPlotCsReq): unknown {
    const obj: any = {};
    message.plotId !== undefined && (obj.plotId = Math.round(message.plotId));
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<FinishPlotCsReq>, I>>(
    object: I
  ): FinishPlotCsReq {
    const message = createBaseFinishPlotCsReq();
    message.plotId = object.plotId ?? 0;
    return message;
  },
};

function createBaseFinishPlotScRsp(): FinishPlotScRsp {
  return { retcode: 0, plotId: 0 };
}

export const FinishPlotScRsp = {
  encode(
    message: FinishPlotScRsp,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.retcode !== 0) {
      writer.uint32(8).uint32(message.retcode);
    }
    if (message.plotId !== 0) {
      writer.uint32(16).uint32(message.plotId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): FinishPlotScRsp {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFinishPlotScRsp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.retcode = reader.uint32();
          break;
        case 2:
          message.plotId = reader.uint32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): FinishPlotScRsp {
    return {
      retcode: isSet(object.retcode) ? Number(object.retcode) : 0,
      plotId: isSet(object.plotId) ? Number(object.plotId) : 0,
    };
  },

  toJSON(message: FinishPlotScRsp): unknown {
    const obj: any = {};
    message.retcode !== undefined &&
      (obj.retcode = Math.round(message.retcode));
    message.plotId !== undefined && (obj.plotId = Math.round(message.plotId));
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<FinishPlotScRsp>, I>>(
    object: I
  ): FinishPlotScRsp {
    const message = createBaseFinishPlotScRsp();
    message.retcode = object.retcode ?? 0;
    message.plotId = object.plotId ?? 0;
    return message;
  },
};

function createBasePrestigeInfo(): PrestigeInfo {
  return { prestigeId: 0, level: 0, exp: 0, takenLevelList: [] };
}

export const PrestigeInfo = {
  encode(
    message: PrestigeInfo,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.prestigeId !== 0) {
      writer.uint32(8).uint32(message.prestigeId);
    }
    if (message.level !== 0) {
      writer.uint32(16).uint32(message.level);
    }
    if (message.exp !== 0) {
      writer.uint32(24).uint32(message.exp);
    }
    writer.uint32(34).fork();
    for (const v of message.takenLevelList) {
      writer.uint32(v);
    }
    writer.ldelim();
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): PrestigeInfo {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePrestigeInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.prestigeId = reader.uint32();
          break;
        case 2:
          message.level = reader.uint32();
          break;
        case 3:
          message.exp = reader.uint32();
          break;
        case 4:
          if ((tag & 7) === 2) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.takenLevelList.push(reader.uint32());
            }
          } else {
            message.takenLevelList.push(reader.uint32());
          }
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): PrestigeInfo {
    return {
      prestigeId: isSet(object.prestigeId) ? Number(object.prestigeId) : 0,
      level: isSet(object.level) ? Number(object.level) : 0,
      exp: isSet(object.exp) ? Number(object.exp) : 0,
      takenLevelList: Array.isArray(object?.takenLevelList)
        ? object.takenLevelList.map((e: any) => Number(e))
        : [],
    };
  },

  toJSON(message: PrestigeInfo): unknown {
    const obj: any = {};
    message.prestigeId !== undefined &&
      (obj.prestigeId = Math.round(message.prestigeId));
    message.level !== undefined && (obj.level = Math.round(message.level));
    message.exp !== undefined && (obj.exp = Math.round(message.exp));
    if (message.takenLevelList) {
      obj.takenLevelList = message.takenLevelList.map((e) => Math.round(e));
    } else {
      obj.takenLevelList = [];
    }
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<PrestigeInfo>, I>>(
    object: I
  ): PrestigeInfo {
    const message = createBasePrestigeInfo();
    message.prestigeId = object.prestigeId ?? 0;
    message.level = object.level ?? 0;
    message.exp = object.exp ?? 0;
    message.takenLevelList = object.takenLevelList?.map((e) => e) || [];
    return message;
  },
};

function createBaseGetPrestigeInfoCsReq(): GetPrestigeInfoCsReq {
  return { prestigeId: 0 };
}

export const GetPrestigeInfoCsReq = {
  encode(
    message: GetPrestigeInfoCsReq,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.prestigeId !== 0) {
      writer.uint32(8).uint32(message.prestigeId);
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): GetPrestigeInfoCsReq {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetPrestigeInfoCsReq();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.prestigeId = reader.uint32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): GetPrestigeInfoCsReq {
    return {
      prestigeId: isSet(object.prestigeId) ? Number(object.prestigeId) : 0,
    };
  },

  toJSON(message: GetPrestigeInfoCsReq): unknown {
    const obj: any = {};
    message.prestigeId !== undefined &&
      (obj.prestigeId = Math.round(message.prestigeId));
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<GetPrestigeInfoCsReq>, I>>(
    object: I
  ): GetPrestigeInfoCsReq {
    const message = createBaseGetPrestigeInfoCsReq();
    message.prestigeId = object.prestigeId ?? 0;
    return message;
  },
};

function createBaseGetPrestigeInfoScRsp(): GetPrestigeInfoScRsp {
  return { retcode: 0, prestigeInfo: undefined };
}

export const GetPrestigeInfoScRsp = {
  encode(
    message: GetPrestigeInfoScRsp,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.retcode !== 0) {
      writer.uint32(8).uint32(message.retcode);
    }
    if (message.prestigeInfo !== undefined) {
      PrestigeInfo.encode(
        message.prestigeInfo,
        writer.uint32(18).fork()
      ).ldelim();
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): GetPrestigeInfoScRsp {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetPrestigeInfoScRsp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.retcode = reader.uint32();
          break;
        case 2:
          message.prestigeInfo = PrestigeInfo.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): GetPrestigeInfoScRsp {
    return {
      retcode: isSet(object.retcode) ? Number(object.retcode) : 0,
      prestigeInfo: isSet(object.prestigeInfo)
        ? PrestigeInfo.fromJSON(object.prestigeInfo)
        : undefined,
    };
  },

  toJSON(message: GetPrestigeInfoScRsp): unknown {
    const obj: any = {};
    message.retcode !== undefined &&
      (obj.retcode = Math.round(message.retcode));
    message.prestigeInfo !== undefined &&
      (obj.prestigeInfo = message.prestigeInfo
        ? PrestigeInfo.toJSON(message.prestigeInfo)
        : undefined);
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<GetPrestigeInfoScRsp>, I>>(
    object: I
  ): GetPrestigeInfoScRsp {
    const message = createBaseGetPrestigeInfoScRsp();
    message.retcode = object.retcode ?? 0;
    message.prestigeInfo =
      object.prestigeInfo !== undefined && object.prestigeInfo !== null
        ? PrestigeInfo.fromPartial(object.prestigeInfo)
        : undefined;
    return message;
  },
};

function createBasePrestigeInfoChangeNotify(): PrestigeInfoChangeNotify {
  return { prestigeInfo: undefined };
}

export const PrestigeInfoChangeNotify = {
  encode(
    message: PrestigeInfoChangeNotify,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.prestigeInfo !== undefined) {
      PrestigeInfo.encode(
        message.prestigeInfo,
        writer.uint32(10).fork()
      ).ldelim();
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): PrestigeInfoChangeNotify {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePrestigeInfoChangeNotify();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.prestigeInfo = PrestigeInfo.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): PrestigeInfoChangeNotify {
    return {
      prestigeInfo: isSet(object.prestigeInfo)
        ? PrestigeInfo.fromJSON(object.prestigeInfo)
        : undefined,
    };
  },

  toJSON(message: PrestigeInfoChangeNotify): unknown {
    const obj: any = {};
    message.prestigeInfo !== undefined &&
      (obj.prestigeInfo = message.prestigeInfo
        ? PrestigeInfo.toJSON(message.prestigeInfo)
        : undefined);
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<PrestigeInfoChangeNotify>, I>>(
    object: I
  ): PrestigeInfoChangeNotify {
    const message = createBasePrestigeInfoChangeNotify();
    message.prestigeInfo =
      object.prestigeInfo !== undefined && object.prestigeInfo !== null
        ? PrestigeInfo.fromPartial(object.prestigeInfo)
        : undefined;
    return message;
  },
};

function createBaseTakePrestigeLevelRewardCsReq(): TakePrestigeLevelRewardCsReq {
  return { prestigeId: 0, level: 0 };
}

export const TakePrestigeLevelRewardCsReq = {
  encode(
    message: TakePrestigeLevelRewardCsReq,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.prestigeId !== 0) {
      writer.uint32(8).uint32(message.prestigeId);
    }
    if (message.level !== 0) {
      writer.uint32(16).uint32(message.level);
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): TakePrestigeLevelRewardCsReq {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTakePrestigeLevelRewardCsReq();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.prestigeId = reader.uint32();
          break;
        case 2:
          message.level = reader.uint32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): TakePrestigeLevelRewardCsReq {
    return {
      prestigeId: isSet(object.prestigeId) ? Number(object.prestigeId) : 0,
      level: isSet(object.level) ? Number(object.level) : 0,
    };
  },

  toJSON(message: TakePrestigeLevelRewardCsReq): unknown {
    const obj: any = {};
    message.prestigeId !== undefined &&
      (obj.prestigeId = Math.round(message.prestigeId));
    message.level !== undefined && (obj.level = Math.round(message.level));
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<TakePrestigeLevelRewardCsReq>, I>>(
    object: I
  ): TakePrestigeLevelRewardCsReq {
    const message = createBaseTakePrestigeLevelRewardCsReq();
    message.prestigeId = object.prestigeId ?? 0;
    message.level = object.level ?? 0;
    return message;
  },
};

function createBaseTakePrestigeLevelRewardScRsp(): TakePrestigeLevelRewardScRsp {
  return { retcode: 0, prestigeId: 0, reward: undefined };
}

export const TakePrestigeLevelRewardScRsp = {
  encode(
    message: TakePrestigeLevelRewardScRsp,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.retcode !== 0) {
      writer.uint32(8).uint32(message.retcode);
    }
    if (message.prestigeId !== 0) {
      writer.uint32(16).uint32(message.prestigeId);
    }
    if (message.reward !== undefined) {
      ItemList.encode(message.reward, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): TakePrestigeLevelRewardScRsp {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTakePrestigeLevelRewardScRsp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.retcode = reader.uint32();
          break;
        case 2:
          message.prestigeId = reader.uint32();
          break;
        case 3:
          message.reward = ItemList.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): TakePrestigeLevelRewardScRsp {
    return {
      retcode: isSet(object.retcode) ? Number(object.retcode) : 0,
      prestigeId: isSet(object.prestigeId) ? Number(object.prestigeId) : 0,
      reward: isSet(object.reward)
        ? ItemList.fromJSON(object.reward)
        : undefined,
    };
  },

  toJSON(message: TakePrestigeLevelRewardScRsp): unknown {
    const obj: any = {};
    message.retcode !== undefined &&
      (obj.retcode = Math.round(message.retcode));
    message.prestigeId !== undefined &&
      (obj.prestigeId = Math.round(message.prestigeId));
    message.reward !== undefined &&
      (obj.reward = message.reward
        ? ItemList.toJSON(message.reward)
        : undefined);
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<TakePrestigeLevelRewardScRsp>, I>>(
    object: I
  ): TakePrestigeLevelRewardScRsp {
    const message = createBaseTakePrestigeLevelRewardScRsp();
    message.retcode = object.retcode ?? 0;
    message.prestigeId = object.prestigeId ?? 0;
    message.reward =
      object.reward !== undefined && object.reward !== null
        ? ItemList.fromPartial(object.reward)
        : undefined;
    return message;
  },
};

function createBaseGetQuestDataCsReq(): GetQuestDataCsReq {
  return {};
}

export const GetQuestDataCsReq = {
  encode(
    _: GetQuestDataCsReq,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetQuestDataCsReq {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetQuestDataCsReq();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(_: any): GetQuestDataCsReq {
    return {};
  },

  toJSON(_: GetQuestDataCsReq): unknown {
    const obj: any = {};
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<GetQuestDataCsReq>, I>>(
    _: I
  ): GetQuestDataCsReq {
    const message = createBaseGetQuestDataCsReq();
    return message;
  },
};

function createBaseQuest(): Quest {
  return { id: 0, status: 0, progress: 0, finishTime: 0 };
}

export const Quest = {
  encode(message: Quest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== 0) {
      writer.uint32(8).uint32(message.id);
    }
    if (message.status !== 0) {
      writer.uint32(16).int32(message.status);
    }
    if (message.progress !== 0) {
      writer.uint32(24).uint32(message.progress);
    }
    if (message.finishTime !== 0) {
      writer.uint32(32).uint32(message.finishTime);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Quest {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQuest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.id = reader.uint32();
          break;
        case 2:
          message.status = reader.int32() as any;
          break;
        case 3:
          message.progress = reader.uint32();
          break;
        case 4:
          message.finishTime = reader.uint32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): Quest {
    return {
      id: isSet(object.id) ? Number(object.id) : 0,
      status: isSet(object.status) ? questStatusFromJSON(object.status) : 0,
      progress: isSet(object.progress) ? Number(object.progress) : 0,
      finishTime: isSet(object.finishTime) ? Number(object.finishTime) : 0,
    };
  },

  toJSON(message: Quest): unknown {
    const obj: any = {};
    message.id !== undefined && (obj.id = Math.round(message.id));
    message.status !== undefined &&
      (obj.status = questStatusToJSON(message.status));
    message.progress !== undefined &&
      (obj.progress = Math.round(message.progress));
    message.finishTime !== undefined &&
      (obj.finishTime = Math.round(message.finishTime));
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<Quest>, I>>(object: I): Quest {
    const message = createBaseQuest();
    message.id = object.id ?? 0;
    message.status = object.status ?? 0;
    message.progress = object.progress ?? 0;
    message.finishTime = object.finishTime ?? 0;
    return message;
  },
};

function createBaseGetQuestDataScRsp(): GetQuestDataScRsp {
  return {
    retcode: 0,
    questList: [],
    totalAchievementExp: 0,
    takenAchievementLevelList: [],
  };
}

export const GetQuestDataScRsp = {
  encode(
    message: GetQuestDataScRsp,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.retcode !== 0) {
      writer.uint32(8).uint32(message.retcode);
    }
    for (const v of message.questList) {
      Quest.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    if (message.totalAchievementExp !== 0) {
      writer.uint32(24).uint32(message.totalAchievementExp);
    }
    writer.uint32(34).fork();
    for (const v of message.takenAchievementLevelList) {
      writer.uint32(v);
    }
    writer.ldelim();
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetQuestDataScRsp {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetQuestDataScRsp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.retcode = reader.uint32();
          break;
        case 2:
          message.questList.push(Quest.decode(reader, reader.uint32()));
          break;
        case 3:
          message.totalAchievementExp = reader.uint32();
          break;
        case 4:
          if ((tag & 7) === 2) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.takenAchievementLevelList.push(reader.uint32());
            }
          } else {
            message.takenAchievementLevelList.push(reader.uint32());
          }
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): GetQuestDataScRsp {
    return {
      retcode: isSet(object.retcode) ? Number(object.retcode) : 0,
      questList: Array.isArray(object?.questList)
        ? object.questList.map((e: any) => Quest.fromJSON(e))
        : [],
      totalAchievementExp: isSet(object.totalAchievementExp)
        ? Number(object.totalAchievementExp)
        : 0,
      takenAchievementLevelList: Array.isArray(
        object?.takenAchievementLevelList
      )
        ? object.takenAchievementLevelList.map((e: any) => Number(e))
        : [],
    };
  },

  toJSON(message: GetQuestDataScRsp): unknown {
    const obj: any = {};
    message.retcode !== undefined &&
      (obj.retcode = Math.round(message.retcode));
    if (message.questList) {
      obj.questList = message.questList.map((e) =>
        e ? Quest.toJSON(e) : undefined
      );
    } else {
      obj.questList = [];
    }
    message.totalAchievementExp !== undefined &&
      (obj.totalAchievementExp = Math.round(message.totalAchievementExp));
    if (message.takenAchievementLevelList) {
      obj.takenAchievementLevelList = message.takenAchievementLevelList.map(
        (e) => Math.round(e)
      );
    } else {
      obj.takenAchievementLevelList = [];
    }
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<GetQuestDataScRsp>, I>>(
    object: I
  ): GetQuestDataScRsp {
    const message = createBaseGetQuestDataScRsp();
    message.retcode = object.retcode ?? 0;
    message.questList =
      object.questList?.map((e) => Quest.fromPartial(e)) || [];
    message.totalAchievementExp = object.totalAchievementExp ?? 0;
    message.takenAchievementLevelList =
      object.takenAchievementLevelList?.map((e) => e) || [];
    return message;
  },
};

function createBaseTakeQuestRewardCsReq(): TakeQuestRewardCsReq {
  return { questIdList: [] };
}

export const TakeQuestRewardCsReq = {
  encode(
    message: TakeQuestRewardCsReq,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    writer.uint32(10).fork();
    for (const v of message.questIdList) {
      writer.uint32(v);
    }
    writer.ldelim();
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): TakeQuestRewardCsReq {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTakeQuestRewardCsReq();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if ((tag & 7) === 2) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.questIdList.push(reader.uint32());
            }
          } else {
            message.questIdList.push(reader.uint32());
          }
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): TakeQuestRewardCsReq {
    return {
      questIdList: Array.isArray(object?.questIdList)
        ? object.questIdList.map((e: any) => Number(e))
        : [],
    };
  },

  toJSON(message: TakeQuestRewardCsReq): unknown {
    const obj: any = {};
    if (message.questIdList) {
      obj.questIdList = message.questIdList.map((e) => Math.round(e));
    } else {
      obj.questIdList = [];
    }
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<TakeQuestRewardCsReq>, I>>(
    object: I
  ): TakeQuestRewardCsReq {
    const message = createBaseTakeQuestRewardCsReq();
    message.questIdList = object.questIdList?.map((e) => e) || [];
    return message;
  },
};

function createBaseTakeQuestRewardScRsp(): TakeQuestRewardScRsp {
  return { retcode: 0, reward: undefined, succQuestIdList: [] };
}

export const TakeQuestRewardScRsp = {
  encode(
    message: TakeQuestRewardScRsp,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.retcode !== 0) {
      writer.uint32(8).uint32(message.retcode);
    }
    if (message.reward !== undefined) {
      ItemList.encode(message.reward, writer.uint32(18).fork()).ldelim();
    }
    writer.uint32(26).fork();
    for (const v of message.succQuestIdList) {
      writer.uint32(v);
    }
    writer.ldelim();
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): TakeQuestRewardScRsp {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTakeQuestRewardScRsp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.retcode = reader.uint32();
          break;
        case 2:
          message.reward = ItemList.decode(reader, reader.uint32());
          break;
        case 3:
          if ((tag & 7) === 2) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.succQuestIdList.push(reader.uint32());
            }
          } else {
            message.succQuestIdList.push(reader.uint32());
          }
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): TakeQuestRewardScRsp {
    return {
      retcode: isSet(object.retcode) ? Number(object.retcode) : 0,
      reward: isSet(object.reward)
        ? ItemList.fromJSON(object.reward)
        : undefined,
      succQuestIdList: Array.isArray(object?.succQuestIdList)
        ? object.succQuestIdList.map((e: any) => Number(e))
        : [],
    };
  },

  toJSON(message: TakeQuestRewardScRsp): unknown {
    const obj: any = {};
    message.retcode !== undefined &&
      (obj.retcode = Math.round(message.retcode));
    message.reward !== undefined &&
      (obj.reward = message.reward
        ? ItemList.toJSON(message.reward)
        : undefined);
    if (message.succQuestIdList) {
      obj.succQuestIdList = message.succQuestIdList.map((e) => Math.round(e));
    } else {
      obj.succQuestIdList = [];
    }
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<TakeQuestRewardScRsp>, I>>(
    object: I
  ): TakeQuestRewardScRsp {
    const message = createBaseTakeQuestRewardScRsp();
    message.retcode = object.retcode ?? 0;
    message.reward =
      object.reward !== undefined && object.reward !== null
        ? ItemList.fromPartial(object.reward)
        : undefined;
    message.succQuestIdList = object.succQuestIdList?.map((e) => e) || [];
    return message;
  },
};

function createBaseTakeAchievementLevelRewardCsReq(): TakeAchievementLevelRewardCsReq {
  return { achievementLevelList: [] };
}

export const TakeAchievementLevelRewardCsReq = {
  encode(
    message: TakeAchievementLevelRewardCsReq,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    writer.uint32(10).fork();
    for (const v of message.achievementLevelList) {
      writer.uint32(v);
    }
    writer.ldelim();
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): TakeAchievementLevelRewardCsReq {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTakeAchievementLevelRewardCsReq();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if ((tag & 7) === 2) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.achievementLevelList.push(reader.uint32());
            }
          } else {
            message.achievementLevelList.push(reader.uint32());
          }
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): TakeAchievementLevelRewardCsReq {
    return {
      achievementLevelList: Array.isArray(object?.achievementLevelList)
        ? object.achievementLevelList.map((e: any) => Number(e))
        : [],
    };
  },

  toJSON(message: TakeAchievementLevelRewardCsReq): unknown {
    const obj: any = {};
    if (message.achievementLevelList) {
      obj.achievementLevelList = message.achievementLevelList.map((e) =>
        Math.round(e)
      );
    } else {
      obj.achievementLevelList = [];
    }
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<TakeAchievementLevelRewardCsReq>, I>>(
    object: I
  ): TakeAchievementLevelRewardCsReq {
    const message = createBaseTakeAchievementLevelRewardCsReq();
    message.achievementLevelList =
      object.achievementLevelList?.map((e) => e) || [];
    return message;
  },
};

function createBaseTakeAchievementLevelRewardScRsp(): TakeAchievementLevelRewardScRsp {
  return { retcode: 0, reward: undefined, succAchievementLevelList: [] };
}

export const TakeAchievementLevelRewardScRsp = {
  encode(
    message: TakeAchievementLevelRewardScRsp,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.retcode !== 0) {
      writer.uint32(8).uint32(message.retcode);
    }
    if (message.reward !== undefined) {
      ItemList.encode(message.reward, writer.uint32(18).fork()).ldelim();
    }
    writer.uint32(26).fork();
    for (const v of message.succAchievementLevelList) {
      writer.uint32(v);
    }
    writer.ldelim();
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): TakeAchievementLevelRewardScRsp {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTakeAchievementLevelRewardScRsp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.retcode = reader.uint32();
          break;
        case 2:
          message.reward = ItemList.decode(reader, reader.uint32());
          break;
        case 3:
          if ((tag & 7) === 2) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.succAchievementLevelList.push(reader.uint32());
            }
          } else {
            message.succAchievementLevelList.push(reader.uint32());
          }
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): TakeAchievementLevelRewardScRsp {
    return {
      retcode: isSet(object.retcode) ? Number(object.retcode) : 0,
      reward: isSet(object.reward)
        ? ItemList.fromJSON(object.reward)
        : undefined,
      succAchievementLevelList: Array.isArray(object?.succAchievementLevelList)
        ? object.succAchievementLevelList.map((e: any) => Number(e))
        : [],
    };
  },

  toJSON(message: TakeAchievementLevelRewardScRsp): unknown {
    const obj: any = {};
    message.retcode !== undefined &&
      (obj.retcode = Math.round(message.retcode));
    message.reward !== undefined &&
      (obj.reward = message.reward
        ? ItemList.toJSON(message.reward)
        : undefined);
    if (message.succAchievementLevelList) {
      obj.succAchievementLevelList = message.succAchievementLevelList.map((e) =>
        Math.round(e)
      );
    } else {
      obj.succAchievementLevelList = [];
    }
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<TakeAchievementLevelRewardScRsp>, I>>(
    object: I
  ): TakeAchievementLevelRewardScRsp {
    const message = createBaseTakeAchievementLevelRewardScRsp();
    message.retcode = object.retcode ?? 0;
    message.reward =
      object.reward !== undefined && object.reward !== null
        ? ItemList.fromPartial(object.reward)
        : undefined;
    message.succAchievementLevelList =
      object.succAchievementLevelList?.map((e) => e) || [];
    return message;
  },
};

function createBaseStartRaidCsReq(): StartRaidCsReq {
  return { propEntityId: 0, raidId: 0, worldLevel: 0, avatarList: [] };
}

export const StartRaidCsReq = {
  encode(
    message: StartRaidCsReq,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.propEntityId !== 0) {
      writer.uint32(8).uint32(message.propEntityId);
    }
    if (message.raidId !== 0) {
      writer.uint32(16).uint32(message.raidId);
    }
    if (message.worldLevel !== 0) {
      writer.uint32(24).uint32(message.worldLevel);
    }
    writer.uint32(34).fork();
    for (const v of message.avatarList) {
      writer.uint32(v);
    }
    writer.ldelim();
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): StartRaidCsReq {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStartRaidCsReq();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.propEntityId = reader.uint32();
          break;
        case 2:
          message.raidId = reader.uint32();
          break;
        case 3:
          message.worldLevel = reader.uint32();
          break;
        case 4:
          if ((tag & 7) === 2) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.avatarList.push(reader.uint32());
            }
          } else {
            message.avatarList.push(reader.uint32());
          }
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): StartRaidCsReq {
    return {
      propEntityId: isSet(object.propEntityId)
        ? Number(object.propEntityId)
        : 0,
      raidId: isSet(object.raidId) ? Number(object.raidId) : 0,
      worldLevel: isSet(object.worldLevel) ? Number(object.worldLevel) : 0,
      avatarList: Array.isArray(object?.avatarList)
        ? object.avatarList.map((e: any) => Number(e))
        : [],
    };
  },

  toJSON(message: StartRaidCsReq): unknown {
    const obj: any = {};
    message.propEntityId !== undefined &&
      (obj.propEntityId = Math.round(message.propEntityId));
    message.raidId !== undefined && (obj.raidId = Math.round(message.raidId));
    message.worldLevel !== undefined &&
      (obj.worldLevel = Math.round(message.worldLevel));
    if (message.avatarList) {
      obj.avatarList = message.avatarList.map((e) => Math.round(e));
    } else {
      obj.avatarList = [];
    }
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<StartRaidCsReq>, I>>(
    object: I
  ): StartRaidCsReq {
    const message = createBaseStartRaidCsReq();
    message.propEntityId = object.propEntityId ?? 0;
    message.raidId = object.raidId ?? 0;
    message.worldLevel = object.worldLevel ?? 0;
    message.avatarList = object.avatarList?.map((e) => e) || [];
    return message;
  },
};

function createBaseStartRaidScRsp(): StartRaidScRsp {
  return { retcode: 0 };
}

export const StartRaidScRsp = {
  encode(
    message: StartRaidScRsp,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.retcode !== 0) {
      writer.uint32(8).uint32(message.retcode);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): StartRaidScRsp {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStartRaidScRsp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.retcode = reader.uint32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): StartRaidScRsp {
    return {
      retcode: isSet(object.retcode) ? Number(object.retcode) : 0,
    };
  },

  toJSON(message: StartRaidScRsp): unknown {
    const obj: any = {};
    message.retcode !== undefined &&
      (obj.retcode = Math.round(message.retcode));
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<StartRaidScRsp>, I>>(
    object: I
  ): StartRaidScRsp {
    const message = createBaseStartRaidScRsp();
    message.retcode = object.retcode ?? 0;
    return message;
  },
};

function createBaseLeaveRaidCsReq(): LeaveRaidCsReq {
  return { raidId: 0 };
}

export const LeaveRaidCsReq = {
  encode(
    message: LeaveRaidCsReq,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.raidId !== 0) {
      writer.uint32(8).uint32(message.raidId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): LeaveRaidCsReq {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLeaveRaidCsReq();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.raidId = reader.uint32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): LeaveRaidCsReq {
    return {
      raidId: isSet(object.raidId) ? Number(object.raidId) : 0,
    };
  },

  toJSON(message: LeaveRaidCsReq): unknown {
    const obj: any = {};
    message.raidId !== undefined && (obj.raidId = Math.round(message.raidId));
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<LeaveRaidCsReq>, I>>(
    object: I
  ): LeaveRaidCsReq {
    const message = createBaseLeaveRaidCsReq();
    message.raidId = object.raidId ?? 0;
    return message;
  },
};

function createBaseLeaveRaidScRsp(): LeaveRaidScRsp {
  return { retcode: 0 };
}

export const LeaveRaidScRsp = {
  encode(
    message: LeaveRaidScRsp,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.retcode !== 0) {
      writer.uint32(8).uint32(message.retcode);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): LeaveRaidScRsp {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLeaveRaidScRsp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.retcode = reader.uint32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): LeaveRaidScRsp {
    return {
      retcode: isSet(object.retcode) ? Number(object.retcode) : 0,
    };
  },

  toJSON(message: LeaveRaidScRsp): unknown {
    const obj: any = {};
    message.retcode !== undefined &&
      (obj.retcode = Math.round(message.retcode));
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<LeaveRaidScRsp>, I>>(
    object: I
  ): LeaveRaidScRsp {
    const message = createBaseLeaveRaidScRsp();
    message.retcode = object.retcode ?? 0;
    return message;
  },
};

function createBaseRaidInfoNotify(): RaidInfoNotify {
  return { raidId: 0, worldLevel: 0, status: 0, itemList: undefined };
}

export const RaidInfoNotify = {
  encode(
    message: RaidInfoNotify,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.raidId !== 0) {
      writer.uint32(8).uint32(message.raidId);
    }
    if (message.worldLevel !== 0) {
      writer.uint32(16).uint32(message.worldLevel);
    }
    if (message.status !== 0) {
      writer.uint32(24).int32(message.status);
    }
    if (message.itemList !== undefined) {
      ItemList.encode(message.itemList, writer.uint32(34).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): RaidInfoNotify {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRaidInfoNotify();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.raidId = reader.uint32();
          break;
        case 2:
          message.worldLevel = reader.uint32();
          break;
        case 3:
          message.status = reader.int32() as any;
          break;
        case 4:
          message.itemList = ItemList.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): RaidInfoNotify {
    return {
      raidId: isSet(object.raidId) ? Number(object.raidId) : 0,
      worldLevel: isSet(object.worldLevel) ? Number(object.worldLevel) : 0,
      status: isSet(object.status) ? raidStatusFromJSON(object.status) : 0,
      itemList: isSet(object.itemList)
        ? ItemList.fromJSON(object.itemList)
        : undefined,
    };
  },

  toJSON(message: RaidInfoNotify): unknown {
    const obj: any = {};
    message.raidId !== undefined && (obj.raidId = Math.round(message.raidId));
    message.worldLevel !== undefined &&
      (obj.worldLevel = Math.round(message.worldLevel));
    message.status !== undefined &&
      (obj.status = raidStatusToJSON(message.status));
    message.itemList !== undefined &&
      (obj.itemList = message.itemList
        ? ItemList.toJSON(message.itemList)
        : undefined);
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<RaidInfoNotify>, I>>(
    object: I
  ): RaidInfoNotify {
    const message = createBaseRaidInfoNotify();
    message.raidId = object.raidId ?? 0;
    message.worldLevel = object.worldLevel ?? 0;
    message.status = object.status ?? 0;
    message.itemList =
      object.itemList !== undefined && object.itemList !== null
        ? ItemList.fromPartial(object.itemList)
        : undefined;
    return message;
  },
};

function createBaseChallengeRaid(): ChallengeRaid {
  return { raidId: 0, maxScore: 0 };
}

export const ChallengeRaid = {
  encode(
    message: ChallengeRaid,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.raidId !== 0) {
      writer.uint32(8).uint32(message.raidId);
    }
    if (message.maxScore !== 0) {
      writer.uint32(16).uint32(message.maxScore);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ChallengeRaid {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseChallengeRaid();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.raidId = reader.uint32();
          break;
        case 2:
          message.maxScore = reader.uint32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): ChallengeRaid {
    return {
      raidId: isSet(object.raidId) ? Number(object.raidId) : 0,
      maxScore: isSet(object.maxScore) ? Number(object.maxScore) : 0,
    };
  },

  toJSON(message: ChallengeRaid): unknown {
    const obj: any = {};
    message.raidId !== undefined && (obj.raidId = Math.round(message.raidId));
    message.maxScore !== undefined &&
      (obj.maxScore = Math.round(message.maxScore));
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<ChallengeRaid>, I>>(
    object: I
  ): ChallengeRaid {
    const message = createBaseChallengeRaid();
    message.raidId = object.raidId ?? 0;
    message.maxScore = object.maxScore ?? 0;
    return message;
  },
};

function createBaseGetChallengeRaidInfoCsReq(): GetChallengeRaidInfoCsReq {
  return {};
}

export const GetChallengeRaidInfoCsReq = {
  encode(
    _: GetChallengeRaidInfoCsReq,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): GetChallengeRaidInfoCsReq {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetChallengeRaidInfoCsReq();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(_: any): GetChallengeRaidInfoCsReq {
    return {};
  },

  toJSON(_: GetChallengeRaidInfoCsReq): unknown {
    const obj: any = {};
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<GetChallengeRaidInfoCsReq>, I>>(
    _: I
  ): GetChallengeRaidInfoCsReq {
    const message = createBaseGetChallengeRaidInfoCsReq();
    return message;
  },
};

function createBaseGetChallengeRaidInfoScRsp(): GetChallengeRaidInfoScRsp {
  return { retcode: 0, challengeRaidList: [], takenRewardIdList: [] };
}

export const GetChallengeRaidInfoScRsp = {
  encode(
    message: GetChallengeRaidInfoScRsp,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.retcode !== 0) {
      writer.uint32(8).uint32(message.retcode);
    }
    for (const v of message.challengeRaidList) {
      ChallengeRaid.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    writer.uint32(26).fork();
    for (const v of message.takenRewardIdList) {
      writer.uint32(v);
    }
    writer.ldelim();
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): GetChallengeRaidInfoScRsp {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetChallengeRaidInfoScRsp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.retcode = reader.uint32();
          break;
        case 2:
          message.challengeRaidList.push(
            ChallengeRaid.decode(reader, reader.uint32())
          );
          break;
        case 3:
          if ((tag & 7) === 2) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.takenRewardIdList.push(reader.uint32());
            }
          } else {
            message.takenRewardIdList.push(reader.uint32());
          }
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): GetChallengeRaidInfoScRsp {
    return {
      retcode: isSet(object.retcode) ? Number(object.retcode) : 0,
      challengeRaidList: Array.isArray(object?.challengeRaidList)
        ? object.challengeRaidList.map((e: any) => ChallengeRaid.fromJSON(e))
        : [],
      takenRewardIdList: Array.isArray(object?.takenRewardIdList)
        ? object.takenRewardIdList.map((e: any) => Number(e))
        : [],
    };
  },

  toJSON(message: GetChallengeRaidInfoScRsp): unknown {
    const obj: any = {};
    message.retcode !== undefined &&
      (obj.retcode = Math.round(message.retcode));
    if (message.challengeRaidList) {
      obj.challengeRaidList = message.challengeRaidList.map((e) =>
        e ? ChallengeRaid.toJSON(e) : undefined
      );
    } else {
      obj.challengeRaidList = [];
    }
    if (message.takenRewardIdList) {
      obj.takenRewardIdList = message.takenRewardIdList.map((e) =>
        Math.round(e)
      );
    } else {
      obj.takenRewardIdList = [];
    }
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<GetChallengeRaidInfoScRsp>, I>>(
    object: I
  ): GetChallengeRaidInfoScRsp {
    const message = createBaseGetChallengeRaidInfoScRsp();
    message.retcode = object.retcode ?? 0;
    message.challengeRaidList =
      object.challengeRaidList?.map((e) => ChallengeRaid.fromPartial(e)) || [];
    message.takenRewardIdList = object.takenRewardIdList?.map((e) => e) || [];
    return message;
  },
};

function createBaseTakeChallengeRaidRewardCsReq(): TakeChallengeRaidRewardCsReq {
  return { rewardId: 0 };
}

export const TakeChallengeRaidRewardCsReq = {
  encode(
    message: TakeChallengeRaidRewardCsReq,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.rewardId !== 0) {
      writer.uint32(8).uint32(message.rewardId);
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): TakeChallengeRaidRewardCsReq {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTakeChallengeRaidRewardCsReq();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.rewardId = reader.uint32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): TakeChallengeRaidRewardCsReq {
    return {
      rewardId: isSet(object.rewardId) ? Number(object.rewardId) : 0,
    };
  },

  toJSON(message: TakeChallengeRaidRewardCsReq): unknown {
    const obj: any = {};
    message.rewardId !== undefined &&
      (obj.rewardId = Math.round(message.rewardId));
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<TakeChallengeRaidRewardCsReq>, I>>(
    object: I
  ): TakeChallengeRaidRewardCsReq {
    const message = createBaseTakeChallengeRaidRewardCsReq();
    message.rewardId = object.rewardId ?? 0;
    return message;
  },
};

function createBaseTakeChallengeRaidRewardScRsp(): TakeChallengeRaidRewardScRsp {
  return { retcode: 0, rewardId: 0, reward: undefined };
}

export const TakeChallengeRaidRewardScRsp = {
  encode(
    message: TakeChallengeRaidRewardScRsp,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.retcode !== 0) {
      writer.uint32(8).uint32(message.retcode);
    }
    if (message.rewardId !== 0) {
      writer.uint32(16).uint32(message.rewardId);
    }
    if (message.reward !== undefined) {
      ItemList.encode(message.reward, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): TakeChallengeRaidRewardScRsp {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTakeChallengeRaidRewardScRsp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.retcode = reader.uint32();
          break;
        case 2:
          message.rewardId = reader.uint32();
          break;
        case 3:
          message.reward = ItemList.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): TakeChallengeRaidRewardScRsp {
    return {
      retcode: isSet(object.retcode) ? Number(object.retcode) : 0,
      rewardId: isSet(object.rewardId) ? Number(object.rewardId) : 0,
      reward: isSet(object.reward)
        ? ItemList.fromJSON(object.reward)
        : undefined,
    };
  },

  toJSON(message: TakeChallengeRaidRewardScRsp): unknown {
    const obj: any = {};
    message.retcode !== undefined &&
      (obj.retcode = Math.round(message.retcode));
    message.rewardId !== undefined &&
      (obj.rewardId = Math.round(message.rewardId));
    message.reward !== undefined &&
      (obj.reward = message.reward
        ? ItemList.toJSON(message.reward)
        : undefined);
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<TakeChallengeRaidRewardScRsp>, I>>(
    object: I
  ): TakeChallengeRaidRewardScRsp {
    const message = createBaseTakeChallengeRaidRewardScRsp();
    message.retcode = object.retcode ?? 0;
    message.rewardId = object.rewardId ?? 0;
    message.reward =
      object.reward !== undefined && object.reward !== null
        ? ItemList.fromPartial(object.reward)
        : undefined;
    return message;
  },
};

function createBaseChallengeRaidNotify(): ChallengeRaidNotify {
  return { challengeRaid: undefined };
}

export const ChallengeRaidNotify = {
  encode(
    message: ChallengeRaidNotify,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.challengeRaid !== undefined) {
      ChallengeRaid.encode(
        message.challengeRaid,
        writer.uint32(10).fork()
      ).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ChallengeRaidNotify {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseChallengeRaidNotify();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.challengeRaid = ChallengeRaid.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): ChallengeRaidNotify {
    return {
      challengeRaid: isSet(object.challengeRaid)
        ? ChallengeRaid.fromJSON(object.challengeRaid)
        : undefined,
    };
  },

  toJSON(message: ChallengeRaidNotify): unknown {
    const obj: any = {};
    message.challengeRaid !== undefined &&
      (obj.challengeRaid = message.challengeRaid
        ? ChallengeRaid.toJSON(message.challengeRaid)
        : undefined);
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<ChallengeRaidNotify>, I>>(
    object: I
  ): ChallengeRaidNotify {
    const message = createBaseChallengeRaidNotify();
    message.challengeRaid =
      object.challengeRaid !== undefined && object.challengeRaid !== null
        ? ChallengeRaid.fromPartial(object.challengeRaid)
        : undefined;
    return message;
  },
};

function createBaseRogueBuff(): RogueBuff {
  return { buffId: 0, level: 0 };
}

export const RogueBuff = {
  encode(
    message: RogueBuff,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.buffId !== 0) {
      writer.uint32(8).uint32(message.buffId);
    }
    if (message.level !== 0) {
      writer.uint32(16).uint32(message.level);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): RogueBuff {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRogueBuff();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.buffId = reader.uint32();
          break;
        case 2:
          message.level = reader.uint32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): RogueBuff {
    return {
      buffId: isSet(object.buffId) ? Number(object.buffId) : 0,
      level: isSet(object.level) ? Number(object.level) : 0,
    };
  },

  toJSON(message: RogueBuff): unknown {
    const obj: any = {};
    message.buffId !== undefined && (obj.buffId = Math.round(message.buffId));
    message.level !== undefined && (obj.level = Math.round(message.level));
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<RogueBuff>, I>>(
    object: I
  ): RogueBuff {
    const message = createBaseRogueBuff();
    message.buffId = object.buffId ?? 0;
    message.level = object.level ?? 0;
    return message;
  },
};

function createBaseRogueBuffList(): RogueBuffList {
  return { buffList: [] };
}

export const RogueBuffList = {
  encode(
    message: RogueBuffList,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    for (const v of message.buffList) {
      RogueBuff.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): RogueBuffList {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRogueBuffList();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.buffList.push(RogueBuff.decode(reader, reader.uint32()));
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): RogueBuffList {
    return {
      buffList: Array.isArray(object?.buffList)
        ? object.buffList.map((e: any) => RogueBuff.fromJSON(e))
        : [],
    };
  },

  toJSON(message: RogueBuffList): unknown {
    const obj: any = {};
    if (message.buffList) {
      obj.buffList = message.buffList.map((e) =>
        e ? RogueBuff.toJSON(e) : undefined
      );
    } else {
      obj.buffList = [];
    }
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<RogueBuffList>, I>>(
    object: I
  ): RogueBuffList {
    const message = createBaseRogueBuffList();
    message.buffList =
      object.buffList?.map((e) => RogueBuff.fromPartial(e)) || [];
    return message;
  },
};

function createBaseRogueRoom(): RogueRoom {
  return { roomId: 0, status: 0, siteId: 0 };
}

export const RogueRoom = {
  encode(
    message: RogueRoom,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.roomId !== 0) {
      writer.uint32(8).uint32(message.roomId);
    }
    if (message.status !== 0) {
      writer.uint32(16).int32(message.status);
    }
    if (message.siteId !== 0) {
      writer.uint32(24).uint32(message.siteId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): RogueRoom {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRogueRoom();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.roomId = reader.uint32();
          break;
        case 2:
          message.status = reader.int32() as any;
          break;
        case 3:
          message.siteId = reader.uint32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): RogueRoom {
    return {
      roomId: isSet(object.roomId) ? Number(object.roomId) : 0,
      status: isSet(object.status) ? rogueRoomStatusFromJSON(object.status) : 0,
      siteId: isSet(object.siteId) ? Number(object.siteId) : 0,
    };
  },

  toJSON(message: RogueRoom): unknown {
    const obj: any = {};
    message.roomId !== undefined && (obj.roomId = Math.round(message.roomId));
    message.status !== undefined &&
      (obj.status = rogueRoomStatusToJSON(message.status));
    message.siteId !== undefined && (obj.siteId = Math.round(message.siteId));
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<RogueRoom>, I>>(
    object: I
  ): RogueRoom {
    const message = createBaseRogueRoom();
    message.roomId = object.roomId ?? 0;
    message.status = object.status ?? 0;
    message.siteId = object.siteId ?? 0;
    return message;
  },
};

function createBaseRogueLevel(): RogueLevel {
  return { levelId: 0, mapId: 0, roomList: [], curRoomId: 0 };
}

export const RogueLevel = {
  encode(
    message: RogueLevel,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.levelId !== 0) {
      writer.uint32(8).uint32(message.levelId);
    }
    if (message.mapId !== 0) {
      writer.uint32(16).uint32(message.mapId);
    }
    for (const v of message.roomList) {
      RogueRoom.encode(v!, writer.uint32(26).fork()).ldelim();
    }
    if (message.curRoomId !== 0) {
      writer.uint32(32).uint32(message.curRoomId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): RogueLevel {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRogueLevel();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.levelId = reader.uint32();
          break;
        case 2:
          message.mapId = reader.uint32();
          break;
        case 3:
          message.roomList.push(RogueRoom.decode(reader, reader.uint32()));
          break;
        case 4:
          message.curRoomId = reader.uint32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): RogueLevel {
    return {
      levelId: isSet(object.levelId) ? Number(object.levelId) : 0,
      mapId: isSet(object.mapId) ? Number(object.mapId) : 0,
      roomList: Array.isArray(object?.roomList)
        ? object.roomList.map((e: any) => RogueRoom.fromJSON(e))
        : [],
      curRoomId: isSet(object.curRoomId) ? Number(object.curRoomId) : 0,
    };
  },

  toJSON(message: RogueLevel): unknown {
    const obj: any = {};
    message.levelId !== undefined &&
      (obj.levelId = Math.round(message.levelId));
    message.mapId !== undefined && (obj.mapId = Math.round(message.mapId));
    if (message.roomList) {
      obj.roomList = message.roomList.map((e) =>
        e ? RogueRoom.toJSON(e) : undefined
      );
    } else {
      obj.roomList = [];
    }
    message.curRoomId !== undefined &&
      (obj.curRoomId = Math.round(message.curRoomId));
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<RogueLevel>, I>>(
    object: I
  ): RogueLevel {
    const message = createBaseRogueLevel();
    message.levelId = object.levelId ?? 0;
    message.mapId = object.mapId ?? 0;
    message.roomList =
      object.roomList?.map((e) => RogueRoom.fromPartial(e)) || [];
    message.curRoomId = object.curRoomId ?? 0;
    return message;
  },
};

function createBaseRogueBless(): RogueBless {
  return { blessId: 0, level: 0 };
}

export const RogueBless = {
  encode(
    message: RogueBless,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.blessId !== 0) {
      writer.uint32(8).uint32(message.blessId);
    }
    if (message.level !== 0) {
      writer.uint32(16).uint32(message.level);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): RogueBless {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRogueBless();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.blessId = reader.uint32();
          break;
        case 2:
          message.level = reader.uint32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): RogueBless {
    return {
      blessId: isSet(object.blessId) ? Number(object.blessId) : 0,
      level: isSet(object.level) ? Number(object.level) : 0,
    };
  },

  toJSON(message: RogueBless): unknown {
    const obj: any = {};
    message.blessId !== undefined &&
      (obj.blessId = Math.round(message.blessId));
    message.level !== undefined && (obj.level = Math.round(message.level));
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<RogueBless>, I>>(
    object: I
  ): RogueBless {
    const message = createBaseRogueBless();
    message.blessId = object.blessId ?? 0;
    message.level = object.level ?? 0;
    return message;
  },
};

function createBaseRogueBlessInfo(): RogueBlessInfo {
  return {
    blessList: [],
    activeBlessId: 0,
    bless: undefined,
    monsterKillCount: 0,
  };
}

export const RogueBlessInfo = {
  encode(
    message: RogueBlessInfo,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    for (const v of message.blessList) {
      RogueBless.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    if (message.activeBlessId !== 0) {
      writer.uint32(16).uint32(message.activeBlessId);
    }
    if (message.bless !== undefined) {
      RogueBless.encode(message.bless, writer.uint32(26).fork()).ldelim();
    }
    if (message.monsterKillCount !== 0) {
      writer.uint32(32).uint32(message.monsterKillCount);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): RogueBlessInfo {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRogueBlessInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.blessList.push(RogueBless.decode(reader, reader.uint32()));
          break;
        case 2:
          message.activeBlessId = reader.uint32();
          break;
        case 3:
          message.bless = RogueBless.decode(reader, reader.uint32());
          break;
        case 4:
          message.monsterKillCount = reader.uint32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): RogueBlessInfo {
    return {
      blessList: Array.isArray(object?.blessList)
        ? object.blessList.map((e: any) => RogueBless.fromJSON(e))
        : [],
      activeBlessId: isSet(object.activeBlessId)
        ? Number(object.activeBlessId)
        : 0,
      bless: isSet(object.bless)
        ? RogueBless.fromJSON(object.bless)
        : undefined,
      monsterKillCount: isSet(object.monsterKillCount)
        ? Number(object.monsterKillCount)
        : 0,
    };
  },

  toJSON(message: RogueBlessInfo): unknown {
    const obj: any = {};
    if (message.blessList) {
      obj.blessList = message.blessList.map((e) =>
        e ? RogueBless.toJSON(e) : undefined
      );
    } else {
      obj.blessList = [];
    }
    message.activeBlessId !== undefined &&
      (obj.activeBlessId = Math.round(message.activeBlessId));
    message.bless !== undefined &&
      (obj.bless = message.bless
        ? RogueBless.toJSON(message.bless)
        : undefined);
    message.monsterKillCount !== undefined &&
      (obj.monsterKillCount = Math.round(message.monsterKillCount));
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<RogueBlessInfo>, I>>(
    object: I
  ): RogueBlessInfo {
    const message = createBaseRogueBlessInfo();
    message.blessList =
      object.blessList?.map((e) => RogueBless.fromPartial(e)) || [];
    message.activeBlessId = object.activeBlessId ?? 0;
    message.bless =
      object.bless !== undefined && object.bless !== null
        ? RogueBless.fromPartial(object.bless)
        : undefined;
    message.monsterKillCount = object.monsterKillCount ?? 0;
    return message;
  },
};

function createBaseRogueBuffSelectInfo(): RogueBuffSelectInfo {
  return {
    rollBuffCount: 0,
    rogueCoin: 0,
    leftSelectCount: 0,
    mazeBuffList: [],
    rollBuffMaxCount: 0,
    rollBuffCostData: undefined,
  };
}

export const RogueBuffSelectInfo = {
  encode(
    message: RogueBuffSelectInfo,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.rollBuffCount !== 0) {
      writer.uint32(8).uint32(message.rollBuffCount);
    }
    if (message.rogueCoin !== 0) {
      writer.uint32(16).uint32(message.rogueCoin);
    }
    if (message.leftSelectCount !== 0) {
      writer.uint32(24).uint32(message.leftSelectCount);
    }
    for (const v of message.mazeBuffList) {
      RogueBuff.encode(v!, writer.uint32(34).fork()).ldelim();
    }
    if (message.rollBuffMaxCount !== 0) {
      writer.uint32(40).uint32(message.rollBuffMaxCount);
    }
    if (message.rollBuffCostData !== undefined) {
      ItemCostData.encode(
        message.rollBuffCostData,
        writer.uint32(50).fork()
      ).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): RogueBuffSelectInfo {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRogueBuffSelectInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.rollBuffCount = reader.uint32();
          break;
        case 2:
          message.rogueCoin = reader.uint32();
          break;
        case 3:
          message.leftSelectCount = reader.uint32();
          break;
        case 4:
          message.mazeBuffList.push(RogueBuff.decode(reader, reader.uint32()));
          break;
        case 5:
          message.rollBuffMaxCount = reader.uint32();
          break;
        case 6:
          message.rollBuffCostData = ItemCostData.decode(
            reader,
            reader.uint32()
          );
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): RogueBuffSelectInfo {
    return {
      rollBuffCount: isSet(object.rollBuffCount)
        ? Number(object.rollBuffCount)
        : 0,
      rogueCoin: isSet(object.rogueCoin) ? Number(object.rogueCoin) : 0,
      leftSelectCount: isSet(object.leftSelectCount)
        ? Number(object.leftSelectCount)
        : 0,
      mazeBuffList: Array.isArray(object?.mazeBuffList)
        ? object.mazeBuffList.map((e: any) => RogueBuff.fromJSON(e))
        : [],
      rollBuffMaxCount: isSet(object.rollBuffMaxCount)
        ? Number(object.rollBuffMaxCount)
        : 0,
      rollBuffCostData: isSet(object.rollBuffCostData)
        ? ItemCostData.fromJSON(object.rollBuffCostData)
        : undefined,
    };
  },

  toJSON(message: RogueBuffSelectInfo): unknown {
    const obj: any = {};
    message.rollBuffCount !== undefined &&
      (obj.rollBuffCount = Math.round(message.rollBuffCount));
    message.rogueCoin !== undefined &&
      (obj.rogueCoin = Math.round(message.rogueCoin));
    message.leftSelectCount !== undefined &&
      (obj.leftSelectCount = Math.round(message.leftSelectCount));
    if (message.mazeBuffList) {
      obj.mazeBuffList = message.mazeBuffList.map((e) =>
        e ? RogueBuff.toJSON(e) : undefined
      );
    } else {
      obj.mazeBuffList = [];
    }
    message.rollBuffMaxCount !== undefined &&
      (obj.rollBuffMaxCount = Math.round(message.rollBuffMaxCount));
    message.rollBuffCostData !== undefined &&
      (obj.rollBuffCostData = message.rollBuffCostData
        ? ItemCostData.toJSON(message.rollBuffCostData)
        : undefined);
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<RogueBuffSelectInfo>, I>>(
    object: I
  ): RogueBuffSelectInfo {
    const message = createBaseRogueBuffSelectInfo();
    message.rollBuffCount = object.rollBuffCount ?? 0;
    message.rogueCoin = object.rogueCoin ?? 0;
    message.leftSelectCount = object.leftSelectCount ?? 0;
    message.mazeBuffList =
      object.mazeBuffList?.map((e) => RogueBuff.fromPartial(e)) || [];
    message.rollBuffMaxCount = object.rollBuffMaxCount ?? 0;
    message.rollBuffCostData =
      object.rollBuffCostData !== undefined && object.rollBuffCostData !== null
        ? ItemCostData.fromPartial(object.rollBuffCostData)
        : undefined;
    return message;
  },
};

function createBaseRogueShopBuff(): RogueShopBuff {
  return { buffInfo: undefined, totalCount: 0, leftCount: 0 };
}

export const RogueShopBuff = {
  encode(
    message: RogueShopBuff,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.buffInfo !== undefined) {
      RogueBuff.encode(message.buffInfo, writer.uint32(10).fork()).ldelim();
    }
    if (message.totalCount !== 0) {
      writer.uint32(16).uint32(message.totalCount);
    }
    if (message.leftCount !== 0) {
      writer.uint32(24).uint32(message.leftCount);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): RogueShopBuff {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRogueShopBuff();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.buffInfo = RogueBuff.decode(reader, reader.uint32());
          break;
        case 2:
          message.totalCount = reader.uint32();
          break;
        case 3:
          message.leftCount = reader.uint32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): RogueShopBuff {
    return {
      buffInfo: isSet(object.buffInfo)
        ? RogueBuff.fromJSON(object.buffInfo)
        : undefined,
      totalCount: isSet(object.totalCount) ? Number(object.totalCount) : 0,
      leftCount: isSet(object.leftCount) ? Number(object.leftCount) : 0,
    };
  },

  toJSON(message: RogueShopBuff): unknown {
    const obj: any = {};
    message.buffInfo !== undefined &&
      (obj.buffInfo = message.buffInfo
        ? RogueBuff.toJSON(message.buffInfo)
        : undefined);
    message.totalCount !== undefined &&
      (obj.totalCount = Math.round(message.totalCount));
    message.leftCount !== undefined &&
      (obj.leftCount = Math.round(message.leftCount));
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<RogueShopBuff>, I>>(
    object: I
  ): RogueShopBuff {
    const message = createBaseRogueShopBuff();
    message.buffInfo =
      object.buffInfo !== undefined && object.buffInfo !== null
        ? RogueBuff.fromPartial(object.buffInfo)
        : undefined;
    message.totalCount = object.totalCount ?? 0;
    message.leftCount = object.leftCount ?? 0;
    return message;
  },
};

function createBaseRogueShopItem(): RogueShopItem {
  return { itemId: 0, totalCount: 0, leftCount: 0, costData: undefined };
}

export const RogueShopItem = {
  encode(
    message: RogueShopItem,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.itemId !== 0) {
      writer.uint32(8).uint32(message.itemId);
    }
    if (message.totalCount !== 0) {
      writer.uint32(16).uint32(message.totalCount);
    }
    if (message.leftCount !== 0) {
      writer.uint32(24).uint32(message.leftCount);
    }
    if (message.costData !== undefined) {
      ItemCostData.encode(message.costData, writer.uint32(34).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): RogueShopItem {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRogueShopItem();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.itemId = reader.uint32();
          break;
        case 2:
          message.totalCount = reader.uint32();
          break;
        case 3:
          message.leftCount = reader.uint32();
          break;
        case 4:
          message.costData = ItemCostData.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): RogueShopItem {
    return {
      itemId: isSet(object.itemId) ? Number(object.itemId) : 0,
      totalCount: isSet(object.totalCount) ? Number(object.totalCount) : 0,
      leftCount: isSet(object.leftCount) ? Number(object.leftCount) : 0,
      costData: isSet(object.costData)
        ? ItemCostData.fromJSON(object.costData)
        : undefined,
    };
  },

  toJSON(message: RogueShopItem): unknown {
    const obj: any = {};
    message.itemId !== undefined && (obj.itemId = Math.round(message.itemId));
    message.totalCount !== undefined &&
      (obj.totalCount = Math.round(message.totalCount));
    message.leftCount !== undefined &&
      (obj.leftCount = Math.round(message.leftCount));
    message.costData !== undefined &&
      (obj.costData = message.costData
        ? ItemCostData.toJSON(message.costData)
        : undefined);
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<RogueShopItem>, I>>(
    object: I
  ): RogueShopItem {
    const message = createBaseRogueShopItem();
    message.itemId = object.itemId ?? 0;
    message.totalCount = object.totalCount ?? 0;
    message.leftCount = object.leftCount ?? 0;
    message.costData =
      object.costData !== undefined && object.costData !== null
        ? ItemCostData.fromPartial(object.costData)
        : undefined;
    return message;
  },
};

function createBaseRogueShopInfo(): RogueShopInfo {
  return { rogueShopId: 0, shopBuffList: [], shopItemList: [] };
}

export const RogueShopInfo = {
  encode(
    message: RogueShopInfo,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.rogueShopId !== 0) {
      writer.uint32(8).uint32(message.rogueShopId);
    }
    for (const v of message.shopBuffList) {
      RogueShopBuff.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    for (const v of message.shopItemList) {
      RogueShopItem.encode(v!, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): RogueShopInfo {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRogueShopInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.rogueShopId = reader.uint32();
          break;
        case 2:
          message.shopBuffList.push(
            RogueShopBuff.decode(reader, reader.uint32())
          );
          break;
        case 3:
          message.shopItemList.push(
            RogueShopItem.decode(reader, reader.uint32())
          );
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): RogueShopInfo {
    return {
      rogueShopId: isSet(object.rogueShopId) ? Number(object.rogueShopId) : 0,
      shopBuffList: Array.isArray(object?.shopBuffList)
        ? object.shopBuffList.map((e: any) => RogueShopBuff.fromJSON(e))
        : [],
      shopItemList: Array.isArray(object?.shopItemList)
        ? object.shopItemList.map((e: any) => RogueShopItem.fromJSON(e))
        : [],
    };
  },

  toJSON(message: RogueShopInfo): unknown {
    const obj: any = {};
    message.rogueShopId !== undefined &&
      (obj.rogueShopId = Math.round(message.rogueShopId));
    if (message.shopBuffList) {
      obj.shopBuffList = message.shopBuffList.map((e) =>
        e ? RogueShopBuff.toJSON(e) : undefined
      );
    } else {
      obj.shopBuffList = [];
    }
    if (message.shopItemList) {
      obj.shopItemList = message.shopItemList.map((e) =>
        e ? RogueShopItem.toJSON(e) : undefined
      );
    } else {
      obj.shopItemList = [];
    }
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<RogueShopInfo>, I>>(
    object: I
  ): RogueShopInfo {
    const message = createBaseRogueShopInfo();
    message.rogueShopId = object.rogueShopId ?? 0;
    message.shopBuffList =
      object.shopBuffList?.map((e) => RogueShopBuff.fromPartial(e)) || [];
    message.shopItemList =
      object.shopItemList?.map((e) => RogueShopItem.fromPartial(e)) || [];
    return message;
  },
};

function createBaseRogueAppraisalRecord(): RogueAppraisalRecord {
  return { groupId: 0, configId: 0, appraisalCount: 0 };
}

export const RogueAppraisalRecord = {
  encode(
    message: RogueAppraisalRecord,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.groupId !== 0) {
      writer.uint32(8).uint32(message.groupId);
    }
    if (message.configId !== 0) {
      writer.uint32(16).uint32(message.configId);
    }
    if (message.appraisalCount !== 0) {
      writer.uint32(24).uint32(message.appraisalCount);
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): RogueAppraisalRecord {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRogueAppraisalRecord();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.groupId = reader.uint32();
          break;
        case 2:
          message.configId = reader.uint32();
          break;
        case 3:
          message.appraisalCount = reader.uint32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): RogueAppraisalRecord {
    return {
      groupId: isSet(object.groupId) ? Number(object.groupId) : 0,
      configId: isSet(object.configId) ? Number(object.configId) : 0,
      appraisalCount: isSet(object.appraisalCount)
        ? Number(object.appraisalCount)
        : 0,
    };
  },

  toJSON(message: RogueAppraisalRecord): unknown {
    const obj: any = {};
    message.groupId !== undefined &&
      (obj.groupId = Math.round(message.groupId));
    message.configId !== undefined &&
      (obj.configId = Math.round(message.configId));
    message.appraisalCount !== undefined &&
      (obj.appraisalCount = Math.round(message.appraisalCount));
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<RogueAppraisalRecord>, I>>(
    object: I
  ): RogueAppraisalRecord {
    const message = createBaseRogueAppraisalRecord();
    message.groupId = object.groupId ?? 0;
    message.configId = object.configId ?? 0;
    message.appraisalCount = object.appraisalCount ?? 0;
    return message;
  },
};

function createBaseRogueAppraisalInfo(): RogueAppraisalInfo {
  return { appraisalList: [] };
}

export const RogueAppraisalInfo = {
  encode(
    message: RogueAppraisalInfo,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    for (const v of message.appraisalList) {
      RogueAppraisalRecord.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): RogueAppraisalInfo {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRogueAppraisalInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.appraisalList.push(
            RogueAppraisalRecord.decode(reader, reader.uint32())
          );
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): RogueAppraisalInfo {
    return {
      appraisalList: Array.isArray(object?.appraisalList)
        ? object.appraisalList.map((e: any) => RogueAppraisalRecord.fromJSON(e))
        : [],
    };
  },

  toJSON(message: RogueAppraisalInfo): unknown {
    const obj: any = {};
    if (message.appraisalList) {
      obj.appraisalList = message.appraisalList.map((e) =>
        e ? RogueAppraisalRecord.toJSON(e) : undefined
      );
    } else {
      obj.appraisalList = [];
    }
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<RogueAppraisalInfo>, I>>(
    object: I
  ): RogueAppraisalInfo {
    const message = createBaseRogueAppraisalInfo();
    message.appraisalList =
      object.appraisalList?.map((e) => RogueAppraisalRecord.fromPartial(e)) ||
      [];
    return message;
  },
};

function createBaseRogueAppraisalItem(): RogueAppraisalItem {
  return { itemId: 0, succRatio: 0, perfectRatio: 0 };
}

export const RogueAppraisalItem = {
  encode(
    message: RogueAppraisalItem,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.itemId !== 0) {
      writer.uint32(8).uint32(message.itemId);
    }
    if (message.succRatio !== 0) {
      writer.uint32(21).float(message.succRatio);
    }
    if (message.perfectRatio !== 0) {
      writer.uint32(29).float(message.perfectRatio);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): RogueAppraisalItem {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRogueAppraisalItem();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.itemId = reader.uint32();
          break;
        case 2:
          message.succRatio = reader.float();
          break;
        case 3:
          message.perfectRatio = reader.float();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): RogueAppraisalItem {
    return {
      itemId: isSet(object.itemId) ? Number(object.itemId) : 0,
      succRatio: isSet(object.succRatio) ? Number(object.succRatio) : 0,
      perfectRatio: isSet(object.perfectRatio)
        ? Number(object.perfectRatio)
        : 0,
    };
  },

  toJSON(message: RogueAppraisalItem): unknown {
    const obj: any = {};
    message.itemId !== undefined && (obj.itemId = Math.round(message.itemId));
    message.succRatio !== undefined && (obj.succRatio = message.succRatio);
    message.perfectRatio !== undefined &&
      (obj.perfectRatio = message.perfectRatio);
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<RogueAppraisalItem>, I>>(
    object: I
  ): RogueAppraisalItem {
    const message = createBaseRogueAppraisalItem();
    message.itemId = object.itemId ?? 0;
    message.succRatio = object.succRatio ?? 0;
    message.perfectRatio = object.perfectRatio ?? 0;
    return message;
  },
};

function createBaseRogueAppraisalItemInfo(): RogueAppraisalItemInfo {
  return { itemList: [] };
}

export const RogueAppraisalItemInfo = {
  encode(
    message: RogueAppraisalItemInfo,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    for (const v of message.itemList) {
      RogueAppraisalItem.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): RogueAppraisalItemInfo {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRogueAppraisalItemInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.itemList.push(
            RogueAppraisalItem.decode(reader, reader.uint32())
          );
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): RogueAppraisalItemInfo {
    return {
      itemList: Array.isArray(object?.itemList)
        ? object.itemList.map((e: any) => RogueAppraisalItem.fromJSON(e))
        : [],
    };
  },

  toJSON(message: RogueAppraisalItemInfo): unknown {
    const obj: any = {};
    if (message.itemList) {
      obj.itemList = message.itemList.map((e) =>
        e ? RogueAppraisalItem.toJSON(e) : undefined
      );
    } else {
      obj.itemList = [];
    }
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<RogueAppraisalItemInfo>, I>>(
    object: I
  ): RogueAppraisalItemInfo {
    const message = createBaseRogueAppraisalItemInfo();
    message.itemList =
      object.itemList?.map((e) => RogueAppraisalItem.fromPartial(e)) || [];
    return message;
  },
};

function createBaseRogueQuest(): RogueQuest {
  return {
    rogueQuestId: 0,
    worldLevel: 0,
    progress: 0,
    status: 0,
    beginTime: 0,
    endTime: 0,
    type: 0,
  };
}

export const RogueQuest = {
  encode(
    message: RogueQuest,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.rogueQuestId !== 0) {
      writer.uint32(8).uint32(message.rogueQuestId);
    }
    if (message.worldLevel !== 0) {
      writer.uint32(16).int32(message.worldLevel);
    }
    if (message.progress !== 0) {
      writer.uint32(24).uint32(message.progress);
    }
    if (message.status !== 0) {
      writer.uint32(32).int32(message.status);
    }
    if (message.beginTime !== 0) {
      writer.uint32(40).uint32(message.beginTime);
    }
    if (message.endTime !== 0) {
      writer.uint32(48).uint32(message.endTime);
    }
    if (message.type !== 0) {
      writer.uint32(56).int32(message.type);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): RogueQuest {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRogueQuest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.rogueQuestId = reader.uint32();
          break;
        case 2:
          message.worldLevel = reader.int32();
          break;
        case 3:
          message.progress = reader.uint32();
          break;
        case 4:
          message.status = reader.int32() as any;
          break;
        case 5:
          message.beginTime = reader.uint32();
          break;
        case 6:
          message.endTime = reader.uint32();
          break;
        case 7:
          message.type = reader.int32() as any;
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): RogueQuest {
    return {
      rogueQuestId: isSet(object.rogueQuestId)
        ? Number(object.rogueQuestId)
        : 0,
      worldLevel: isSet(object.worldLevel) ? Number(object.worldLevel) : 0,
      progress: isSet(object.progress) ? Number(object.progress) : 0,
      status: isSet(object.status)
        ? rogueQuestStatusFromJSON(object.status)
        : 0,
      beginTime: isSet(object.beginTime) ? Number(object.beginTime) : 0,
      endTime: isSet(object.endTime) ? Number(object.endTime) : 0,
      type: isSet(object.type) ? rogueQuestTypeFromJSON(object.type) : 0,
    };
  },

  toJSON(message: RogueQuest): unknown {
    const obj: any = {};
    message.rogueQuestId !== undefined &&
      (obj.rogueQuestId = Math.round(message.rogueQuestId));
    message.worldLevel !== undefined &&
      (obj.worldLevel = Math.round(message.worldLevel));
    message.progress !== undefined &&
      (obj.progress = Math.round(message.progress));
    message.status !== undefined &&
      (obj.status = rogueQuestStatusToJSON(message.status));
    message.beginTime !== undefined &&
      (obj.beginTime = Math.round(message.beginTime));
    message.endTime !== undefined &&
      (obj.endTime = Math.round(message.endTime));
    message.type !== undefined &&
      (obj.type = rogueQuestTypeToJSON(message.type));
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<RogueQuest>, I>>(
    object: I
  ): RogueQuest {
    const message = createBaseRogueQuest();
    message.rogueQuestId = object.rogueQuestId ?? 0;
    message.worldLevel = object.worldLevel ?? 0;
    message.progress = object.progress ?? 0;
    message.status = object.status ?? 0;
    message.beginTime = object.beginTime ?? 0;
    message.endTime = object.endTime ?? 0;
    message.type = object.type ?? 0;
    return message;
  },
};

function createBaseRogueInfo(): RogueInfo {
  return {
    status: 0,
    levelInfo: undefined,
    roomList: [],
    rogueCoin: 0,
    baseAvatarIdList: [],
    rogueStamina: 0,
    reviveCount: 0,
    recoverStaminaCount: 0,
    isRecordSaved: false,
    exploreRewardList: [],
    seasonId: 0,
    beginTime: 0,
    endTime: 0,
    isWin: false,
    mazeBuffList: [],
    extraBuffList: [],
    rogueExploreExp: 0,
    rogueExploreLv: 0,
    buffSelectInfo: undefined,
    isPickAvatar: false,
    blessInfo: undefined,
    buffScore: 0,
    appraisalInfo: undefined,
    worldLevel: 0,
    rogueGachaItemNumOnEnter: 0,
    rogueQuestList: [],
  };
}

export const RogueInfo = {
  encode(
    message: RogueInfo,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.status !== 0) {
      writer.uint32(8).int32(message.status);
    }
    if (message.levelInfo !== undefined) {
      RogueLevel.encode(message.levelInfo, writer.uint32(18).fork()).ldelim();
    }
    for (const v of message.roomList) {
      RogueRoom.encode(v!, writer.uint32(26).fork()).ldelim();
    }
    if (message.rogueCoin !== 0) {
      writer.uint32(32).uint32(message.rogueCoin);
    }
    writer.uint32(42).fork();
    for (const v of message.baseAvatarIdList) {
      writer.uint32(v);
    }
    writer.ldelim();
    if (message.rogueStamina !== 0) {
      writer.uint32(48).uint32(message.rogueStamina);
    }
    if (message.reviveCount !== 0) {
      writer.uint32(56).uint32(message.reviveCount);
    }
    if (message.recoverStaminaCount !== 0) {
      writer.uint32(64).uint32(message.recoverStaminaCount);
    }
    if (message.isRecordSaved === true) {
      writer.uint32(72).bool(message.isRecordSaved);
    }
    writer.uint32(82).fork();
    for (const v of message.exploreRewardList) {
      writer.uint32(v);
    }
    writer.ldelim();
    if (message.seasonId !== 0) {
      writer.uint32(88).uint32(message.seasonId);
    }
    if (message.beginTime !== 0) {
      writer.uint32(96).uint32(message.beginTime);
    }
    if (message.endTime !== 0) {
      writer.uint32(104).uint32(message.endTime);
    }
    if (message.isWin === true) {
      writer.uint32(112).bool(message.isWin);
    }
    for (const v of message.mazeBuffList) {
      RogueBuff.encode(v!, writer.uint32(122).fork()).ldelim();
    }
    for (const v of message.extraBuffList) {
      RogueBuff.encode(v!, writer.uint32(130).fork()).ldelim();
    }
    if (message.rogueExploreExp !== 0) {
      writer.uint32(136).uint32(message.rogueExploreExp);
    }
    if (message.rogueExploreLv !== 0) {
      writer.uint32(144).uint32(message.rogueExploreLv);
    }
    if (message.buffSelectInfo !== undefined) {
      RogueBuffSelectInfo.encode(
        message.buffSelectInfo,
        writer.uint32(154).fork()
      ).ldelim();
    }
    if (message.isPickAvatar === true) {
      writer.uint32(160).bool(message.isPickAvatar);
    }
    if (message.blessInfo !== undefined) {
      RogueBlessInfo.encode(
        message.blessInfo,
        writer.uint32(170).fork()
      ).ldelim();
    }
    if (message.buffScore !== 0) {
      writer.uint32(176).uint32(message.buffScore);
    }
    if (message.appraisalInfo !== undefined) {
      RogueAppraisalInfo.encode(
        message.appraisalInfo,
        writer.uint32(186).fork()
      ).ldelim();
    }
    if (message.worldLevel !== 0) {
      writer.uint32(192).int32(message.worldLevel);
    }
    if (message.rogueGachaItemNumOnEnter !== 0) {
      writer.uint32(200).uint32(message.rogueGachaItemNumOnEnter);
    }
    for (const v of message.rogueQuestList) {
      RogueQuest.encode(v!, writer.uint32(210).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): RogueInfo {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRogueInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.status = reader.int32() as any;
          break;
        case 2:
          message.levelInfo = RogueLevel.decode(reader, reader.uint32());
          break;
        case 3:
          message.roomList.push(RogueRoom.decode(reader, reader.uint32()));
          break;
        case 4:
          message.rogueCoin = reader.uint32();
          break;
        case 5:
          if ((tag & 7) === 2) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.baseAvatarIdList.push(reader.uint32());
            }
          } else {
            message.baseAvatarIdList.push(reader.uint32());
          }
          break;
        case 6:
          message.rogueStamina = reader.uint32();
          break;
        case 7:
          message.reviveCount = reader.uint32();
          break;
        case 8:
          message.recoverStaminaCount = reader.uint32();
          break;
        case 9:
          message.isRecordSaved = reader.bool();
          break;
        case 10:
          if ((tag & 7) === 2) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.exploreRewardList.push(reader.uint32());
            }
          } else {
            message.exploreRewardList.push(reader.uint32());
          }
          break;
        case 11:
          message.seasonId = reader.uint32();
          break;
        case 12:
          message.beginTime = reader.uint32();
          break;
        case 13:
          message.endTime = reader.uint32();
          break;
        case 14:
          message.isWin = reader.bool();
          break;
        case 15:
          message.mazeBuffList.push(RogueBuff.decode(reader, reader.uint32()));
          break;
        case 16:
          message.extraBuffList.push(RogueBuff.decode(reader, reader.uint32()));
          break;
        case 17:
          message.rogueExploreExp = reader.uint32();
          break;
        case 18:
          message.rogueExploreLv = reader.uint32();
          break;
        case 19:
          message.buffSelectInfo = RogueBuffSelectInfo.decode(
            reader,
            reader.uint32()
          );
          break;
        case 20:
          message.isPickAvatar = reader.bool();
          break;
        case 21:
          message.blessInfo = RogueBlessInfo.decode(reader, reader.uint32());
          break;
        case 22:
          message.buffScore = reader.uint32();
          break;
        case 23:
          message.appraisalInfo = RogueAppraisalInfo.decode(
            reader,
            reader.uint32()
          );
          break;
        case 24:
          message.worldLevel = reader.int32();
          break;
        case 25:
          message.rogueGachaItemNumOnEnter = reader.uint32();
          break;
        case 26:
          message.rogueQuestList.push(
            RogueQuest.decode(reader, reader.uint32())
          );
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): RogueInfo {
    return {
      status: isSet(object.status) ? rogueStatusFromJSON(object.status) : 0,
      levelInfo: isSet(object.levelInfo)
        ? RogueLevel.fromJSON(object.levelInfo)
        : undefined,
      roomList: Array.isArray(object?.roomList)
        ? object.roomList.map((e: any) => RogueRoom.fromJSON(e))
        : [],
      rogueCoin: isSet(object.rogueCoin) ? Number(object.rogueCoin) : 0,
      baseAvatarIdList: Array.isArray(object?.baseAvatarIdList)
        ? object.baseAvatarIdList.map((e: any) => Number(e))
        : [],
      rogueStamina: isSet(object.rogueStamina)
        ? Number(object.rogueStamina)
        : 0,
      reviveCount: isSet(object.reviveCount) ? Number(object.reviveCount) : 0,
      recoverStaminaCount: isSet(object.recoverStaminaCount)
        ? Number(object.recoverStaminaCount)
        : 0,
      isRecordSaved: isSet(object.isRecordSaved)
        ? Boolean(object.isRecordSaved)
        : false,
      exploreRewardList: Array.isArray(object?.exploreRewardList)
        ? object.exploreRewardList.map((e: any) => Number(e))
        : [],
      seasonId: isSet(object.seasonId) ? Number(object.seasonId) : 0,
      beginTime: isSet(object.beginTime) ? Number(object.beginTime) : 0,
      endTime: isSet(object.endTime) ? Number(object.endTime) : 0,
      isWin: isSet(object.isWin) ? Boolean(object.isWin) : false,
      mazeBuffList: Array.isArray(object?.mazeBuffList)
        ? object.mazeBuffList.map((e: any) => RogueBuff.fromJSON(e))
        : [],
      extraBuffList: Array.isArray(object?.extraBuffList)
        ? object.extraBuffList.map((e: any) => RogueBuff.fromJSON(e))
        : [],
      rogueExploreExp: isSet(object.rogueExploreExp)
        ? Number(object.rogueExploreExp)
        : 0,
      rogueExploreLv: isSet(object.rogueExploreLv)
        ? Number(object.rogueExploreLv)
        : 0,
      buffSelectInfo: isSet(object.buffSelectInfo)
        ? RogueBuffSelectInfo.fromJSON(object.buffSelectInfo)
        : undefined,
      isPickAvatar: isSet(object.isPickAvatar)
        ? Boolean(object.isPickAvatar)
        : false,
      blessInfo: isSet(object.blessInfo)
        ? RogueBlessInfo.fromJSON(object.blessInfo)
        : undefined,
      buffScore: isSet(object.buffScore) ? Number(object.buffScore) : 0,
      appraisalInfo: isSet(object.appraisalInfo)
        ? RogueAppraisalInfo.fromJSON(object.appraisalInfo)
        : undefined,
      worldLevel: isSet(object.worldLevel) ? Number(object.worldLevel) : 0,
      rogueGachaItemNumOnEnter: isSet(object.rogueGachaItemNumOnEnter)
        ? Number(object.rogueGachaItemNumOnEnter)
        : 0,
      rogueQuestList: Array.isArray(object?.rogueQuestList)
        ? object.rogueQuestList.map((e: any) => RogueQuest.fromJSON(e))
        : [],
    };
  },

  toJSON(message: RogueInfo): unknown {
    const obj: any = {};
    message.status !== undefined &&
      (obj.status = rogueStatusToJSON(message.status));
    message.levelInfo !== undefined &&
      (obj.levelInfo = message.levelInfo
        ? RogueLevel.toJSON(message.levelInfo)
        : undefined);
    if (message.roomList) {
      obj.roomList = message.roomList.map((e) =>
        e ? RogueRoom.toJSON(e) : undefined
      );
    } else {
      obj.roomList = [];
    }
    message.rogueCoin !== undefined &&
      (obj.rogueCoin = Math.round(message.rogueCoin));
    if (message.baseAvatarIdList) {
      obj.baseAvatarIdList = message.baseAvatarIdList.map((e) => Math.round(e));
    } else {
      obj.baseAvatarIdList = [];
    }
    message.rogueStamina !== undefined &&
      (obj.rogueStamina = Math.round(message.rogueStamina));
    message.reviveCount !== undefined &&
      (obj.reviveCount = Math.round(message.reviveCount));
    message.recoverStaminaCount !== undefined &&
      (obj.recoverStaminaCount = Math.round(message.recoverStaminaCount));
    message.isRecordSaved !== undefined &&
      (obj.isRecordSaved = message.isRecordSaved);
    if (message.exploreRewardList) {
      obj.exploreRewardList = message.exploreRewardList.map((e) =>
        Math.round(e)
      );
    } else {
      obj.exploreRewardList = [];
    }
    message.seasonId !== undefined &&
      (obj.seasonId = Math.round(message.seasonId));
    message.beginTime !== undefined &&
      (obj.beginTime = Math.round(message.beginTime));
    message.endTime !== undefined &&
      (obj.endTime = Math.round(message.endTime));
    message.isWin !== undefined && (obj.isWin = message.isWin);
    if (message.mazeBuffList) {
      obj.mazeBuffList = message.mazeBuffList.map((e) =>
        e ? RogueBuff.toJSON(e) : undefined
      );
    } else {
      obj.mazeBuffList = [];
    }
    if (message.extraBuffList) {
      obj.extraBuffList = message.extraBuffList.map((e) =>
        e ? RogueBuff.toJSON(e) : undefined
      );
    } else {
      obj.extraBuffList = [];
    }
    message.rogueExploreExp !== undefined &&
      (obj.rogueExploreExp = Math.round(message.rogueExploreExp));
    message.rogueExploreLv !== undefined &&
      (obj.rogueExploreLv = Math.round(message.rogueExploreLv));
    message.buffSelectInfo !== undefined &&
      (obj.buffSelectInfo = message.buffSelectInfo
        ? RogueBuffSelectInfo.toJSON(message.buffSelectInfo)
        : undefined);
    message.isPickAvatar !== undefined &&
      (obj.isPickAvatar = message.isPickAvatar);
    message.blessInfo !== undefined &&
      (obj.blessInfo = message.blessInfo
        ? RogueBlessInfo.toJSON(message.blessInfo)
        : undefined);
    message.buffScore !== undefined &&
      (obj.buffScore = Math.round(message.buffScore));
    message.appraisalInfo !== undefined &&
      (obj.appraisalInfo = message.appraisalInfo
        ? RogueAppraisalInfo.toJSON(message.appraisalInfo)
        : undefined);
    message.worldLevel !== undefined &&
      (obj.worldLevel = Math.round(message.worldLevel));
    message.rogueGachaItemNumOnEnter !== undefined &&
      (obj.rogueGachaItemNumOnEnter = Math.round(
        message.rogueGachaItemNumOnEnter
      ));
    if (message.rogueQuestList) {
      obj.rogueQuestList = message.rogueQuestList.map((e) =>
        e ? RogueQuest.toJSON(e) : undefined
      );
    } else {
      obj.rogueQuestList = [];
    }
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<RogueInfo>, I>>(
    object: I
  ): RogueInfo {
    const message = createBaseRogueInfo();
    message.status = object.status ?? 0;
    message.levelInfo =
      object.levelInfo !== undefined && object.levelInfo !== null
        ? RogueLevel.fromPartial(object.levelInfo)
        : undefined;
    message.roomList =
      object.roomList?.map((e) => RogueRoom.fromPartial(e)) || [];
    message.rogueCoin = object.rogueCoin ?? 0;
    message.baseAvatarIdList = object.baseAvatarIdList?.map((e) => e) || [];
    message.rogueStamina = object.rogueStamina ?? 0;
    message.reviveCount = object.reviveCount ?? 0;
    message.recoverStaminaCount = object.recoverStaminaCount ?? 0;
    message.isRecordSaved = object.isRecordSaved ?? false;
    message.exploreRewardList = object.exploreRewardList?.map((e) => e) || [];
    message.seasonId = object.seasonId ?? 0;
    message.beginTime = object.beginTime ?? 0;
    message.endTime = object.endTime ?? 0;
    message.isWin = object.isWin ?? false;
    message.mazeBuffList =
      object.mazeBuffList?.map((e) => RogueBuff.fromPartial(e)) || [];
    message.extraBuffList =
      object.extraBuffList?.map((e) => RogueBuff.fromPartial(e)) || [];
    message.rogueExploreExp = object.rogueExploreExp ?? 0;
    message.rogueExploreLv = object.rogueExploreLv ?? 0;
    message.buffSelectInfo =
      object.buffSelectInfo !== undefined && object.buffSelectInfo !== null
        ? RogueBuffSelectInfo.fromPartial(object.buffSelectInfo)
        : undefined;
    message.isPickAvatar = object.isPickAvatar ?? false;
    message.blessInfo =
      object.blessInfo !== undefined && object.blessInfo !== null
        ? RogueBlessInfo.fromPartial(object.blessInfo)
        : undefined;
    message.buffScore = object.buffScore ?? 0;
    message.appraisalInfo =
      object.appraisalInfo !== undefined && object.appraisalInfo !== null
        ? RogueAppraisalInfo.fromPartial(object.appraisalInfo)
        : undefined;
    message.worldLevel = object.worldLevel ?? 0;
    message.rogueGachaItemNumOnEnter = object.rogueGachaItemNumOnEnter ?? 0;
    message.rogueQuestList =
      object.rogueQuestList?.map((e) => RogueQuest.fromPartial(e)) || [];
    return message;
  },
};

function createBaseRogueRecord(): RogueRecord {
  return { slot: 0, avatarList: [], mazeBuffList: [], name: "", score: 0 };
}

export const RogueRecord = {
  encode(
    message: RogueRecord,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.slot !== 0) {
      writer.uint32(8).uint32(message.slot);
    }
    writer.uint32(18).fork();
    for (const v of message.avatarList) {
      writer.uint32(v);
    }
    writer.ldelim();
    for (const v of message.mazeBuffList) {
      RogueBuff.encode(v!, writer.uint32(26).fork()).ldelim();
    }
    if (message.name !== "") {
      writer.uint32(34).string(message.name);
    }
    if (message.score !== 0) {
      writer.uint32(40).uint32(message.score);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): RogueRecord {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRogueRecord();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.slot = reader.uint32();
          break;
        case 2:
          if ((tag & 7) === 2) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.avatarList.push(reader.uint32());
            }
          } else {
            message.avatarList.push(reader.uint32());
          }
          break;
        case 3:
          message.mazeBuffList.push(RogueBuff.decode(reader, reader.uint32()));
          break;
        case 4:
          message.name = reader.string();
          break;
        case 5:
          message.score = reader.uint32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): RogueRecord {
    return {
      slot: isSet(object.slot) ? Number(object.slot) : 0,
      avatarList: Array.isArray(object?.avatarList)
        ? object.avatarList.map((e: any) => Number(e))
        : [],
      mazeBuffList: Array.isArray(object?.mazeBuffList)
        ? object.mazeBuffList.map((e: any) => RogueBuff.fromJSON(e))
        : [],
      name: isSet(object.name) ? String(object.name) : "",
      score: isSet(object.score) ? Number(object.score) : 0,
    };
  },

  toJSON(message: RogueRecord): unknown {
    const obj: any = {};
    message.slot !== undefined && (obj.slot = Math.round(message.slot));
    if (message.avatarList) {
      obj.avatarList = message.avatarList.map((e) => Math.round(e));
    } else {
      obj.avatarList = [];
    }
    if (message.mazeBuffList) {
      obj.mazeBuffList = message.mazeBuffList.map((e) =>
        e ? RogueBuff.toJSON(e) : undefined
      );
    } else {
      obj.mazeBuffList = [];
    }
    message.name !== undefined && (obj.name = message.name);
    message.score !== undefined && (obj.score = Math.round(message.score));
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<RogueRecord>, I>>(
    object: I
  ): RogueRecord {
    const message = createBaseRogueRecord();
    message.slot = object.slot ?? 0;
    message.avatarList = object.avatarList?.map((e) => e) || [];
    message.mazeBuffList =
      object.mazeBuffList?.map((e) => RogueBuff.fromPartial(e)) || [];
    message.name = object.name ?? "";
    message.score = object.score ?? 0;
    return message;
  },
};

function createBaseRogueChallengeInfo(): RogueChallengeInfo {
  return {
    isInChallenge: false,
    challengeRewardList: [],
    histroyMaxScore: 0,
    recordList: [],
    recordSlot: 0,
  };
}

export const RogueChallengeInfo = {
  encode(
    message: RogueChallengeInfo,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.isInChallenge === true) {
      writer.uint32(8).bool(message.isInChallenge);
    }
    writer.uint32(26).fork();
    for (const v of message.challengeRewardList) {
      writer.uint32(v);
    }
    writer.ldelim();
    if (message.histroyMaxScore !== 0) {
      writer.uint32(32).uint32(message.histroyMaxScore);
    }
    for (const v of message.recordList) {
      RogueRecord.encode(v!, writer.uint32(42).fork()).ldelim();
    }
    if (message.recordSlot !== 0) {
      writer.uint32(48).uint32(message.recordSlot);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): RogueChallengeInfo {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRogueChallengeInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.isInChallenge = reader.bool();
          break;
        case 3:
          if ((tag & 7) === 2) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.challengeRewardList.push(reader.uint32());
            }
          } else {
            message.challengeRewardList.push(reader.uint32());
          }
          break;
        case 4:
          message.histroyMaxScore = reader.uint32();
          break;
        case 5:
          message.recordList.push(RogueRecord.decode(reader, reader.uint32()));
          break;
        case 6:
          message.recordSlot = reader.uint32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): RogueChallengeInfo {
    return {
      isInChallenge: isSet(object.isInChallenge)
        ? Boolean(object.isInChallenge)
        : false,
      challengeRewardList: Array.isArray(object?.challengeRewardList)
        ? object.challengeRewardList.map((e: any) => Number(e))
        : [],
      histroyMaxScore: isSet(object.histroyMaxScore)
        ? Number(object.histroyMaxScore)
        : 0,
      recordList: Array.isArray(object?.recordList)
        ? object.recordList.map((e: any) => RogueRecord.fromJSON(e))
        : [],
      recordSlot: isSet(object.recordSlot) ? Number(object.recordSlot) : 0,
    };
  },

  toJSON(message: RogueChallengeInfo): unknown {
    const obj: any = {};
    message.isInChallenge !== undefined &&
      (obj.isInChallenge = message.isInChallenge);
    if (message.challengeRewardList) {
      obj.challengeRewardList = message.challengeRewardList.map((e) =>
        Math.round(e)
      );
    } else {
      obj.challengeRewardList = [];
    }
    message.histroyMaxScore !== undefined &&
      (obj.histroyMaxScore = Math.round(message.histroyMaxScore));
    if (message.recordList) {
      obj.recordList = message.recordList.map((e) =>
        e ? RogueRecord.toJSON(e) : undefined
      );
    } else {
      obj.recordList = [];
    }
    message.recordSlot !== undefined &&
      (obj.recordSlot = Math.round(message.recordSlot));
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<RogueChallengeInfo>, I>>(
    object: I
  ): RogueChallengeInfo {
    const message = createBaseRogueChallengeInfo();
    message.isInChallenge = object.isInChallenge ?? false;
    message.challengeRewardList =
      object.challengeRewardList?.map((e) => e) || [];
    message.histroyMaxScore = object.histroyMaxScore ?? 0;
    message.recordList =
      object.recordList?.map((e) => RogueRecord.fromPartial(e)) || [];
    message.recordSlot = object.recordSlot ?? 0;
    return message;
  },
};

function createBaseRogueFinishInfo(): RogueFinishInfo {
  return {
    isWin: false,
    reward: undefined,
    exploreQuestList: [],
    canSave: false,
    buffScore: 0,
    rogueGachaItemNum: 0,
  };
}

export const RogueFinishInfo = {
  encode(
    message: RogueFinishInfo,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.isWin === true) {
      writer.uint32(8).bool(message.isWin);
    }
    if (message.reward !== undefined) {
      ItemList.encode(message.reward, writer.uint32(18).fork()).ldelim();
    }
    writer.uint32(26).fork();
    for (const v of message.exploreQuestList) {
      writer.uint32(v);
    }
    writer.ldelim();
    if (message.canSave === true) {
      writer.uint32(32).bool(message.canSave);
    }
    if (message.buffScore !== 0) {
      writer.uint32(40).uint32(message.buffScore);
    }
    if (message.rogueGachaItemNum !== 0) {
      writer.uint32(48).uint32(message.rogueGachaItemNum);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): RogueFinishInfo {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRogueFinishInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.isWin = reader.bool();
          break;
        case 2:
          message.reward = ItemList.decode(reader, reader.uint32());
          break;
        case 3:
          if ((tag & 7) === 2) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.exploreQuestList.push(reader.uint32());
            }
          } else {
            message.exploreQuestList.push(reader.uint32());
          }
          break;
        case 4:
          message.canSave = reader.bool();
          break;
        case 5:
          message.buffScore = reader.uint32();
          break;
        case 6:
          message.rogueGachaItemNum = reader.uint32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): RogueFinishInfo {
    return {
      isWin: isSet(object.isWin) ? Boolean(object.isWin) : false,
      reward: isSet(object.reward)
        ? ItemList.fromJSON(object.reward)
        : undefined,
      exploreQuestList: Array.isArray(object?.exploreQuestList)
        ? object.exploreQuestList.map((e: any) => Number(e))
        : [],
      canSave: isSet(object.canSave) ? Boolean(object.canSave) : false,
      buffScore: isSet(object.buffScore) ? Number(object.buffScore) : 0,
      rogueGachaItemNum: isSet(object.rogueGachaItemNum)
        ? Number(object.rogueGachaItemNum)
        : 0,
    };
  },

  toJSON(message: RogueFinishInfo): unknown {
    const obj: any = {};
    message.isWin !== undefined && (obj.isWin = message.isWin);
    message.reward !== undefined &&
      (obj.reward = message.reward
        ? ItemList.toJSON(message.reward)
        : undefined);
    if (message.exploreQuestList) {
      obj.exploreQuestList = message.exploreQuestList.map((e) => Math.round(e));
    } else {
      obj.exploreQuestList = [];
    }
    message.canSave !== undefined && (obj.canSave = message.canSave);
    message.buffScore !== undefined &&
      (obj.buffScore = Math.round(message.buffScore));
    message.rogueGachaItemNum !== undefined &&
      (obj.rogueGachaItemNum = Math.round(message.rogueGachaItemNum));
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<RogueFinishInfo>, I>>(
    object: I
  ): RogueFinishInfo {
    const message = createBaseRogueFinishInfo();
    message.isWin = object.isWin ?? false;
    message.reward =
      object.reward !== undefined && object.reward !== null
        ? ItemList.fromPartial(object.reward)
        : undefined;
    message.exploreQuestList = object.exploreQuestList?.map((e) => e) || [];
    message.canSave = object.canSave ?? false;
    message.buffScore = object.buffScore ?? 0;
    message.rogueGachaItemNum = object.rogueGachaItemNum ?? 0;
    return message;
  },
};

function createBaseRogueChallengeSpecialScore(): RogueChallengeSpecialScore {
  return { scoreId: 0, score: 0 };
}

export const RogueChallengeSpecialScore = {
  encode(
    message: RogueChallengeSpecialScore,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.scoreId !== 0) {
      writer.uint32(8).uint32(message.scoreId);
    }
    if (message.score !== 0) {
      writer.uint32(16).uint32(message.score);
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): RogueChallengeSpecialScore {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRogueChallengeSpecialScore();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.scoreId = reader.uint32();
          break;
        case 2:
          message.score = reader.uint32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): RogueChallengeSpecialScore {
    return {
      scoreId: isSet(object.scoreId) ? Number(object.scoreId) : 0,
      score: isSet(object.score) ? Number(object.score) : 0,
    };
  },

  toJSON(message: RogueChallengeSpecialScore): unknown {
    const obj: any = {};
    message.scoreId !== undefined &&
      (obj.scoreId = Math.round(message.scoreId));
    message.score !== undefined && (obj.score = Math.round(message.score));
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<RogueChallengeSpecialScore>, I>>(
    object: I
  ): RogueChallengeSpecialScore {
    const message = createBaseRogueChallengeSpecialScore();
    message.scoreId = object.scoreId ?? 0;
    message.score = object.score ?? 0;
    return message;
  },
};

function createBaseRogueChallengeScoreInfo(): RogueChallengeScoreInfo {
  return { totalScore: 0, turnScore: 0, damageScore: 0, specialScoreList: [] };
}

export const RogueChallengeScoreInfo = {
  encode(
    message: RogueChallengeScoreInfo,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.totalScore !== 0) {
      writer.uint32(8).uint32(message.totalScore);
    }
    if (message.turnScore !== 0) {
      writer.uint32(16).uint32(message.turnScore);
    }
    if (message.damageScore !== 0) {
      writer.uint32(24).uint32(message.damageScore);
    }
    for (const v of message.specialScoreList) {
      RogueChallengeSpecialScore.encode(v!, writer.uint32(34).fork()).ldelim();
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): RogueChallengeScoreInfo {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRogueChallengeScoreInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.totalScore = reader.uint32();
          break;
        case 2:
          message.turnScore = reader.uint32();
          break;
        case 3:
          message.damageScore = reader.uint32();
          break;
        case 4:
          message.specialScoreList.push(
            RogueChallengeSpecialScore.decode(reader, reader.uint32())
          );
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): RogueChallengeScoreInfo {
    return {
      totalScore: isSet(object.totalScore) ? Number(object.totalScore) : 0,
      turnScore: isSet(object.turnScore) ? Number(object.turnScore) : 0,
      damageScore: isSet(object.damageScore) ? Number(object.damageScore) : 0,
      specialScoreList: Array.isArray(object?.specialScoreList)
        ? object.specialScoreList.map((e: any) =>
            RogueChallengeSpecialScore.fromJSON(e)
          )
        : [],
    };
  },

  toJSON(message: RogueChallengeScoreInfo): unknown {
    const obj: any = {};
    message.totalScore !== undefined &&
      (obj.totalScore = Math.round(message.totalScore));
    message.turnScore !== undefined &&
      (obj.turnScore = Math.round(message.turnScore));
    message.damageScore !== undefined &&
      (obj.damageScore = Math.round(message.damageScore));
    if (message.specialScoreList) {
      obj.specialScoreList = message.specialScoreList.map((e) =>
        e ? RogueChallengeSpecialScore.toJSON(e) : undefined
      );
    } else {
      obj.specialScoreList = [];
    }
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<RogueChallengeScoreInfo>, I>>(
    object: I
  ): RogueChallengeScoreInfo {
    const message = createBaseRogueChallengeScoreInfo();
    message.totalScore = object.totalScore ?? 0;
    message.turnScore = object.turnScore ?? 0;
    message.damageScore = object.damageScore ?? 0;
    message.specialScoreList =
      object.specialScoreList?.map((e) =>
        RogueChallengeSpecialScore.fromPartial(e)
      ) || [];
    return message;
  },
};

function createBaseRogueChallengeFinishInfo(): RogueChallengeFinishInfo {
  return {
    isWin: false,
    rounds: 0,
    damage: 0,
    reward: undefined,
    challengeQuestList: [],
    scoreInfo: undefined,
  };
}

export const RogueChallengeFinishInfo = {
  encode(
    message: RogueChallengeFinishInfo,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.isWin === true) {
      writer.uint32(8).bool(message.isWin);
    }
    if (message.rounds !== 0) {
      writer.uint32(16).uint32(message.rounds);
    }
    if (message.damage !== 0) {
      writer.uint32(29).float(message.damage);
    }
    if (message.reward !== undefined) {
      ItemList.encode(message.reward, writer.uint32(34).fork()).ldelim();
    }
    writer.uint32(50).fork();
    for (const v of message.challengeQuestList) {
      writer.uint32(v);
    }
    writer.ldelim();
    if (message.scoreInfo !== undefined) {
      RogueChallengeScoreInfo.encode(
        message.scoreInfo,
        writer.uint32(82).fork()
      ).ldelim();
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): RogueChallengeFinishInfo {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRogueChallengeFinishInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.isWin = reader.bool();
          break;
        case 2:
          message.rounds = reader.uint32();
          break;
        case 3:
          message.damage = reader.float();
          break;
        case 4:
          message.reward = ItemList.decode(reader, reader.uint32());
          break;
        case 6:
          if ((tag & 7) === 2) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.challengeQuestList.push(reader.uint32());
            }
          } else {
            message.challengeQuestList.push(reader.uint32());
          }
          break;
        case 10:
          message.scoreInfo = RogueChallengeScoreInfo.decode(
            reader,
            reader.uint32()
          );
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): RogueChallengeFinishInfo {
    return {
      isWin: isSet(object.isWin) ? Boolean(object.isWin) : false,
      rounds: isSet(object.rounds) ? Number(object.rounds) : 0,
      damage: isSet(object.damage) ? Number(object.damage) : 0,
      reward: isSet(object.reward)
        ? ItemList.fromJSON(object.reward)
        : undefined,
      challengeQuestList: Array.isArray(object?.challengeQuestList)
        ? object.challengeQuestList.map((e: any) => Number(e))
        : [],
      scoreInfo: isSet(object.scoreInfo)
        ? RogueChallengeScoreInfo.fromJSON(object.scoreInfo)
        : undefined,
    };
  },

  toJSON(message: RogueChallengeFinishInfo): unknown {
    const obj: any = {};
    message.isWin !== undefined && (obj.isWin = message.isWin);
    message.rounds !== undefined && (obj.rounds = Math.round(message.rounds));
    message.damage !== undefined && (obj.damage = message.damage);
    message.reward !== undefined &&
      (obj.reward = message.reward
        ? ItemList.toJSON(message.reward)
        : undefined);
    if (message.challengeQuestList) {
      obj.challengeQuestList = message.challengeQuestList.map((e) =>
        Math.round(e)
      );
    } else {
      obj.challengeQuestList = [];
    }
    message.scoreInfo !== undefined &&
      (obj.scoreInfo = message.scoreInfo
        ? RogueChallengeScoreInfo.toJSON(message.scoreInfo)
        : undefined);
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<RogueChallengeFinishInfo>, I>>(
    object: I
  ): RogueChallengeFinishInfo {
    const message = createBaseRogueChallengeFinishInfo();
    message.isWin = object.isWin ?? false;
    message.rounds = object.rounds ?? 0;
    message.damage = object.damage ?? 0;
    message.reward =
      object.reward !== undefined && object.reward !== null
        ? ItemList.fromPartial(object.reward)
        : undefined;
    message.challengeQuestList = object.challengeQuestList?.map((e) => e) || [];
    message.scoreInfo =
      object.scoreInfo !== undefined && object.scoreInfo !== null
        ? RogueChallengeScoreInfo.fromPartial(object.scoreInfo)
        : undefined;
    return message;
  },
};

function createBaseRogueDialog(): RogueDialog {
  return { rogueDialogId: 0, status: 0 };
}

export const RogueDialog = {
  encode(
    message: RogueDialog,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.rogueDialogId !== 0) {
      writer.uint32(8).uint32(message.rogueDialogId);
    }
    if (message.status !== 0) {
      writer.uint32(16).int32(message.status);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): RogueDialog {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRogueDialog();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.rogueDialogId = reader.uint32();
          break;
        case 2:
          message.status = reader.int32() as any;
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): RogueDialog {
    return {
      rogueDialogId: isSet(object.rogueDialogId)
        ? Number(object.rogueDialogId)
        : 0,
      status: isSet(object.status)
        ? rogueDialogStatusFromJSON(object.status)
        : 0,
    };
  },

  toJSON(message: RogueDialog): unknown {
    const obj: any = {};
    message.rogueDialogId !== undefined &&
      (obj.rogueDialogId = Math.round(message.rogueDialogId));
    message.status !== undefined &&
      (obj.status = rogueDialogStatusToJSON(message.status));
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<RogueDialog>, I>>(
    object: I
  ): RogueDialog {
    const message = createBaseRogueDialog();
    message.rogueDialogId = object.rogueDialogId ?? 0;
    message.status = object.status ?? 0;
    return message;
  },
};

function createBaseRogueGachaGoods(): RogueGachaGoods {
  return { gachaGoodsId: 0, status: 0 };
}

export const RogueGachaGoods = {
  encode(
    message: RogueGachaGoods,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.gachaGoodsId !== 0) {
      writer.uint32(8).uint32(message.gachaGoodsId);
    }
    if (message.status !== 0) {
      writer.uint32(16).uint32(message.status);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): RogueGachaGoods {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRogueGachaGoods();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.gachaGoodsId = reader.uint32();
          break;
        case 2:
          message.status = reader.uint32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): RogueGachaGoods {
    return {
      gachaGoodsId: isSet(object.gachaGoodsId)
        ? Number(object.gachaGoodsId)
        : 0,
      status: isSet(object.status) ? Number(object.status) : 0,
    };
  },

  toJSON(message: RogueGachaGoods): unknown {
    const obj: any = {};
    message.gachaGoodsId !== undefined &&
      (obj.gachaGoodsId = Math.round(message.gachaGoodsId));
    message.status !== undefined && (obj.status = Math.round(message.status));
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<RogueGachaGoods>, I>>(
    object: I
  ): RogueGachaGoods {
    const message = createBaseRogueGachaGoods();
    message.gachaGoodsId = object.gachaGoodsId ?? 0;
    message.status = object.status ?? 0;
    return message;
  },
};

function createBaseRogueGachaInfo(): RogueGachaInfo {
  return {
    gachaPoolId: 0,
    goodsList: [],
    wishIdList: [],
    curWishId: 0,
    gachaCount: 0,
    totalCount: 0,
  };
}

export const RogueGachaInfo = {
  encode(
    message: RogueGachaInfo,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.gachaPoolId !== 0) {
      writer.uint32(8).uint32(message.gachaPoolId);
    }
    for (const v of message.goodsList) {
      RogueGachaGoods.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    writer.uint32(26).fork();
    for (const v of message.wishIdList) {
      writer.uint32(v);
    }
    writer.ldelim();
    if (message.curWishId !== 0) {
      writer.uint32(32).uint32(message.curWishId);
    }
    if (message.gachaCount !== 0) {
      writer.uint32(40).uint32(message.gachaCount);
    }
    if (message.totalCount !== 0) {
      writer.uint32(48).uint32(message.totalCount);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): RogueGachaInfo {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRogueGachaInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.gachaPoolId = reader.uint32();
          break;
        case 2:
          message.goodsList.push(
            RogueGachaGoods.decode(reader, reader.uint32())
          );
          break;
        case 3:
          if ((tag & 7) === 2) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.wishIdList.push(reader.uint32());
            }
          } else {
            message.wishIdList.push(reader.uint32());
          }
          break;
        case 4:
          message.curWishId = reader.uint32();
          break;
        case 5:
          message.gachaCount = reader.uint32();
          break;
        case 6:
          message.totalCount = reader.uint32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): RogueGachaInfo {
    return {
      gachaPoolId: isSet(object.gachaPoolId) ? Number(object.gachaPoolId) : 0,
      goodsList: Array.isArray(object?.goodsList)
        ? object.goodsList.map((e: any) => RogueGachaGoods.fromJSON(e))
        : [],
      wishIdList: Array.isArray(object?.wishIdList)
        ? object.wishIdList.map((e: any) => Number(e))
        : [],
      curWishId: isSet(object.curWishId) ? Number(object.curWishId) : 0,
      gachaCount: isSet(object.gachaCount) ? Number(object.gachaCount) : 0,
      totalCount: isSet(object.totalCount) ? Number(object.totalCount) : 0,
    };
  },

  toJSON(message: RogueGachaInfo): unknown {
    const obj: any = {};
    message.gachaPoolId !== undefined &&
      (obj.gachaPoolId = Math.round(message.gachaPoolId));
    if (message.goodsList) {
      obj.goodsList = message.goodsList.map((e) =>
        e ? RogueGachaGoods.toJSON(e) : undefined
      );
    } else {
      obj.goodsList = [];
    }
    if (message.wishIdList) {
      obj.wishIdList = message.wishIdList.map((e) => Math.round(e));
    } else {
      obj.wishIdList = [];
    }
    message.curWishId !== undefined &&
      (obj.curWishId = Math.round(message.curWishId));
    message.gachaCount !== undefined &&
      (obj.gachaCount = Math.round(message.gachaCount));
    message.totalCount !== undefined &&
      (obj.totalCount = Math.round(message.totalCount));
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<RogueGachaInfo>, I>>(
    object: I
  ): RogueGachaInfo {
    const message = createBaseRogueGachaInfo();
    message.gachaPoolId = object.gachaPoolId ?? 0;
    message.goodsList =
      object.goodsList?.map((e) => RogueGachaGoods.fromPartial(e)) || [];
    message.wishIdList = object.wishIdList?.map((e) => e) || [];
    message.curWishId = object.curWishId ?? 0;
    message.gachaCount = object.gachaCount ?? 0;
    message.totalCount = object.totalCount ?? 0;
    return message;
  },
};

function createBaseGetRogueInfoCsReq(): GetRogueInfoCsReq {
  return {};
}

export const GetRogueInfoCsReq = {
  encode(
    _: GetRogueInfoCsReq,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetRogueInfoCsReq {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetRogueInfoCsReq();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(_: any): GetRogueInfoCsReq {
    return {};
  },

  toJSON(_: GetRogueInfoCsReq): unknown {
    const obj: any = {};
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<GetRogueInfoCsReq>, I>>(
    _: I
  ): GetRogueInfoCsReq {
    const message = createBaseGetRogueInfoCsReq();
    return message;
  },
};

function createBaseGetRogueInfoScRsp(): GetRogueInfoScRsp {
  return { retcode: 0, rogueInfo: undefined, rogueChallengeInfo: undefined };
}

export const GetRogueInfoScRsp = {
  encode(
    message: GetRogueInfoScRsp,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.retcode !== 0) {
      writer.uint32(8).uint32(message.retcode);
    }
    if (message.rogueInfo !== undefined) {
      RogueInfo.encode(message.rogueInfo, writer.uint32(18).fork()).ldelim();
    }
    if (message.rogueChallengeInfo !== undefined) {
      RogueChallengeInfo.encode(
        message.rogueChallengeInfo,
        writer.uint32(26).fork()
      ).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetRogueInfoScRsp {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetRogueInfoScRsp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.retcode = reader.uint32();
          break;
        case 2:
          message.rogueInfo = RogueInfo.decode(reader, reader.uint32());
          break;
        case 3:
          message.rogueChallengeInfo = RogueChallengeInfo.decode(
            reader,
            reader.uint32()
          );
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): GetRogueInfoScRsp {
    return {
      retcode: isSet(object.retcode) ? Number(object.retcode) : 0,
      rogueInfo: isSet(object.rogueInfo)
        ? RogueInfo.fromJSON(object.rogueInfo)
        : undefined,
      rogueChallengeInfo: isSet(object.rogueChallengeInfo)
        ? RogueChallengeInfo.fromJSON(object.rogueChallengeInfo)
        : undefined,
    };
  },

  toJSON(message: GetRogueInfoScRsp): unknown {
    const obj: any = {};
    message.retcode !== undefined &&
      (obj.retcode = Math.round(message.retcode));
    message.rogueInfo !== undefined &&
      (obj.rogueInfo = message.rogueInfo
        ? RogueInfo.toJSON(message.rogueInfo)
        : undefined);
    message.rogueChallengeInfo !== undefined &&
      (obj.rogueChallengeInfo = message.rogueChallengeInfo
        ? RogueChallengeInfo.toJSON(message.rogueChallengeInfo)
        : undefined);
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<GetRogueInfoScRsp>, I>>(
    object: I
  ): GetRogueInfoScRsp {
    const message = createBaseGetRogueInfoScRsp();
    message.retcode = object.retcode ?? 0;
    message.rogueInfo =
      object.rogueInfo !== undefined && object.rogueInfo !== null
        ? RogueInfo.fromPartial(object.rogueInfo)
        : undefined;
    message.rogueChallengeInfo =
      object.rogueChallengeInfo !== undefined &&
      object.rogueChallengeInfo !== null
        ? RogueChallengeInfo.fromPartial(object.rogueChallengeInfo)
        : undefined;
    return message;
  },
};

function createBaseStartRogueCsReq(): StartRogueCsReq {
  return { baseAvatarIdList: [] };
}

export const StartRogueCsReq = {
  encode(
    message: StartRogueCsReq,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    writer.uint32(10).fork();
    for (const v of message.baseAvatarIdList) {
      writer.uint32(v);
    }
    writer.ldelim();
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): StartRogueCsReq {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStartRogueCsReq();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if ((tag & 7) === 2) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.baseAvatarIdList.push(reader.uint32());
            }
          } else {
            message.baseAvatarIdList.push(reader.uint32());
          }
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): StartRogueCsReq {
    return {
      baseAvatarIdList: Array.isArray(object?.baseAvatarIdList)
        ? object.baseAvatarIdList.map((e: any) => Number(e))
        : [],
    };
  },

  toJSON(message: StartRogueCsReq): unknown {
    const obj: any = {};
    if (message.baseAvatarIdList) {
      obj.baseAvatarIdList = message.baseAvatarIdList.map((e) => Math.round(e));
    } else {
      obj.baseAvatarIdList = [];
    }
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<StartRogueCsReq>, I>>(
    object: I
  ): StartRogueCsReq {
    const message = createBaseStartRogueCsReq();
    message.baseAvatarIdList = object.baseAvatarIdList?.map((e) => e) || [];
    return message;
  },
};

function createBaseStartRogueScRsp(): StartRogueScRsp {
  return { retcode: 0, maze: undefined, rogueInfo: undefined };
}

export const StartRogueScRsp = {
  encode(
    message: StartRogueScRsp,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.retcode !== 0) {
      writer.uint32(8).uint32(message.retcode);
    }
    if (message.maze !== undefined) {
      Maze.encode(message.maze, writer.uint32(18).fork()).ldelim();
    }
    if (message.rogueInfo !== undefined) {
      RogueInfo.encode(message.rogueInfo, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): StartRogueScRsp {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStartRogueScRsp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.retcode = reader.uint32();
          break;
        case 2:
          message.maze = Maze.decode(reader, reader.uint32());
          break;
        case 3:
          message.rogueInfo = RogueInfo.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): StartRogueScRsp {
    return {
      retcode: isSet(object.retcode) ? Number(object.retcode) : 0,
      maze: isSet(object.maze) ? Maze.fromJSON(object.maze) : undefined,
      rogueInfo: isSet(object.rogueInfo)
        ? RogueInfo.fromJSON(object.rogueInfo)
        : undefined,
    };
  },

  toJSON(message: StartRogueScRsp): unknown {
    const obj: any = {};
    message.retcode !== undefined &&
      (obj.retcode = Math.round(message.retcode));
    message.maze !== undefined &&
      (obj.maze = message.maze ? Maze.toJSON(message.maze) : undefined);
    message.rogueInfo !== undefined &&
      (obj.rogueInfo = message.rogueInfo
        ? RogueInfo.toJSON(message.rogueInfo)
        : undefined);
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<StartRogueScRsp>, I>>(
    object: I
  ): StartRogueScRsp {
    const message = createBaseStartRogueScRsp();
    message.retcode = object.retcode ?? 0;
    message.maze =
      object.maze !== undefined && object.maze !== null
        ? Maze.fromPartial(object.maze)
        : undefined;
    message.rogueInfo =
      object.rogueInfo !== undefined && object.rogueInfo !== null
        ? RogueInfo.fromPartial(object.rogueInfo)
        : undefined;
    return message;
  },
};

function createBaseEnterRogueCsReq(): EnterRogueCsReq {
  return {};
}

export const EnterRogueCsReq = {
  encode(
    _: EnterRogueCsReq,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): EnterRogueCsReq {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEnterRogueCsReq();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(_: any): EnterRogueCsReq {
    return {};
  },

  toJSON(_: EnterRogueCsReq): unknown {
    const obj: any = {};
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<EnterRogueCsReq>, I>>(
    _: I
  ): EnterRogueCsReq {
    const message = createBaseEnterRogueCsReq();
    return message;
  },
};

function createBaseEnterRogueScRsp(): EnterRogueScRsp {
  return { retcode: 0, maze: undefined, rogueInfo: undefined };
}

export const EnterRogueScRsp = {
  encode(
    message: EnterRogueScRsp,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.retcode !== 0) {
      writer.uint32(8).uint32(message.retcode);
    }
    if (message.maze !== undefined) {
      Maze.encode(message.maze, writer.uint32(18).fork()).ldelim();
    }
    if (message.rogueInfo !== undefined) {
      RogueInfo.encode(message.rogueInfo, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): EnterRogueScRsp {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEnterRogueScRsp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.retcode = reader.uint32();
          break;
        case 2:
          message.maze = Maze.decode(reader, reader.uint32());
          break;
        case 3:
          message.rogueInfo = RogueInfo.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): EnterRogueScRsp {
    return {
      retcode: isSet(object.retcode) ? Number(object.retcode) : 0,
      maze: isSet(object.maze) ? Maze.fromJSON(object.maze) : undefined,
      rogueInfo: isSet(object.rogueInfo)
        ? RogueInfo.fromJSON(object.rogueInfo)
        : undefined,
    };
  },

  toJSON(message: EnterRogueScRsp): unknown {
    const obj: any = {};
    message.retcode !== undefined &&
      (obj.retcode = Math.round(message.retcode));
    message.maze !== undefined &&
      (obj.maze = message.maze ? Maze.toJSON(message.maze) : undefined);
    message.rogueInfo !== undefined &&
      (obj.rogueInfo = message.rogueInfo
        ? RogueInfo.toJSON(message.rogueInfo)
        : undefined);
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<EnterRogueScRsp>, I>>(
    object: I
  ): EnterRogueScRsp {
    const message = createBaseEnterRogueScRsp();
    message.retcode = object.retcode ?? 0;
    message.maze =
      object.maze !== undefined && object.maze !== null
        ? Maze.fromPartial(object.maze)
        : undefined;
    message.rogueInfo =
      object.rogueInfo !== undefined && object.rogueInfo !== null
        ? RogueInfo.fromPartial(object.rogueInfo)
        : undefined;
    return message;
  },
};

function createBaseLeaveRogueCsReq(): LeaveRogueCsReq {
  return {};
}

export const LeaveRogueCsReq = {
  encode(
    _: LeaveRogueCsReq,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): LeaveRogueCsReq {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLeaveRogueCsReq();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(_: any): LeaveRogueCsReq {
    return {};
  },

  toJSON(_: LeaveRogueCsReq): unknown {
    const obj: any = {};
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<LeaveRogueCsReq>, I>>(
    _: I
  ): LeaveRogueCsReq {
    const message = createBaseLeaveRogueCsReq();
    return message;
  },
};

function createBaseLeaveRogueScRsp(): LeaveRogueScRsp {
  return { retcode: 0, maze: undefined };
}

export const LeaveRogueScRsp = {
  encode(
    message: LeaveRogueScRsp,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.retcode !== 0) {
      writer.uint32(8).uint32(message.retcode);
    }
    if (message.maze !== undefined) {
      Maze.encode(message.maze, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): LeaveRogueScRsp {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLeaveRogueScRsp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.retcode = reader.uint32();
          break;
        case 2:
          message.maze = Maze.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): LeaveRogueScRsp {
    return {
      retcode: isSet(object.retcode) ? Number(object.retcode) : 0,
      maze: isSet(object.maze) ? Maze.fromJSON(object.maze) : undefined,
    };
  },

  toJSON(message: LeaveRogueScRsp): unknown {
    const obj: any = {};
    message.retcode !== undefined &&
      (obj.retcode = Math.round(message.retcode));
    message.maze !== undefined &&
      (obj.maze = message.maze ? Maze.toJSON(message.maze) : undefined);
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<LeaveRogueScRsp>, I>>(
    object: I
  ): LeaveRogueScRsp {
    const message = createBaseLeaveRogueScRsp();
    message.retcode = object.retcode ?? 0;
    message.maze =
      object.maze !== undefined && object.maze !== null
        ? Maze.fromPartial(object.maze)
        : undefined;
    return message;
  },
};

function createBaseSyncRogueBuffSelectInfoScNotify(): SyncRogueBuffSelectInfoScNotify {
  return { buffSelectInfo: undefined };
}

export const SyncRogueBuffSelectInfoScNotify = {
  encode(
    message: SyncRogueBuffSelectInfoScNotify,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.buffSelectInfo !== undefined) {
      RogueBuffSelectInfo.encode(
        message.buffSelectInfo,
        writer.uint32(10).fork()
      ).ldelim();
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): SyncRogueBuffSelectInfoScNotify {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSyncRogueBuffSelectInfoScNotify();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.buffSelectInfo = RogueBuffSelectInfo.decode(
            reader,
            reader.uint32()
          );
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): SyncRogueBuffSelectInfoScNotify {
    return {
      buffSelectInfo: isSet(object.buffSelectInfo)
        ? RogueBuffSelectInfo.fromJSON(object.buffSelectInfo)
        : undefined,
    };
  },

  toJSON(message: SyncRogueBuffSelectInfoScNotify): unknown {
    const obj: any = {};
    message.buffSelectInfo !== undefined &&
      (obj.buffSelectInfo = message.buffSelectInfo
        ? RogueBuffSelectInfo.toJSON(message.buffSelectInfo)
        : undefined);
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<SyncRogueBuffSelectInfoScNotify>, I>>(
    object: I
  ): SyncRogueBuffSelectInfoScNotify {
    const message = createBaseSyncRogueBuffSelectInfoScNotify();
    message.buffSelectInfo =
      object.buffSelectInfo !== undefined && object.buffSelectInfo !== null
        ? RogueBuffSelectInfo.fromPartial(object.buffSelectInfo)
        : undefined;
    return message;
  },
};

function createBaseSelectRogueBuffCsReq(): SelectRogueBuffCsReq {
  return { mazeBuffId: 0 };
}

export const SelectRogueBuffCsReq = {
  encode(
    message: SelectRogueBuffCsReq,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.mazeBuffId !== 0) {
      writer.uint32(16).uint32(message.mazeBuffId);
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): SelectRogueBuffCsReq {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSelectRogueBuffCsReq();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2:
          message.mazeBuffId = reader.uint32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): SelectRogueBuffCsReq {
    return {
      mazeBuffId: isSet(object.mazeBuffId) ? Number(object.mazeBuffId) : 0,
    };
  },

  toJSON(message: SelectRogueBuffCsReq): unknown {
    const obj: any = {};
    message.mazeBuffId !== undefined &&
      (obj.mazeBuffId = Math.round(message.mazeBuffId));
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<SelectRogueBuffCsReq>, I>>(
    object: I
  ): SelectRogueBuffCsReq {
    const message = createBaseSelectRogueBuffCsReq();
    message.mazeBuffId = object.mazeBuffId ?? 0;
    return message;
  },
};

function createBaseSelectRogueBuffScRsp(): SelectRogueBuffScRsp {
  return { retcode: 0, godPlotId: 0, buffSelectInfo: undefined };
}

export const SelectRogueBuffScRsp = {
  encode(
    message: SelectRogueBuffScRsp,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.retcode !== 0) {
      writer.uint32(8).uint32(message.retcode);
    }
    if (message.godPlotId !== 0) {
      writer.uint32(16).uint32(message.godPlotId);
    }
    if (message.buffSelectInfo !== undefined) {
      RogueBuffSelectInfo.encode(
        message.buffSelectInfo,
        writer.uint32(26).fork()
      ).ldelim();
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): SelectRogueBuffScRsp {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSelectRogueBuffScRsp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.retcode = reader.uint32();
          break;
        case 2:
          message.godPlotId = reader.uint32();
          break;
        case 3:
          message.buffSelectInfo = RogueBuffSelectInfo.decode(
            reader,
            reader.uint32()
          );
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): SelectRogueBuffScRsp {
    return {
      retcode: isSet(object.retcode) ? Number(object.retcode) : 0,
      godPlotId: isSet(object.godPlotId) ? Number(object.godPlotId) : 0,
      buffSelectInfo: isSet(object.buffSelectInfo)
        ? RogueBuffSelectInfo.fromJSON(object.buffSelectInfo)
        : undefined,
    };
  },

  toJSON(message: SelectRogueBuffScRsp): unknown {
    const obj: any = {};
    message.retcode !== undefined &&
      (obj.retcode = Math.round(message.retcode));
    message.godPlotId !== undefined &&
      (obj.godPlotId = Math.round(message.godPlotId));
    message.buffSelectInfo !== undefined &&
      (obj.buffSelectInfo = message.buffSelectInfo
        ? RogueBuffSelectInfo.toJSON(message.buffSelectInfo)
        : undefined);
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<SelectRogueBuffScRsp>, I>>(
    object: I
  ): SelectRogueBuffScRsp {
    const message = createBaseSelectRogueBuffScRsp();
    message.retcode = object.retcode ?? 0;
    message.godPlotId = object.godPlotId ?? 0;
    message.buffSelectInfo =
      object.buffSelectInfo !== undefined && object.buffSelectInfo !== null
        ? RogueBuffSelectInfo.fromPartial(object.buffSelectInfo)
        : undefined;
    return message;
  },
};

function createBaseRollRogueBuffCsReq(): RollRogueBuffCsReq {
  return {};
}

export const RollRogueBuffCsReq = {
  encode(
    _: RollRogueBuffCsReq,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): RollRogueBuffCsReq {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRollRogueBuffCsReq();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(_: any): RollRogueBuffCsReq {
    return {};
  },

  toJSON(_: RollRogueBuffCsReq): unknown {
    const obj: any = {};
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<RollRogueBuffCsReq>, I>>(
    _: I
  ): RollRogueBuffCsReq {
    const message = createBaseRollRogueBuffCsReq();
    return message;
  },
};

function createBaseRollRogueBuffScRsp(): RollRogueBuffScRsp {
  return { retcode: 0, buffSelectInfo: undefined };
}

export const RollRogueBuffScRsp = {
  encode(
    message: RollRogueBuffScRsp,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.retcode !== 0) {
      writer.uint32(8).uint32(message.retcode);
    }
    if (message.buffSelectInfo !== undefined) {
      RogueBuffSelectInfo.encode(
        message.buffSelectInfo,
        writer.uint32(18).fork()
      ).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): RollRogueBuffScRsp {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRollRogueBuffScRsp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.retcode = reader.uint32();
          break;
        case 2:
          message.buffSelectInfo = RogueBuffSelectInfo.decode(
            reader,
            reader.uint32()
          );
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): RollRogueBuffScRsp {
    return {
      retcode: isSet(object.retcode) ? Number(object.retcode) : 0,
      buffSelectInfo: isSet(object.buffSelectInfo)
        ? RogueBuffSelectInfo.fromJSON(object.buffSelectInfo)
        : undefined,
    };
  },

  toJSON(message: RollRogueBuffScRsp): unknown {
    const obj: any = {};
    message.retcode !== undefined &&
      (obj.retcode = Math.round(message.retcode));
    message.buffSelectInfo !== undefined &&
      (obj.buffSelectInfo = message.buffSelectInfo
        ? RogueBuffSelectInfo.toJSON(message.buffSelectInfo)
        : undefined);
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<RollRogueBuffScRsp>, I>>(
    object: I
  ): RollRogueBuffScRsp {
    const message = createBaseRollRogueBuffScRsp();
    message.retcode = object.retcode ?? 0;
    message.buffSelectInfo =
      object.buffSelectInfo !== undefined && object.buffSelectInfo !== null
        ? RogueBuffSelectInfo.fromPartial(object.buffSelectInfo)
        : undefined;
    return message;
  },
};

function createBaseEnterNextRogueRoomScNotify(): EnterNextRogueRoomScNotify {
  return { maze: undefined, room: undefined, appraisalInfo: undefined };
}

export const EnterNextRogueRoomScNotify = {
  encode(
    message: EnterNextRogueRoomScNotify,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.maze !== undefined) {
      Maze.encode(message.maze, writer.uint32(10).fork()).ldelim();
    }
    if (message.room !== undefined) {
      RogueRoom.encode(message.room, writer.uint32(18).fork()).ldelim();
    }
    if (message.appraisalInfo !== undefined) {
      RogueAppraisalInfo.encode(
        message.appraisalInfo,
        writer.uint32(26).fork()
      ).ldelim();
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): EnterNextRogueRoomScNotify {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEnterNextRogueRoomScNotify();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.maze = Maze.decode(reader, reader.uint32());
          break;
        case 2:
          message.room = RogueRoom.decode(reader, reader.uint32());
          break;
        case 3:
          message.appraisalInfo = RogueAppraisalInfo.decode(
            reader,
            reader.uint32()
          );
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): EnterNextRogueRoomScNotify {
    return {
      maze: isSet(object.maze) ? Maze.fromJSON(object.maze) : undefined,
      room: isSet(object.room) ? RogueRoom.fromJSON(object.room) : undefined,
      appraisalInfo: isSet(object.appraisalInfo)
        ? RogueAppraisalInfo.fromJSON(object.appraisalInfo)
        : undefined,
    };
  },

  toJSON(message: EnterNextRogueRoomScNotify): unknown {
    const obj: any = {};
    message.maze !== undefined &&
      (obj.maze = message.maze ? Maze.toJSON(message.maze) : undefined);
    message.room !== undefined &&
      (obj.room = message.room ? RogueRoom.toJSON(message.room) : undefined);
    message.appraisalInfo !== undefined &&
      (obj.appraisalInfo = message.appraisalInfo
        ? RogueAppraisalInfo.toJSON(message.appraisalInfo)
        : undefined);
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<EnterNextRogueRoomScNotify>, I>>(
    object: I
  ): EnterNextRogueRoomScNotify {
    const message = createBaseEnterNextRogueRoomScNotify();
    message.maze =
      object.maze !== undefined && object.maze !== null
        ? Maze.fromPartial(object.maze)
        : undefined;
    message.room =
      object.room !== undefined && object.room !== null
        ? RogueRoom.fromPartial(object.room)
        : undefined;
    message.appraisalInfo =
      object.appraisalInfo !== undefined && object.appraisalInfo !== null
        ? RogueAppraisalInfo.fromPartial(object.appraisalInfo)
        : undefined;
    return message;
  },
};

function createBaseSyncRogueFinishScNotify(): SyncRogueFinishScNotify {
  return { finishInfo: undefined };
}

export const SyncRogueFinishScNotify = {
  encode(
    message: SyncRogueFinishScNotify,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.finishInfo !== undefined) {
      RogueFinishInfo.encode(
        message.finishInfo,
        writer.uint32(10).fork()
      ).ldelim();
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): SyncRogueFinishScNotify {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSyncRogueFinishScNotify();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.finishInfo = RogueFinishInfo.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): SyncRogueFinishScNotify {
    return {
      finishInfo: isSet(object.finishInfo)
        ? RogueFinishInfo.fromJSON(object.finishInfo)
        : undefined,
    };
  },

  toJSON(message: SyncRogueFinishScNotify): unknown {
    const obj: any = {};
    message.finishInfo !== undefined &&
      (obj.finishInfo = message.finishInfo
        ? RogueFinishInfo.toJSON(message.finishInfo)
        : undefined);
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<SyncRogueFinishScNotify>, I>>(
    object: I
  ): SyncRogueFinishScNotify {
    const message = createBaseSyncRogueFinishScNotify();
    message.finishInfo =
      object.finishInfo !== undefined && object.finishInfo !== null
        ? RogueFinishInfo.fromPartial(object.finishInfo)
        : undefined;
    return message;
  },
};

function createBasePickRogueAvatarCsReq(): PickRogueAvatarCsReq {
  return { baseAvatarId: 0, propEntityId: 0, baseAvatarIdList: [] };
}

export const PickRogueAvatarCsReq = {
  encode(
    message: PickRogueAvatarCsReq,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.baseAvatarId !== 0) {
      writer.uint32(8).uint32(message.baseAvatarId);
    }
    if (message.propEntityId !== 0) {
      writer.uint32(16).uint32(message.propEntityId);
    }
    writer.uint32(26).fork();
    for (const v of message.baseAvatarIdList) {
      writer.uint32(v);
    }
    writer.ldelim();
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): PickRogueAvatarCsReq {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePickRogueAvatarCsReq();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.baseAvatarId = reader.uint32();
          break;
        case 2:
          message.propEntityId = reader.uint32();
          break;
        case 3:
          if ((tag & 7) === 2) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.baseAvatarIdList.push(reader.uint32());
            }
          } else {
            message.baseAvatarIdList.push(reader.uint32());
          }
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): PickRogueAvatarCsReq {
    return {
      baseAvatarId: isSet(object.baseAvatarId)
        ? Number(object.baseAvatarId)
        : 0,
      propEntityId: isSet(object.propEntityId)
        ? Number(object.propEntityId)
        : 0,
      baseAvatarIdList: Array.isArray(object?.baseAvatarIdList)
        ? object.baseAvatarIdList.map((e: any) => Number(e))
        : [],
    };
  },

  toJSON(message: PickRogueAvatarCsReq): unknown {
    const obj: any = {};
    message.baseAvatarId !== undefined &&
      (obj.baseAvatarId = Math.round(message.baseAvatarId));
    message.propEntityId !== undefined &&
      (obj.propEntityId = Math.round(message.propEntityId));
    if (message.baseAvatarIdList) {
      obj.baseAvatarIdList = message.baseAvatarIdList.map((e) => Math.round(e));
    } else {
      obj.baseAvatarIdList = [];
    }
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<PickRogueAvatarCsReq>, I>>(
    object: I
  ): PickRogueAvatarCsReq {
    const message = createBasePickRogueAvatarCsReq();
    message.baseAvatarId = object.baseAvatarId ?? 0;
    message.propEntityId = object.propEntityId ?? 0;
    message.baseAvatarIdList = object.baseAvatarIdList?.map((e) => e) || [];
    return message;
  },
};

function createBasePickRogueAvatarScRsp(): PickRogueAvatarScRsp {
  return { retcode: 0, baseAvatarId: 0, baseAvatarIdList: [] };
}

export const PickRogueAvatarScRsp = {
  encode(
    message: PickRogueAvatarScRsp,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.retcode !== 0) {
      writer.uint32(8).uint32(message.retcode);
    }
    if (message.baseAvatarId !== 0) {
      writer.uint32(16).uint32(message.baseAvatarId);
    }
    writer.uint32(26).fork();
    for (const v of message.baseAvatarIdList) {
      writer.uint32(v);
    }
    writer.ldelim();
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): PickRogueAvatarScRsp {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePickRogueAvatarScRsp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.retcode = reader.uint32();
          break;
        case 2:
          message.baseAvatarId = reader.uint32();
          break;
        case 3:
          if ((tag & 7) === 2) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.baseAvatarIdList.push(reader.uint32());
            }
          } else {
            message.baseAvatarIdList.push(reader.uint32());
          }
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): PickRogueAvatarScRsp {
    return {
      retcode: isSet(object.retcode) ? Number(object.retcode) : 0,
      baseAvatarId: isSet(object.baseAvatarId)
        ? Number(object.baseAvatarId)
        : 0,
      baseAvatarIdList: Array.isArray(object?.baseAvatarIdList)
        ? object.baseAvatarIdList.map((e: any) => Number(e))
        : [],
    };
  },

  toJSON(message: PickRogueAvatarScRsp): unknown {
    const obj: any = {};
    message.retcode !== undefined &&
      (obj.retcode = Math.round(message.retcode));
    message.baseAvatarId !== undefined &&
      (obj.baseAvatarId = Math.round(message.baseAvatarId));
    if (message.baseAvatarIdList) {
      obj.baseAvatarIdList = message.baseAvatarIdList.map((e) => Math.round(e));
    } else {
      obj.baseAvatarIdList = [];
    }
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<PickRogueAvatarScRsp>, I>>(
    object: I
  ): PickRogueAvatarScRsp {
    const message = createBasePickRogueAvatarScRsp();
    message.retcode = object.retcode ?? 0;
    message.baseAvatarId = object.baseAvatarId ?? 0;
    message.baseAvatarIdList = object.baseAvatarIdList?.map((e) => e) || [];
    return message;
  },
};

function createBaseAddRogueBuffScNotify(): AddRogueBuffScNotify {
  return { mazeBuffInfo: undefined };
}

export const AddRogueBuffScNotify = {
  encode(
    message: AddRogueBuffScNotify,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.mazeBuffInfo !== undefined) {
      RogueBuff.encode(message.mazeBuffInfo, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): AddRogueBuffScNotify {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAddRogueBuffScNotify();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.mazeBuffInfo = RogueBuff.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): AddRogueBuffScNotify {
    return {
      mazeBuffInfo: isSet(object.mazeBuffInfo)
        ? RogueBuff.fromJSON(object.mazeBuffInfo)
        : undefined,
    };
  },

  toJSON(message: AddRogueBuffScNotify): unknown {
    const obj: any = {};
    message.mazeBuffInfo !== undefined &&
      (obj.mazeBuffInfo = message.mazeBuffInfo
        ? RogueBuff.toJSON(message.mazeBuffInfo)
        : undefined);
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<AddRogueBuffScNotify>, I>>(
    object: I
  ): AddRogueBuffScNotify {
    const message = createBaseAddRogueBuffScNotify();
    message.mazeBuffInfo =
      object.mazeBuffInfo !== undefined && object.mazeBuffInfo !== null
        ? RogueBuff.fromPartial(object.mazeBuffInfo)
        : undefined;
    return message;
  },
};

function createBaseReviveRogueAvatarCsReq(): ReviveRogueAvatarCsReq {
  return { baseAvatarId: 0 };
}

export const ReviveRogueAvatarCsReq = {
  encode(
    message: ReviveRogueAvatarCsReq,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.baseAvatarId !== 0) {
      writer.uint32(8).uint32(message.baseAvatarId);
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): ReviveRogueAvatarCsReq {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReviveRogueAvatarCsReq();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.baseAvatarId = reader.uint32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): ReviveRogueAvatarCsReq {
    return {
      baseAvatarId: isSet(object.baseAvatarId)
        ? Number(object.baseAvatarId)
        : 0,
    };
  },

  toJSON(message: ReviveRogueAvatarCsReq): unknown {
    const obj: any = {};
    message.baseAvatarId !== undefined &&
      (obj.baseAvatarId = Math.round(message.baseAvatarId));
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<ReviveRogueAvatarCsReq>, I>>(
    object: I
  ): ReviveRogueAvatarCsReq {
    const message = createBaseReviveRogueAvatarCsReq();
    message.baseAvatarId = object.baseAvatarId ?? 0;
    return message;
  },
};

function createBaseReviveRogueAvatarScRsp(): ReviveRogueAvatarScRsp {
  return { retcode: 0, baseAvatarId: 0, rogueStamina: 0, reviveCount: 0 };
}

export const ReviveRogueAvatarScRsp = {
  encode(
    message: ReviveRogueAvatarScRsp,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.retcode !== 0) {
      writer.uint32(8).uint32(message.retcode);
    }
    if (message.baseAvatarId !== 0) {
      writer.uint32(16).uint32(message.baseAvatarId);
    }
    if (message.rogueStamina !== 0) {
      writer.uint32(24).uint32(message.rogueStamina);
    }
    if (message.reviveCount !== 0) {
      writer.uint32(32).uint32(message.reviveCount);
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): ReviveRogueAvatarScRsp {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReviveRogueAvatarScRsp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.retcode = reader.uint32();
          break;
        case 2:
          message.baseAvatarId = reader.uint32();
          break;
        case 3:
          message.rogueStamina = reader.uint32();
          break;
        case 4:
          message.reviveCount = reader.uint32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): ReviveRogueAvatarScRsp {
    return {
      retcode: isSet(object.retcode) ? Number(object.retcode) : 0,
      baseAvatarId: isSet(object.baseAvatarId)
        ? Number(object.baseAvatarId)
        : 0,
      rogueStamina: isSet(object.rogueStamina)
        ? Number(object.rogueStamina)
        : 0,
      reviveCount: isSet(object.reviveCount) ? Number(object.reviveCount) : 0,
    };
  },

  toJSON(message: ReviveRogueAvatarScRsp): unknown {
    const obj: any = {};
    message.retcode !== undefined &&
      (obj.retcode = Math.round(message.retcode));
    message.baseAvatarId !== undefined &&
      (obj.baseAvatarId = Math.round(message.baseAvatarId));
    message.rogueStamina !== undefined &&
      (obj.rogueStamina = Math.round(message.rogueStamina));
    message.reviveCount !== undefined &&
      (obj.reviveCount = Math.round(message.reviveCount));
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<ReviveRogueAvatarScRsp>, I>>(
    object: I
  ): ReviveRogueAvatarScRsp {
    const message = createBaseReviveRogueAvatarScRsp();
    message.retcode = object.retcode ?? 0;
    message.baseAvatarId = object.baseAvatarId ?? 0;
    message.rogueStamina = object.rogueStamina ?? 0;
    message.reviveCount = object.reviveCount ?? 0;
    return message;
  },
};

function createBaseSaveRogueRecordCsReq(): SaveRogueRecordCsReq {
  return { save: false, slot: 0, name: "" };
}

export const SaveRogueRecordCsReq = {
  encode(
    message: SaveRogueRecordCsReq,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.save === true) {
      writer.uint32(8).bool(message.save);
    }
    if (message.slot !== 0) {
      writer.uint32(16).uint32(message.slot);
    }
    if (message.name !== "") {
      writer.uint32(26).string(message.name);
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): SaveRogueRecordCsReq {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSaveRogueRecordCsReq();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.save = reader.bool();
          break;
        case 2:
          message.slot = reader.uint32();
          break;
        case 3:
          message.name = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): SaveRogueRecordCsReq {
    return {
      save: isSet(object.save) ? Boolean(object.save) : false,
      slot: isSet(object.slot) ? Number(object.slot) : 0,
      name: isSet(object.name) ? String(object.name) : "",
    };
  },

  toJSON(message: SaveRogueRecordCsReq): unknown {
    const obj: any = {};
    message.save !== undefined && (obj.save = message.save);
    message.slot !== undefined && (obj.slot = Math.round(message.slot));
    message.name !== undefined && (obj.name = message.name);
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<SaveRogueRecordCsReq>, I>>(
    object: I
  ): SaveRogueRecordCsReq {
    const message = createBaseSaveRogueRecordCsReq();
    message.save = object.save ?? false;
    message.slot = object.slot ?? 0;
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseSaveRogueRecordScRsp(): SaveRogueRecordScRsp {
  return { retcode: 0, record: undefined };
}

export const SaveRogueRecordScRsp = {
  encode(
    message: SaveRogueRecordScRsp,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.retcode !== 0) {
      writer.uint32(8).uint32(message.retcode);
    }
    if (message.record !== undefined) {
      RogueRecord.encode(message.record, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): SaveRogueRecordScRsp {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSaveRogueRecordScRsp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.retcode = reader.uint32();
          break;
        case 2:
          message.record = RogueRecord.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): SaveRogueRecordScRsp {
    return {
      retcode: isSet(object.retcode) ? Number(object.retcode) : 0,
      record: isSet(object.record)
        ? RogueRecord.fromJSON(object.record)
        : undefined,
    };
  },

  toJSON(message: SaveRogueRecordScRsp): unknown {
    const obj: any = {};
    message.retcode !== undefined &&
      (obj.retcode = Math.round(message.retcode));
    message.record !== undefined &&
      (obj.record = message.record
        ? RogueRecord.toJSON(message.record)
        : undefined);
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<SaveRogueRecordScRsp>, I>>(
    object: I
  ): SaveRogueRecordScRsp {
    const message = createBaseSaveRogueRecordScRsp();
    message.retcode = object.retcode ?? 0;
    message.record =
      object.record !== undefined && object.record !== null
        ? RogueRecord.fromPartial(object.record)
        : undefined;
    return message;
  },
};

function createBaseRecoverRogueStaminaCsReq(): RecoverRogueStaminaCsReq {
  return { propEntityId: 0 };
}

export const RecoverRogueStaminaCsReq = {
  encode(
    message: RecoverRogueStaminaCsReq,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.propEntityId !== 0) {
      writer.uint32(8).uint32(message.propEntityId);
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): RecoverRogueStaminaCsReq {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRecoverRogueStaminaCsReq();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.propEntityId = reader.uint32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): RecoverRogueStaminaCsReq {
    return {
      propEntityId: isSet(object.propEntityId)
        ? Number(object.propEntityId)
        : 0,
    };
  },

  toJSON(message: RecoverRogueStaminaCsReq): unknown {
    const obj: any = {};
    message.propEntityId !== undefined &&
      (obj.propEntityId = Math.round(message.propEntityId));
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<RecoverRogueStaminaCsReq>, I>>(
    object: I
  ): RecoverRogueStaminaCsReq {
    const message = createBaseRecoverRogueStaminaCsReq();
    message.propEntityId = object.propEntityId ?? 0;
    return message;
  },
};

function createBaseRecoverRogueStaminaScRsp(): RecoverRogueStaminaScRsp {
  return { retcode: 0, rogueStamina: 0, rogueCoin: 0, recoverStaminaCount: 0 };
}

export const RecoverRogueStaminaScRsp = {
  encode(
    message: RecoverRogueStaminaScRsp,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.retcode !== 0) {
      writer.uint32(8).uint32(message.retcode);
    }
    if (message.rogueStamina !== 0) {
      writer.uint32(16).uint32(message.rogueStamina);
    }
    if (message.rogueCoin !== 0) {
      writer.uint32(24).uint32(message.rogueCoin);
    }
    if (message.recoverStaminaCount !== 0) {
      writer.uint32(32).uint32(message.recoverStaminaCount);
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): RecoverRogueStaminaScRsp {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRecoverRogueStaminaScRsp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.retcode = reader.uint32();
          break;
        case 2:
          message.rogueStamina = reader.uint32();
          break;
        case 3:
          message.rogueCoin = reader.uint32();
          break;
        case 4:
          message.recoverStaminaCount = reader.uint32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): RecoverRogueStaminaScRsp {
    return {
      retcode: isSet(object.retcode) ? Number(object.retcode) : 0,
      rogueStamina: isSet(object.rogueStamina)
        ? Number(object.rogueStamina)
        : 0,
      rogueCoin: isSet(object.rogueCoin) ? Number(object.rogueCoin) : 0,
      recoverStaminaCount: isSet(object.recoverStaminaCount)
        ? Number(object.recoverStaminaCount)
        : 0,
    };
  },

  toJSON(message: RecoverRogueStaminaScRsp): unknown {
    const obj: any = {};
    message.retcode !== undefined &&
      (obj.retcode = Math.round(message.retcode));
    message.rogueStamina !== undefined &&
      (obj.rogueStamina = Math.round(message.rogueStamina));
    message.rogueCoin !== undefined &&
      (obj.rogueCoin = Math.round(message.rogueCoin));
    message.recoverStaminaCount !== undefined &&
      (obj.recoverStaminaCount = Math.round(message.recoverStaminaCount));
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<RecoverRogueStaminaScRsp>, I>>(
    object: I
  ): RecoverRogueStaminaScRsp {
    const message = createBaseRecoverRogueStaminaScRsp();
    message.retcode = object.retcode ?? 0;
    message.rogueStamina = object.rogueStamina ?? 0;
    message.rogueCoin = object.rogueCoin ?? 0;
    message.recoverStaminaCount = object.recoverStaminaCount ?? 0;
    return message;
  },
};

function createBaseStartRogueChallengeCsReq(): StartRogueChallengeCsReq {
  return { recordSlot: 0 };
}

export const StartRogueChallengeCsReq = {
  encode(
    message: StartRogueChallengeCsReq,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.recordSlot !== 0) {
      writer.uint32(8).uint32(message.recordSlot);
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): StartRogueChallengeCsReq {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStartRogueChallengeCsReq();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.recordSlot = reader.uint32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): StartRogueChallengeCsReq {
    return {
      recordSlot: isSet(object.recordSlot) ? Number(object.recordSlot) : 0,
    };
  },

  toJSON(message: StartRogueChallengeCsReq): unknown {
    const obj: any = {};
    message.recordSlot !== undefined &&
      (obj.recordSlot = Math.round(message.recordSlot));
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<StartRogueChallengeCsReq>, I>>(
    object: I
  ): StartRogueChallengeCsReq {
    const message = createBaseStartRogueChallengeCsReq();
    message.recordSlot = object.recordSlot ?? 0;
    return message;
  },
};

function createBaseStartRogueChallengeScRsp(): StartRogueChallengeScRsp {
  return { retcode: 0, maze: undefined, rogueChallengeInfo: undefined };
}

export const StartRogueChallengeScRsp = {
  encode(
    message: StartRogueChallengeScRsp,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.retcode !== 0) {
      writer.uint32(8).uint32(message.retcode);
    }
    if (message.maze !== undefined) {
      Maze.encode(message.maze, writer.uint32(18).fork()).ldelim();
    }
    if (message.rogueChallengeInfo !== undefined) {
      RogueChallengeInfo.encode(
        message.rogueChallengeInfo,
        writer.uint32(26).fork()
      ).ldelim();
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): StartRogueChallengeScRsp {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStartRogueChallengeScRsp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.retcode = reader.uint32();
          break;
        case 2:
          message.maze = Maze.decode(reader, reader.uint32());
          break;
        case 3:
          message.rogueChallengeInfo = RogueChallengeInfo.decode(
            reader,
            reader.uint32()
          );
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): StartRogueChallengeScRsp {
    return {
      retcode: isSet(object.retcode) ? Number(object.retcode) : 0,
      maze: isSet(object.maze) ? Maze.fromJSON(object.maze) : undefined,
      rogueChallengeInfo: isSet(object.rogueChallengeInfo)
        ? RogueChallengeInfo.fromJSON(object.rogueChallengeInfo)
        : undefined,
    };
  },

  toJSON(message: StartRogueChallengeScRsp): unknown {
    const obj: any = {};
    message.retcode !== undefined &&
      (obj.retcode = Math.round(message.retcode));
    message.maze !== undefined &&
      (obj.maze = message.maze ? Maze.toJSON(message.maze) : undefined);
    message.rogueChallengeInfo !== undefined &&
      (obj.rogueChallengeInfo = message.rogueChallengeInfo
        ? RogueChallengeInfo.toJSON(message.rogueChallengeInfo)
        : undefined);
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<StartRogueChallengeScRsp>, I>>(
    object: I
  ): StartRogueChallengeScRsp {
    const message = createBaseStartRogueChallengeScRsp();
    message.retcode = object.retcode ?? 0;
    message.maze =
      object.maze !== undefined && object.maze !== null
        ? Maze.fromPartial(object.maze)
        : undefined;
    message.rogueChallengeInfo =
      object.rogueChallengeInfo !== undefined &&
      object.rogueChallengeInfo !== null
        ? RogueChallengeInfo.fromPartial(object.rogueChallengeInfo)
        : undefined;
    return message;
  },
};

function createBaseLeaveRogueChallengeCsReq(): LeaveRogueChallengeCsReq {
  return {};
}

export const LeaveRogueChallengeCsReq = {
  encode(
    _: LeaveRogueChallengeCsReq,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): LeaveRogueChallengeCsReq {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLeaveRogueChallengeCsReq();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(_: any): LeaveRogueChallengeCsReq {
    return {};
  },

  toJSON(_: LeaveRogueChallengeCsReq): unknown {
    const obj: any = {};
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<LeaveRogueChallengeCsReq>, I>>(
    _: I
  ): LeaveRogueChallengeCsReq {
    const message = createBaseLeaveRogueChallengeCsReq();
    return message;
  },
};

function createBaseLeaveRogueChallengeScRsp(): LeaveRogueChallengeScRsp {
  return { retcode: 0, maze: undefined, rogueChallengeInfo: undefined };
}

export const LeaveRogueChallengeScRsp = {
  encode(
    message: LeaveRogueChallengeScRsp,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.retcode !== 0) {
      writer.uint32(8).uint32(message.retcode);
    }
    if (message.maze !== undefined) {
      Maze.encode(message.maze, writer.uint32(18).fork()).ldelim();
    }
    if (message.rogueChallengeInfo !== undefined) {
      RogueChallengeInfo.encode(
        message.rogueChallengeInfo,
        writer.uint32(26).fork()
      ).ldelim();
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): LeaveRogueChallengeScRsp {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLeaveRogueChallengeScRsp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.retcode = reader.uint32();
          break;
        case 2:
          message.maze = Maze.decode(reader, reader.uint32());
          break;
        case 3:
          message.rogueChallengeInfo = RogueChallengeInfo.decode(
            reader,
            reader.uint32()
          );
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): LeaveRogueChallengeScRsp {
    return {
      retcode: isSet(object.retcode) ? Number(object.retcode) : 0,
      maze: isSet(object.maze) ? Maze.fromJSON(object.maze) : undefined,
      rogueChallengeInfo: isSet(object.rogueChallengeInfo)
        ? RogueChallengeInfo.fromJSON(object.rogueChallengeInfo)
        : undefined,
    };
  },

  toJSON(message: LeaveRogueChallengeScRsp): unknown {
    const obj: any = {};
    message.retcode !== undefined &&
      (obj.retcode = Math.round(message.retcode));
    message.maze !== undefined &&
      (obj.maze = message.maze ? Maze.toJSON(message.maze) : undefined);
    message.rogueChallengeInfo !== undefined &&
      (obj.rogueChallengeInfo = message.rogueChallengeInfo
        ? RogueChallengeInfo.toJSON(message.rogueChallengeInfo)
        : undefined);
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<LeaveRogueChallengeScRsp>, I>>(
    object: I
  ): LeaveRogueChallengeScRsp {
    const message = createBaseLeaveRogueChallengeScRsp();
    message.retcode = object.retcode ?? 0;
    message.maze =
      object.maze !== undefined && object.maze !== null
        ? Maze.fromPartial(object.maze)
        : undefined;
    message.rogueChallengeInfo =
      object.rogueChallengeInfo !== undefined &&
      object.rogueChallengeInfo !== null
        ? RogueChallengeInfo.fromPartial(object.rogueChallengeInfo)
        : undefined;
    return message;
  },
};

function createBaseSyncRogueChallengeFinishScNotify(): SyncRogueChallengeFinishScNotify {
  return { finishInfo: undefined };
}

export const SyncRogueChallengeFinishScNotify = {
  encode(
    message: SyncRogueChallengeFinishScNotify,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.finishInfo !== undefined) {
      RogueChallengeFinishInfo.encode(
        message.finishInfo,
        writer.uint32(10).fork()
      ).ldelim();
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): SyncRogueChallengeFinishScNotify {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSyncRogueChallengeFinishScNotify();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.finishInfo = RogueChallengeFinishInfo.decode(
            reader,
            reader.uint32()
          );
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): SyncRogueChallengeFinishScNotify {
    return {
      finishInfo: isSet(object.finishInfo)
        ? RogueChallengeFinishInfo.fromJSON(object.finishInfo)
        : undefined,
    };
  },

  toJSON(message: SyncRogueChallengeFinishScNotify): unknown {
    const obj: any = {};
    message.finishInfo !== undefined &&
      (obj.finishInfo = message.finishInfo
        ? RogueChallengeFinishInfo.toJSON(message.finishInfo)
        : undefined);
    return obj;
  },

  fromPartial<
    I extends Exact<DeepPartial<SyncRogueChallengeFinishScNotify>, I>
  >(object: I): SyncRogueChallengeFinishScNotify {
    const message = createBaseSyncRogueChallengeFinishScNotify();
    message.finishInfo =
      object.finishInfo !== undefined && object.finishInfo !== null
        ? RogueChallengeFinishInfo.fromPartial(object.finishInfo)
        : undefined;
    return message;
  },
};

function createBaseQuitRogueCsReq(): QuitRogueCsReq {
  return {};
}

export const QuitRogueCsReq = {
  encode(
    _: QuitRogueCsReq,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): QuitRogueCsReq {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQuitRogueCsReq();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(_: any): QuitRogueCsReq {
    return {};
  },

  toJSON(_: QuitRogueCsReq): unknown {
    const obj: any = {};
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<QuitRogueCsReq>, I>>(
    _: I
  ): QuitRogueCsReq {
    const message = createBaseQuitRogueCsReq();
    return message;
  },
};

function createBaseQuitRogueScRsp(): QuitRogueScRsp {
  return { retcode: 0, finishInfo: undefined };
}

export const QuitRogueScRsp = {
  encode(
    message: QuitRogueScRsp,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.retcode !== 0) {
      writer.uint32(8).uint32(message.retcode);
    }
    if (message.finishInfo !== undefined) {
      RogueFinishInfo.encode(
        message.finishInfo,
        writer.uint32(18).fork()
      ).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): QuitRogueScRsp {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQuitRogueScRsp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.retcode = reader.uint32();
          break;
        case 2:
          message.finishInfo = RogueFinishInfo.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): QuitRogueScRsp {
    return {
      retcode: isSet(object.retcode) ? Number(object.retcode) : 0,
      finishInfo: isSet(object.finishInfo)
        ? RogueFinishInfo.fromJSON(object.finishInfo)
        : undefined,
    };
  },

  toJSON(message: QuitRogueScRsp): unknown {
    const obj: any = {};
    message.retcode !== undefined &&
      (obj.retcode = Math.round(message.retcode));
    message.finishInfo !== undefined &&
      (obj.finishInfo = message.finishInfo
        ? RogueFinishInfo.toJSON(message.finishInfo)
        : undefined);
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<QuitRogueScRsp>, I>>(
    object: I
  ): QuitRogueScRsp {
    const message = createBaseQuitRogueScRsp();
    message.retcode = object.retcode ?? 0;
    message.finishInfo =
      object.finishInfo !== undefined && object.finishInfo !== null
        ? RogueFinishInfo.fromPartial(object.finishInfo)
        : undefined;
    return message;
  },
};

function createBaseAppraisalRogueStoneCsReq(): AppraisalRogueStoneCsReq {
  return { stoneItemId: 0 };
}

export const AppraisalRogueStoneCsReq = {
  encode(
    message: AppraisalRogueStoneCsReq,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.stoneItemId !== 0) {
      writer.uint32(8).uint32(message.stoneItemId);
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): AppraisalRogueStoneCsReq {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAppraisalRogueStoneCsReq();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.stoneItemId = reader.uint32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): AppraisalRogueStoneCsReq {
    return {
      stoneItemId: isSet(object.stoneItemId) ? Number(object.stoneItemId) : 0,
    };
  },

  toJSON(message: AppraisalRogueStoneCsReq): unknown {
    const obj: any = {};
    message.stoneItemId !== undefined &&
      (obj.stoneItemId = Math.round(message.stoneItemId));
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<AppraisalRogueStoneCsReq>, I>>(
    object: I
  ): AppraisalRogueStoneCsReq {
    const message = createBaseAppraisalRogueStoneCsReq();
    message.stoneItemId = object.stoneItemId ?? 0;
    return message;
  },
};

function createBaseAppraisalRogueStoneScRsp(): AppraisalRogueStoneScRsp {
  return {
    retcode: 0,
    result: 0,
    reward: undefined,
    mazeBuffInfo: undefined,
    appraisalRecord: undefined,
    itemInfo: undefined,
  };
}

export const AppraisalRogueStoneScRsp = {
  encode(
    message: AppraisalRogueStoneScRsp,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.retcode !== 0) {
      writer.uint32(8).uint32(message.retcode);
    }
    if (message.result !== 0) {
      writer.uint32(16).int32(message.result);
    }
    if (message.reward !== undefined) {
      ItemList.encode(message.reward, writer.uint32(26).fork()).ldelim();
    }
    if (message.mazeBuffInfo !== undefined) {
      RogueBuff.encode(message.mazeBuffInfo, writer.uint32(34).fork()).ldelim();
    }
    if (message.appraisalRecord !== undefined) {
      RogueAppraisalRecord.encode(
        message.appraisalRecord,
        writer.uint32(42).fork()
      ).ldelim();
    }
    if (message.itemInfo !== undefined) {
      RogueAppraisalItemInfo.encode(
        message.itemInfo,
        writer.uint32(50).fork()
      ).ldelim();
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): AppraisalRogueStoneScRsp {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAppraisalRogueStoneScRsp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.retcode = reader.uint32();
          break;
        case 2:
          message.result = reader.int32() as any;
          break;
        case 3:
          message.reward = ItemList.decode(reader, reader.uint32());
          break;
        case 4:
          message.mazeBuffInfo = RogueBuff.decode(reader, reader.uint32());
          break;
        case 5:
          message.appraisalRecord = RogueAppraisalRecord.decode(
            reader,
            reader.uint32()
          );
          break;
        case 6:
          message.itemInfo = RogueAppraisalItemInfo.decode(
            reader,
            reader.uint32()
          );
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): AppraisalRogueStoneScRsp {
    return {
      retcode: isSet(object.retcode) ? Number(object.retcode) : 0,
      result: isSet(object.result)
        ? rogueStoneAppraisalResultFromJSON(object.result)
        : 0,
      reward: isSet(object.reward)
        ? ItemList.fromJSON(object.reward)
        : undefined,
      mazeBuffInfo: isSet(object.mazeBuffInfo)
        ? RogueBuff.fromJSON(object.mazeBuffInfo)
        : undefined,
      appraisalRecord: isSet(object.appraisalRecord)
        ? RogueAppraisalRecord.fromJSON(object.appraisalRecord)
        : undefined,
      itemInfo: isSet(object.itemInfo)
        ? RogueAppraisalItemInfo.fromJSON(object.itemInfo)
        : undefined,
    };
  },

  toJSON(message: AppraisalRogueStoneScRsp): unknown {
    const obj: any = {};
    message.retcode !== undefined &&
      (obj.retcode = Math.round(message.retcode));
    message.result !== undefined &&
      (obj.result = rogueStoneAppraisalResultToJSON(message.result));
    message.reward !== undefined &&
      (obj.reward = message.reward
        ? ItemList.toJSON(message.reward)
        : undefined);
    message.mazeBuffInfo !== undefined &&
      (obj.mazeBuffInfo = message.mazeBuffInfo
        ? RogueBuff.toJSON(message.mazeBuffInfo)
        : undefined);
    message.appraisalRecord !== undefined &&
      (obj.appraisalRecord = message.appraisalRecord
        ? RogueAppraisalRecord.toJSON(message.appraisalRecord)
        : undefined);
    message.itemInfo !== undefined &&
      (obj.itemInfo = message.itemInfo
        ? RogueAppraisalItemInfo.toJSON(message.itemInfo)
        : undefined);
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<AppraisalRogueStoneScRsp>, I>>(
    object: I
  ): AppraisalRogueStoneScRsp {
    const message = createBaseAppraisalRogueStoneScRsp();
    message.retcode = object.retcode ?? 0;
    message.result = object.result ?? 0;
    message.reward =
      object.reward !== undefined && object.reward !== null
        ? ItemList.fromPartial(object.reward)
        : undefined;
    message.mazeBuffInfo =
      object.mazeBuffInfo !== undefined && object.mazeBuffInfo !== null
        ? RogueBuff.fromPartial(object.mazeBuffInfo)
        : undefined;
    message.appraisalRecord =
      object.appraisalRecord !== undefined && object.appraisalRecord !== null
        ? RogueAppraisalRecord.fromPartial(object.appraisalRecord)
        : undefined;
    message.itemInfo =
      object.itemInfo !== undefined && object.itemInfo !== null
        ? RogueAppraisalItemInfo.fromPartial(object.itemInfo)
        : undefined;
    return message;
  },
};

function createBaseSyncRogueSeasonFinishScNotify(): SyncRogueSeasonFinishScNotify {
  return { finishInfo: undefined };
}

export const SyncRogueSeasonFinishScNotify = {
  encode(
    message: SyncRogueSeasonFinishScNotify,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.finishInfo !== undefined) {
      RogueFinishInfo.encode(
        message.finishInfo,
        writer.uint32(18).fork()
      ).ldelim();
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): SyncRogueSeasonFinishScNotify {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSyncRogueSeasonFinishScNotify();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2:
          message.finishInfo = RogueFinishInfo.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): SyncRogueSeasonFinishScNotify {
    return {
      finishInfo: isSet(object.finishInfo)
        ? RogueFinishInfo.fromJSON(object.finishInfo)
        : undefined,
    };
  },

  toJSON(message: SyncRogueSeasonFinishScNotify): unknown {
    const obj: any = {};
    message.finishInfo !== undefined &&
      (obj.finishInfo = message.finishInfo
        ? RogueFinishInfo.toJSON(message.finishInfo)
        : undefined);
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<SyncRogueSeasonFinishScNotify>, I>>(
    object: I
  ): SyncRogueSeasonFinishScNotify {
    const message = createBaseSyncRogueSeasonFinishScNotify();
    message.finishInfo =
      object.finishInfo !== undefined && object.finishInfo !== null
        ? RogueFinishInfo.fromPartial(object.finishInfo)
        : undefined;
    return message;
  },
};

function createBaseSyncRogueInfoChangeScNotify(): SyncRogueInfoChangeScNotify {
  return { recoverStaminaCount: 0, rogueExploreLv: 0 };
}

export const SyncRogueInfoChangeScNotify = {
  encode(
    message: SyncRogueInfoChangeScNotify,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.recoverStaminaCount !== 0) {
      writer.uint32(8).uint32(message.recoverStaminaCount);
    }
    if (message.rogueExploreLv !== 0) {
      writer.uint32(16).uint32(message.rogueExploreLv);
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): SyncRogueInfoChangeScNotify {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSyncRogueInfoChangeScNotify();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.recoverStaminaCount = reader.uint32();
          break;
        case 2:
          message.rogueExploreLv = reader.uint32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): SyncRogueInfoChangeScNotify {
    return {
      recoverStaminaCount: isSet(object.recoverStaminaCount)
        ? Number(object.recoverStaminaCount)
        : 0,
      rogueExploreLv: isSet(object.rogueExploreLv)
        ? Number(object.rogueExploreLv)
        : 0,
    };
  },

  toJSON(message: SyncRogueInfoChangeScNotify): unknown {
    const obj: any = {};
    message.recoverStaminaCount !== undefined &&
      (obj.recoverStaminaCount = Math.round(message.recoverStaminaCount));
    message.rogueExploreLv !== undefined &&
      (obj.rogueExploreLv = Math.round(message.rogueExploreLv));
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<SyncRogueInfoChangeScNotify>, I>>(
    object: I
  ): SyncRogueInfoChangeScNotify {
    const message = createBaseSyncRogueInfoChangeScNotify();
    message.recoverStaminaCount = object.recoverStaminaCount ?? 0;
    message.rogueExploreLv = object.rogueExploreLv ?? 0;
    return message;
  },
};

function createBaseAddRogueExtraBuffScNotify(): AddRogueExtraBuffScNotify {
  return { extraBuffInfo: undefined };
}

export const AddRogueExtraBuffScNotify = {
  encode(
    message: AddRogueExtraBuffScNotify,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.extraBuffInfo !== undefined) {
      RogueBuff.encode(
        message.extraBuffInfo,
        writer.uint32(10).fork()
      ).ldelim();
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): AddRogueExtraBuffScNotify {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAddRogueExtraBuffScNotify();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.extraBuffInfo = RogueBuff.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): AddRogueExtraBuffScNotify {
    return {
      extraBuffInfo: isSet(object.extraBuffInfo)
        ? RogueBuff.fromJSON(object.extraBuffInfo)
        : undefined,
    };
  },

  toJSON(message: AddRogueExtraBuffScNotify): unknown {
    const obj: any = {};
    message.extraBuffInfo !== undefined &&
      (obj.extraBuffInfo = message.extraBuffInfo
        ? RogueBuff.toJSON(message.extraBuffInfo)
        : undefined);
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<AddRogueExtraBuffScNotify>, I>>(
    object: I
  ): AddRogueExtraBuffScNotify {
    const message = createBaseAddRogueExtraBuffScNotify();
    message.extraBuffInfo =
      object.extraBuffInfo !== undefined && object.extraBuffInfo !== null
        ? RogueBuff.fromPartial(object.extraBuffInfo)
        : undefined;
    return message;
  },
};

function createBaseEnterRogueMapRoomCsReq(): EnterRogueMapRoomCsReq {
  return { roomId: 0 };
}

export const EnterRogueMapRoomCsReq = {
  encode(
    message: EnterRogueMapRoomCsReq,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.roomId !== 0) {
      writer.uint32(8).uint32(message.roomId);
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): EnterRogueMapRoomCsReq {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEnterRogueMapRoomCsReq();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.roomId = reader.uint32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): EnterRogueMapRoomCsReq {
    return {
      roomId: isSet(object.roomId) ? Number(object.roomId) : 0,
    };
  },

  toJSON(message: EnterRogueMapRoomCsReq): unknown {
    const obj: any = {};
    message.roomId !== undefined && (obj.roomId = Math.round(message.roomId));
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<EnterRogueMapRoomCsReq>, I>>(
    object: I
  ): EnterRogueMapRoomCsReq {
    const message = createBaseEnterRogueMapRoomCsReq();
    message.roomId = object.roomId ?? 0;
    return message;
  },
};

function createBaseEnterRogueMapRoomScRsp(): EnterRogueMapRoomScRsp {
  return { retcode: 0, maze: undefined, curRoomId: 0 };
}

export const EnterRogueMapRoomScRsp = {
  encode(
    message: EnterRogueMapRoomScRsp,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.retcode !== 0) {
      writer.uint32(8).uint32(message.retcode);
    }
    if (message.maze !== undefined) {
      Maze.encode(message.maze, writer.uint32(18).fork()).ldelim();
    }
    if (message.curRoomId !== 0) {
      writer.uint32(24).uint32(message.curRoomId);
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): EnterRogueMapRoomScRsp {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEnterRogueMapRoomScRsp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.retcode = reader.uint32();
          break;
        case 2:
          message.maze = Maze.decode(reader, reader.uint32());
          break;
        case 3:
          message.curRoomId = reader.uint32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): EnterRogueMapRoomScRsp {
    return {
      retcode: isSet(object.retcode) ? Number(object.retcode) : 0,
      maze: isSet(object.maze) ? Maze.fromJSON(object.maze) : undefined,
      curRoomId: isSet(object.curRoomId) ? Number(object.curRoomId) : 0,
    };
  },

  toJSON(message: EnterRogueMapRoomScRsp): unknown {
    const obj: any = {};
    message.retcode !== undefined &&
      (obj.retcode = Math.round(message.retcode));
    message.maze !== undefined &&
      (obj.maze = message.maze ? Maze.toJSON(message.maze) : undefined);
    message.curRoomId !== undefined &&
      (obj.curRoomId = Math.round(message.curRoomId));
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<EnterRogueMapRoomScRsp>, I>>(
    object: I
  ): EnterRogueMapRoomScRsp {
    const message = createBaseEnterRogueMapRoomScRsp();
    message.retcode = object.retcode ?? 0;
    message.maze =
      object.maze !== undefined && object.maze !== null
        ? Maze.fromPartial(object.maze)
        : undefined;
    message.curRoomId = object.curRoomId ?? 0;
    return message;
  },
};

function createBaseEnterRogueNextLevelCsReq(): EnterRogueNextLevelCsReq {
  return {};
}

export const EnterRogueNextLevelCsReq = {
  encode(
    _: EnterRogueNextLevelCsReq,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): EnterRogueNextLevelCsReq {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEnterRogueNextLevelCsReq();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(_: any): EnterRogueNextLevelCsReq {
    return {};
  },

  toJSON(_: EnterRogueNextLevelCsReq): unknown {
    const obj: any = {};
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<EnterRogueNextLevelCsReq>, I>>(
    _: I
  ): EnterRogueNextLevelCsReq {
    const message = createBaseEnterRogueNextLevelCsReq();
    return message;
  },
};

function createBaseEnterRogueNextLevelScRsp(): EnterRogueNextLevelScRsp {
  return {
    retcode: 0,
    maze: undefined,
    levelInfo: undefined,
    appraisalInfo: undefined,
  };
}

export const EnterRogueNextLevelScRsp = {
  encode(
    message: EnterRogueNextLevelScRsp,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.retcode !== 0) {
      writer.uint32(8).uint32(message.retcode);
    }
    if (message.maze !== undefined) {
      Maze.encode(message.maze, writer.uint32(18).fork()).ldelim();
    }
    if (message.levelInfo !== undefined) {
      RogueLevel.encode(message.levelInfo, writer.uint32(26).fork()).ldelim();
    }
    if (message.appraisalInfo !== undefined) {
      RogueAppraisalInfo.encode(
        message.appraisalInfo,
        writer.uint32(34).fork()
      ).ldelim();
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): EnterRogueNextLevelScRsp {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEnterRogueNextLevelScRsp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.retcode = reader.uint32();
          break;
        case 2:
          message.maze = Maze.decode(reader, reader.uint32());
          break;
        case 3:
          message.levelInfo = RogueLevel.decode(reader, reader.uint32());
          break;
        case 4:
          message.appraisalInfo = RogueAppraisalInfo.decode(
            reader,
            reader.uint32()
          );
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): EnterRogueNextLevelScRsp {
    return {
      retcode: isSet(object.retcode) ? Number(object.retcode) : 0,
      maze: isSet(object.maze) ? Maze.fromJSON(object.maze) : undefined,
      levelInfo: isSet(object.levelInfo)
        ? RogueLevel.fromJSON(object.levelInfo)
        : undefined,
      appraisalInfo: isSet(object.appraisalInfo)
        ? RogueAppraisalInfo.fromJSON(object.appraisalInfo)
        : undefined,
    };
  },

  toJSON(message: EnterRogueNextLevelScRsp): unknown {
    const obj: any = {};
    message.retcode !== undefined &&
      (obj.retcode = Math.round(message.retcode));
    message.maze !== undefined &&
      (obj.maze = message.maze ? Maze.toJSON(message.maze) : undefined);
    message.levelInfo !== undefined &&
      (obj.levelInfo = message.levelInfo
        ? RogueLevel.toJSON(message.levelInfo)
        : undefined);
    message.appraisalInfo !== undefined &&
      (obj.appraisalInfo = message.appraisalInfo
        ? RogueAppraisalInfo.toJSON(message.appraisalInfo)
        : undefined);
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<EnterRogueNextLevelScRsp>, I>>(
    object: I
  ): EnterRogueNextLevelScRsp {
    const message = createBaseEnterRogueNextLevelScRsp();
    message.retcode = object.retcode ?? 0;
    message.maze =
      object.maze !== undefined && object.maze !== null
        ? Maze.fromPartial(object.maze)
        : undefined;
    message.levelInfo =
      object.levelInfo !== undefined && object.levelInfo !== null
        ? RogueLevel.fromPartial(object.levelInfo)
        : undefined;
    message.appraisalInfo =
      object.appraisalInfo !== undefined && object.appraisalInfo !== null
        ? RogueAppraisalInfo.fromPartial(object.appraisalInfo)
        : undefined;
    return message;
  },
};

function createBaseSyncRogueMapRoomScNotify(): SyncRogueMapRoomScNotify {
  return { levelId: 0, mapId: 0, roomInfo: undefined };
}

export const SyncRogueMapRoomScNotify = {
  encode(
    message: SyncRogueMapRoomScNotify,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.levelId !== 0) {
      writer.uint32(8).uint32(message.levelId);
    }
    if (message.mapId !== 0) {
      writer.uint32(16).uint32(message.mapId);
    }
    if (message.roomInfo !== undefined) {
      RogueRoom.encode(message.roomInfo, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): SyncRogueMapRoomScNotify {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSyncRogueMapRoomScNotify();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.levelId = reader.uint32();
          break;
        case 2:
          message.mapId = reader.uint32();
          break;
        case 3:
          message.roomInfo = RogueRoom.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): SyncRogueMapRoomScNotify {
    return {
      levelId: isSet(object.levelId) ? Number(object.levelId) : 0,
      mapId: isSet(object.mapId) ? Number(object.mapId) : 0,
      roomInfo: isSet(object.roomInfo)
        ? RogueRoom.fromJSON(object.roomInfo)
        : undefined,
    };
  },

  toJSON(message: SyncRogueMapRoomScNotify): unknown {
    const obj: any = {};
    message.levelId !== undefined &&
      (obj.levelId = Math.round(message.levelId));
    message.mapId !== undefined && (obj.mapId = Math.round(message.mapId));
    message.roomInfo !== undefined &&
      (obj.roomInfo = message.roomInfo
        ? RogueRoom.toJSON(message.roomInfo)
        : undefined);
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<SyncRogueMapRoomScNotify>, I>>(
    object: I
  ): SyncRogueMapRoomScNotify {
    const message = createBaseSyncRogueMapRoomScNotify();
    message.levelId = object.levelId ?? 0;
    message.mapId = object.mapId ?? 0;
    message.roomInfo =
      object.roomInfo !== undefined && object.roomInfo !== null
        ? RogueRoom.fromPartial(object.roomInfo)
        : undefined;
    return message;
  },
};

function createBaseSyncRoguePickAvatarScNotify(): SyncRoguePickAvatarScNotify {
  return {};
}

export const SyncRoguePickAvatarScNotify = {
  encode(
    _: SyncRoguePickAvatarScNotify,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): SyncRoguePickAvatarScNotify {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSyncRoguePickAvatarScNotify();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(_: any): SyncRoguePickAvatarScNotify {
    return {};
  },

  toJSON(_: SyncRoguePickAvatarScNotify): unknown {
    const obj: any = {};
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<SyncRoguePickAvatarScNotify>, I>>(
    _: I
  ): SyncRoguePickAvatarScNotify {
    const message = createBaseSyncRoguePickAvatarScNotify();
    return message;
  },
};

function createBaseSetRogueBlessCsReq(): SetRogueBlessCsReq {
  return { blessId: 0 };
}

export const SetRogueBlessCsReq = {
  encode(
    message: SetRogueBlessCsReq,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.blessId !== 0) {
      writer.uint32(8).uint32(message.blessId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SetRogueBlessCsReq {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSetRogueBlessCsReq();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.blessId = reader.uint32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): SetRogueBlessCsReq {
    return {
      blessId: isSet(object.blessId) ? Number(object.blessId) : 0,
    };
  },

  toJSON(message: SetRogueBlessCsReq): unknown {
    const obj: any = {};
    message.blessId !== undefined &&
      (obj.blessId = Math.round(message.blessId));
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<SetRogueBlessCsReq>, I>>(
    object: I
  ): SetRogueBlessCsReq {
    const message = createBaseSetRogueBlessCsReq();
    message.blessId = object.blessId ?? 0;
    return message;
  },
};

function createBaseSetRogueBlessScRsp(): SetRogueBlessScRsp {
  return { retcode: 0, blessId: 0 };
}

export const SetRogueBlessScRsp = {
  encode(
    message: SetRogueBlessScRsp,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.retcode !== 0) {
      writer.uint32(8).uint32(message.retcode);
    }
    if (message.blessId !== 0) {
      writer.uint32(16).uint32(message.blessId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SetRogueBlessScRsp {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSetRogueBlessScRsp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.retcode = reader.uint32();
          break;
        case 2:
          message.blessId = reader.uint32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): SetRogueBlessScRsp {
    return {
      retcode: isSet(object.retcode) ? Number(object.retcode) : 0,
      blessId: isSet(object.blessId) ? Number(object.blessId) : 0,
    };
  },

  toJSON(message: SetRogueBlessScRsp): unknown {
    const obj: any = {};
    message.retcode !== undefined &&
      (obj.retcode = Math.round(message.retcode));
    message.blessId !== undefined &&
      (obj.blessId = Math.round(message.blessId));
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<SetRogueBlessScRsp>, I>>(
    object: I
  ): SetRogueBlessScRsp {
    const message = createBaseSetRogueBlessScRsp();
    message.retcode = object.retcode ?? 0;
    message.blessId = object.blessId ?? 0;
    return message;
  },
};

function createBaseSyncRogueBlessScNotify(): SyncRogueBlessScNotify {
  return { blessInfo: undefined, levelUpMax: false };
}

export const SyncRogueBlessScNotify = {
  encode(
    message: SyncRogueBlessScNotify,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.blessInfo !== undefined) {
      RogueBlessInfo.encode(
        message.blessInfo,
        writer.uint32(10).fork()
      ).ldelim();
    }
    if (message.levelUpMax === true) {
      writer.uint32(16).bool(message.levelUpMax);
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): SyncRogueBlessScNotify {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSyncRogueBlessScNotify();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.blessInfo = RogueBlessInfo.decode(reader, reader.uint32());
          break;
        case 2:
          message.levelUpMax = reader.bool();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): SyncRogueBlessScNotify {
    return {
      blessInfo: isSet(object.blessInfo)
        ? RogueBlessInfo.fromJSON(object.blessInfo)
        : undefined,
      levelUpMax: isSet(object.levelUpMax) ? Boolean(object.levelUpMax) : false,
    };
  },

  toJSON(message: SyncRogueBlessScNotify): unknown {
    const obj: any = {};
    message.blessInfo !== undefined &&
      (obj.blessInfo = message.blessInfo
        ? RogueBlessInfo.toJSON(message.blessInfo)
        : undefined);
    message.levelUpMax !== undefined && (obj.levelUpMax = message.levelUpMax);
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<SyncRogueBlessScNotify>, I>>(
    object: I
  ): SyncRogueBlessScNotify {
    const message = createBaseSyncRogueBlessScNotify();
    message.blessInfo =
      object.blessInfo !== undefined && object.blessInfo !== null
        ? RogueBlessInfo.fromPartial(object.blessInfo)
        : undefined;
    message.levelUpMax = object.levelUpMax ?? false;
    return message;
  },
};

function createBaseGetRogueShopInfoCsReq(): GetRogueShopInfoCsReq {
  return {};
}

export const GetRogueShopInfoCsReq = {
  encode(
    _: GetRogueShopInfoCsReq,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): GetRogueShopInfoCsReq {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetRogueShopInfoCsReq();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(_: any): GetRogueShopInfoCsReq {
    return {};
  },

  toJSON(_: GetRogueShopInfoCsReq): unknown {
    const obj: any = {};
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<GetRogueShopInfoCsReq>, I>>(
    _: I
  ): GetRogueShopInfoCsReq {
    const message = createBaseGetRogueShopInfoCsReq();
    return message;
  },
};

function createBaseGetRogueShopInfoScRsp(): GetRogueShopInfoScRsp {
  return { retcode: 0, rogueShopInfo: undefined };
}

export const GetRogueShopInfoScRsp = {
  encode(
    message: GetRogueShopInfoScRsp,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.retcode !== 0) {
      writer.uint32(8).uint32(message.retcode);
    }
    if (message.rogueShopInfo !== undefined) {
      RogueShopInfo.encode(
        message.rogueShopInfo,
        writer.uint32(18).fork()
      ).ldelim();
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): GetRogueShopInfoScRsp {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetRogueShopInfoScRsp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.retcode = reader.uint32();
          break;
        case 2:
          message.rogueShopInfo = RogueShopInfo.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): GetRogueShopInfoScRsp {
    return {
      retcode: isSet(object.retcode) ? Number(object.retcode) : 0,
      rogueShopInfo: isSet(object.rogueShopInfo)
        ? RogueShopInfo.fromJSON(object.rogueShopInfo)
        : undefined,
    };
  },

  toJSON(message: GetRogueShopInfoScRsp): unknown {
    const obj: any = {};
    message.retcode !== undefined &&
      (obj.retcode = Math.round(message.retcode));
    message.rogueShopInfo !== undefined &&
      (obj.rogueShopInfo = message.rogueShopInfo
        ? RogueShopInfo.toJSON(message.rogueShopInfo)
        : undefined);
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<GetRogueShopInfoScRsp>, I>>(
    object: I
  ): GetRogueShopInfoScRsp {
    const message = createBaseGetRogueShopInfoScRsp();
    message.retcode = object.retcode ?? 0;
    message.rogueShopInfo =
      object.rogueShopInfo !== undefined && object.rogueShopInfo !== null
        ? RogueShopInfo.fromPartial(object.rogueShopInfo)
        : undefined;
    return message;
  },
};

function createBaseBuyRogueShopBuffCsReq(): BuyRogueShopBuffCsReq {
  return { buffId: 0, buyCount: 0 };
}

export const BuyRogueShopBuffCsReq = {
  encode(
    message: BuyRogueShopBuffCsReq,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.buffId !== 0) {
      writer.uint32(8).uint32(message.buffId);
    }
    if (message.buyCount !== 0) {
      writer.uint32(16).uint32(message.buyCount);
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): BuyRogueShopBuffCsReq {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBuyRogueShopBuffCsReq();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.buffId = reader.uint32();
          break;
        case 2:
          message.buyCount = reader.uint32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): BuyRogueShopBuffCsReq {
    return {
      buffId: isSet(object.buffId) ? Number(object.buffId) : 0,
      buyCount: isSet(object.buyCount) ? Number(object.buyCount) : 0,
    };
  },

  toJSON(message: BuyRogueShopBuffCsReq): unknown {
    const obj: any = {};
    message.buffId !== undefined && (obj.buffId = Math.round(message.buffId));
    message.buyCount !== undefined &&
      (obj.buyCount = Math.round(message.buyCount));
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<BuyRogueShopBuffCsReq>, I>>(
    object: I
  ): BuyRogueShopBuffCsReq {
    const message = createBaseBuyRogueShopBuffCsReq();
    message.buffId = object.buffId ?? 0;
    message.buyCount = object.buyCount ?? 0;
    return message;
  },
};

function createBaseBuyRogueShopBuffScRsp(): BuyRogueShopBuffScRsp {
  return {
    retcode: 0,
    buyRogueBuff: undefined,
    buyCount: 0,
    rogueShopBuff: undefined,
  };
}

export const BuyRogueShopBuffScRsp = {
  encode(
    message: BuyRogueShopBuffScRsp,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.retcode !== 0) {
      writer.uint32(8).uint32(message.retcode);
    }
    if (message.buyRogueBuff !== undefined) {
      RogueBuff.encode(message.buyRogueBuff, writer.uint32(18).fork()).ldelim();
    }
    if (message.buyCount !== 0) {
      writer.uint32(24).uint32(message.buyCount);
    }
    if (message.rogueShopBuff !== undefined) {
      RogueShopBuff.encode(
        message.rogueShopBuff,
        writer.uint32(34).fork()
      ).ldelim();
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): BuyRogueShopBuffScRsp {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBuyRogueShopBuffScRsp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.retcode = reader.uint32();
          break;
        case 2:
          message.buyRogueBuff = RogueBuff.decode(reader, reader.uint32());
          break;
        case 3:
          message.buyCount = reader.uint32();
          break;
        case 4:
          message.rogueShopBuff = RogueShopBuff.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): BuyRogueShopBuffScRsp {
    return {
      retcode: isSet(object.retcode) ? Number(object.retcode) : 0,
      buyRogueBuff: isSet(object.buyRogueBuff)
        ? RogueBuff.fromJSON(object.buyRogueBuff)
        : undefined,
      buyCount: isSet(object.buyCount) ? Number(object.buyCount) : 0,
      rogueShopBuff: isSet(object.rogueShopBuff)
        ? RogueShopBuff.fromJSON(object.rogueShopBuff)
        : undefined,
    };
  },

  toJSON(message: BuyRogueShopBuffScRsp): unknown {
    const obj: any = {};
    message.retcode !== undefined &&
      (obj.retcode = Math.round(message.retcode));
    message.buyRogueBuff !== undefined &&
      (obj.buyRogueBuff = message.buyRogueBuff
        ? RogueBuff.toJSON(message.buyRogueBuff)
        : undefined);
    message.buyCount !== undefined &&
      (obj.buyCount = Math.round(message.buyCount));
    message.rogueShopBuff !== undefined &&
      (obj.rogueShopBuff = message.rogueShopBuff
        ? RogueShopBuff.toJSON(message.rogueShopBuff)
        : undefined);
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<BuyRogueShopBuffScRsp>, I>>(
    object: I
  ): BuyRogueShopBuffScRsp {
    const message = createBaseBuyRogueShopBuffScRsp();
    message.retcode = object.retcode ?? 0;
    message.buyRogueBuff =
      object.buyRogueBuff !== undefined && object.buyRogueBuff !== null
        ? RogueBuff.fromPartial(object.buyRogueBuff)
        : undefined;
    message.buyCount = object.buyCount ?? 0;
    message.rogueShopBuff =
      object.rogueShopBuff !== undefined && object.rogueShopBuff !== null
        ? RogueShopBuff.fromPartial(object.rogueShopBuff)
        : undefined;
    return message;
  },
};

function createBaseBuyRogueShopItemCsReq(): BuyRogueShopItemCsReq {
  return { itemId: 0, buyCount: 0 };
}

export const BuyRogueShopItemCsReq = {
  encode(
    message: BuyRogueShopItemCsReq,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.itemId !== 0) {
      writer.uint32(8).uint32(message.itemId);
    }
    if (message.buyCount !== 0) {
      writer.uint32(16).uint32(message.buyCount);
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): BuyRogueShopItemCsReq {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBuyRogueShopItemCsReq();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.itemId = reader.uint32();
          break;
        case 2:
          message.buyCount = reader.uint32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): BuyRogueShopItemCsReq {
    return {
      itemId: isSet(object.itemId) ? Number(object.itemId) : 0,
      buyCount: isSet(object.buyCount) ? Number(object.buyCount) : 0,
    };
  },

  toJSON(message: BuyRogueShopItemCsReq): unknown {
    const obj: any = {};
    message.itemId !== undefined && (obj.itemId = Math.round(message.itemId));
    message.buyCount !== undefined &&
      (obj.buyCount = Math.round(message.buyCount));
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<BuyRogueShopItemCsReq>, I>>(
    object: I
  ): BuyRogueShopItemCsReq {
    const message = createBaseBuyRogueShopItemCsReq();
    message.itemId = object.itemId ?? 0;
    message.buyCount = object.buyCount ?? 0;
    return message;
  },
};

function createBaseBuyRogueShopItemScRsp(): BuyRogueShopItemScRsp {
  return {
    retcode: 0,
    itemId: 0,
    buyCount: 0,
    rogueShopItem: undefined,
    rogueShopInfo: undefined,
  };
}

export const BuyRogueShopItemScRsp = {
  encode(
    message: BuyRogueShopItemScRsp,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.retcode !== 0) {
      writer.uint32(8).uint32(message.retcode);
    }
    if (message.itemId !== 0) {
      writer.uint32(16).uint32(message.itemId);
    }
    if (message.buyCount !== 0) {
      writer.uint32(24).uint32(message.buyCount);
    }
    if (message.rogueShopItem !== undefined) {
      RogueShopItem.encode(
        message.rogueShopItem,
        writer.uint32(34).fork()
      ).ldelim();
    }
    if (message.rogueShopInfo !== undefined) {
      RogueShopInfo.encode(
        message.rogueShopInfo,
        writer.uint32(42).fork()
      ).ldelim();
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): BuyRogueShopItemScRsp {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBuyRogueShopItemScRsp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.retcode = reader.uint32();
          break;
        case 2:
          message.itemId = reader.uint32();
          break;
        case 3:
          message.buyCount = reader.uint32();
          break;
        case 4:
          message.rogueShopItem = RogueShopItem.decode(reader, reader.uint32());
          break;
        case 5:
          message.rogueShopInfo = RogueShopInfo.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): BuyRogueShopItemScRsp {
    return {
      retcode: isSet(object.retcode) ? Number(object.retcode) : 0,
      itemId: isSet(object.itemId) ? Number(object.itemId) : 0,
      buyCount: isSet(object.buyCount) ? Number(object.buyCount) : 0,
      rogueShopItem: isSet(object.rogueShopItem)
        ? RogueShopItem.fromJSON(object.rogueShopItem)
        : undefined,
      rogueShopInfo: isSet(object.rogueShopInfo)
        ? RogueShopInfo.fromJSON(object.rogueShopInfo)
        : undefined,
    };
  },

  toJSON(message: BuyRogueShopItemScRsp): unknown {
    const obj: any = {};
    message.retcode !== undefined &&
      (obj.retcode = Math.round(message.retcode));
    message.itemId !== undefined && (obj.itemId = Math.round(message.itemId));
    message.buyCount !== undefined &&
      (obj.buyCount = Math.round(message.buyCount));
    message.rogueShopItem !== undefined &&
      (obj.rogueShopItem = message.rogueShopItem
        ? RogueShopItem.toJSON(message.rogueShopItem)
        : undefined);
    message.rogueShopInfo !== undefined &&
      (obj.rogueShopInfo = message.rogueShopInfo
        ? RogueShopInfo.toJSON(message.rogueShopInfo)
        : undefined);
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<BuyRogueShopItemScRsp>, I>>(
    object: I
  ): BuyRogueShopItemScRsp {
    const message = createBaseBuyRogueShopItemScRsp();
    message.retcode = object.retcode ?? 0;
    message.itemId = object.itemId ?? 0;
    message.buyCount = object.buyCount ?? 0;
    message.rogueShopItem =
      object.rogueShopItem !== undefined && object.rogueShopItem !== null
        ? RogueShopItem.fromPartial(object.rogueShopItem)
        : undefined;
    message.rogueShopInfo =
      object.rogueShopInfo !== undefined && object.rogueShopInfo !== null
        ? RogueShopInfo.fromPartial(object.rogueShopInfo)
        : undefined;
    return message;
  },
};

function createBaseFinishRogueDialogueGroupCsReq(): FinishRogueDialogueGroupCsReq {
  return { dialogueGroupId: 0 };
}

export const FinishRogueDialogueGroupCsReq = {
  encode(
    message: FinishRogueDialogueGroupCsReq,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.dialogueGroupId !== 0) {
      writer.uint32(8).uint32(message.dialogueGroupId);
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): FinishRogueDialogueGroupCsReq {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFinishRogueDialogueGroupCsReq();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.dialogueGroupId = reader.uint32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): FinishRogueDialogueGroupCsReq {
    return {
      dialogueGroupId: isSet(object.dialogueGroupId)
        ? Number(object.dialogueGroupId)
        : 0,
    };
  },

  toJSON(message: FinishRogueDialogueGroupCsReq): unknown {
    const obj: any = {};
    message.dialogueGroupId !== undefined &&
      (obj.dialogueGroupId = Math.round(message.dialogueGroupId));
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<FinishRogueDialogueGroupCsReq>, I>>(
    object: I
  ): FinishRogueDialogueGroupCsReq {
    const message = createBaseFinishRogueDialogueGroupCsReq();
    message.dialogueGroupId = object.dialogueGroupId ?? 0;
    return message;
  },
};

function createBaseFinishRogueDialogueGroupScRsp(): FinishRogueDialogueGroupScRsp {
  return { retcode: 0 };
}

export const FinishRogueDialogueGroupScRsp = {
  encode(
    message: FinishRogueDialogueGroupScRsp,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.retcode !== 0) {
      writer.uint32(8).uint32(message.retcode);
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): FinishRogueDialogueGroupScRsp {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFinishRogueDialogueGroupScRsp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.retcode = reader.uint32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): FinishRogueDialogueGroupScRsp {
    return {
      retcode: isSet(object.retcode) ? Number(object.retcode) : 0,
    };
  },

  toJSON(message: FinishRogueDialogueGroupScRsp): unknown {
    const obj: any = {};
    message.retcode !== undefined &&
      (obj.retcode = Math.round(message.retcode));
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<FinishRogueDialogueGroupScRsp>, I>>(
    object: I
  ): FinishRogueDialogueGroupScRsp {
    const message = createBaseFinishRogueDialogueGroupScRsp();
    message.retcode = object.retcode ?? 0;
    return message;
  },
};

function createBaseUnlockRogueRoomCsReq(): UnlockRogueRoomCsReq {
  return { roomId: 0 };
}

export const UnlockRogueRoomCsReq = {
  encode(
    message: UnlockRogueRoomCsReq,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.roomId !== 0) {
      writer.uint32(8).uint32(message.roomId);
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): UnlockRogueRoomCsReq {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUnlockRogueRoomCsReq();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.roomId = reader.uint32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): UnlockRogueRoomCsReq {
    return {
      roomId: isSet(object.roomId) ? Number(object.roomId) : 0,
    };
  },

  toJSON(message: UnlockRogueRoomCsReq): unknown {
    const obj: any = {};
    message.roomId !== undefined && (obj.roomId = Math.round(message.roomId));
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<UnlockRogueRoomCsReq>, I>>(
    object: I
  ): UnlockRogueRoomCsReq {
    const message = createBaseUnlockRogueRoomCsReq();
    message.roomId = object.roomId ?? 0;
    return message;
  },
};

function createBaseUnlockRogueRoomScRsp(): UnlockRogueRoomScRsp {
  return { retcode: 0 };
}

export const UnlockRogueRoomScRsp = {
  encode(
    message: UnlockRogueRoomScRsp,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.retcode !== 0) {
      writer.uint32(8).uint32(message.retcode);
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): UnlockRogueRoomScRsp {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUnlockRogueRoomScRsp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.retcode = reader.uint32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): UnlockRogueRoomScRsp {
    return {
      retcode: isSet(object.retcode) ? Number(object.retcode) : 0,
    };
  },

  toJSON(message: UnlockRogueRoomScRsp): unknown {
    const obj: any = {};
    message.retcode !== undefined &&
      (obj.retcode = Math.round(message.retcode));
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<UnlockRogueRoomScRsp>, I>>(
    object: I
  ): UnlockRogueRoomScRsp {
    const message = createBaseUnlockRogueRoomScRsp();
    message.retcode = object.retcode ?? 0;
    return message;
  },
};

function createBaseGetRogueGachaInfoCsReq(): GetRogueGachaInfoCsReq {
  return {};
}

export const GetRogueGachaInfoCsReq = {
  encode(
    _: GetRogueGachaInfoCsReq,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): GetRogueGachaInfoCsReq {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetRogueGachaInfoCsReq();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(_: any): GetRogueGachaInfoCsReq {
    return {};
  },

  toJSON(_: GetRogueGachaInfoCsReq): unknown {
    const obj: any = {};
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<GetRogueGachaInfoCsReq>, I>>(
    _: I
  ): GetRogueGachaInfoCsReq {
    const message = createBaseGetRogueGachaInfoCsReq();
    return message;
  },
};

function createBaseGetRogueGachaInfoScRsp(): GetRogueGachaInfoScRsp {
  return { retcode: 0, rogueGachaInfo: undefined };
}

export const GetRogueGachaInfoScRsp = {
  encode(
    message: GetRogueGachaInfoScRsp,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.retcode !== 0) {
      writer.uint32(8).uint32(message.retcode);
    }
    if (message.rogueGachaInfo !== undefined) {
      RogueGachaInfo.encode(
        message.rogueGachaInfo,
        writer.uint32(18).fork()
      ).ldelim();
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): GetRogueGachaInfoScRsp {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetRogueGachaInfoScRsp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.retcode = reader.uint32();
          break;
        case 2:
          message.rogueGachaInfo = RogueGachaInfo.decode(
            reader,
            reader.uint32()
          );
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): GetRogueGachaInfoScRsp {
    return {
      retcode: isSet(object.retcode) ? Number(object.retcode) : 0,
      rogueGachaInfo: isSet(object.rogueGachaInfo)
        ? RogueGachaInfo.fromJSON(object.rogueGachaInfo)
        : undefined,
    };
  },

  toJSON(message: GetRogueGachaInfoScRsp): unknown {
    const obj: any = {};
    message.retcode !== undefined &&
      (obj.retcode = Math.round(message.retcode));
    message.rogueGachaInfo !== undefined &&
      (obj.rogueGachaInfo = message.rogueGachaInfo
        ? RogueGachaInfo.toJSON(message.rogueGachaInfo)
        : undefined);
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<GetRogueGachaInfoScRsp>, I>>(
    object: I
  ): GetRogueGachaInfoScRsp {
    const message = createBaseGetRogueGachaInfoScRsp();
    message.retcode = object.retcode ?? 0;
    message.rogueGachaInfo =
      object.rogueGachaInfo !== undefined && object.rogueGachaInfo !== null
        ? RogueGachaInfo.fromPartial(object.rogueGachaInfo)
        : undefined;
    return message;
  },
};

function createBaseSetRogueGachaWishListCsReq(): SetRogueGachaWishListCsReq {
  return { wishListId: 0 };
}

export const SetRogueGachaWishListCsReq = {
  encode(
    message: SetRogueGachaWishListCsReq,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.wishListId !== 0) {
      writer.uint32(8).uint32(message.wishListId);
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): SetRogueGachaWishListCsReq {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSetRogueGachaWishListCsReq();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.wishListId = reader.uint32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): SetRogueGachaWishListCsReq {
    return {
      wishListId: isSet(object.wishListId) ? Number(object.wishListId) : 0,
    };
  },

  toJSON(message: SetRogueGachaWishListCsReq): unknown {
    const obj: any = {};
    message.wishListId !== undefined &&
      (obj.wishListId = Math.round(message.wishListId));
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<SetRogueGachaWishListCsReq>, I>>(
    object: I
  ): SetRogueGachaWishListCsReq {
    const message = createBaseSetRogueGachaWishListCsReq();
    message.wishListId = object.wishListId ?? 0;
    return message;
  },
};

function createBaseSetRogueGachaWishListScRsp(): SetRogueGachaWishListScRsp {
  return { retcode: 0, rogueGachaInfo: undefined };
}

export const SetRogueGachaWishListScRsp = {
  encode(
    message: SetRogueGachaWishListScRsp,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.retcode !== 0) {
      writer.uint32(8).uint32(message.retcode);
    }
    if (message.rogueGachaInfo !== undefined) {
      RogueGachaInfo.encode(
        message.rogueGachaInfo,
        writer.uint32(18).fork()
      ).ldelim();
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): SetRogueGachaWishListScRsp {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSetRogueGachaWishListScRsp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.retcode = reader.uint32();
          break;
        case 2:
          message.rogueGachaInfo = RogueGachaInfo.decode(
            reader,
            reader.uint32()
          );
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): SetRogueGachaWishListScRsp {
    return {
      retcode: isSet(object.retcode) ? Number(object.retcode) : 0,
      rogueGachaInfo: isSet(object.rogueGachaInfo)
        ? RogueGachaInfo.fromJSON(object.rogueGachaInfo)
        : undefined,
    };
  },

  toJSON(message: SetRogueGachaWishListScRsp): unknown {
    const obj: any = {};
    message.retcode !== undefined &&
      (obj.retcode = Math.round(message.retcode));
    message.rogueGachaInfo !== undefined &&
      (obj.rogueGachaInfo = message.rogueGachaInfo
        ? RogueGachaInfo.toJSON(message.rogueGachaInfo)
        : undefined);
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<SetRogueGachaWishListScRsp>, I>>(
    object: I
  ): SetRogueGachaWishListScRsp {
    const message = createBaseSetRogueGachaWishListScRsp();
    message.retcode = object.retcode ?? 0;
    message.rogueGachaInfo =
      object.rogueGachaInfo !== undefined && object.rogueGachaInfo !== null
        ? RogueGachaInfo.fromPartial(object.rogueGachaInfo)
        : undefined;
    return message;
  },
};

function createBaseDoRogueGachaCsReq(): DoRogueGachaCsReq {
  return { count: 0 };
}

export const DoRogueGachaCsReq = {
  encode(
    message: DoRogueGachaCsReq,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.count !== 0) {
      writer.uint32(8).uint32(message.count);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): DoRogueGachaCsReq {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDoRogueGachaCsReq();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.count = reader.uint32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): DoRogueGachaCsReq {
    return {
      count: isSet(object.count) ? Number(object.count) : 0,
    };
  },

  toJSON(message: DoRogueGachaCsReq): unknown {
    const obj: any = {};
    message.count !== undefined && (obj.count = Math.round(message.count));
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<DoRogueGachaCsReq>, I>>(
    object: I
  ): DoRogueGachaCsReq {
    const message = createBaseDoRogueGachaCsReq();
    message.count = object.count ?? 0;
    return message;
  },
};

function createBaseDoRogueGachaScRsp(): DoRogueGachaScRsp {
  return { retcode: 0, itemList: undefined, rogueGachaInfo: undefined };
}

export const DoRogueGachaScRsp = {
  encode(
    message: DoRogueGachaScRsp,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.retcode !== 0) {
      writer.uint32(8).uint32(message.retcode);
    }
    if (message.itemList !== undefined) {
      ItemList.encode(message.itemList, writer.uint32(18).fork()).ldelim();
    }
    if (message.rogueGachaInfo !== undefined) {
      RogueGachaInfo.encode(
        message.rogueGachaInfo,
        writer.uint32(26).fork()
      ).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): DoRogueGachaScRsp {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDoRogueGachaScRsp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.retcode = reader.uint32();
          break;
        case 2:
          message.itemList = ItemList.decode(reader, reader.uint32());
          break;
        case 3:
          message.rogueGachaInfo = RogueGachaInfo.decode(
            reader,
            reader.uint32()
          );
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): DoRogueGachaScRsp {
    return {
      retcode: isSet(object.retcode) ? Number(object.retcode) : 0,
      itemList: isSet(object.itemList)
        ? ItemList.fromJSON(object.itemList)
        : undefined,
      rogueGachaInfo: isSet(object.rogueGachaInfo)
        ? RogueGachaInfo.fromJSON(object.rogueGachaInfo)
        : undefined,
    };
  },

  toJSON(message: DoRogueGachaScRsp): unknown {
    const obj: any = {};
    message.retcode !== undefined &&
      (obj.retcode = Math.round(message.retcode));
    message.itemList !== undefined &&
      (obj.itemList = message.itemList
        ? ItemList.toJSON(message.itemList)
        : undefined);
    message.rogueGachaInfo !== undefined &&
      (obj.rogueGachaInfo = message.rogueGachaInfo
        ? RogueGachaInfo.toJSON(message.rogueGachaInfo)
        : undefined);
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<DoRogueGachaScRsp>, I>>(
    object: I
  ): DoRogueGachaScRsp {
    const message = createBaseDoRogueGachaScRsp();
    message.retcode = object.retcode ?? 0;
    message.itemList =
      object.itemList !== undefined && object.itemList !== null
        ? ItemList.fromPartial(object.itemList)
        : undefined;
    message.rogueGachaInfo =
      object.rogueGachaInfo !== undefined && object.rogueGachaInfo !== null
        ? RogueGachaInfo.fromPartial(object.rogueGachaInfo)
        : undefined;
    return message;
  },
};

function createBaseSyncRogueGachaRefreshScNotify(): SyncRogueGachaRefreshScNotify {
  return { rogueGachaInfo: undefined };
}

export const SyncRogueGachaRefreshScNotify = {
  encode(
    message: SyncRogueGachaRefreshScNotify,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.rogueGachaInfo !== undefined) {
      RogueGachaInfo.encode(
        message.rogueGachaInfo,
        writer.uint32(10).fork()
      ).ldelim();
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): SyncRogueGachaRefreshScNotify {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSyncRogueGachaRefreshScNotify();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.rogueGachaInfo = RogueGachaInfo.decode(
            reader,
            reader.uint32()
          );
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): SyncRogueGachaRefreshScNotify {
    return {
      rogueGachaInfo: isSet(object.rogueGachaInfo)
        ? RogueGachaInfo.fromJSON(object.rogueGachaInfo)
        : undefined,
    };
  },

  toJSON(message: SyncRogueGachaRefreshScNotify): unknown {
    const obj: any = {};
    message.rogueGachaInfo !== undefined &&
      (obj.rogueGachaInfo = message.rogueGachaInfo
        ? RogueGachaInfo.toJSON(message.rogueGachaInfo)
        : undefined);
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<SyncRogueGachaRefreshScNotify>, I>>(
    object: I
  ): SyncRogueGachaRefreshScNotify {
    const message = createBaseSyncRogueGachaRefreshScNotify();
    message.rogueGachaInfo =
      object.rogueGachaInfo !== undefined && object.rogueGachaInfo !== null
        ? RogueGachaInfo.fromPartial(object.rogueGachaInfo)
        : undefined;
    return message;
  },
};

function createBaseGetRogueAppraisalItemInfoCsReq(): GetRogueAppraisalItemInfoCsReq {
  return {};
}

export const GetRogueAppraisalItemInfoCsReq = {
  encode(
    _: GetRogueAppraisalItemInfoCsReq,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): GetRogueAppraisalItemInfoCsReq {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetRogueAppraisalItemInfoCsReq();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(_: any): GetRogueAppraisalItemInfoCsReq {
    return {};
  },

  toJSON(_: GetRogueAppraisalItemInfoCsReq): unknown {
    const obj: any = {};
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<GetRogueAppraisalItemInfoCsReq>, I>>(
    _: I
  ): GetRogueAppraisalItemInfoCsReq {
    const message = createBaseGetRogueAppraisalItemInfoCsReq();
    return message;
  },
};

function createBaseGetRogueAppraisalItemInfoScRsp(): GetRogueAppraisalItemInfoScRsp {
  return { retcode: 0, itemInfo: undefined };
}

export const GetRogueAppraisalItemInfoScRsp = {
  encode(
    message: GetRogueAppraisalItemInfoScRsp,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.retcode !== 0) {
      writer.uint32(8).uint32(message.retcode);
    }
    if (message.itemInfo !== undefined) {
      RogueAppraisalItemInfo.encode(
        message.itemInfo,
        writer.uint32(18).fork()
      ).ldelim();
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): GetRogueAppraisalItemInfoScRsp {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetRogueAppraisalItemInfoScRsp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.retcode = reader.uint32();
          break;
        case 2:
          message.itemInfo = RogueAppraisalItemInfo.decode(
            reader,
            reader.uint32()
          );
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): GetRogueAppraisalItemInfoScRsp {
    return {
      retcode: isSet(object.retcode) ? Number(object.retcode) : 0,
      itemInfo: isSet(object.itemInfo)
        ? RogueAppraisalItemInfo.fromJSON(object.itemInfo)
        : undefined,
    };
  },

  toJSON(message: GetRogueAppraisalItemInfoScRsp): unknown {
    const obj: any = {};
    message.retcode !== undefined &&
      (obj.retcode = Math.round(message.retcode));
    message.itemInfo !== undefined &&
      (obj.itemInfo = message.itemInfo
        ? RogueAppraisalItemInfo.toJSON(message.itemInfo)
        : undefined);
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<GetRogueAppraisalItemInfoScRsp>, I>>(
    object: I
  ): GetRogueAppraisalItemInfoScRsp {
    const message = createBaseGetRogueAppraisalItemInfoScRsp();
    message.retcode = object.retcode ?? 0;
    message.itemInfo =
      object.itemInfo !== undefined && object.itemInfo !== null
        ? RogueAppraisalItemInfo.fromPartial(object.itemInfo)
        : undefined;
    return message;
  },
};

function createBaseSyncRogueMiracleGetItemScNotify(): SyncRogueMiracleGetItemScNotify {
  return { itemData: undefined };
}

export const SyncRogueMiracleGetItemScNotify = {
  encode(
    message: SyncRogueMiracleGetItemScNotify,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.itemData !== undefined) {
      ItemList.encode(message.itemData, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): SyncRogueMiracleGetItemScNotify {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSyncRogueMiracleGetItemScNotify();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.itemData = ItemList.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): SyncRogueMiracleGetItemScNotify {
    return {
      itemData: isSet(object.itemData)
        ? ItemList.fromJSON(object.itemData)
        : undefined,
    };
  },

  toJSON(message: SyncRogueMiracleGetItemScNotify): unknown {
    const obj: any = {};
    message.itemData !== undefined &&
      (obj.itemData = message.itemData
        ? ItemList.toJSON(message.itemData)
        : undefined);
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<SyncRogueMiracleGetItemScNotify>, I>>(
    object: I
  ): SyncRogueMiracleGetItemScNotify {
    const message = createBaseSyncRogueMiracleGetItemScNotify();
    message.itemData =
      object.itemData !== undefined && object.itemData !== null
        ? ItemList.fromPartial(object.itemData)
        : undefined;
    return message;
  },
};

function createBaseSyncRogueQuestScNotify(): SyncRogueQuestScNotify {
  return { rogueQuest: undefined };
}

export const SyncRogueQuestScNotify = {
  encode(
    message: SyncRogueQuestScNotify,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.rogueQuest !== undefined) {
      RogueQuest.encode(message.rogueQuest, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): SyncRogueQuestScNotify {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSyncRogueQuestScNotify();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.rogueQuest = RogueQuest.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): SyncRogueQuestScNotify {
    return {
      rogueQuest: isSet(object.rogueQuest)
        ? RogueQuest.fromJSON(object.rogueQuest)
        : undefined,
    };
  },

  toJSON(message: SyncRogueQuestScNotify): unknown {
    const obj: any = {};
    message.rogueQuest !== undefined &&
      (obj.rogueQuest = message.rogueQuest
        ? RogueQuest.toJSON(message.rogueQuest)
        : undefined);
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<SyncRogueQuestScNotify>, I>>(
    object: I
  ): SyncRogueQuestScNotify {
    const message = createBaseSyncRogueQuestScNotify();
    message.rogueQuest =
      object.rogueQuest !== undefined && object.rogueQuest !== null
        ? RogueQuest.fromPartial(object.rogueQuest)
        : undefined;
    return message;
  },
};

function createBaseGetRogueQuestRewardCsReq(): GetRogueQuestRewardCsReq {
  return { rogueQuestId: 0, type: 0 };
}

export const GetRogueQuestRewardCsReq = {
  encode(
    message: GetRogueQuestRewardCsReq,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.rogueQuestId !== 0) {
      writer.uint32(8).uint32(message.rogueQuestId);
    }
    if (message.type !== 0) {
      writer.uint32(16).int32(message.type);
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): GetRogueQuestRewardCsReq {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetRogueQuestRewardCsReq();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.rogueQuestId = reader.uint32();
          break;
        case 2:
          message.type = reader.int32() as any;
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): GetRogueQuestRewardCsReq {
    return {
      rogueQuestId: isSet(object.rogueQuestId)
        ? Number(object.rogueQuestId)
        : 0,
      type: isSet(object.type) ? rogueQuestTypeFromJSON(object.type) : 0,
    };
  },

  toJSON(message: GetRogueQuestRewardCsReq): unknown {
    const obj: any = {};
    message.rogueQuestId !== undefined &&
      (obj.rogueQuestId = Math.round(message.rogueQuestId));
    message.type !== undefined &&
      (obj.type = rogueQuestTypeToJSON(message.type));
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<GetRogueQuestRewardCsReq>, I>>(
    object: I
  ): GetRogueQuestRewardCsReq {
    const message = createBaseGetRogueQuestRewardCsReq();
    message.rogueQuestId = object.rogueQuestId ?? 0;
    message.type = object.type ?? 0;
    return message;
  },
};

function createBaseGetRogueQuestRewardScRsp(): GetRogueQuestRewardScRsp {
  return { retcode: 0, reward: undefined, rogueQuest: undefined };
}

export const GetRogueQuestRewardScRsp = {
  encode(
    message: GetRogueQuestRewardScRsp,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.retcode !== 0) {
      writer.uint32(8).uint32(message.retcode);
    }
    if (message.reward !== undefined) {
      ItemList.encode(message.reward, writer.uint32(18).fork()).ldelim();
    }
    if (message.rogueQuest !== undefined) {
      RogueQuest.encode(message.rogueQuest, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): GetRogueQuestRewardScRsp {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetRogueQuestRewardScRsp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.retcode = reader.uint32();
          break;
        case 2:
          message.reward = ItemList.decode(reader, reader.uint32());
          break;
        case 3:
          message.rogueQuest = RogueQuest.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): GetRogueQuestRewardScRsp {
    return {
      retcode: isSet(object.retcode) ? Number(object.retcode) : 0,
      reward: isSet(object.reward)
        ? ItemList.fromJSON(object.reward)
        : undefined,
      rogueQuest: isSet(object.rogueQuest)
        ? RogueQuest.fromJSON(object.rogueQuest)
        : undefined,
    };
  },

  toJSON(message: GetRogueQuestRewardScRsp): unknown {
    const obj: any = {};
    message.retcode !== undefined &&
      (obj.retcode = Math.round(message.retcode));
    message.reward !== undefined &&
      (obj.reward = message.reward
        ? ItemList.toJSON(message.reward)
        : undefined);
    message.rogueQuest !== undefined &&
      (obj.rogueQuest = message.rogueQuest
        ? RogueQuest.toJSON(message.rogueQuest)
        : undefined);
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<GetRogueQuestRewardScRsp>, I>>(
    object: I
  ): GetRogueQuestRewardScRsp {
    const message = createBaseGetRogueQuestRewardScRsp();
    message.retcode = object.retcode ?? 0;
    message.reward =
      object.reward !== undefined && object.reward !== null
        ? ItemList.fromPartial(object.reward)
        : undefined;
    message.rogueQuest =
      object.rogueQuest !== undefined && object.rogueQuest !== null
        ? RogueQuest.fromPartial(object.rogueQuest)
        : undefined;
    return message;
  },
};

function createBaseVector(): Vector {
  return { x: 0, y: 0, z: 0 };
}

export const Vector = {
  encode(
    message: Vector,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.x !== 0) {
      writer.uint32(8).sint32(message.x);
    }
    if (message.y !== 0) {
      writer.uint32(16).sint32(message.y);
    }
    if (message.z !== 0) {
      writer.uint32(24).sint32(message.z);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Vector {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVector();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.x = reader.sint32();
          break;
        case 2:
          message.y = reader.sint32();
          break;
        case 3:
          message.z = reader.sint32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): Vector {
    return {
      x: isSet(object.x) ? Number(object.x) : 0,
      y: isSet(object.y) ? Number(object.y) : 0,
      z: isSet(object.z) ? Number(object.z) : 0,
    };
  },

  toJSON(message: Vector): unknown {
    const obj: any = {};
    message.x !== undefined && (obj.x = Math.round(message.x));
    message.y !== undefined && (obj.y = Math.round(message.y));
    message.z !== undefined && (obj.z = Math.round(message.z));
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<Vector>, I>>(object: I): Vector {
    const message = createBaseVector();
    message.x = object.x ?? 0;
    message.y = object.y ?? 0;
    message.z = object.z ?? 0;
    return message;
  },
};

function createBaseMotionInfo(): MotionInfo {
  return { pos: undefined, rot: undefined };
}

export const MotionInfo = {
  encode(
    message: MotionInfo,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.pos !== undefined) {
      Vector.encode(message.pos, writer.uint32(10).fork()).ldelim();
    }
    if (message.rot !== undefined) {
      Vector.encode(message.rot, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MotionInfo {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMotionInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.pos = Vector.decode(reader, reader.uint32());
          break;
        case 2:
          message.rot = Vector.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): MotionInfo {
    return {
      pos: isSet(object.pos) ? Vector.fromJSON(object.pos) : undefined,
      rot: isSet(object.rot) ? Vector.fromJSON(object.rot) : undefined,
    };
  },

  toJSON(message: MotionInfo): unknown {
    const obj: any = {};
    message.pos !== undefined &&
      (obj.pos = message.pos ? Vector.toJSON(message.pos) : undefined);
    message.rot !== undefined &&
      (obj.rot = message.rot ? Vector.toJSON(message.rot) : undefined);
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<MotionInfo>, I>>(
    object: I
  ): MotionInfo {
    const message = createBaseMotionInfo();
    message.pos =
      object.pos !== undefined && object.pos !== null
        ? Vector.fromPartial(object.pos)
        : undefined;
    message.rot =
      object.rot !== undefined && object.rot !== null
        ? Vector.fromPartial(object.rot)
        : undefined;
    return message;
  },
};

function createBaseSceneActorInfo(): SceneActorInfo {
  return { uid: 0, avatarType: 0, baseAvatarId: 0, mapLayer: 0 };
}

export const SceneActorInfo = {
  encode(
    message: SceneActorInfo,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.uid !== 0) {
      writer.uint32(8).uint32(message.uid);
    }
    if (message.avatarType !== 0) {
      writer.uint32(16).int32(message.avatarType);
    }
    if (message.baseAvatarId !== 0) {
      writer.uint32(24).uint32(message.baseAvatarId);
    }
    if (message.mapLayer !== 0) {
      writer.uint32(32).uint32(message.mapLayer);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SceneActorInfo {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSceneActorInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.uid = reader.uint32();
          break;
        case 2:
          message.avatarType = reader.int32() as any;
          break;
        case 3:
          message.baseAvatarId = reader.uint32();
          break;
        case 4:
          message.mapLayer = reader.uint32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): SceneActorInfo {
    return {
      uid: isSet(object.uid) ? Number(object.uid) : 0,
      avatarType: isSet(object.avatarType)
        ? avatarTypeFromJSON(object.avatarType)
        : 0,
      baseAvatarId: isSet(object.baseAvatarId)
        ? Number(object.baseAvatarId)
        : 0,
      mapLayer: isSet(object.mapLayer) ? Number(object.mapLayer) : 0,
    };
  },

  toJSON(message: SceneActorInfo): unknown {
    const obj: any = {};
    message.uid !== undefined && (obj.uid = Math.round(message.uid));
    message.avatarType !== undefined &&
      (obj.avatarType = avatarTypeToJSON(message.avatarType));
    message.baseAvatarId !== undefined &&
      (obj.baseAvatarId = Math.round(message.baseAvatarId));
    message.mapLayer !== undefined &&
      (obj.mapLayer = Math.round(message.mapLayer));
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<SceneActorInfo>, I>>(
    object: I
  ): SceneActorInfo {
    const message = createBaseSceneActorInfo();
    message.uid = object.uid ?? 0;
    message.avatarType = object.avatarType ?? 0;
    message.baseAvatarId = object.baseAvatarId ?? 0;
    message.mapLayer = object.mapLayer ?? 0;
    return message;
  },
};

function createBaseSceneNpcMonsterInfo(): SceneNpcMonsterInfo {
  return {
    monsterId: 0,
    isGenMonster: false,
    eventId: 0,
    isSetWorldLevel: false,
    worldLevel: 0,
  };
}

export const SceneNpcMonsterInfo = {
  encode(
    message: SceneNpcMonsterInfo,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.monsterId !== 0) {
      writer.uint32(8).uint32(message.monsterId);
    }
    if (message.isGenMonster === true) {
      writer.uint32(16).bool(message.isGenMonster);
    }
    if (message.eventId !== 0) {
      writer.uint32(24).uint32(message.eventId);
    }
    if (message.isSetWorldLevel === true) {
      writer.uint32(32).bool(message.isSetWorldLevel);
    }
    if (message.worldLevel !== 0) {
      writer.uint32(40).uint32(message.worldLevel);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SceneNpcMonsterInfo {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSceneNpcMonsterInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.monsterId = reader.uint32();
          break;
        case 2:
          message.isGenMonster = reader.bool();
          break;
        case 3:
          message.eventId = reader.uint32();
          break;
        case 4:
          message.isSetWorldLevel = reader.bool();
          break;
        case 5:
          message.worldLevel = reader.uint32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): SceneNpcMonsterInfo {
    return {
      monsterId: isSet(object.monsterId) ? Number(object.monsterId) : 0,
      isGenMonster: isSet(object.isGenMonster)
        ? Boolean(object.isGenMonster)
        : false,
      eventId: isSet(object.eventId) ? Number(object.eventId) : 0,
      isSetWorldLevel: isSet(object.isSetWorldLevel)
        ? Boolean(object.isSetWorldLevel)
        : false,
      worldLevel: isSet(object.worldLevel) ? Number(object.worldLevel) : 0,
    };
  },

  toJSON(message: SceneNpcMonsterInfo): unknown {
    const obj: any = {};
    message.monsterId !== undefined &&
      (obj.monsterId = Math.round(message.monsterId));
    message.isGenMonster !== undefined &&
      (obj.isGenMonster = message.isGenMonster);
    message.eventId !== undefined &&
      (obj.eventId = Math.round(message.eventId));
    message.isSetWorldLevel !== undefined &&
      (obj.isSetWorldLevel = message.isSetWorldLevel);
    message.worldLevel !== undefined &&
      (obj.worldLevel = Math.round(message.worldLevel));
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<SceneNpcMonsterInfo>, I>>(
    object: I
  ): SceneNpcMonsterInfo {
    const message = createBaseSceneNpcMonsterInfo();
    message.monsterId = object.monsterId ?? 0;
    message.isGenMonster = object.isGenMonster ?? false;
    message.eventId = object.eventId ?? 0;
    message.isSetWorldLevel = object.isSetWorldLevel ?? false;
    message.worldLevel = object.worldLevel ?? 0;
    return message;
  },
};

function createBaseNpcRogueInfo(): NpcRogueInfo {
  return { dialogueGroupId: 0, rogueNpcId: 0 };
}

export const NpcRogueInfo = {
  encode(
    message: NpcRogueInfo,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.dialogueGroupId !== 0) {
      writer.uint32(8).uint32(message.dialogueGroupId);
    }
    if (message.rogueNpcId !== 0) {
      writer.uint32(16).uint32(message.rogueNpcId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): NpcRogueInfo {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNpcRogueInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.dialogueGroupId = reader.uint32();
          break;
        case 2:
          message.rogueNpcId = reader.uint32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): NpcRogueInfo {
    return {
      dialogueGroupId: isSet(object.dialogueGroupId)
        ? Number(object.dialogueGroupId)
        : 0,
      rogueNpcId: isSet(object.rogueNpcId) ? Number(object.rogueNpcId) : 0,
    };
  },

  toJSON(message: NpcRogueInfo): unknown {
    const obj: any = {};
    message.dialogueGroupId !== undefined &&
      (obj.dialogueGroupId = Math.round(message.dialogueGroupId));
    message.rogueNpcId !== undefined &&
      (obj.rogueNpcId = Math.round(message.rogueNpcId));
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<NpcRogueInfo>, I>>(
    object: I
  ): NpcRogueInfo {
    const message = createBaseNpcRogueInfo();
    message.dialogueGroupId = object.dialogueGroupId ?? 0;
    message.rogueNpcId = object.rogueNpcId ?? 0;
    return message;
  },
};

function createBaseNpcExtraInfo(): NpcExtraInfo {
  return { rogueInfo: undefined };
}

export const NpcExtraInfo = {
  encode(
    message: NpcExtraInfo,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.rogueInfo !== undefined) {
      NpcRogueInfo.encode(message.rogueInfo, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): NpcExtraInfo {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNpcExtraInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.rogueInfo = NpcRogueInfo.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): NpcExtraInfo {
    return {
      rogueInfo: isSet(object.rogueInfo)
        ? NpcRogueInfo.fromJSON(object.rogueInfo)
        : undefined,
    };
  },

  toJSON(message: NpcExtraInfo): unknown {
    const obj: any = {};
    message.rogueInfo !== undefined &&
      (obj.rogueInfo = message.rogueInfo
        ? NpcRogueInfo.toJSON(message.rogueInfo)
        : undefined);
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<NpcExtraInfo>, I>>(
    object: I
  ): NpcExtraInfo {
    const message = createBaseNpcExtraInfo();
    message.rogueInfo =
      object.rogueInfo !== undefined && object.rogueInfo !== null
        ? NpcRogueInfo.fromPartial(object.rogueInfo)
        : undefined;
    return message;
  },
};

function createBaseSceneNpcInfo(): SceneNpcInfo {
  return { npcId: 0, extraInfo: undefined };
}

export const SceneNpcInfo = {
  encode(
    message: SceneNpcInfo,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.npcId !== 0) {
      writer.uint32(8).uint32(message.npcId);
    }
    if (message.extraInfo !== undefined) {
      NpcExtraInfo.encode(message.extraInfo, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SceneNpcInfo {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSceneNpcInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.npcId = reader.uint32();
          break;
        case 2:
          message.extraInfo = NpcExtraInfo.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): SceneNpcInfo {
    return {
      npcId: isSet(object.npcId) ? Number(object.npcId) : 0,
      extraInfo: isSet(object.extraInfo)
        ? NpcExtraInfo.fromJSON(object.extraInfo)
        : undefined,
    };
  },

  toJSON(message: SceneNpcInfo): unknown {
    const obj: any = {};
    message.npcId !== undefined && (obj.npcId = Math.round(message.npcId));
    message.extraInfo !== undefined &&
      (obj.extraInfo = message.extraInfo
        ? NpcExtraInfo.toJSON(message.extraInfo)
        : undefined);
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<SceneNpcInfo>, I>>(
    object: I
  ): SceneNpcInfo {
    const message = createBaseSceneNpcInfo();
    message.npcId = object.npcId ?? 0;
    message.extraInfo =
      object.extraInfo !== undefined && object.extraInfo !== null
        ? NpcExtraInfo.fromPartial(object.extraInfo)
        : undefined;
    return message;
  },
};

function createBasePropRogueInfo(): PropRogueInfo {
  return {
    roomId: 0,
    appraisalCount: 0,
    appraisalMaxCount: 0,
    pickAvatarMaxCount: 0,
  };
}

export const PropRogueInfo = {
  encode(
    message: PropRogueInfo,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.roomId !== 0) {
      writer.uint32(8).uint32(message.roomId);
    }
    if (message.appraisalCount !== 0) {
      writer.uint32(16).uint32(message.appraisalCount);
    }
    if (message.appraisalMaxCount !== 0) {
      writer.uint32(24).uint32(message.appraisalMaxCount);
    }
    if (message.pickAvatarMaxCount !== 0) {
      writer.uint32(32).uint32(message.pickAvatarMaxCount);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): PropRogueInfo {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePropRogueInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.roomId = reader.uint32();
          break;
        case 2:
          message.appraisalCount = reader.uint32();
          break;
        case 3:
          message.appraisalMaxCount = reader.uint32();
          break;
        case 4:
          message.pickAvatarMaxCount = reader.uint32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): PropRogueInfo {
    return {
      roomId: isSet(object.roomId) ? Number(object.roomId) : 0,
      appraisalCount: isSet(object.appraisalCount)
        ? Number(object.appraisalCount)
        : 0,
      appraisalMaxCount: isSet(object.appraisalMaxCount)
        ? Number(object.appraisalMaxCount)
        : 0,
      pickAvatarMaxCount: isSet(object.pickAvatarMaxCount)
        ? Number(object.pickAvatarMaxCount)
        : 0,
    };
  },

  toJSON(message: PropRogueInfo): unknown {
    const obj: any = {};
    message.roomId !== undefined && (obj.roomId = Math.round(message.roomId));
    message.appraisalCount !== undefined &&
      (obj.appraisalCount = Math.round(message.appraisalCount));
    message.appraisalMaxCount !== undefined &&
      (obj.appraisalMaxCount = Math.round(message.appraisalMaxCount));
    message.pickAvatarMaxCount !== undefined &&
      (obj.pickAvatarMaxCount = Math.round(message.pickAvatarMaxCount));
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<PropRogueInfo>, I>>(
    object: I
  ): PropRogueInfo {
    const message = createBasePropRogueInfo();
    message.roomId = object.roomId ?? 0;
    message.appraisalCount = object.appraisalCount ?? 0;
    message.appraisalMaxCount = object.appraisalMaxCount ?? 0;
    message.pickAvatarMaxCount = object.pickAvatarMaxCount ?? 0;
    return message;
  },
};

function createBasePropExtraInfo(): PropExtraInfo {
  return { rogueInfo: undefined };
}

export const PropExtraInfo = {
  encode(
    message: PropExtraInfo,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.rogueInfo !== undefined) {
      PropRogueInfo.encode(
        message.rogueInfo,
        writer.uint32(10).fork()
      ).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): PropExtraInfo {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePropExtraInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.rogueInfo = PropRogueInfo.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): PropExtraInfo {
    return {
      rogueInfo: isSet(object.rogueInfo)
        ? PropRogueInfo.fromJSON(object.rogueInfo)
        : undefined,
    };
  },

  toJSON(message: PropExtraInfo): unknown {
    const obj: any = {};
    message.rogueInfo !== undefined &&
      (obj.rogueInfo = message.rogueInfo
        ? PropRogueInfo.toJSON(message.rogueInfo)
        : undefined);
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<PropExtraInfo>, I>>(
    object: I
  ): PropExtraInfo {
    const message = createBasePropExtraInfo();
    message.rogueInfo =
      object.rogueInfo !== undefined && object.rogueInfo !== null
        ? PropRogueInfo.fromPartial(object.rogueInfo)
        : undefined;
    return message;
  },
};

function createBaseScenePropInfo(): ScenePropInfo {
  return {
    propId: 0,
    propState: 0,
    createTimeMs: 0,
    lifeTimeMs: 0,
    extraInfo: undefined,
  };
}

export const ScenePropInfo = {
  encode(
    message: ScenePropInfo,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.propId !== 0) {
      writer.uint32(8).uint32(message.propId);
    }
    if (message.propState !== 0) {
      writer.uint32(16).uint32(message.propState);
    }
    if (message.createTimeMs !== 0) {
      writer.uint32(24).uint64(message.createTimeMs);
    }
    if (message.lifeTimeMs !== 0) {
      writer.uint32(32).uint32(message.lifeTimeMs);
    }
    if (message.extraInfo !== undefined) {
      PropExtraInfo.encode(
        message.extraInfo,
        writer.uint32(42).fork()
      ).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ScenePropInfo {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseScenePropInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.propId = reader.uint32();
          break;
        case 2:
          message.propState = reader.uint32();
          break;
        case 3:
          message.createTimeMs = longToNumber(reader.uint64() as Long);
          break;
        case 4:
          message.lifeTimeMs = reader.uint32();
          break;
        case 5:
          message.extraInfo = PropExtraInfo.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): ScenePropInfo {
    return {
      propId: isSet(object.propId) ? Number(object.propId) : 0,
      propState: isSet(object.propState) ? Number(object.propState) : 0,
      createTimeMs: isSet(object.createTimeMs)
        ? Number(object.createTimeMs)
        : 0,
      lifeTimeMs: isSet(object.lifeTimeMs) ? Number(object.lifeTimeMs) : 0,
      extraInfo: isSet(object.extraInfo)
        ? PropExtraInfo.fromJSON(object.extraInfo)
        : undefined,
    };
  },

  toJSON(message: ScenePropInfo): unknown {
    const obj: any = {};
    message.propId !== undefined && (obj.propId = Math.round(message.propId));
    message.propState !== undefined &&
      (obj.propState = Math.round(message.propState));
    message.createTimeMs !== undefined &&
      (obj.createTimeMs = Math.round(message.createTimeMs));
    message.lifeTimeMs !== undefined &&
      (obj.lifeTimeMs = Math.round(message.lifeTimeMs));
    message.extraInfo !== undefined &&
      (obj.extraInfo = message.extraInfo
        ? PropExtraInfo.toJSON(message.extraInfo)
        : undefined);
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<ScenePropInfo>, I>>(
    object: I
  ): ScenePropInfo {
    const message = createBaseScenePropInfo();
    message.propId = object.propId ?? 0;
    message.propState = object.propState ?? 0;
    message.createTimeMs = object.createTimeMs ?? 0;
    message.lifeTimeMs = object.lifeTimeMs ?? 0;
    message.extraInfo =
      object.extraInfo !== undefined && object.extraInfo !== null
        ? PropExtraInfo.fromPartial(object.extraInfo)
        : undefined;
    return message;
  },
};

function createBaseSceneEntityInfo(): SceneEntityInfo {
  return {
    entityId: 0,
    motion: undefined,
    groupId: 0,
    instId: 0,
    actor: undefined,
    npcMonster: undefined,
    npc: undefined,
    prop: undefined,
  };
}

export const SceneEntityInfo = {
  encode(
    message: SceneEntityInfo,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.entityId !== 0) {
      writer.uint32(8).uint32(message.entityId);
    }
    if (message.motion !== undefined) {
      MotionInfo.encode(message.motion, writer.uint32(18).fork()).ldelim();
    }
    if (message.groupId !== 0) {
      writer.uint32(24).uint32(message.groupId);
    }
    if (message.instId !== 0) {
      writer.uint32(32).uint32(message.instId);
    }
    if (message.actor !== undefined) {
      SceneActorInfo.encode(message.actor, writer.uint32(42).fork()).ldelim();
    }
    if (message.npcMonster !== undefined) {
      SceneNpcMonsterInfo.encode(
        message.npcMonster,
        writer.uint32(50).fork()
      ).ldelim();
    }
    if (message.npc !== undefined) {
      SceneNpcInfo.encode(message.npc, writer.uint32(58).fork()).ldelim();
    }
    if (message.prop !== undefined) {
      ScenePropInfo.encode(message.prop, writer.uint32(66).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SceneEntityInfo {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSceneEntityInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.entityId = reader.uint32();
          break;
        case 2:
          message.motion = MotionInfo.decode(reader, reader.uint32());
          break;
        case 3:
          message.groupId = reader.uint32();
          break;
        case 4:
          message.instId = reader.uint32();
          break;
        case 5:
          message.actor = SceneActorInfo.decode(reader, reader.uint32());
          break;
        case 6:
          message.npcMonster = SceneNpcMonsterInfo.decode(
            reader,
            reader.uint32()
          );
          break;
        case 7:
          message.npc = SceneNpcInfo.decode(reader, reader.uint32());
          break;
        case 8:
          message.prop = ScenePropInfo.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): SceneEntityInfo {
    return {
      entityId: isSet(object.entityId) ? Number(object.entityId) : 0,
      motion: isSet(object.motion)
        ? MotionInfo.fromJSON(object.motion)
        : undefined,
      groupId: isSet(object.groupId) ? Number(object.groupId) : 0,
      instId: isSet(object.instId) ? Number(object.instId) : 0,
      actor: isSet(object.actor)
        ? SceneActorInfo.fromJSON(object.actor)
        : undefined,
      npcMonster: isSet(object.npcMonster)
        ? SceneNpcMonsterInfo.fromJSON(object.npcMonster)
        : undefined,
      npc: isSet(object.npc) ? SceneNpcInfo.fromJSON(object.npc) : undefined,
      prop: isSet(object.prop)
        ? ScenePropInfo.fromJSON(object.prop)
        : undefined,
    };
  },

  toJSON(message: SceneEntityInfo): unknown {
    const obj: any = {};
    message.entityId !== undefined &&
      (obj.entityId = Math.round(message.entityId));
    message.motion !== undefined &&
      (obj.motion = message.motion
        ? MotionInfo.toJSON(message.motion)
        : undefined);
    message.groupId !== undefined &&
      (obj.groupId = Math.round(message.groupId));
    message.instId !== undefined && (obj.instId = Math.round(message.instId));
    message.actor !== undefined &&
      (obj.actor = message.actor
        ? SceneActorInfo.toJSON(message.actor)
        : undefined);
    message.npcMonster !== undefined &&
      (obj.npcMonster = message.npcMonster
        ? SceneNpcMonsterInfo.toJSON(message.npcMonster)
        : undefined);
    message.npc !== undefined &&
      (obj.npc = message.npc ? SceneNpcInfo.toJSON(message.npc) : undefined);
    message.prop !== undefined &&
      (obj.prop = message.prop
        ? ScenePropInfo.toJSON(message.prop)
        : undefined);
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<SceneEntityInfo>, I>>(
    object: I
  ): SceneEntityInfo {
    const message = createBaseSceneEntityInfo();
    message.entityId = object.entityId ?? 0;
    message.motion =
      object.motion !== undefined && object.motion !== null
        ? MotionInfo.fromPartial(object.motion)
        : undefined;
    message.groupId = object.groupId ?? 0;
    message.instId = object.instId ?? 0;
    message.actor =
      object.actor !== undefined && object.actor !== null
        ? SceneActorInfo.fromPartial(object.actor)
        : undefined;
    message.npcMonster =
      object.npcMonster !== undefined && object.npcMonster !== null
        ? SceneNpcMonsterInfo.fromPartial(object.npcMonster)
        : undefined;
    message.npc =
      object.npc !== undefined && object.npc !== null
        ? SceneNpcInfo.fromPartial(object.npc)
        : undefined;
    message.prop =
      object.prop !== undefined && object.prop !== null
        ? ScenePropInfo.fromPartial(object.prop)
        : undefined;
    return message;
  },
};

function createBaseBuffInfo(): BuffInfo {
  return {
    buffId: 0,
    level: 0,
    addTimeMs: 0,
    lifeTime: 0,
    count: 0,
    baseAvatarId: 0,
    dynamicValues: {},
  };
}

export const BuffInfo = {
  encode(
    message: BuffInfo,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.buffId !== 0) {
      writer.uint32(8).uint32(message.buffId);
    }
    if (message.level !== 0) {
      writer.uint32(16).uint32(message.level);
    }
    if (message.addTimeMs !== 0) {
      writer.uint32(24).uint64(message.addTimeMs);
    }
    if (message.lifeTime !== 0) {
      writer.uint32(37).float(message.lifeTime);
    }
    if (message.count !== 0) {
      writer.uint32(40).uint32(message.count);
    }
    if (message.baseAvatarId !== 0) {
      writer.uint32(48).uint32(message.baseAvatarId);
    }
    Object.entries(message.dynamicValues).forEach(([key, value]) => {
      BuffInfo_DynamicValuesEntry.encode(
        { key: key as any, value },
        writer.uint32(58).fork()
      ).ldelim();
    });
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): BuffInfo {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBuffInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.buffId = reader.uint32();
          break;
        case 2:
          message.level = reader.uint32();
          break;
        case 3:
          message.addTimeMs = longToNumber(reader.uint64() as Long);
          break;
        case 4:
          message.lifeTime = reader.float();
          break;
        case 5:
          message.count = reader.uint32();
          break;
        case 6:
          message.baseAvatarId = reader.uint32();
          break;
        case 7:
          const entry7 = BuffInfo_DynamicValuesEntry.decode(
            reader,
            reader.uint32()
          );
          if (entry7.value !== undefined) {
            message.dynamicValues[entry7.key] = entry7.value;
          }
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): BuffInfo {
    return {
      buffId: isSet(object.buffId) ? Number(object.buffId) : 0,
      level: isSet(object.level) ? Number(object.level) : 0,
      addTimeMs: isSet(object.addTimeMs) ? Number(object.addTimeMs) : 0,
      lifeTime: isSet(object.lifeTime) ? Number(object.lifeTime) : 0,
      count: isSet(object.count) ? Number(object.count) : 0,
      baseAvatarId: isSet(object.baseAvatarId)
        ? Number(object.baseAvatarId)
        : 0,
      dynamicValues: isObject(object.dynamicValues)
        ? Object.entries(object.dynamicValues).reduce<{
            [key: string]: number;
          }>((acc, [key, value]) => {
            acc[key] = Number(value);
            return acc;
          }, {})
        : {},
    };
  },

  toJSON(message: BuffInfo): unknown {
    const obj: any = {};
    message.buffId !== undefined && (obj.buffId = Math.round(message.buffId));
    message.level !== undefined && (obj.level = Math.round(message.level));
    message.addTimeMs !== undefined &&
      (obj.addTimeMs = Math.round(message.addTimeMs));
    message.lifeTime !== undefined && (obj.lifeTime = message.lifeTime);
    message.count !== undefined && (obj.count = Math.round(message.count));
    message.baseAvatarId !== undefined &&
      (obj.baseAvatarId = Math.round(message.baseAvatarId));
    obj.dynamicValues = {};
    if (message.dynamicValues) {
      Object.entries(message.dynamicValues).forEach(([k, v]) => {
        obj.dynamicValues[k] = v;
      });
    }
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<BuffInfo>, I>>(object: I): BuffInfo {
    const message = createBaseBuffInfo();
    message.buffId = object.buffId ?? 0;
    message.level = object.level ?? 0;
    message.addTimeMs = object.addTimeMs ?? 0;
    message.lifeTime = object.lifeTime ?? 0;
    message.count = object.count ?? 0;
    message.baseAvatarId = object.baseAvatarId ?? 0;
    message.dynamicValues = Object.entries(object.dynamicValues ?? {}).reduce<{
      [key: string]: number;
    }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = Number(value);
      }
      return acc;
    }, {});
    return message;
  },
};

function createBaseBuffInfo_DynamicValuesEntry(): BuffInfo_DynamicValuesEntry {
  return { key: "", value: 0 };
}

export const BuffInfo_DynamicValuesEntry = {
  encode(
    message: BuffInfo_DynamicValuesEntry,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== 0) {
      writer.uint32(21).float(message.value);
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): BuffInfo_DynamicValuesEntry {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBuffInfo_DynamicValuesEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.key = reader.string();
          break;
        case 2:
          message.value = reader.float();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): BuffInfo_DynamicValuesEntry {
    return {
      key: isSet(object.key) ? String(object.key) : "",
      value: isSet(object.value) ? Number(object.value) : 0,
    };
  },

  toJSON(message: BuffInfo_DynamicValuesEntry): unknown {
    const obj: any = {};
    message.key !== undefined && (obj.key = message.key);
    message.value !== undefined && (obj.value = message.value);
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<BuffInfo_DynamicValuesEntry>, I>>(
    object: I
  ): BuffInfo_DynamicValuesEntry {
    const message = createBaseBuffInfo_DynamicValuesEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? 0;
    return message;
  },
};

function createBaseEntityBuffInfo(): EntityBuffInfo {
  return { entityId: 0, buffList: [] };
}

export const EntityBuffInfo = {
  encode(
    message: EntityBuffInfo,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.entityId !== 0) {
      writer.uint32(8).uint32(message.entityId);
    }
    for (const v of message.buffList) {
      BuffInfo.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): EntityBuffInfo {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEntityBuffInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.entityId = reader.uint32();
          break;
        case 2:
          message.buffList.push(BuffInfo.decode(reader, reader.uint32()));
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): EntityBuffInfo {
    return {
      entityId: isSet(object.entityId) ? Number(object.entityId) : 0,
      buffList: Array.isArray(object?.buffList)
        ? object.buffList.map((e: any) => BuffInfo.fromJSON(e))
        : [],
    };
  },

  toJSON(message: EntityBuffInfo): unknown {
    const obj: any = {};
    message.entityId !== undefined &&
      (obj.entityId = Math.round(message.entityId));
    if (message.buffList) {
      obj.buffList = message.buffList.map((e) =>
        e ? BuffInfo.toJSON(e) : undefined
      );
    } else {
      obj.buffList = [];
    }
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<EntityBuffInfo>, I>>(
    object: I
  ): EntityBuffInfo {
    const message = createBaseEntityBuffInfo();
    message.entityId = object.entityId ?? 0;
    message.buffList =
      object.buffList?.map((e) => BuffInfo.fromPartial(e)) || [];
    return message;
  },
};

function createBaseSceneInfo(): SceneInfo {
  return {
    planeId: 0,
    floorId: 0,
    entityList: [],
    lightenSectionList: [],
    leaderEntityId: 0,
    entryId: 0,
    envBuffList: [],
    entityBuffList: [],
    gameModeType: 0,
  };
}

export const SceneInfo = {
  encode(
    message: SceneInfo,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.planeId !== 0) {
      writer.uint32(8).uint32(message.planeId);
    }
    if (message.floorId !== 0) {
      writer.uint32(16).uint32(message.floorId);
    }
    for (const v of message.entityList) {
      SceneEntityInfo.encode(v!, writer.uint32(26).fork()).ldelim();
    }
    writer.uint32(34).fork();
    for (const v of message.lightenSectionList) {
      writer.uint32(v);
    }
    writer.ldelim();
    if (message.leaderEntityId !== 0) {
      writer.uint32(40).uint32(message.leaderEntityId);
    }
    if (message.entryId !== 0) {
      writer.uint32(48).uint32(message.entryId);
    }
    for (const v of message.envBuffList) {
      BuffInfo.encode(v!, writer.uint32(58).fork()).ldelim();
    }
    for (const v of message.entityBuffList) {
      EntityBuffInfo.encode(v!, writer.uint32(66).fork()).ldelim();
    }
    if (message.gameModeType !== 0) {
      writer.uint32(72).uint32(message.gameModeType);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SceneInfo {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSceneInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.planeId = reader.uint32();
          break;
        case 2:
          message.floorId = reader.uint32();
          break;
        case 3:
          message.entityList.push(
            SceneEntityInfo.decode(reader, reader.uint32())
          );
          break;
        case 4:
          if ((tag & 7) === 2) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.lightenSectionList.push(reader.uint32());
            }
          } else {
            message.lightenSectionList.push(reader.uint32());
          }
          break;
        case 5:
          message.leaderEntityId = reader.uint32();
          break;
        case 6:
          message.entryId = reader.uint32();
          break;
        case 7:
          message.envBuffList.push(BuffInfo.decode(reader, reader.uint32()));
          break;
        case 8:
          message.entityBuffList.push(
            EntityBuffInfo.decode(reader, reader.uint32())
          );
          break;
        case 9:
          message.gameModeType = reader.uint32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): SceneInfo {
    return {
      planeId: isSet(object.planeId) ? Number(object.planeId) : 0,
      floorId: isSet(object.floorId) ? Number(object.floorId) : 0,
      entityList: Array.isArray(object?.entityList)
        ? object.entityList.map((e: any) => SceneEntityInfo.fromJSON(e))
        : [],
      lightenSectionList: Array.isArray(object?.lightenSectionList)
        ? object.lightenSectionList.map((e: any) => Number(e))
        : [],
      leaderEntityId: isSet(object.leaderEntityId)
        ? Number(object.leaderEntityId)
        : 0,
      entryId: isSet(object.entryId) ? Number(object.entryId) : 0,
      envBuffList: Array.isArray(object?.envBuffList)
        ? object.envBuffList.map((e: any) => BuffInfo.fromJSON(e))
        : [],
      entityBuffList: Array.isArray(object?.entityBuffList)
        ? object.entityBuffList.map((e: any) => EntityBuffInfo.fromJSON(e))
        : [],
      gameModeType: isSet(object.gameModeType)
        ? Number(object.gameModeType)
        : 0,
    };
  },

  toJSON(message: SceneInfo): unknown {
    const obj: any = {};
    message.planeId !== undefined &&
      (obj.planeId = Math.round(message.planeId));
    message.floorId !== undefined &&
      (obj.floorId = Math.round(message.floorId));
    if (message.entityList) {
      obj.entityList = message.entityList.map((e) =>
        e ? SceneEntityInfo.toJSON(e) : undefined
      );
    } else {
      obj.entityList = [];
    }
    if (message.lightenSectionList) {
      obj.lightenSectionList = message.lightenSectionList.map((e) =>
        Math.round(e)
      );
    } else {
      obj.lightenSectionList = [];
    }
    message.leaderEntityId !== undefined &&
      (obj.leaderEntityId = Math.round(message.leaderEntityId));
    message.entryId !== undefined &&
      (obj.entryId = Math.round(message.entryId));
    if (message.envBuffList) {
      obj.envBuffList = message.envBuffList.map((e) =>
        e ? BuffInfo.toJSON(e) : undefined
      );
    } else {
      obj.envBuffList = [];
    }
    if (message.entityBuffList) {
      obj.entityBuffList = message.entityBuffList.map((e) =>
        e ? EntityBuffInfo.toJSON(e) : undefined
      );
    } else {
      obj.entityBuffList = [];
    }
    message.gameModeType !== undefined &&
      (obj.gameModeType = Math.round(message.gameModeType));
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<SceneInfo>, I>>(
    object: I
  ): SceneInfo {
    const message = createBaseSceneInfo();
    message.planeId = object.planeId ?? 0;
    message.floorId = object.floorId ?? 0;
    message.entityList =
      object.entityList?.map((e) => SceneEntityInfo.fromPartial(e)) || [];
    message.lightenSectionList = object.lightenSectionList?.map((e) => e) || [];
    message.leaderEntityId = object.leaderEntityId ?? 0;
    message.entryId = object.entryId ?? 0;
    message.envBuffList =
      object.envBuffList?.map((e) => BuffInfo.fromPartial(e)) || [];
    message.entityBuffList =
      object.entityBuffList?.map((e) => EntityBuffInfo.fromPartial(e)) || [];
    message.gameModeType = object.gameModeType ?? 0;
    return message;
  },
};

function createBaseEntityMotion(): EntityMotion {
  return { entityId: 0, motion: undefined, mapLayer: 0 };
}

export const EntityMotion = {
  encode(
    message: EntityMotion,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.entityId !== 0) {
      writer.uint32(8).uint32(message.entityId);
    }
    if (message.motion !== undefined) {
      MotionInfo.encode(message.motion, writer.uint32(18).fork()).ldelim();
    }
    if (message.mapLayer !== 0) {
      writer.uint32(24).uint32(message.mapLayer);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): EntityMotion {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEntityMotion();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.entityId = reader.uint32();
          break;
        case 2:
          message.motion = MotionInfo.decode(reader, reader.uint32());
          break;
        case 3:
          message.mapLayer = reader.uint32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): EntityMotion {
    return {
      entityId: isSet(object.entityId) ? Number(object.entityId) : 0,
      motion: isSet(object.motion)
        ? MotionInfo.fromJSON(object.motion)
        : undefined,
      mapLayer: isSet(object.mapLayer) ? Number(object.mapLayer) : 0,
    };
  },

  toJSON(message: EntityMotion): unknown {
    const obj: any = {};
    message.entityId !== undefined &&
      (obj.entityId = Math.round(message.entityId));
    message.motion !== undefined &&
      (obj.motion = message.motion
        ? MotionInfo.toJSON(message.motion)
        : undefined);
    message.mapLayer !== undefined &&
      (obj.mapLayer = Math.round(message.mapLayer));
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<EntityMotion>, I>>(
    object: I
  ): EntityMotion {
    const message = createBaseEntityMotion();
    message.entityId = object.entityId ?? 0;
    message.motion =
      object.motion !== undefined && object.motion !== null
        ? MotionInfo.fromPartial(object.motion)
        : undefined;
    message.mapLayer = object.mapLayer ?? 0;
    return message;
  },
};

function createBaseSceneEntityMoveCsReq(): SceneEntityMoveCsReq {
  return { entityMotionList: [], entryId: 0 };
}

export const SceneEntityMoveCsReq = {
  encode(
    message: SceneEntityMoveCsReq,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    for (const v of message.entityMotionList) {
      EntityMotion.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    if (message.entryId !== 0) {
      writer.uint32(16).uint32(message.entryId);
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): SceneEntityMoveCsReq {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSceneEntityMoveCsReq();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.entityMotionList.push(
            EntityMotion.decode(reader, reader.uint32())
          );
          break;
        case 2:
          message.entryId = reader.uint32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): SceneEntityMoveCsReq {
    return {
      entityMotionList: Array.isArray(object?.entityMotionList)
        ? object.entityMotionList.map((e: any) => EntityMotion.fromJSON(e))
        : [],
      entryId: isSet(object.entryId) ? Number(object.entryId) : 0,
    };
  },

  toJSON(message: SceneEntityMoveCsReq): unknown {
    const obj: any = {};
    if (message.entityMotionList) {
      obj.entityMotionList = message.entityMotionList.map((e) =>
        e ? EntityMotion.toJSON(e) : undefined
      );
    } else {
      obj.entityMotionList = [];
    }
    message.entryId !== undefined &&
      (obj.entryId = Math.round(message.entryId));
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<SceneEntityMoveCsReq>, I>>(
    object: I
  ): SceneEntityMoveCsReq {
    const message = createBaseSceneEntityMoveCsReq();
    message.entityMotionList =
      object.entityMotionList?.map((e) => EntityMotion.fromPartial(e)) || [];
    message.entryId = object.entryId ?? 0;
    return message;
  },
};

function createBaseSceneEntityMoveScRsp(): SceneEntityMoveScRsp {
  return { retcode: 0, downloadData: undefined };
}

export const SceneEntityMoveScRsp = {
  encode(
    message: SceneEntityMoveScRsp,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.retcode !== 0) {
      writer.uint32(8).uint32(message.retcode);
    }
    if (message.downloadData !== undefined) {
      ClientDownloadData.encode(
        message.downloadData,
        writer.uint32(18).fork()
      ).ldelim();
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): SceneEntityMoveScRsp {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSceneEntityMoveScRsp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.retcode = reader.uint32();
          break;
        case 2:
          message.downloadData = ClientDownloadData.decode(
            reader,
            reader.uint32()
          );
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): SceneEntityMoveScRsp {
    return {
      retcode: isSet(object.retcode) ? Number(object.retcode) : 0,
      downloadData: isSet(object.downloadData)
        ? ClientDownloadData.fromJSON(object.downloadData)
        : undefined,
    };
  },

  toJSON(message: SceneEntityMoveScRsp): unknown {
    const obj: any = {};
    message.retcode !== undefined &&
      (obj.retcode = Math.round(message.retcode));
    message.downloadData !== undefined &&
      (obj.downloadData = message.downloadData
        ? ClientDownloadData.toJSON(message.downloadData)
        : undefined);
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<SceneEntityMoveScRsp>, I>>(
    object: I
  ): SceneEntityMoveScRsp {
    const message = createBaseSceneEntityMoveScRsp();
    message.retcode = object.retcode ?? 0;
    message.downloadData =
      object.downloadData !== undefined && object.downloadData !== null
        ? ClientDownloadData.fromPartial(object.downloadData)
        : undefined;
    return message;
  },
};

function createBaseSceneEntityMoveScNotify(): SceneEntityMoveScNotify {
  return { entityId: 0, motion: undefined };
}

export const SceneEntityMoveScNotify = {
  encode(
    message: SceneEntityMoveScNotify,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.entityId !== 0) {
      writer.uint32(8).uint32(message.entityId);
    }
    if (message.motion !== undefined) {
      MotionInfo.encode(message.motion, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): SceneEntityMoveScNotify {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSceneEntityMoveScNotify();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.entityId = reader.uint32();
          break;
        case 2:
          message.motion = MotionInfo.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): SceneEntityMoveScNotify {
    return {
      entityId: isSet(object.entityId) ? Number(object.entityId) : 0,
      motion: isSet(object.motion)
        ? MotionInfo.fromJSON(object.motion)
        : undefined,
    };
  },

  toJSON(message: SceneEntityMoveScNotify): unknown {
    const obj: any = {};
    message.entityId !== undefined &&
      (obj.entityId = Math.round(message.entityId));
    message.motion !== undefined &&
      (obj.motion = message.motion
        ? MotionInfo.toJSON(message.motion)
        : undefined);
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<SceneEntityMoveScNotify>, I>>(
    object: I
  ): SceneEntityMoveScNotify {
    const message = createBaseSceneEntityMoveScNotify();
    message.entityId = object.entityId ?? 0;
    message.motion =
      object.motion !== undefined && object.motion !== null
        ? MotionInfo.fromPartial(object.motion)
        : undefined;
    return message;
  },
};

function createBaseInteractPropCsReq(): InteractPropCsReq {
  return { propEntityId: 0, interactId: 0, motion: undefined };
}

export const InteractPropCsReq = {
  encode(
    message: InteractPropCsReq,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.propEntityId !== 0) {
      writer.uint32(8).uint32(message.propEntityId);
    }
    if (message.interactId !== 0) {
      writer.uint32(16).uint32(message.interactId);
    }
    if (message.motion !== undefined) {
      MotionInfo.encode(message.motion, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): InteractPropCsReq {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInteractPropCsReq();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.propEntityId = reader.uint32();
          break;
        case 2:
          message.interactId = reader.uint32();
          break;
        case 3:
          message.motion = MotionInfo.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): InteractPropCsReq {
    return {
      propEntityId: isSet(object.propEntityId)
        ? Number(object.propEntityId)
        : 0,
      interactId: isSet(object.interactId) ? Number(object.interactId) : 0,
      motion: isSet(object.motion)
        ? MotionInfo.fromJSON(object.motion)
        : undefined,
    };
  },

  toJSON(message: InteractPropCsReq): unknown {
    const obj: any = {};
    message.propEntityId !== undefined &&
      (obj.propEntityId = Math.round(message.propEntityId));
    message.interactId !== undefined &&
      (obj.interactId = Math.round(message.interactId));
    message.motion !== undefined &&
      (obj.motion = message.motion
        ? MotionInfo.toJSON(message.motion)
        : undefined);
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<InteractPropCsReq>, I>>(
    object: I
  ): InteractPropCsReq {
    const message = createBaseInteractPropCsReq();
    message.propEntityId = object.propEntityId ?? 0;
    message.interactId = object.interactId ?? 0;
    message.motion =
      object.motion !== undefined && object.motion !== null
        ? MotionInfo.fromPartial(object.motion)
        : undefined;
    return message;
  },
};

function createBaseInteractPropScRsp(): InteractPropScRsp {
  return { retcode: 0, propEntityId: 0, propState: 0 };
}

export const InteractPropScRsp = {
  encode(
    message: InteractPropScRsp,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.retcode !== 0) {
      writer.uint32(8).uint32(message.retcode);
    }
    if (message.propEntityId !== 0) {
      writer.uint32(16).uint32(message.propEntityId);
    }
    if (message.propState !== 0) {
      writer.uint32(24).uint32(message.propState);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): InteractPropScRsp {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInteractPropScRsp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.retcode = reader.uint32();
          break;
        case 2:
          message.propEntityId = reader.uint32();
          break;
        case 3:
          message.propState = reader.uint32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): InteractPropScRsp {
    return {
      retcode: isSet(object.retcode) ? Number(object.retcode) : 0,
      propEntityId: isSet(object.propEntityId)
        ? Number(object.propEntityId)
        : 0,
      propState: isSet(object.propState) ? Number(object.propState) : 0,
    };
  },

  toJSON(message: InteractPropScRsp): unknown {
    const obj: any = {};
    message.retcode !== undefined &&
      (obj.retcode = Math.round(message.retcode));
    message.propEntityId !== undefined &&
      (obj.propEntityId = Math.round(message.propEntityId));
    message.propState !== undefined &&
      (obj.propState = Math.round(message.propState));
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<InteractPropScRsp>, I>>(
    object: I
  ): InteractPropScRsp {
    const message = createBaseInteractPropScRsp();
    message.retcode = object.retcode ?? 0;
    message.propEntityId = object.propEntityId ?? 0;
    message.propState = object.propState ?? 0;
    return message;
  },
};

function createBaseSceneCastSkillCsReq(): SceneCastSkillCsReq {
  return {
    castEntityId: 0,
    skillIndex: 0,
    abilityTargetEntityId: 0,
    hitTargetEntityIdList: [],
    assistMonsterEntityIdList: [],
    targetMotion: undefined,
  };
}

export const SceneCastSkillCsReq = {
  encode(
    message: SceneCastSkillCsReq,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.castEntityId !== 0) {
      writer.uint32(8).uint32(message.castEntityId);
    }
    if (message.skillIndex !== 0) {
      writer.uint32(16).uint32(message.skillIndex);
    }
    if (message.abilityTargetEntityId !== 0) {
      writer.uint32(24).uint32(message.abilityTargetEntityId);
    }
    writer.uint32(34).fork();
    for (const v of message.hitTargetEntityIdList) {
      writer.uint32(v);
    }
    writer.ldelim();
    writer.uint32(42).fork();
    for (const v of message.assistMonsterEntityIdList) {
      writer.uint32(v);
    }
    writer.ldelim();
    if (message.targetMotion !== undefined) {
      MotionInfo.encode(
        message.targetMotion,
        writer.uint32(50).fork()
      ).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SceneCastSkillCsReq {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSceneCastSkillCsReq();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.castEntityId = reader.uint32();
          break;
        case 2:
          message.skillIndex = reader.uint32();
          break;
        case 3:
          message.abilityTargetEntityId = reader.uint32();
          break;
        case 4:
          if ((tag & 7) === 2) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.hitTargetEntityIdList.push(reader.uint32());
            }
          } else {
            message.hitTargetEntityIdList.push(reader.uint32());
          }
          break;
        case 5:
          if ((tag & 7) === 2) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.assistMonsterEntityIdList.push(reader.uint32());
            }
          } else {
            message.assistMonsterEntityIdList.push(reader.uint32());
          }
          break;
        case 6:
          message.targetMotion = MotionInfo.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): SceneCastSkillCsReq {
    return {
      castEntityId: isSet(object.castEntityId)
        ? Number(object.castEntityId)
        : 0,
      skillIndex: isSet(object.skillIndex) ? Number(object.skillIndex) : 0,
      abilityTargetEntityId: isSet(object.abilityTargetEntityId)
        ? Number(object.abilityTargetEntityId)
        : 0,
      hitTargetEntityIdList: Array.isArray(object?.hitTargetEntityIdList)
        ? object.hitTargetEntityIdList.map((e: any) => Number(e))
        : [],
      assistMonsterEntityIdList: Array.isArray(
        object?.assistMonsterEntityIdList
      )
        ? object.assistMonsterEntityIdList.map((e: any) => Number(e))
        : [],
      targetMotion: isSet(object.targetMotion)
        ? MotionInfo.fromJSON(object.targetMotion)
        : undefined,
    };
  },

  toJSON(message: SceneCastSkillCsReq): unknown {
    const obj: any = {};
    message.castEntityId !== undefined &&
      (obj.castEntityId = Math.round(message.castEntityId));
    message.skillIndex !== undefined &&
      (obj.skillIndex = Math.round(message.skillIndex));
    message.abilityTargetEntityId !== undefined &&
      (obj.abilityTargetEntityId = Math.round(message.abilityTargetEntityId));
    if (message.hitTargetEntityIdList) {
      obj.hitTargetEntityIdList = message.hitTargetEntityIdList.map((e) =>
        Math.round(e)
      );
    } else {
      obj.hitTargetEntityIdList = [];
    }
    if (message.assistMonsterEntityIdList) {
      obj.assistMonsterEntityIdList = message.assistMonsterEntityIdList.map(
        (e) => Math.round(e)
      );
    } else {
      obj.assistMonsterEntityIdList = [];
    }
    message.targetMotion !== undefined &&
      (obj.targetMotion = message.targetMotion
        ? MotionInfo.toJSON(message.targetMotion)
        : undefined);
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<SceneCastSkillCsReq>, I>>(
    object: I
  ): SceneCastSkillCsReq {
    const message = createBaseSceneCastSkillCsReq();
    message.castEntityId = object.castEntityId ?? 0;
    message.skillIndex = object.skillIndex ?? 0;
    message.abilityTargetEntityId = object.abilityTargetEntityId ?? 0;
    message.hitTargetEntityIdList =
      object.hitTargetEntityIdList?.map((e) => e) || [];
    message.assistMonsterEntityIdList =
      object.assistMonsterEntityIdList?.map((e) => e) || [];
    message.targetMotion =
      object.targetMotion !== undefined && object.targetMotion !== null
        ? MotionInfo.fromPartial(object.targetMotion)
        : undefined;
    return message;
  },
};

function createBaseSceneCastSkillScRsp(): SceneCastSkillScRsp {
  return { retcode: 0, battleInfo: undefined };
}

export const SceneCastSkillScRsp = {
  encode(
    message: SceneCastSkillScRsp,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.retcode !== 0) {
      writer.uint32(8).uint32(message.retcode);
    }
    if (message.battleInfo !== undefined) {
      SceneBattleInfo.encode(
        message.battleInfo,
        writer.uint32(18).fork()
      ).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SceneCastSkillScRsp {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSceneCastSkillScRsp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.retcode = reader.uint32();
          break;
        case 2:
          message.battleInfo = SceneBattleInfo.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): SceneCastSkillScRsp {
    return {
      retcode: isSet(object.retcode) ? Number(object.retcode) : 0,
      battleInfo: isSet(object.battleInfo)
        ? SceneBattleInfo.fromJSON(object.battleInfo)
        : undefined,
    };
  },

  toJSON(message: SceneCastSkillScRsp): unknown {
    const obj: any = {};
    message.retcode !== undefined &&
      (obj.retcode = Math.round(message.retcode));
    message.battleInfo !== undefined &&
      (obj.battleInfo = message.battleInfo
        ? SceneBattleInfo.toJSON(message.battleInfo)
        : undefined);
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<SceneCastSkillScRsp>, I>>(
    object: I
  ): SceneCastSkillScRsp {
    const message = createBaseSceneCastSkillScRsp();
    message.retcode = object.retcode ?? 0;
    message.battleInfo =
      object.battleInfo !== undefined && object.battleInfo !== null
        ? SceneBattleInfo.fromPartial(object.battleInfo)
        : undefined;
    return message;
  },
};

function createBaseSceneEnterStageCsReq(): SceneEnterStageCsReq {
  return { eventId: 0 };
}

export const SceneEnterStageCsReq = {
  encode(
    message: SceneEnterStageCsReq,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.eventId !== 0) {
      writer.uint32(8).uint32(message.eventId);
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): SceneEnterStageCsReq {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSceneEnterStageCsReq();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.eventId = reader.uint32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): SceneEnterStageCsReq {
    return {
      eventId: isSet(object.eventId) ? Number(object.eventId) : 0,
    };
  },

  toJSON(message: SceneEnterStageCsReq): unknown {
    const obj: any = {};
    message.eventId !== undefined &&
      (obj.eventId = Math.round(message.eventId));
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<SceneEnterStageCsReq>, I>>(
    object: I
  ): SceneEnterStageCsReq {
    const message = createBaseSceneEnterStageCsReq();
    message.eventId = object.eventId ?? 0;
    return message;
  },
};

function createBaseSceneEnterStageScRsp(): SceneEnterStageScRsp {
  return { retcode: 0, battleInfo: undefined };
}

export const SceneEnterStageScRsp = {
  encode(
    message: SceneEnterStageScRsp,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.retcode !== 0) {
      writer.uint32(8).uint32(message.retcode);
    }
    if (message.battleInfo !== undefined) {
      SceneBattleInfo.encode(
        message.battleInfo,
        writer.uint32(18).fork()
      ).ldelim();
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): SceneEnterStageScRsp {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSceneEnterStageScRsp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.retcode = reader.uint32();
          break;
        case 2:
          message.battleInfo = SceneBattleInfo.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): SceneEnterStageScRsp {
    return {
      retcode: isSet(object.retcode) ? Number(object.retcode) : 0,
      battleInfo: isSet(object.battleInfo)
        ? SceneBattleInfo.fromJSON(object.battleInfo)
        : undefined,
    };
  },

  toJSON(message: SceneEnterStageScRsp): unknown {
    const obj: any = {};
    message.retcode !== undefined &&
      (obj.retcode = Math.round(message.retcode));
    message.battleInfo !== undefined &&
      (obj.battleInfo = message.battleInfo
        ? SceneBattleInfo.toJSON(message.battleInfo)
        : undefined);
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<SceneEnterStageScRsp>, I>>(
    object: I
  ): SceneEnterStageScRsp {
    const message = createBaseSceneEnterStageScRsp();
    message.retcode = object.retcode ?? 0;
    message.battleInfo =
      object.battleInfo !== undefined && object.battleInfo !== null
        ? SceneBattleInfo.fromPartial(object.battleInfo)
        : undefined;
    return message;
  },
};

function createBaseGetCurSceneInfoCsReq(): GetCurSceneInfoCsReq {
  return {};
}

export const GetCurSceneInfoCsReq = {
  encode(
    _: GetCurSceneInfoCsReq,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): GetCurSceneInfoCsReq {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetCurSceneInfoCsReq();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(_: any): GetCurSceneInfoCsReq {
    return {};
  },

  toJSON(_: GetCurSceneInfoCsReq): unknown {
    const obj: any = {};
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<GetCurSceneInfoCsReq>, I>>(
    _: I
  ): GetCurSceneInfoCsReq {
    const message = createBaseGetCurSceneInfoCsReq();
    return message;
  },
};

function createBaseGetCurSceneInfoScRsp(): GetCurSceneInfoScRsp {
  return { retcode: 0, scene: undefined };
}

export const GetCurSceneInfoScRsp = {
  encode(
    message: GetCurSceneInfoScRsp,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.retcode !== 0) {
      writer.uint32(8).uint32(message.retcode);
    }
    if (message.scene !== undefined) {
      SceneInfo.encode(message.scene, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): GetCurSceneInfoScRsp {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetCurSceneInfoScRsp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.retcode = reader.uint32();
          break;
        case 2:
          message.scene = SceneInfo.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): GetCurSceneInfoScRsp {
    return {
      retcode: isSet(object.retcode) ? Number(object.retcode) : 0,
      scene: isSet(object.scene) ? SceneInfo.fromJSON(object.scene) : undefined,
    };
  },

  toJSON(message: GetCurSceneInfoScRsp): unknown {
    const obj: any = {};
    message.retcode !== undefined &&
      (obj.retcode = Math.round(message.retcode));
    message.scene !== undefined &&
      (obj.scene = message.scene ? SceneInfo.toJSON(message.scene) : undefined);
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<GetCurSceneInfoScRsp>, I>>(
    object: I
  ): GetCurSceneInfoScRsp {
    const message = createBaseGetCurSceneInfoScRsp();
    message.retcode = object.retcode ?? 0;
    message.scene =
      object.scene !== undefined && object.scene !== null
        ? SceneInfo.fromPartial(object.scene)
        : undefined;
    return message;
  },
};

function createBaseSceneEntityUpdateScNotify(): SceneEntityUpdateScNotify {
  return { entityList: [] };
}

export const SceneEntityUpdateScNotify = {
  encode(
    message: SceneEntityUpdateScNotify,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    for (const v of message.entityList) {
      SceneEntityInfo.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): SceneEntityUpdateScNotify {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSceneEntityUpdateScNotify();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.entityList.push(
            SceneEntityInfo.decode(reader, reader.uint32())
          );
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): SceneEntityUpdateScNotify {
    return {
      entityList: Array.isArray(object?.entityList)
        ? object.entityList.map((e: any) => SceneEntityInfo.fromJSON(e))
        : [],
    };
  },

  toJSON(message: SceneEntityUpdateScNotify): unknown {
    const obj: any = {};
    if (message.entityList) {
      obj.entityList = message.entityList.map((e) =>
        e ? SceneEntityInfo.toJSON(e) : undefined
      );
    } else {
      obj.entityList = [];
    }
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<SceneEntityUpdateScNotify>, I>>(
    object: I
  ): SceneEntityUpdateScNotify {
    const message = createBaseSceneEntityUpdateScNotify();
    message.entityList =
      object.entityList?.map((e) => SceneEntityInfo.fromPartial(e)) || [];
    return message;
  },
};

function createBaseSceneEntityDisappearScNotify(): SceneEntityDisappearScNotify {
  return { entityIdList: [] };
}

export const SceneEntityDisappearScNotify = {
  encode(
    message: SceneEntityDisappearScNotify,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    writer.uint32(10).fork();
    for (const v of message.entityIdList) {
      writer.uint32(v);
    }
    writer.ldelim();
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): SceneEntityDisappearScNotify {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSceneEntityDisappearScNotify();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if ((tag & 7) === 2) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.entityIdList.push(reader.uint32());
            }
          } else {
            message.entityIdList.push(reader.uint32());
          }
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): SceneEntityDisappearScNotify {
    return {
      entityIdList: Array.isArray(object?.entityIdList)
        ? object.entityIdList.map((e: any) => Number(e))
        : [],
    };
  },

  toJSON(message: SceneEntityDisappearScNotify): unknown {
    const obj: any = {};
    if (message.entityIdList) {
      obj.entityIdList = message.entityIdList.map((e) => Math.round(e));
    } else {
      obj.entityIdList = [];
    }
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<SceneEntityDisappearScNotify>, I>>(
    object: I
  ): SceneEntityDisappearScNotify {
    const message = createBaseSceneEntityDisappearScNotify();
    message.entityIdList = object.entityIdList?.map((e) => e) || [];
    return message;
  },
};

function createBaseSpringTransferCsReq(): SpringTransferCsReq {
  return { planeId: 0, floorId: 0, propEntityId: 0 };
}

export const SpringTransferCsReq = {
  encode(
    message: SpringTransferCsReq,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.planeId !== 0) {
      writer.uint32(8).uint32(message.planeId);
    }
    if (message.floorId !== 0) {
      writer.uint32(16).uint32(message.floorId);
    }
    if (message.propEntityId !== 0) {
      writer.uint32(24).uint32(message.propEntityId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SpringTransferCsReq {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSpringTransferCsReq();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.planeId = reader.uint32();
          break;
        case 2:
          message.floorId = reader.uint32();
          break;
        case 3:
          message.propEntityId = reader.uint32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): SpringTransferCsReq {
    return {
      planeId: isSet(object.planeId) ? Number(object.planeId) : 0,
      floorId: isSet(object.floorId) ? Number(object.floorId) : 0,
      propEntityId: isSet(object.propEntityId)
        ? Number(object.propEntityId)
        : 0,
    };
  },

  toJSON(message: SpringTransferCsReq): unknown {
    const obj: any = {};
    message.planeId !== undefined &&
      (obj.planeId = Math.round(message.planeId));
    message.floorId !== undefined &&
      (obj.floorId = Math.round(message.floorId));
    message.propEntityId !== undefined &&
      (obj.propEntityId = Math.round(message.propEntityId));
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<SpringTransferCsReq>, I>>(
    object: I
  ): SpringTransferCsReq {
    const message = createBaseSpringTransferCsReq();
    message.planeId = object.planeId ?? 0;
    message.floorId = object.floorId ?? 0;
    message.propEntityId = object.propEntityId ?? 0;
    return message;
  },
};

function createBaseSpringTransferScRsp(): SpringTransferScRsp {
  return { retcode: 0 };
}

export const SpringTransferScRsp = {
  encode(
    message: SpringTransferScRsp,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.retcode !== 0) {
      writer.uint32(8).uint32(message.retcode);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SpringTransferScRsp {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSpringTransferScRsp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.retcode = reader.uint32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): SpringTransferScRsp {
    return {
      retcode: isSet(object.retcode) ? Number(object.retcode) : 0,
    };
  },

  toJSON(message: SpringTransferScRsp): unknown {
    const obj: any = {};
    message.retcode !== undefined &&
      (obj.retcode = Math.round(message.retcode));
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<SpringTransferScRsp>, I>>(
    object: I
  ): SpringTransferScRsp {
    const message = createBaseSpringTransferScRsp();
    message.retcode = object.retcode ?? 0;
    return message;
  },
};

function createBaseUpdateBuffScNotify(): UpdateBuffScNotify {
  return { entityId: 0, buff: undefined };
}

export const UpdateBuffScNotify = {
  encode(
    message: UpdateBuffScNotify,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.entityId !== 0) {
      writer.uint32(8).uint32(message.entityId);
    }
    if (message.buff !== undefined) {
      BuffInfo.encode(message.buff, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): UpdateBuffScNotify {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateBuffScNotify();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.entityId = reader.uint32();
          break;
        case 2:
          message.buff = BuffInfo.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): UpdateBuffScNotify {
    return {
      entityId: isSet(object.entityId) ? Number(object.entityId) : 0,
      buff: isSet(object.buff) ? BuffInfo.fromJSON(object.buff) : undefined,
    };
  },

  toJSON(message: UpdateBuffScNotify): unknown {
    const obj: any = {};
    message.entityId !== undefined &&
      (obj.entityId = Math.round(message.entityId));
    message.buff !== undefined &&
      (obj.buff = message.buff ? BuffInfo.toJSON(message.buff) : undefined);
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<UpdateBuffScNotify>, I>>(
    object: I
  ): UpdateBuffScNotify {
    const message = createBaseUpdateBuffScNotify();
    message.entityId = object.entityId ?? 0;
    message.buff =
      object.buff !== undefined && object.buff !== null
        ? BuffInfo.fromPartial(object.buff)
        : undefined;
    return message;
  },
};

function createBaseDelBuffScNotify(): DelBuffScNotify {
  return { entityId: 0, buffId: 0 };
}

export const DelBuffScNotify = {
  encode(
    message: DelBuffScNotify,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.entityId !== 0) {
      writer.uint32(8).uint32(message.entityId);
    }
    if (message.buffId !== 0) {
      writer.uint32(16).uint32(message.buffId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): DelBuffScNotify {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDelBuffScNotify();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.entityId = reader.uint32();
          break;
        case 2:
          message.buffId = reader.uint32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): DelBuffScNotify {
    return {
      entityId: isSet(object.entityId) ? Number(object.entityId) : 0,
      buffId: isSet(object.buffId) ? Number(object.buffId) : 0,
    };
  },

  toJSON(message: DelBuffScNotify): unknown {
    const obj: any = {};
    message.entityId !== undefined &&
      (obj.entityId = Math.round(message.entityId));
    message.buffId !== undefined && (obj.buffId = Math.round(message.buffId));
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<DelBuffScNotify>, I>>(
    object: I
  ): DelBuffScNotify {
    const message = createBaseDelBuffScNotify();
    message.entityId = object.entityId ?? 0;
    message.buffId = object.buffId ?? 0;
    return message;
  },
};

function createBaseSpringRefreshCsReq(): SpringRefreshCsReq {
  return { planeId: 0, floorId: 0, propEntityId: 0 };
}

export const SpringRefreshCsReq = {
  encode(
    message: SpringRefreshCsReq,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.planeId !== 0) {
      writer.uint32(8).uint32(message.planeId);
    }
    if (message.floorId !== 0) {
      writer.uint32(16).uint32(message.floorId);
    }
    if (message.propEntityId !== 0) {
      writer.uint32(24).uint32(message.propEntityId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SpringRefreshCsReq {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSpringRefreshCsReq();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.planeId = reader.uint32();
          break;
        case 2:
          message.floorId = reader.uint32();
          break;
        case 3:
          message.propEntityId = reader.uint32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): SpringRefreshCsReq {
    return {
      planeId: isSet(object.planeId) ? Number(object.planeId) : 0,
      floorId: isSet(object.floorId) ? Number(object.floorId) : 0,
      propEntityId: isSet(object.propEntityId)
        ? Number(object.propEntityId)
        : 0,
    };
  },

  toJSON(message: SpringRefreshCsReq): unknown {
    const obj: any = {};
    message.planeId !== undefined &&
      (obj.planeId = Math.round(message.planeId));
    message.floorId !== undefined &&
      (obj.floorId = Math.round(message.floorId));
    message.propEntityId !== undefined &&
      (obj.propEntityId = Math.round(message.propEntityId));
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<SpringRefreshCsReq>, I>>(
    object: I
  ): SpringRefreshCsReq {
    const message = createBaseSpringRefreshCsReq();
    message.planeId = object.planeId ?? 0;
    message.floorId = object.floorId ?? 0;
    message.propEntityId = object.propEntityId ?? 0;
    return message;
  },
};

function createBaseSpringRefreshScRsp(): SpringRefreshScRsp {
  return { retcode: 0 };
}

export const SpringRefreshScRsp = {
  encode(
    message: SpringRefreshScRsp,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.retcode !== 0) {
      writer.uint32(8).uint32(message.retcode);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SpringRefreshScRsp {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSpringRefreshScRsp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.retcode = reader.uint32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): SpringRefreshScRsp {
    return {
      retcode: isSet(object.retcode) ? Number(object.retcode) : 0,
    };
  },

  toJSON(message: SpringRefreshScRsp): unknown {
    const obj: any = {};
    message.retcode !== undefined &&
      (obj.retcode = Math.round(message.retcode));
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<SpringRefreshScRsp>, I>>(
    object: I
  ): SpringRefreshScRsp {
    const message = createBaseSpringRefreshScRsp();
    message.retcode = object.retcode ?? 0;
    return message;
  },
};

function createBaseLastSpringRefreshTimeNotify(): LastSpringRefreshTimeNotify {
  return { lastTime: 0 };
}

export const LastSpringRefreshTimeNotify = {
  encode(
    message: LastSpringRefreshTimeNotify,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.lastTime !== 0) {
      writer.uint32(8).uint32(message.lastTime);
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): LastSpringRefreshTimeNotify {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLastSpringRefreshTimeNotify();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.lastTime = reader.uint32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): LastSpringRefreshTimeNotify {
    return {
      lastTime: isSet(object.lastTime) ? Number(object.lastTime) : 0,
    };
  },

  toJSON(message: LastSpringRefreshTimeNotify): unknown {
    const obj: any = {};
    message.lastTime !== undefined &&
      (obj.lastTime = Math.round(message.lastTime));
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<LastSpringRefreshTimeNotify>, I>>(
    object: I
  ): LastSpringRefreshTimeNotify {
    const message = createBaseLastSpringRefreshTimeNotify();
    message.lastTime = object.lastTime ?? 0;
    return message;
  },
};

function createBaseReturnLastTownCsReq(): ReturnLastTownCsReq {
  return {};
}

export const ReturnLastTownCsReq = {
  encode(
    _: ReturnLastTownCsReq,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ReturnLastTownCsReq {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReturnLastTownCsReq();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(_: any): ReturnLastTownCsReq {
    return {};
  },

  toJSON(_: ReturnLastTownCsReq): unknown {
    const obj: any = {};
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<ReturnLastTownCsReq>, I>>(
    _: I
  ): ReturnLastTownCsReq {
    const message = createBaseReturnLastTownCsReq();
    return message;
  },
};

function createBaseReturnLastTownScRsp(): ReturnLastTownScRsp {
  return { retcode: 0, scene: undefined };
}

export const ReturnLastTownScRsp = {
  encode(
    message: ReturnLastTownScRsp,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.retcode !== 0) {
      writer.uint32(8).uint32(message.retcode);
    }
    if (message.scene !== undefined) {
      SceneInfo.encode(message.scene, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ReturnLastTownScRsp {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReturnLastTownScRsp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.retcode = reader.uint32();
          break;
        case 2:
          message.scene = SceneInfo.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): ReturnLastTownScRsp {
    return {
      retcode: isSet(object.retcode) ? Number(object.retcode) : 0,
      scene: isSet(object.scene) ? SceneInfo.fromJSON(object.scene) : undefined,
    };
  },

  toJSON(message: ReturnLastTownScRsp): unknown {
    const obj: any = {};
    message.retcode !== undefined &&
      (obj.retcode = Math.round(message.retcode));
    message.scene !== undefined &&
      (obj.scene = message.scene ? SceneInfo.toJSON(message.scene) : undefined);
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<ReturnLastTownScRsp>, I>>(
    object: I
  ): ReturnLastTownScRsp {
    const message = createBaseReturnLastTownScRsp();
    message.retcode = object.retcode ?? 0;
    message.scene =
      object.scene !== undefined && object.scene !== null
        ? SceneInfo.fromPartial(object.scene)
        : undefined;
    return message;
  },
};

function createBaseEnterSectionCsReq(): EnterSectionCsReq {
  return { sectionId: 0 };
}

export const EnterSectionCsReq = {
  encode(
    message: EnterSectionCsReq,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.sectionId !== 0) {
      writer.uint32(8).uint32(message.sectionId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): EnterSectionCsReq {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEnterSectionCsReq();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.sectionId = reader.uint32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): EnterSectionCsReq {
    return {
      sectionId: isSet(object.sectionId) ? Number(object.sectionId) : 0,
    };
  },

  toJSON(message: EnterSectionCsReq): unknown {
    const obj: any = {};
    message.sectionId !== undefined &&
      (obj.sectionId = Math.round(message.sectionId));
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<EnterSectionCsReq>, I>>(
    object: I
  ): EnterSectionCsReq {
    const message = createBaseEnterSectionCsReq();
    message.sectionId = object.sectionId ?? 0;
    return message;
  },
};

function createBaseEnterSectionScRsp(): EnterSectionScRsp {
  return { retcode: 0 };
}

export const EnterSectionScRsp = {
  encode(
    message: EnterSectionScRsp,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.retcode !== 0) {
      writer.uint32(8).uint32(message.retcode);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): EnterSectionScRsp {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEnterSectionScRsp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.retcode = reader.uint32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): EnterSectionScRsp {
    return {
      retcode: isSet(object.retcode) ? Number(object.retcode) : 0,
    };
  },

  toJSON(message: EnterSectionScRsp): unknown {
    const obj: any = {};
    message.retcode !== undefined &&
      (obj.retcode = Math.round(message.retcode));
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<EnterSectionScRsp>, I>>(
    object: I
  ): EnterSectionScRsp {
    const message = createBaseEnterSectionScRsp();
    message.retcode = object.retcode ?? 0;
    return message;
  },
};

function createBaseSetCurInteractEntityCsReq(): SetCurInteractEntityCsReq {
  return { entityId: 0 };
}

export const SetCurInteractEntityCsReq = {
  encode(
    message: SetCurInteractEntityCsReq,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.entityId !== 0) {
      writer.uint32(8).uint32(message.entityId);
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): SetCurInteractEntityCsReq {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSetCurInteractEntityCsReq();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.entityId = reader.uint32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): SetCurInteractEntityCsReq {
    return {
      entityId: isSet(object.entityId) ? Number(object.entityId) : 0,
    };
  },

  toJSON(message: SetCurInteractEntityCsReq): unknown {
    const obj: any = {};
    message.entityId !== undefined &&
      (obj.entityId = Math.round(message.entityId));
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<SetCurInteractEntityCsReq>, I>>(
    object: I
  ): SetCurInteractEntityCsReq {
    const message = createBaseSetCurInteractEntityCsReq();
    message.entityId = object.entityId ?? 0;
    return message;
  },
};

function createBaseSetCurInteractEntityScRsp(): SetCurInteractEntityScRsp {
  return { retcode: 0 };
}

export const SetCurInteractEntityScRsp = {
  encode(
    message: SetCurInteractEntityScRsp,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.retcode !== 0) {
      writer.uint32(8).uint32(message.retcode);
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): SetCurInteractEntityScRsp {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSetCurInteractEntityScRsp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.retcode = reader.uint32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): SetCurInteractEntityScRsp {
    return {
      retcode: isSet(object.retcode) ? Number(object.retcode) : 0,
    };
  },

  toJSON(message: SetCurInteractEntityScRsp): unknown {
    const obj: any = {};
    message.retcode !== undefined &&
      (obj.retcode = Math.round(message.retcode));
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<SetCurInteractEntityScRsp>, I>>(
    object: I
  ): SetCurInteractEntityScRsp {
    const message = createBaseSetCurInteractEntityScRsp();
    message.retcode = object.retcode ?? 0;
    return message;
  },
};

function createBaseRecoverAllLineupCsReq(): RecoverAllLineupCsReq {
  return {};
}

export const RecoverAllLineupCsReq = {
  encode(
    _: RecoverAllLineupCsReq,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): RecoverAllLineupCsReq {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRecoverAllLineupCsReq();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(_: any): RecoverAllLineupCsReq {
    return {};
  },

  toJSON(_: RecoverAllLineupCsReq): unknown {
    const obj: any = {};
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<RecoverAllLineupCsReq>, I>>(
    _: I
  ): RecoverAllLineupCsReq {
    const message = createBaseRecoverAllLineupCsReq();
    return message;
  },
};

function createBaseRecoverAllLineupScRsp(): RecoverAllLineupScRsp {
  return { retcode: 0 };
}

export const RecoverAllLineupScRsp = {
  encode(
    message: RecoverAllLineupScRsp,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.retcode !== 0) {
      writer.uint32(8).uint32(message.retcode);
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): RecoverAllLineupScRsp {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRecoverAllLineupScRsp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.retcode = reader.uint32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): RecoverAllLineupScRsp {
    return {
      retcode: isSet(object.retcode) ? Number(object.retcode) : 0,
    };
  },

  toJSON(message: RecoverAllLineupScRsp): unknown {
    const obj: any = {};
    message.retcode !== undefined &&
      (obj.retcode = Math.round(message.retcode));
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<RecoverAllLineupScRsp>, I>>(
    object: I
  ): RecoverAllLineupScRsp {
    const message = createBaseRecoverAllLineupScRsp();
    message.retcode = object.retcode ?? 0;
    return message;
  },
};

function createBaseSavePointsInfoNotify(): SavePointsInfoNotify {
  return { validTimes: 0, refreshTime: 0 };
}

export const SavePointsInfoNotify = {
  encode(
    message: SavePointsInfoNotify,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.validTimes !== 0) {
      writer.uint32(8).uint32(message.validTimes);
    }
    if (message.refreshTime !== 0) {
      writer.uint32(16).uint32(message.refreshTime);
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): SavePointsInfoNotify {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSavePointsInfoNotify();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.validTimes = reader.uint32();
          break;
        case 2:
          message.refreshTime = reader.uint32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): SavePointsInfoNotify {
    return {
      validTimes: isSet(object.validTimes) ? Number(object.validTimes) : 0,
      refreshTime: isSet(object.refreshTime) ? Number(object.refreshTime) : 0,
    };
  },

  toJSON(message: SavePointsInfoNotify): unknown {
    const obj: any = {};
    message.validTimes !== undefined &&
      (obj.validTimes = Math.round(message.validTimes));
    message.refreshTime !== undefined &&
      (obj.refreshTime = Math.round(message.refreshTime));
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<SavePointsInfoNotify>, I>>(
    object: I
  ): SavePointsInfoNotify {
    const message = createBaseSavePointsInfoNotify();
    message.validTimes = object.validTimes ?? 0;
    message.refreshTime = object.refreshTime ?? 0;
    return message;
  },
};

function createBaseStartCocoonStageCsReq(): StartCocoonStageCsReq {
  return { propEntityId: 0, cocoonId: 0, wave: 0, worldLevel: 0 };
}

export const StartCocoonStageCsReq = {
  encode(
    message: StartCocoonStageCsReq,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.propEntityId !== 0) {
      writer.uint32(8).uint32(message.propEntityId);
    }
    if (message.cocoonId !== 0) {
      writer.uint32(16).uint32(message.cocoonId);
    }
    if (message.wave !== 0) {
      writer.uint32(24).uint32(message.wave);
    }
    if (message.worldLevel !== 0) {
      writer.uint32(32).uint32(message.worldLevel);
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): StartCocoonStageCsReq {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStartCocoonStageCsReq();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.propEntityId = reader.uint32();
          break;
        case 2:
          message.cocoonId = reader.uint32();
          break;
        case 3:
          message.wave = reader.uint32();
          break;
        case 4:
          message.worldLevel = reader.uint32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): StartCocoonStageCsReq {
    return {
      propEntityId: isSet(object.propEntityId)
        ? Number(object.propEntityId)
        : 0,
      cocoonId: isSet(object.cocoonId) ? Number(object.cocoonId) : 0,
      wave: isSet(object.wave) ? Number(object.wave) : 0,
      worldLevel: isSet(object.worldLevel) ? Number(object.worldLevel) : 0,
    };
  },

  toJSON(message: StartCocoonStageCsReq): unknown {
    const obj: any = {};
    message.propEntityId !== undefined &&
      (obj.propEntityId = Math.round(message.propEntityId));
    message.cocoonId !== undefined &&
      (obj.cocoonId = Math.round(message.cocoonId));
    message.wave !== undefined && (obj.wave = Math.round(message.wave));
    message.worldLevel !== undefined &&
      (obj.worldLevel = Math.round(message.worldLevel));
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<StartCocoonStageCsReq>, I>>(
    object: I
  ): StartCocoonStageCsReq {
    const message = createBaseStartCocoonStageCsReq();
    message.propEntityId = object.propEntityId ?? 0;
    message.cocoonId = object.cocoonId ?? 0;
    message.wave = object.wave ?? 0;
    message.worldLevel = object.worldLevel ?? 0;
    return message;
  },
};

function createBaseStartCocoonStageScRsp(): StartCocoonStageScRsp {
  return {
    retcode: 0,
    battleInfo: undefined,
    propEntityId: 0,
    cocoonId: 0,
    wave: 0,
  };
}

export const StartCocoonStageScRsp = {
  encode(
    message: StartCocoonStageScRsp,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.retcode !== 0) {
      writer.uint32(8).uint32(message.retcode);
    }
    if (message.battleInfo !== undefined) {
      SceneBattleInfo.encode(
        message.battleInfo,
        writer.uint32(18).fork()
      ).ldelim();
    }
    if (message.propEntityId !== 0) {
      writer.uint32(24).uint32(message.propEntityId);
    }
    if (message.cocoonId !== 0) {
      writer.uint32(32).uint32(message.cocoonId);
    }
    if (message.wave !== 0) {
      writer.uint32(40).uint32(message.wave);
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): StartCocoonStageScRsp {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStartCocoonStageScRsp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.retcode = reader.uint32();
          break;
        case 2:
          message.battleInfo = SceneBattleInfo.decode(reader, reader.uint32());
          break;
        case 3:
          message.propEntityId = reader.uint32();
          break;
        case 4:
          message.cocoonId = reader.uint32();
          break;
        case 5:
          message.wave = reader.uint32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): StartCocoonStageScRsp {
    return {
      retcode: isSet(object.retcode) ? Number(object.retcode) : 0,
      battleInfo: isSet(object.battleInfo)
        ? SceneBattleInfo.fromJSON(object.battleInfo)
        : undefined,
      propEntityId: isSet(object.propEntityId)
        ? Number(object.propEntityId)
        : 0,
      cocoonId: isSet(object.cocoonId) ? Number(object.cocoonId) : 0,
      wave: isSet(object.wave) ? Number(object.wave) : 0,
    };
  },

  toJSON(message: StartCocoonStageScRsp): unknown {
    const obj: any = {};
    message.retcode !== undefined &&
      (obj.retcode = Math.round(message.retcode));
    message.battleInfo !== undefined &&
      (obj.battleInfo = message.battleInfo
        ? SceneBattleInfo.toJSON(message.battleInfo)
        : undefined);
    message.propEntityId !== undefined &&
      (obj.propEntityId = Math.round(message.propEntityId));
    message.cocoonId !== undefined &&
      (obj.cocoonId = Math.round(message.cocoonId));
    message.wave !== undefined && (obj.wave = Math.round(message.wave));
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<StartCocoonStageScRsp>, I>>(
    object: I
  ): StartCocoonStageScRsp {
    const message = createBaseStartCocoonStageScRsp();
    message.retcode = object.retcode ?? 0;
    message.battleInfo =
      object.battleInfo !== undefined && object.battleInfo !== null
        ? SceneBattleInfo.fromPartial(object.battleInfo)
        : undefined;
    message.propEntityId = object.propEntityId ?? 0;
    message.cocoonId = object.cocoonId ?? 0;
    message.wave = object.wave ?? 0;
    return message;
  },
};

function createBaseEntityBindPropCsReq(): EntityBindPropCsReq {
  return { isBind: false, motion: undefined };
}

export const EntityBindPropCsReq = {
  encode(
    message: EntityBindPropCsReq,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.isBind === true) {
      writer.uint32(8).bool(message.isBind);
    }
    if (message.motion !== undefined) {
      MotionInfo.encode(message.motion, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): EntityBindPropCsReq {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEntityBindPropCsReq();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.isBind = reader.bool();
          break;
        case 2:
          message.motion = MotionInfo.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): EntityBindPropCsReq {
    return {
      isBind: isSet(object.isBind) ? Boolean(object.isBind) : false,
      motion: isSet(object.motion)
        ? MotionInfo.fromJSON(object.motion)
        : undefined,
    };
  },

  toJSON(message: EntityBindPropCsReq): unknown {
    const obj: any = {};
    message.isBind !== undefined && (obj.isBind = message.isBind);
    message.motion !== undefined &&
      (obj.motion = message.motion
        ? MotionInfo.toJSON(message.motion)
        : undefined);
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<EntityBindPropCsReq>, I>>(
    object: I
  ): EntityBindPropCsReq {
    const message = createBaseEntityBindPropCsReq();
    message.isBind = object.isBind ?? false;
    message.motion =
      object.motion !== undefined && object.motion !== null
        ? MotionInfo.fromPartial(object.motion)
        : undefined;
    return message;
  },
};

function createBaseEntityBindPropScRsp(): EntityBindPropScRsp {
  return { retcode: 0 };
}

export const EntityBindPropScRsp = {
  encode(
    message: EntityBindPropScRsp,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.retcode !== 0) {
      writer.uint32(8).uint32(message.retcode);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): EntityBindPropScRsp {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEntityBindPropScRsp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.retcode = reader.uint32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): EntityBindPropScRsp {
    return {
      retcode: isSet(object.retcode) ? Number(object.retcode) : 0,
    };
  },

  toJSON(message: EntityBindPropScRsp): unknown {
    const obj: any = {};
    message.retcode !== undefined &&
      (obj.retcode = Math.round(message.retcode));
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<EntityBindPropScRsp>, I>>(
    object: I
  ): EntityBindPropScRsp {
    const message = createBaseEntityBindPropScRsp();
    message.retcode = object.retcode ?? 0;
    return message;
  },
};

function createBaseSetClientPausedCsReq(): SetClientPausedCsReq {
  return { paused: false };
}

export const SetClientPausedCsReq = {
  encode(
    message: SetClientPausedCsReq,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.paused === true) {
      writer.uint32(8).bool(message.paused);
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): SetClientPausedCsReq {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSetClientPausedCsReq();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.paused = reader.bool();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): SetClientPausedCsReq {
    return {
      paused: isSet(object.paused) ? Boolean(object.paused) : false,
    };
  },

  toJSON(message: SetClientPausedCsReq): unknown {
    const obj: any = {};
    message.paused !== undefined && (obj.paused = message.paused);
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<SetClientPausedCsReq>, I>>(
    object: I
  ): SetClientPausedCsReq {
    const message = createBaseSetClientPausedCsReq();
    message.paused = object.paused ?? false;
    return message;
  },
};

function createBaseSetClientPausedScRsp(): SetClientPausedScRsp {
  return { retcode: 0, paused: false };
}

export const SetClientPausedScRsp = {
  encode(
    message: SetClientPausedScRsp,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.retcode !== 0) {
      writer.uint32(8).uint32(message.retcode);
    }
    if (message.paused === true) {
      writer.uint32(16).bool(message.paused);
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): SetClientPausedScRsp {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSetClientPausedScRsp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.retcode = reader.uint32();
          break;
        case 2:
          message.paused = reader.bool();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): SetClientPausedScRsp {
    return {
      retcode: isSet(object.retcode) ? Number(object.retcode) : 0,
      paused: isSet(object.paused) ? Boolean(object.paused) : false,
    };
  },

  toJSON(message: SetClientPausedScRsp): unknown {
    const obj: any = {};
    message.retcode !== undefined &&
      (obj.retcode = Math.round(message.retcode));
    message.paused !== undefined && (obj.paused = message.paused);
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<SetClientPausedScRsp>, I>>(
    object: I
  ): SetClientPausedScRsp {
    const message = createBaseSetClientPausedScRsp();
    message.retcode = object.retcode ?? 0;
    message.paused = object.paused ?? false;
    return message;
  },
};

function createBaseUpdateBuffGroupStartScNotify(): UpdateBuffGroupStartScNotify {
  return {};
}

export const UpdateBuffGroupStartScNotify = {
  encode(
    _: UpdateBuffGroupStartScNotify,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): UpdateBuffGroupStartScNotify {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateBuffGroupStartScNotify();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(_: any): UpdateBuffGroupStartScNotify {
    return {};
  },

  toJSON(_: UpdateBuffGroupStartScNotify): unknown {
    const obj: any = {};
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<UpdateBuffGroupStartScNotify>, I>>(
    _: I
  ): UpdateBuffGroupStartScNotify {
    const message = createBaseUpdateBuffGroupStartScNotify();
    return message;
  },
};

function createBaseUpdateBuffGroupEndScNotify(): UpdateBuffGroupEndScNotify {
  return {};
}

export const UpdateBuffGroupEndScNotify = {
  encode(
    _: UpdateBuffGroupEndScNotify,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): UpdateBuffGroupEndScNotify {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateBuffGroupEndScNotify();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(_: any): UpdateBuffGroupEndScNotify {
    return {};
  },

  toJSON(_: UpdateBuffGroupEndScNotify): unknown {
    const obj: any = {};
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<UpdateBuffGroupEndScNotify>, I>>(
    _: I
  ): UpdateBuffGroupEndScNotify {
    const message = createBaseUpdateBuffGroupEndScNotify();
    return message;
  },
};

function createBaseActivateFarmElementCsReq(): ActivateFarmElementCsReq {
  return { entityId: 0, worldLevel: 0 };
}

export const ActivateFarmElementCsReq = {
  encode(
    message: ActivateFarmElementCsReq,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.entityId !== 0) {
      writer.uint32(8).uint32(message.entityId);
    }
    if (message.worldLevel !== 0) {
      writer.uint32(16).uint32(message.worldLevel);
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): ActivateFarmElementCsReq {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseActivateFarmElementCsReq();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.entityId = reader.uint32();
          break;
        case 2:
          message.worldLevel = reader.uint32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): ActivateFarmElementCsReq {
    return {
      entityId: isSet(object.entityId) ? Number(object.entityId) : 0,
      worldLevel: isSet(object.worldLevel) ? Number(object.worldLevel) : 0,
    };
  },

  toJSON(message: ActivateFarmElementCsReq): unknown {
    const obj: any = {};
    message.entityId !== undefined &&
      (obj.entityId = Math.round(message.entityId));
    message.worldLevel !== undefined &&
      (obj.worldLevel = Math.round(message.worldLevel));
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<ActivateFarmElementCsReq>, I>>(
    object: I
  ): ActivateFarmElementCsReq {
    const message = createBaseActivateFarmElementCsReq();
    message.entityId = object.entityId ?? 0;
    message.worldLevel = object.worldLevel ?? 0;
    return message;
  },
};

function createBaseActivateFarmElementScRsp(): ActivateFarmElementScRsp {
  return { retcode: 0, entityId: 0, worldLevel: 0 };
}

export const ActivateFarmElementScRsp = {
  encode(
    message: ActivateFarmElementScRsp,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.retcode !== 0) {
      writer.uint32(8).uint32(message.retcode);
    }
    if (message.entityId !== 0) {
      writer.uint32(16).uint32(message.entityId);
    }
    if (message.worldLevel !== 0) {
      writer.uint32(24).uint32(message.worldLevel);
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): ActivateFarmElementScRsp {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseActivateFarmElementScRsp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.retcode = reader.uint32();
          break;
        case 2:
          message.entityId = reader.uint32();
          break;
        case 3:
          message.worldLevel = reader.uint32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): ActivateFarmElementScRsp {
    return {
      retcode: isSet(object.retcode) ? Number(object.retcode) : 0,
      entityId: isSet(object.entityId) ? Number(object.entityId) : 0,
      worldLevel: isSet(object.worldLevel) ? Number(object.worldLevel) : 0,
    };
  },

  toJSON(message: ActivateFarmElementScRsp): unknown {
    const obj: any = {};
    message.retcode !== undefined &&
      (obj.retcode = Math.round(message.retcode));
    message.entityId !== undefined &&
      (obj.entityId = Math.round(message.entityId));
    message.worldLevel !== undefined &&
      (obj.worldLevel = Math.round(message.worldLevel));
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<ActivateFarmElementScRsp>, I>>(
    object: I
  ): ActivateFarmElementScRsp {
    const message = createBaseActivateFarmElementScRsp();
    message.retcode = object.retcode ?? 0;
    message.entityId = object.entityId ?? 0;
    message.worldLevel = object.worldLevel ?? 0;
    return message;
  },
};

function createBaseAvatarPresetHp(): AvatarPresetHp {
  return { avatarId: 0, presetHp: 0 };
}

export const AvatarPresetHp = {
  encode(
    message: AvatarPresetHp,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.avatarId !== 0) {
      writer.uint32(8).uint32(message.avatarId);
    }
    if (message.presetHp !== 0) {
      writer.uint32(16).uint32(message.presetHp);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): AvatarPresetHp {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAvatarPresetHp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.avatarId = reader.uint32();
          break;
        case 2:
          message.presetHp = reader.uint32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): AvatarPresetHp {
    return {
      avatarId: isSet(object.avatarId) ? Number(object.avatarId) : 0,
      presetHp: isSet(object.presetHp) ? Number(object.presetHp) : 0,
    };
  },

  toJSON(message: AvatarPresetHp): unknown {
    const obj: any = {};
    message.avatarId !== undefined &&
      (obj.avatarId = Math.round(message.avatarId));
    message.presetHp !== undefined &&
      (obj.presetHp = Math.round(message.presetHp));
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<AvatarPresetHp>, I>>(
    object: I
  ): AvatarPresetHp {
    const message = createBaseAvatarPresetHp();
    message.avatarId = object.avatarId ?? 0;
    message.presetHp = object.presetHp ?? 0;
    return message;
  },
};

function createBaseSpringRecoverConfig(): SpringRecoverConfig {
  return { avatarPresetHpList: [], autoRecoverHp: false, defaultHp: 0 };
}

export const SpringRecoverConfig = {
  encode(
    message: SpringRecoverConfig,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    for (const v of message.avatarPresetHpList) {
      AvatarPresetHp.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    if (message.autoRecoverHp === true) {
      writer.uint32(16).bool(message.autoRecoverHp);
    }
    if (message.defaultHp !== 0) {
      writer.uint32(24).uint32(message.defaultHp);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SpringRecoverConfig {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSpringRecoverConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.avatarPresetHpList.push(
            AvatarPresetHp.decode(reader, reader.uint32())
          );
          break;
        case 2:
          message.autoRecoverHp = reader.bool();
          break;
        case 3:
          message.defaultHp = reader.uint32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): SpringRecoverConfig {
    return {
      avatarPresetHpList: Array.isArray(object?.avatarPresetHpList)
        ? object.avatarPresetHpList.map((e: any) => AvatarPresetHp.fromJSON(e))
        : [],
      autoRecoverHp: isSet(object.autoRecoverHp)
        ? Boolean(object.autoRecoverHp)
        : false,
      defaultHp: isSet(object.defaultHp) ? Number(object.defaultHp) : 0,
    };
  },

  toJSON(message: SpringRecoverConfig): unknown {
    const obj: any = {};
    if (message.avatarPresetHpList) {
      obj.avatarPresetHpList = message.avatarPresetHpList.map((e) =>
        e ? AvatarPresetHp.toJSON(e) : undefined
      );
    } else {
      obj.avatarPresetHpList = [];
    }
    message.autoRecoverHp !== undefined &&
      (obj.autoRecoverHp = message.autoRecoverHp);
    message.defaultHp !== undefined &&
      (obj.defaultHp = Math.round(message.defaultHp));
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<SpringRecoverConfig>, I>>(
    object: I
  ): SpringRecoverConfig {
    const message = createBaseSpringRecoverConfig();
    message.avatarPresetHpList =
      object.avatarPresetHpList?.map((e) => AvatarPresetHp.fromPartial(e)) ||
      [];
    message.autoRecoverHp = object.autoRecoverHp ?? false;
    message.defaultHp = object.defaultHp ?? 0;
    return message;
  },
};

function createBaseHealPoolInfo(): HealPoolInfo {
  return { healPool: 0, refreshTime: 0 };
}

export const HealPoolInfo = {
  encode(
    message: HealPoolInfo,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.healPool !== 0) {
      writer.uint32(8).uint32(message.healPool);
    }
    if (message.refreshTime !== 0) {
      writer.uint32(16).uint32(message.refreshTime);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): HealPoolInfo {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHealPoolInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.healPool = reader.uint32();
          break;
        case 2:
          message.refreshTime = reader.uint32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): HealPoolInfo {
    return {
      healPool: isSet(object.healPool) ? Number(object.healPool) : 0,
      refreshTime: isSet(object.refreshTime) ? Number(object.refreshTime) : 0,
    };
  },

  toJSON(message: HealPoolInfo): unknown {
    const obj: any = {};
    message.healPool !== undefined &&
      (obj.healPool = Math.round(message.healPool));
    message.refreshTime !== undefined &&
      (obj.refreshTime = Math.round(message.refreshTime));
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<HealPoolInfo>, I>>(
    object: I
  ): HealPoolInfo {
    const message = createBaseHealPoolInfo();
    message.healPool = object.healPool ?? 0;
    message.refreshTime = object.refreshTime ?? 0;
    return message;
  },
};

function createBaseGetSpringRecoverDataCsReq(): GetSpringRecoverDataCsReq {
  return {};
}

export const GetSpringRecoverDataCsReq = {
  encode(
    _: GetSpringRecoverDataCsReq,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): GetSpringRecoverDataCsReq {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetSpringRecoverDataCsReq();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(_: any): GetSpringRecoverDataCsReq {
    return {};
  },

  toJSON(_: GetSpringRecoverDataCsReq): unknown {
    const obj: any = {};
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<GetSpringRecoverDataCsReq>, I>>(
    _: I
  ): GetSpringRecoverDataCsReq {
    const message = createBaseGetSpringRecoverDataCsReq();
    return message;
  },
};

function createBaseGetSpringRecoverDataScRsp(): GetSpringRecoverDataScRsp {
  return {
    retcode: 0,
    springRecoverConfig: undefined,
    healPoolInfo: undefined,
  };
}

export const GetSpringRecoverDataScRsp = {
  encode(
    message: GetSpringRecoverDataScRsp,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.retcode !== 0) {
      writer.uint32(8).uint32(message.retcode);
    }
    if (message.springRecoverConfig !== undefined) {
      SpringRecoverConfig.encode(
        message.springRecoverConfig,
        writer.uint32(18).fork()
      ).ldelim();
    }
    if (message.healPoolInfo !== undefined) {
      HealPoolInfo.encode(
        message.healPoolInfo,
        writer.uint32(26).fork()
      ).ldelim();
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): GetSpringRecoverDataScRsp {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetSpringRecoverDataScRsp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.retcode = reader.uint32();
          break;
        case 2:
          message.springRecoverConfig = SpringRecoverConfig.decode(
            reader,
            reader.uint32()
          );
          break;
        case 3:
          message.healPoolInfo = HealPoolInfo.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): GetSpringRecoverDataScRsp {
    return {
      retcode: isSet(object.retcode) ? Number(object.retcode) : 0,
      springRecoverConfig: isSet(object.springRecoverConfig)
        ? SpringRecoverConfig.fromJSON(object.springRecoverConfig)
        : undefined,
      healPoolInfo: isSet(object.healPoolInfo)
        ? HealPoolInfo.fromJSON(object.healPoolInfo)
        : undefined,
    };
  },

  toJSON(message: GetSpringRecoverDataScRsp): unknown {
    const obj: any = {};
    message.retcode !== undefined &&
      (obj.retcode = Math.round(message.retcode));
    message.springRecoverConfig !== undefined &&
      (obj.springRecoverConfig = message.springRecoverConfig
        ? SpringRecoverConfig.toJSON(message.springRecoverConfig)
        : undefined);
    message.healPoolInfo !== undefined &&
      (obj.healPoolInfo = message.healPoolInfo
        ? HealPoolInfo.toJSON(message.healPoolInfo)
        : undefined);
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<GetSpringRecoverDataScRsp>, I>>(
    object: I
  ): GetSpringRecoverDataScRsp {
    const message = createBaseGetSpringRecoverDataScRsp();
    message.retcode = object.retcode ?? 0;
    message.springRecoverConfig =
      object.springRecoverConfig !== undefined &&
      object.springRecoverConfig !== null
        ? SpringRecoverConfig.fromPartial(object.springRecoverConfig)
        : undefined;
    message.healPoolInfo =
      object.healPoolInfo !== undefined && object.healPoolInfo !== null
        ? HealPoolInfo.fromPartial(object.healPoolInfo)
        : undefined;
    return message;
  },
};

function createBaseSetSpringRecoverConfigCsReq(): SetSpringRecoverConfigCsReq {
  return { springRecoverConfig: undefined };
}

export const SetSpringRecoverConfigCsReq = {
  encode(
    message: SetSpringRecoverConfigCsReq,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.springRecoverConfig !== undefined) {
      SpringRecoverConfig.encode(
        message.springRecoverConfig,
        writer.uint32(10).fork()
      ).ldelim();
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): SetSpringRecoverConfigCsReq {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSetSpringRecoverConfigCsReq();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.springRecoverConfig = SpringRecoverConfig.decode(
            reader,
            reader.uint32()
          );
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): SetSpringRecoverConfigCsReq {
    return {
      springRecoverConfig: isSet(object.springRecoverConfig)
        ? SpringRecoverConfig.fromJSON(object.springRecoverConfig)
        : undefined,
    };
  },

  toJSON(message: SetSpringRecoverConfigCsReq): unknown {
    const obj: any = {};
    message.springRecoverConfig !== undefined &&
      (obj.springRecoverConfig = message.springRecoverConfig
        ? SpringRecoverConfig.toJSON(message.springRecoverConfig)
        : undefined);
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<SetSpringRecoverConfigCsReq>, I>>(
    object: I
  ): SetSpringRecoverConfigCsReq {
    const message = createBaseSetSpringRecoverConfigCsReq();
    message.springRecoverConfig =
      object.springRecoverConfig !== undefined &&
      object.springRecoverConfig !== null
        ? SpringRecoverConfig.fromPartial(object.springRecoverConfig)
        : undefined;
    return message;
  },
};

function createBaseSetSpringRecoverConfigScRsp(): SetSpringRecoverConfigScRsp {
  return { retcode: 0, springRecoverConfig: undefined };
}

export const SetSpringRecoverConfigScRsp = {
  encode(
    message: SetSpringRecoverConfigScRsp,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.retcode !== 0) {
      writer.uint32(8).uint32(message.retcode);
    }
    if (message.springRecoverConfig !== undefined) {
      SpringRecoverConfig.encode(
        message.springRecoverConfig,
        writer.uint32(18).fork()
      ).ldelim();
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): SetSpringRecoverConfigScRsp {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSetSpringRecoverConfigScRsp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.retcode = reader.uint32();
          break;
        case 2:
          message.springRecoverConfig = SpringRecoverConfig.decode(
            reader,
            reader.uint32()
          );
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): SetSpringRecoverConfigScRsp {
    return {
      retcode: isSet(object.retcode) ? Number(object.retcode) : 0,
      springRecoverConfig: isSet(object.springRecoverConfig)
        ? SpringRecoverConfig.fromJSON(object.springRecoverConfig)
        : undefined,
    };
  },

  toJSON(message: SetSpringRecoverConfigScRsp): unknown {
    const obj: any = {};
    message.retcode !== undefined &&
      (obj.retcode = Math.round(message.retcode));
    message.springRecoverConfig !== undefined &&
      (obj.springRecoverConfig = message.springRecoverConfig
        ? SpringRecoverConfig.toJSON(message.springRecoverConfig)
        : undefined);
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<SetSpringRecoverConfigScRsp>, I>>(
    object: I
  ): SetSpringRecoverConfigScRsp {
    const message = createBaseSetSpringRecoverConfigScRsp();
    message.retcode = object.retcode ?? 0;
    message.springRecoverConfig =
      object.springRecoverConfig !== undefined &&
      object.springRecoverConfig !== null
        ? SpringRecoverConfig.fromPartial(object.springRecoverConfig)
        : undefined;
    return message;
  },
};

function createBaseSpringRecoverCsReq(): SpringRecoverCsReq {
  return { planeId: 0, floorId: 0, propEntityId: 0 };
}

export const SpringRecoverCsReq = {
  encode(
    message: SpringRecoverCsReq,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.planeId !== 0) {
      writer.uint32(8).uint32(message.planeId);
    }
    if (message.floorId !== 0) {
      writer.uint32(16).uint32(message.floorId);
    }
    if (message.propEntityId !== 0) {
      writer.uint32(24).uint32(message.propEntityId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SpringRecoverCsReq {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSpringRecoverCsReq();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.planeId = reader.uint32();
          break;
        case 2:
          message.floorId = reader.uint32();
          break;
        case 3:
          message.propEntityId = reader.uint32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): SpringRecoverCsReq {
    return {
      planeId: isSet(object.planeId) ? Number(object.planeId) : 0,
      floorId: isSet(object.floorId) ? Number(object.floorId) : 0,
      propEntityId: isSet(object.propEntityId)
        ? Number(object.propEntityId)
        : 0,
    };
  },

  toJSON(message: SpringRecoverCsReq): unknown {
    const obj: any = {};
    message.planeId !== undefined &&
      (obj.planeId = Math.round(message.planeId));
    message.floorId !== undefined &&
      (obj.floorId = Math.round(message.floorId));
    message.propEntityId !== undefined &&
      (obj.propEntityId = Math.round(message.propEntityId));
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<SpringRecoverCsReq>, I>>(
    object: I
  ): SpringRecoverCsReq {
    const message = createBaseSpringRecoverCsReq();
    message.planeId = object.planeId ?? 0;
    message.floorId = object.floorId ?? 0;
    message.propEntityId = object.propEntityId ?? 0;
    return message;
  },
};

function createBaseSpringRecoverScRsp(): SpringRecoverScRsp {
  return { retcode: 0, healPoolInfo: undefined };
}

export const SpringRecoverScRsp = {
  encode(
    message: SpringRecoverScRsp,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.retcode !== 0) {
      writer.uint32(8).uint32(message.retcode);
    }
    if (message.healPoolInfo !== undefined) {
      HealPoolInfo.encode(
        message.healPoolInfo,
        writer.uint32(18).fork()
      ).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SpringRecoverScRsp {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSpringRecoverScRsp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.retcode = reader.uint32();
          break;
        case 2:
          message.healPoolInfo = HealPoolInfo.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): SpringRecoverScRsp {
    return {
      retcode: isSet(object.retcode) ? Number(object.retcode) : 0,
      healPoolInfo: isSet(object.healPoolInfo)
        ? HealPoolInfo.fromJSON(object.healPoolInfo)
        : undefined,
    };
  },

  toJSON(message: SpringRecoverScRsp): unknown {
    const obj: any = {};
    message.retcode !== undefined &&
      (obj.retcode = Math.round(message.retcode));
    message.healPoolInfo !== undefined &&
      (obj.healPoolInfo = message.healPoolInfo
        ? HealPoolInfo.toJSON(message.healPoolInfo)
        : undefined);
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<SpringRecoverScRsp>, I>>(
    object: I
  ): SpringRecoverScRsp {
    const message = createBaseSpringRecoverScRsp();
    message.retcode = object.retcode ?? 0;
    message.healPoolInfo =
      object.healPoolInfo !== undefined && object.healPoolInfo !== null
        ? HealPoolInfo.fromPartial(object.healPoolInfo)
        : undefined;
    return message;
  },
};

function createBaseHealPoolInfoNotify(): HealPoolInfoNotify {
  return { healPoolInfo: undefined };
}

export const HealPoolInfoNotify = {
  encode(
    message: HealPoolInfoNotify,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.healPoolInfo !== undefined) {
      HealPoolInfo.encode(
        message.healPoolInfo,
        writer.uint32(10).fork()
      ).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): HealPoolInfoNotify {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHealPoolInfoNotify();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.healPoolInfo = HealPoolInfo.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): HealPoolInfoNotify {
    return {
      healPoolInfo: isSet(object.healPoolInfo)
        ? HealPoolInfo.fromJSON(object.healPoolInfo)
        : undefined,
    };
  },

  toJSON(message: HealPoolInfoNotify): unknown {
    const obj: any = {};
    message.healPoolInfo !== undefined &&
      (obj.healPoolInfo = message.healPoolInfo
        ? HealPoolInfo.toJSON(message.healPoolInfo)
        : undefined);
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<HealPoolInfoNotify>, I>>(
    object: I
  ): HealPoolInfoNotify {
    const message = createBaseHealPoolInfoNotify();
    message.healPoolInfo =
      object.healPoolInfo !== undefined && object.healPoolInfo !== null
        ? HealPoolInfo.fromPartial(object.healPoolInfo)
        : undefined;
    return message;
  },
};

function createBaseSpringRecoverSingleAvatarCsReq(): SpringRecoverSingleAvatarCsReq {
  return {
    planeId: 0,
    floorId: 0,
    propEntityId: 0,
    avatarType: 0,
    id: 0,
    recoverFull: false,
  };
}

export const SpringRecoverSingleAvatarCsReq = {
  encode(
    message: SpringRecoverSingleAvatarCsReq,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.planeId !== 0) {
      writer.uint32(8).uint32(message.planeId);
    }
    if (message.floorId !== 0) {
      writer.uint32(16).uint32(message.floorId);
    }
    if (message.propEntityId !== 0) {
      writer.uint32(24).uint32(message.propEntityId);
    }
    if (message.avatarType !== 0) {
      writer.uint32(32).int32(message.avatarType);
    }
    if (message.id !== 0) {
      writer.uint32(40).uint32(message.id);
    }
    if (message.recoverFull === true) {
      writer.uint32(48).bool(message.recoverFull);
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): SpringRecoverSingleAvatarCsReq {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSpringRecoverSingleAvatarCsReq();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.planeId = reader.uint32();
          break;
        case 2:
          message.floorId = reader.uint32();
          break;
        case 3:
          message.propEntityId = reader.uint32();
          break;
        case 4:
          message.avatarType = reader.int32() as any;
          break;
        case 5:
          message.id = reader.uint32();
          break;
        case 6:
          message.recoverFull = reader.bool();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): SpringRecoverSingleAvatarCsReq {
    return {
      planeId: isSet(object.planeId) ? Number(object.planeId) : 0,
      floorId: isSet(object.floorId) ? Number(object.floorId) : 0,
      propEntityId: isSet(object.propEntityId)
        ? Number(object.propEntityId)
        : 0,
      avatarType: isSet(object.avatarType)
        ? avatarTypeFromJSON(object.avatarType)
        : 0,
      id: isSet(object.id) ? Number(object.id) : 0,
      recoverFull: isSet(object.recoverFull)
        ? Boolean(object.recoverFull)
        : false,
    };
  },

  toJSON(message: SpringRecoverSingleAvatarCsReq): unknown {
    const obj: any = {};
    message.planeId !== undefined &&
      (obj.planeId = Math.round(message.planeId));
    message.floorId !== undefined &&
      (obj.floorId = Math.round(message.floorId));
    message.propEntityId !== undefined &&
      (obj.propEntityId = Math.round(message.propEntityId));
    message.avatarType !== undefined &&
      (obj.avatarType = avatarTypeToJSON(message.avatarType));
    message.id !== undefined && (obj.id = Math.round(message.id));
    message.recoverFull !== undefined &&
      (obj.recoverFull = message.recoverFull);
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<SpringRecoverSingleAvatarCsReq>, I>>(
    object: I
  ): SpringRecoverSingleAvatarCsReq {
    const message = createBaseSpringRecoverSingleAvatarCsReq();
    message.planeId = object.planeId ?? 0;
    message.floorId = object.floorId ?? 0;
    message.propEntityId = object.propEntityId ?? 0;
    message.avatarType = object.avatarType ?? 0;
    message.id = object.id ?? 0;
    message.recoverFull = object.recoverFull ?? false;
    return message;
  },
};

function createBaseSpringRecoverSingleAvatarScRsp(): SpringRecoverSingleAvatarScRsp {
  return { retcode: 0, avatarType: 0, id: 0, hp: 0 };
}

export const SpringRecoverSingleAvatarScRsp = {
  encode(
    message: SpringRecoverSingleAvatarScRsp,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.retcode !== 0) {
      writer.uint32(8).uint32(message.retcode);
    }
    if (message.avatarType !== 0) {
      writer.uint32(16).int32(message.avatarType);
    }
    if (message.id !== 0) {
      writer.uint32(24).uint32(message.id);
    }
    if (message.hp !== 0) {
      writer.uint32(32).uint32(message.hp);
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): SpringRecoverSingleAvatarScRsp {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSpringRecoverSingleAvatarScRsp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.retcode = reader.uint32();
          break;
        case 2:
          message.avatarType = reader.int32() as any;
          break;
        case 3:
          message.id = reader.uint32();
          break;
        case 4:
          message.hp = reader.uint32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): SpringRecoverSingleAvatarScRsp {
    return {
      retcode: isSet(object.retcode) ? Number(object.retcode) : 0,
      avatarType: isSet(object.avatarType)
        ? avatarTypeFromJSON(object.avatarType)
        : 0,
      id: isSet(object.id) ? Number(object.id) : 0,
      hp: isSet(object.hp) ? Number(object.hp) : 0,
    };
  },

  toJSON(message: SpringRecoverSingleAvatarScRsp): unknown {
    const obj: any = {};
    message.retcode !== undefined &&
      (obj.retcode = Math.round(message.retcode));
    message.avatarType !== undefined &&
      (obj.avatarType = avatarTypeToJSON(message.avatarType));
    message.id !== undefined && (obj.id = Math.round(message.id));
    message.hp !== undefined && (obj.hp = Math.round(message.hp));
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<SpringRecoverSingleAvatarScRsp>, I>>(
    object: I
  ): SpringRecoverSingleAvatarScRsp {
    const message = createBaseSpringRecoverSingleAvatarScRsp();
    message.retcode = object.retcode ?? 0;
    message.avatarType = object.avatarType ?? 0;
    message.id = object.id ?? 0;
    message.hp = object.hp ?? 0;
    return message;
  },
};

function createBaseShop(): Shop {
  return { shopId: 0, beginTime: 0, endTime: 0, goodsList: [] };
}

export const Shop = {
  encode(message: Shop, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.shopId !== 0) {
      writer.uint32(8).uint32(message.shopId);
    }
    if (message.beginTime !== 0) {
      writer.uint32(16).uint32(message.beginTime);
    }
    if (message.endTime !== 0) {
      writer.uint32(24).uint32(message.endTime);
    }
    for (const v of message.goodsList) {
      Goods.encode(v!, writer.uint32(34).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Shop {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseShop();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.shopId = reader.uint32();
          break;
        case 2:
          message.beginTime = reader.uint32();
          break;
        case 3:
          message.endTime = reader.uint32();
          break;
        case 4:
          message.goodsList.push(Goods.decode(reader, reader.uint32()));
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): Shop {
    return {
      shopId: isSet(object.shopId) ? Number(object.shopId) : 0,
      beginTime: isSet(object.beginTime) ? Number(object.beginTime) : 0,
      endTime: isSet(object.endTime) ? Number(object.endTime) : 0,
      goodsList: Array.isArray(object?.goodsList)
        ? object.goodsList.map((e: any) => Goods.fromJSON(e))
        : [],
    };
  },

  toJSON(message: Shop): unknown {
    const obj: any = {};
    message.shopId !== undefined && (obj.shopId = Math.round(message.shopId));
    message.beginTime !== undefined &&
      (obj.beginTime = Math.round(message.beginTime));
    message.endTime !== undefined &&
      (obj.endTime = Math.round(message.endTime));
    if (message.goodsList) {
      obj.goodsList = message.goodsList.map((e) =>
        e ? Goods.toJSON(e) : undefined
      );
    } else {
      obj.goodsList = [];
    }
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<Shop>, I>>(object: I): Shop {
    const message = createBaseShop();
    message.shopId = object.shopId ?? 0;
    message.beginTime = object.beginTime ?? 0;
    message.endTime = object.endTime ?? 0;
    message.goodsList =
      object.goodsList?.map((e) => Goods.fromPartial(e)) || [];
    return message;
  },
};

function createBaseGoods(): Goods {
  return { goodsId: 0, buyTimes: 0, beginTime: 0, endTime: 0 };
}

export const Goods = {
  encode(message: Goods, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.goodsId !== 0) {
      writer.uint32(8).uint32(message.goodsId);
    }
    if (message.buyTimes !== 0) {
      writer.uint32(16).uint32(message.buyTimes);
    }
    if (message.beginTime !== 0) {
      writer.uint32(24).uint32(message.beginTime);
    }
    if (message.endTime !== 0) {
      writer.uint32(32).uint32(message.endTime);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Goods {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGoods();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.goodsId = reader.uint32();
          break;
        case 2:
          message.buyTimes = reader.uint32();
          break;
        case 3:
          message.beginTime = reader.uint32();
          break;
        case 4:
          message.endTime = reader.uint32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): Goods {
    return {
      goodsId: isSet(object.goodsId) ? Number(object.goodsId) : 0,
      buyTimes: isSet(object.buyTimes) ? Number(object.buyTimes) : 0,
      beginTime: isSet(object.beginTime) ? Number(object.beginTime) : 0,
      endTime: isSet(object.endTime) ? Number(object.endTime) : 0,
    };
  },

  toJSON(message: Goods): unknown {
    const obj: any = {};
    message.goodsId !== undefined &&
      (obj.goodsId = Math.round(message.goodsId));
    message.buyTimes !== undefined &&
      (obj.buyTimes = Math.round(message.buyTimes));
    message.beginTime !== undefined &&
      (obj.beginTime = Math.round(message.beginTime));
    message.endTime !== undefined &&
      (obj.endTime = Math.round(message.endTime));
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<Goods>, I>>(object: I): Goods {
    const message = createBaseGoods();
    message.goodsId = object.goodsId ?? 0;
    message.buyTimes = object.buyTimes ?? 0;
    message.beginTime = object.beginTime ?? 0;
    message.endTime = object.endTime ?? 0;
    return message;
  },
};

function createBaseGetShopListCsReq(): GetShopListCsReq {
  return { shopType: 0 };
}

export const GetShopListCsReq = {
  encode(
    message: GetShopListCsReq,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.shopType !== 0) {
      writer.uint32(8).uint32(message.shopType);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetShopListCsReq {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetShopListCsReq();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.shopType = reader.uint32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): GetShopListCsReq {
    return {
      shopType: isSet(object.shopType) ? Number(object.shopType) : 0,
    };
  },

  toJSON(message: GetShopListCsReq): unknown {
    const obj: any = {};
    message.shopType !== undefined &&
      (obj.shopType = Math.round(message.shopType));
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<GetShopListCsReq>, I>>(
    object: I
  ): GetShopListCsReq {
    const message = createBaseGetShopListCsReq();
    message.shopType = object.shopType ?? 0;
    return message;
  },
};

function createBaseGetShopListScRsp(): GetShopListScRsp {
  return { retcode: 0, shopList: [], shopType: 0 };
}

export const GetShopListScRsp = {
  encode(
    message: GetShopListScRsp,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.retcode !== 0) {
      writer.uint32(8).uint32(message.retcode);
    }
    for (const v of message.shopList) {
      Shop.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    if (message.shopType !== 0) {
      writer.uint32(24).uint32(message.shopType);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetShopListScRsp {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetShopListScRsp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.retcode = reader.uint32();
          break;
        case 2:
          message.shopList.push(Shop.decode(reader, reader.uint32()));
          break;
        case 3:
          message.shopType = reader.uint32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): GetShopListScRsp {
    return {
      retcode: isSet(object.retcode) ? Number(object.retcode) : 0,
      shopList: Array.isArray(object?.shopList)
        ? object.shopList.map((e: any) => Shop.fromJSON(e))
        : [],
      shopType: isSet(object.shopType) ? Number(object.shopType) : 0,
    };
  },

  toJSON(message: GetShopListScRsp): unknown {
    const obj: any = {};
    message.retcode !== undefined &&
      (obj.retcode = Math.round(message.retcode));
    if (message.shopList) {
      obj.shopList = message.shopList.map((e) =>
        e ? Shop.toJSON(e) : undefined
      );
    } else {
      obj.shopList = [];
    }
    message.shopType !== undefined &&
      (obj.shopType = Math.round(message.shopType));
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<GetShopListScRsp>, I>>(
    object: I
  ): GetShopListScRsp {
    const message = createBaseGetShopListScRsp();
    message.retcode = object.retcode ?? 0;
    message.shopList = object.shopList?.map((e) => Shop.fromPartial(e)) || [];
    message.shopType = object.shopType ?? 0;
    return message;
  },
};

function createBaseBuyGoodsCsReq(): BuyGoodsCsReq {
  return { shopId: 0, goodsId: 0, goodsNum: 0 };
}

export const BuyGoodsCsReq = {
  encode(
    message: BuyGoodsCsReq,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.shopId !== 0) {
      writer.uint32(8).uint32(message.shopId);
    }
    if (message.goodsId !== 0) {
      writer.uint32(16).uint32(message.goodsId);
    }
    if (message.goodsNum !== 0) {
      writer.uint32(24).uint32(message.goodsNum);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): BuyGoodsCsReq {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBuyGoodsCsReq();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.shopId = reader.uint32();
          break;
        case 2:
          message.goodsId = reader.uint32();
          break;
        case 3:
          message.goodsNum = reader.uint32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): BuyGoodsCsReq {
    return {
      shopId: isSet(object.shopId) ? Number(object.shopId) : 0,
      goodsId: isSet(object.goodsId) ? Number(object.goodsId) : 0,
      goodsNum: isSet(object.goodsNum) ? Number(object.goodsNum) : 0,
    };
  },

  toJSON(message: BuyGoodsCsReq): unknown {
    const obj: any = {};
    message.shopId !== undefined && (obj.shopId = Math.round(message.shopId));
    message.goodsId !== undefined &&
      (obj.goodsId = Math.round(message.goodsId));
    message.goodsNum !== undefined &&
      (obj.goodsNum = Math.round(message.goodsNum));
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<BuyGoodsCsReq>, I>>(
    object: I
  ): BuyGoodsCsReq {
    const message = createBaseBuyGoodsCsReq();
    message.shopId = object.shopId ?? 0;
    message.goodsId = object.goodsId ?? 0;
    message.goodsNum = object.goodsNum ?? 0;
    return message;
  },
};

function createBaseBuyGoodsScRsp(): BuyGoodsScRsp {
  return {
    retcode: 0,
    shopId: 0,
    goodsId: 0,
    goodsBuyTimes: 0,
    returnItemList: undefined,
  };
}

export const BuyGoodsScRsp = {
  encode(
    message: BuyGoodsScRsp,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.retcode !== 0) {
      writer.uint32(8).uint32(message.retcode);
    }
    if (message.shopId !== 0) {
      writer.uint32(16).uint32(message.shopId);
    }
    if (message.goodsId !== 0) {
      writer.uint32(24).uint32(message.goodsId);
    }
    if (message.goodsBuyTimes !== 0) {
      writer.uint32(32).uint32(message.goodsBuyTimes);
    }
    if (message.returnItemList !== undefined) {
      ItemList.encode(
        message.returnItemList,
        writer.uint32(42).fork()
      ).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): BuyGoodsScRsp {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBuyGoodsScRsp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.retcode = reader.uint32();
          break;
        case 2:
          message.shopId = reader.uint32();
          break;
        case 3:
          message.goodsId = reader.uint32();
          break;
        case 4:
          message.goodsBuyTimes = reader.uint32();
          break;
        case 5:
          message.returnItemList = ItemList.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): BuyGoodsScRsp {
    return {
      retcode: isSet(object.retcode) ? Number(object.retcode) : 0,
      shopId: isSet(object.shopId) ? Number(object.shopId) : 0,
      goodsId: isSet(object.goodsId) ? Number(object.goodsId) : 0,
      goodsBuyTimes: isSet(object.goodsBuyTimes)
        ? Number(object.goodsBuyTimes)
        : 0,
      returnItemList: isSet(object.returnItemList)
        ? ItemList.fromJSON(object.returnItemList)
        : undefined,
    };
  },

  toJSON(message: BuyGoodsScRsp): unknown {
    const obj: any = {};
    message.retcode !== undefined &&
      (obj.retcode = Math.round(message.retcode));
    message.shopId !== undefined && (obj.shopId = Math.round(message.shopId));
    message.goodsId !== undefined &&
      (obj.goodsId = Math.round(message.goodsId));
    message.goodsBuyTimes !== undefined &&
      (obj.goodsBuyTimes = Math.round(message.goodsBuyTimes));
    message.returnItemList !== undefined &&
      (obj.returnItemList = message.returnItemList
        ? ItemList.toJSON(message.returnItemList)
        : undefined);
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<BuyGoodsScRsp>, I>>(
    object: I
  ): BuyGoodsScRsp {
    const message = createBaseBuyGoodsScRsp();
    message.retcode = object.retcode ?? 0;
    message.shopId = object.shopId ?? 0;
    message.goodsId = object.goodsId ?? 0;
    message.goodsBuyTimes = object.goodsBuyTimes ?? 0;
    message.returnItemList =
      object.returnItemList !== undefined && object.returnItemList !== null
        ? ItemList.fromPartial(object.returnItemList)
        : undefined;
    return message;
  },
};

function createBaseStage(): Stage {
  return { id: 0, winTimes: 0, challengeValue: 0 };
}

export const Stage = {
  encode(message: Stage, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== 0) {
      writer.uint32(8).uint32(message.id);
    }
    if (message.winTimes !== 0) {
      writer.uint32(16).uint32(message.winTimes);
    }
    if (message.challengeValue !== 0) {
      writer.uint32(24).uint32(message.challengeValue);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Stage {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.id = reader.uint32();
          break;
        case 2:
          message.winTimes = reader.uint32();
          break;
        case 3:
          message.challengeValue = reader.uint32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): Stage {
    return {
      id: isSet(object.id) ? Number(object.id) : 0,
      winTimes: isSet(object.winTimes) ? Number(object.winTimes) : 0,
      challengeValue: isSet(object.challengeValue)
        ? Number(object.challengeValue)
        : 0,
    };
  },

  toJSON(message: Stage): unknown {
    const obj: any = {};
    message.id !== undefined && (obj.id = Math.round(message.id));
    message.winTimes !== undefined &&
      (obj.winTimes = Math.round(message.winTimes));
    message.challengeValue !== undefined &&
      (obj.challengeValue = Math.round(message.challengeValue));
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<Stage>, I>>(object: I): Stage {
    const message = createBaseStage();
    message.id = object.id ?? 0;
    message.winTimes = object.winTimes ?? 0;
    message.challengeValue = object.challengeValue ?? 0;
    return message;
  },
};

function createBaseGetStageDataCsReq(): GetStageDataCsReq {
  return { stageIdList: [] };
}

export const GetStageDataCsReq = {
  encode(
    message: GetStageDataCsReq,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    writer.uint32(10).fork();
    for (const v of message.stageIdList) {
      writer.uint32(v);
    }
    writer.ldelim();
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetStageDataCsReq {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetStageDataCsReq();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if ((tag & 7) === 2) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.stageIdList.push(reader.uint32());
            }
          } else {
            message.stageIdList.push(reader.uint32());
          }
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): GetStageDataCsReq {
    return {
      stageIdList: Array.isArray(object?.stageIdList)
        ? object.stageIdList.map((e: any) => Number(e))
        : [],
    };
  },

  toJSON(message: GetStageDataCsReq): unknown {
    const obj: any = {};
    if (message.stageIdList) {
      obj.stageIdList = message.stageIdList.map((e) => Math.round(e));
    } else {
      obj.stageIdList = [];
    }
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<GetStageDataCsReq>, I>>(
    object: I
  ): GetStageDataCsReq {
    const message = createBaseGetStageDataCsReq();
    message.stageIdList = object.stageIdList?.map((e) => e) || [];
    return message;
  },
};

function createBaseGetStageDataScRsp(): GetStageDataScRsp {
  return { retcode: 0, stageList: [], isAll: false };
}

export const GetStageDataScRsp = {
  encode(
    message: GetStageDataScRsp,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.retcode !== 0) {
      writer.uint32(8).uint32(message.retcode);
    }
    for (const v of message.stageList) {
      Stage.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    if (message.isAll === true) {
      writer.uint32(24).bool(message.isAll);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetStageDataScRsp {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetStageDataScRsp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.retcode = reader.uint32();
          break;
        case 2:
          message.stageList.push(Stage.decode(reader, reader.uint32()));
          break;
        case 3:
          message.isAll = reader.bool();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): GetStageDataScRsp {
    return {
      retcode: isSet(object.retcode) ? Number(object.retcode) : 0,
      stageList: Array.isArray(object?.stageList)
        ? object.stageList.map((e: any) => Stage.fromJSON(e))
        : [],
      isAll: isSet(object.isAll) ? Boolean(object.isAll) : false,
    };
  },

  toJSON(message: GetStageDataScRsp): unknown {
    const obj: any = {};
    message.retcode !== undefined &&
      (obj.retcode = Math.round(message.retcode));
    if (message.stageList) {
      obj.stageList = message.stageList.map((e) =>
        e ? Stage.toJSON(e) : undefined
      );
    } else {
      obj.stageList = [];
    }
    message.isAll !== undefined && (obj.isAll = message.isAll);
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<GetStageDataScRsp>, I>>(
    object: I
  ): GetStageDataScRsp {
    const message = createBaseGetStageDataScRsp();
    message.retcode = object.retcode ?? 0;
    message.stageList =
      object.stageList?.map((e) => Stage.fromPartial(e)) || [];
    message.isAll = object.isAll ?? false;
    return message;
  },
};

function createBaseStageBeginCsReq(): StageBeginCsReq {
  return { stageId: 0, lineupIndex: 0 };
}

export const StageBeginCsReq = {
  encode(
    message: StageBeginCsReq,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.stageId !== 0) {
      writer.uint32(8).uint32(message.stageId);
    }
    if (message.lineupIndex !== 0) {
      writer.uint32(16).uint32(message.lineupIndex);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): StageBeginCsReq {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStageBeginCsReq();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.stageId = reader.uint32();
          break;
        case 2:
          message.lineupIndex = reader.uint32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): StageBeginCsReq {
    return {
      stageId: isSet(object.stageId) ? Number(object.stageId) : 0,
      lineupIndex: isSet(object.lineupIndex) ? Number(object.lineupIndex) : 0,
    };
  },

  toJSON(message: StageBeginCsReq): unknown {
    const obj: any = {};
    message.stageId !== undefined &&
      (obj.stageId = Math.round(message.stageId));
    message.lineupIndex !== undefined &&
      (obj.lineupIndex = Math.round(message.lineupIndex));
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<StageBeginCsReq>, I>>(
    object: I
  ): StageBeginCsReq {
    const message = createBaseStageBeginCsReq();
    message.stageId = object.stageId ?? 0;
    message.lineupIndex = object.lineupIndex ?? 0;
    return message;
  },
};

function createBaseStageBeginScRsp(): StageBeginScRsp {
  return { retcode: 0, logicRandomSeed: 0, stageId: 0, battleAvatarList: [] };
}

export const StageBeginScRsp = {
  encode(
    message: StageBeginScRsp,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.retcode !== 0) {
      writer.uint32(8).uint32(message.retcode);
    }
    if (message.logicRandomSeed !== 0) {
      writer.uint32(16).uint32(message.logicRandomSeed);
    }
    if (message.stageId !== 0) {
      writer.uint32(24).uint32(message.stageId);
    }
    for (const v of message.battleAvatarList) {
      BattleAvatar.encode(v!, writer.uint32(34).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): StageBeginScRsp {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStageBeginScRsp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.retcode = reader.uint32();
          break;
        case 2:
          message.logicRandomSeed = reader.uint32();
          break;
        case 3:
          message.stageId = reader.uint32();
          break;
        case 4:
          message.battleAvatarList.push(
            BattleAvatar.decode(reader, reader.uint32())
          );
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): StageBeginScRsp {
    return {
      retcode: isSet(object.retcode) ? Number(object.retcode) : 0,
      logicRandomSeed: isSet(object.logicRandomSeed)
        ? Number(object.logicRandomSeed)
        : 0,
      stageId: isSet(object.stageId) ? Number(object.stageId) : 0,
      battleAvatarList: Array.isArray(object?.battleAvatarList)
        ? object.battleAvatarList.map((e: any) => BattleAvatar.fromJSON(e))
        : [],
    };
  },

  toJSON(message: StageBeginScRsp): unknown {
    const obj: any = {};
    message.retcode !== undefined &&
      (obj.retcode = Math.round(message.retcode));
    message.logicRandomSeed !== undefined &&
      (obj.logicRandomSeed = Math.round(message.logicRandomSeed));
    message.stageId !== undefined &&
      (obj.stageId = Math.round(message.stageId));
    if (message.battleAvatarList) {
      obj.battleAvatarList = message.battleAvatarList.map((e) =>
        e ? BattleAvatar.toJSON(e) : undefined
      );
    } else {
      obj.battleAvatarList = [];
    }
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<StageBeginScRsp>, I>>(
    object: I
  ): StageBeginScRsp {
    const message = createBaseStageBeginScRsp();
    message.retcode = object.retcode ?? 0;
    message.logicRandomSeed = object.logicRandomSeed ?? 0;
    message.stageId = object.stageId ?? 0;
    message.battleAvatarList =
      object.battleAvatarList?.map((e) => BattleAvatar.fromPartial(e)) || [];
    return message;
  },
};

function createBaseBasicModuleSync(): BasicModuleSync {
  return { stamina: 0, weekCocoonFinishedCount: 0 };
}

export const BasicModuleSync = {
  encode(
    message: BasicModuleSync,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.stamina !== 0) {
      writer.uint32(8).uint32(message.stamina);
    }
    if (message.weekCocoonFinishedCount !== 0) {
      writer.uint32(16).uint32(message.weekCocoonFinishedCount);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): BasicModuleSync {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBasicModuleSync();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.stamina = reader.uint32();
          break;
        case 2:
          message.weekCocoonFinishedCount = reader.uint32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): BasicModuleSync {
    return {
      stamina: isSet(object.stamina) ? Number(object.stamina) : 0,
      weekCocoonFinishedCount: isSet(object.weekCocoonFinishedCount)
        ? Number(object.weekCocoonFinishedCount)
        : 0,
    };
  },

  toJSON(message: BasicModuleSync): unknown {
    const obj: any = {};
    message.stamina !== undefined &&
      (obj.stamina = Math.round(message.stamina));
    message.weekCocoonFinishedCount !== undefined &&
      (obj.weekCocoonFinishedCount = Math.round(
        message.weekCocoonFinishedCount
      ));
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<BasicModuleSync>, I>>(
    object: I
  ): BasicModuleSync {
    const message = createBaseBasicModuleSync();
    message.stamina = object.stamina ?? 0;
    message.weekCocoonFinishedCount = object.weekCocoonFinishedCount ?? 0;
    return message;
  },
};

function createBaseRogueModuleSync(): RogueModuleSync {
  return { rogueCoin: 0, rogueStamina: 0, rogueExploreExp: 0 };
}

export const RogueModuleSync = {
  encode(
    message: RogueModuleSync,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.rogueCoin !== 0) {
      writer.uint32(8).uint32(message.rogueCoin);
    }
    if (message.rogueStamina !== 0) {
      writer.uint32(16).uint32(message.rogueStamina);
    }
    if (message.rogueExploreExp !== 0) {
      writer.uint32(24).uint32(message.rogueExploreExp);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): RogueModuleSync {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRogueModuleSync();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.rogueCoin = reader.uint32();
          break;
        case 2:
          message.rogueStamina = reader.uint32();
          break;
        case 3:
          message.rogueExploreExp = reader.uint32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): RogueModuleSync {
    return {
      rogueCoin: isSet(object.rogueCoin) ? Number(object.rogueCoin) : 0,
      rogueStamina: isSet(object.rogueStamina)
        ? Number(object.rogueStamina)
        : 0,
      rogueExploreExp: isSet(object.rogueExploreExp)
        ? Number(object.rogueExploreExp)
        : 0,
    };
  },

  toJSON(message: RogueModuleSync): unknown {
    const obj: any = {};
    message.rogueCoin !== undefined &&
      (obj.rogueCoin = Math.round(message.rogueCoin));
    message.rogueStamina !== undefined &&
      (obj.rogueStamina = Math.round(message.rogueStamina));
    message.rogueExploreExp !== undefined &&
      (obj.rogueExploreExp = Math.round(message.rogueExploreExp));
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<RogueModuleSync>, I>>(
    object: I
  ): RogueModuleSync {
    const message = createBaseRogueModuleSync();
    message.rogueCoin = object.rogueCoin ?? 0;
    message.rogueStamina = object.rogueStamina ?? 0;
    message.rogueExploreExp = object.rogueExploreExp ?? 0;
    return message;
  },
};

function createBaseAvatarSync(): AvatarSync {
  return { avatarList: [] };
}

export const AvatarSync = {
  encode(
    message: AvatarSync,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    for (const v of message.avatarList) {
      Avatar.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): AvatarSync {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAvatarSync();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.avatarList.push(Avatar.decode(reader, reader.uint32()));
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): AvatarSync {
    return {
      avatarList: Array.isArray(object?.avatarList)
        ? object.avatarList.map((e: any) => Avatar.fromJSON(e))
        : [],
    };
  },

  toJSON(message: AvatarSync): unknown {
    const obj: any = {};
    if (message.avatarList) {
      obj.avatarList = message.avatarList.map((e) =>
        e ? Avatar.toJSON(e) : undefined
      );
    } else {
      obj.avatarList = [];
    }
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<AvatarSync>, I>>(
    object: I
  ): AvatarSync {
    const message = createBaseAvatarSync();
    message.avatarList =
      object.avatarList?.map((e) => Avatar.fromPartial(e)) || [];
    return message;
  },
};

function createBaseMissionSync(): MissionSync {
  return {
    missionList: [],
    finishedMainMissionIdList: [],
    delMissionIdList: [],
    delMainMissionIdList: [],
  };
}

export const MissionSync = {
  encode(
    message: MissionSync,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    for (const v of message.missionList) {
      Mission.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    writer.uint32(18).fork();
    for (const v of message.finishedMainMissionIdList) {
      writer.uint32(v);
    }
    writer.ldelim();
    writer.uint32(26).fork();
    for (const v of message.delMissionIdList) {
      writer.uint32(v);
    }
    writer.ldelim();
    writer.uint32(34).fork();
    for (const v of message.delMainMissionIdList) {
      writer.uint32(v);
    }
    writer.ldelim();
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MissionSync {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMissionSync();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.missionList.push(Mission.decode(reader, reader.uint32()));
          break;
        case 2:
          if ((tag & 7) === 2) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.finishedMainMissionIdList.push(reader.uint32());
            }
          } else {
            message.finishedMainMissionIdList.push(reader.uint32());
          }
          break;
        case 3:
          if ((tag & 7) === 2) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.delMissionIdList.push(reader.uint32());
            }
          } else {
            message.delMissionIdList.push(reader.uint32());
          }
          break;
        case 4:
          if ((tag & 7) === 2) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.delMainMissionIdList.push(reader.uint32());
            }
          } else {
            message.delMainMissionIdList.push(reader.uint32());
          }
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): MissionSync {
    return {
      missionList: Array.isArray(object?.missionList)
        ? object.missionList.map((e: any) => Mission.fromJSON(e))
        : [],
      finishedMainMissionIdList: Array.isArray(
        object?.finishedMainMissionIdList
      )
        ? object.finishedMainMissionIdList.map((e: any) => Number(e))
        : [],
      delMissionIdList: Array.isArray(object?.delMissionIdList)
        ? object.delMissionIdList.map((e: any) => Number(e))
        : [],
      delMainMissionIdList: Array.isArray(object?.delMainMissionIdList)
        ? object.delMainMissionIdList.map((e: any) => Number(e))
        : [],
    };
  },

  toJSON(message: MissionSync): unknown {
    const obj: any = {};
    if (message.missionList) {
      obj.missionList = message.missionList.map((e) =>
        e ? Mission.toJSON(e) : undefined
      );
    } else {
      obj.missionList = [];
    }
    if (message.finishedMainMissionIdList) {
      obj.finishedMainMissionIdList = message.finishedMainMissionIdList.map(
        (e) => Math.round(e)
      );
    } else {
      obj.finishedMainMissionIdList = [];
    }
    if (message.delMissionIdList) {
      obj.delMissionIdList = message.delMissionIdList.map((e) => Math.round(e));
    } else {
      obj.delMissionIdList = [];
    }
    if (message.delMainMissionIdList) {
      obj.delMainMissionIdList = message.delMainMissionIdList.map((e) =>
        Math.round(e)
      );
    } else {
      obj.delMainMissionIdList = [];
    }
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<MissionSync>, I>>(
    object: I
  ): MissionSync {
    const message = createBaseMissionSync();
    message.missionList =
      object.missionList?.map((e) => Mission.fromPartial(e)) || [];
    message.finishedMainMissionIdList =
      object.finishedMainMissionIdList?.map((e) => e) || [];
    message.delMissionIdList = object.delMissionIdList?.map((e) => e) || [];
    message.delMainMissionIdList =
      object.delMainMissionIdList?.map((e) => e) || [];
    return message;
  },
};

function createBaseMissionEventSync(): MissionEventSync {
  return {
    missionEventList: [],
    finishedMissionEventIdList: [],
    delMissionEventIdList: [],
  };
}

export const MissionEventSync = {
  encode(
    message: MissionEventSync,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    for (const v of message.missionEventList) {
      Mission.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    writer.uint32(18).fork();
    for (const v of message.finishedMissionEventIdList) {
      writer.uint32(v);
    }
    writer.ldelim();
    writer.uint32(26).fork();
    for (const v of message.delMissionEventIdList) {
      writer.uint32(v);
    }
    writer.ldelim();
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MissionEventSync {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMissionEventSync();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.missionEventList.push(
            Mission.decode(reader, reader.uint32())
          );
          break;
        case 2:
          if ((tag & 7) === 2) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.finishedMissionEventIdList.push(reader.uint32());
            }
          } else {
            message.finishedMissionEventIdList.push(reader.uint32());
          }
          break;
        case 3:
          if ((tag & 7) === 2) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.delMissionEventIdList.push(reader.uint32());
            }
          } else {
            message.delMissionEventIdList.push(reader.uint32());
          }
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): MissionEventSync {
    return {
      missionEventList: Array.isArray(object?.missionEventList)
        ? object.missionEventList.map((e: any) => Mission.fromJSON(e))
        : [],
      finishedMissionEventIdList: Array.isArray(
        object?.finishedMissionEventIdList
      )
        ? object.finishedMissionEventIdList.map((e: any) => Number(e))
        : [],
      delMissionEventIdList: Array.isArray(object?.delMissionEventIdList)
        ? object.delMissionEventIdList.map((e: any) => Number(e))
        : [],
    };
  },

  toJSON(message: MissionEventSync): unknown {
    const obj: any = {};
    if (message.missionEventList) {
      obj.missionEventList = message.missionEventList.map((e) =>
        e ? Mission.toJSON(e) : undefined
      );
    } else {
      obj.missionEventList = [];
    }
    if (message.finishedMissionEventIdList) {
      obj.finishedMissionEventIdList = message.finishedMissionEventIdList.map(
        (e) => Math.round(e)
      );
    } else {
      obj.finishedMissionEventIdList = [];
    }
    if (message.delMissionEventIdList) {
      obj.delMissionEventIdList = message.delMissionEventIdList.map((e) =>
        Math.round(e)
      );
    } else {
      obj.delMissionEventIdList = [];
    }
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<MissionEventSync>, I>>(
    object: I
  ): MissionEventSync {
    const message = createBaseMissionEventSync();
    message.missionEventList =
      object.missionEventList?.map((e) => Mission.fromPartial(e)) || [];
    message.finishedMissionEventIdList =
      object.finishedMissionEventIdList?.map((e) => e) || [];
    message.delMissionEventIdList =
      object.delMissionEventIdList?.map((e) => e) || [];
    return message;
  },
};

function createBasePlayerSyncScNotify(): PlayerSyncScNotify {
  return {
    basicInfo: undefined,
    avatarSync: undefined,
    equipmentList: [],
    delEquipmentList: [],
    materialList: [],
    questList: [],
    missionSync: undefined,
    basicModuleSync: undefined,
    relicList: [],
    delRelicList: [],
    missionEventSync: undefined,
    basicTypeInfoList: [],
    rogueItemList: [],
    rogueModuleSync: undefined,
    waitDelResourceList: [],
    totalAchievementExp: 0,
    newItemHintList: [],
    groupStatusList: [],
    sectionStatusList: [],
  };
}

export const PlayerSyncScNotify = {
  encode(
    message: PlayerSyncScNotify,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.basicInfo !== undefined) {
      PlayerBasicInfo.encode(
        message.basicInfo,
        writer.uint32(10).fork()
      ).ldelim();
    }
    if (message.avatarSync !== undefined) {
      AvatarSync.encode(message.avatarSync, writer.uint32(18).fork()).ldelim();
    }
    for (const v of message.equipmentList) {
      Equipment.encode(v!, writer.uint32(26).fork()).ldelim();
    }
    writer.uint32(34).fork();
    for (const v of message.delEquipmentList) {
      writer.uint32(v);
    }
    writer.ldelim();
    for (const v of message.materialList) {
      Material.encode(v!, writer.uint32(42).fork()).ldelim();
    }
    for (const v of message.questList) {
      Quest.encode(v!, writer.uint32(50).fork()).ldelim();
    }
    if (message.missionSync !== undefined) {
      MissionSync.encode(
        message.missionSync,
        writer.uint32(58).fork()
      ).ldelim();
    }
    if (message.basicModuleSync !== undefined) {
      BasicModuleSync.encode(
        message.basicModuleSync,
        writer.uint32(66).fork()
      ).ldelim();
    }
    for (const v of message.relicList) {
      Relic.encode(v!, writer.uint32(74).fork()).ldelim();
    }
    writer.uint32(82).fork();
    for (const v of message.delRelicList) {
      writer.uint32(v);
    }
    writer.ldelim();
    if (message.missionEventSync !== undefined) {
      MissionEventSync.encode(
        message.missionEventSync,
        writer.uint32(90).fork()
      ).ldelim();
    }
    for (const v of message.basicTypeInfoList) {
      HeroBasicTypeInfo.encode(v!, writer.uint32(98).fork()).ldelim();
    }
    for (const v of message.rogueItemList) {
      Material.encode(v!, writer.uint32(106).fork()).ldelim();
    }
    if (message.rogueModuleSync !== undefined) {
      RogueModuleSync.encode(
        message.rogueModuleSync,
        writer.uint32(114).fork()
      ).ldelim();
    }
    for (const v of message.waitDelResourceList) {
      WaitDelResource.encode(v!, writer.uint32(122).fork()).ldelim();
    }
    if (message.totalAchievementExp !== 0) {
      writer.uint32(128).uint32(message.totalAchievementExp);
    }
    writer.uint32(138).fork();
    for (const v of message.newItemHintList) {
      writer.uint32(v);
    }
    writer.ldelim();
    for (const v of message.groupStatusList) {
      GroupStatus.encode(v!, writer.uint32(146).fork()).ldelim();
    }
    for (const v of message.sectionStatusList) {
      SectionStatus.encode(v!, writer.uint32(154).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): PlayerSyncScNotify {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePlayerSyncScNotify();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.basicInfo = PlayerBasicInfo.decode(reader, reader.uint32());
          break;
        case 2:
          message.avatarSync = AvatarSync.decode(reader, reader.uint32());
          break;
        case 3:
          message.equipmentList.push(Equipment.decode(reader, reader.uint32()));
          break;
        case 4:
          if ((tag & 7) === 2) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.delEquipmentList.push(reader.uint32());
            }
          } else {
            message.delEquipmentList.push(reader.uint32());
          }
          break;
        case 5:
          message.materialList.push(Material.decode(reader, reader.uint32()));
          break;
        case 6:
          message.questList.push(Quest.decode(reader, reader.uint32()));
          break;
        case 7:
          message.missionSync = MissionSync.decode(reader, reader.uint32());
          break;
        case 8:
          message.basicModuleSync = BasicModuleSync.decode(
            reader,
            reader.uint32()
          );
          break;
        case 9:
          message.relicList.push(Relic.decode(reader, reader.uint32()));
          break;
        case 10:
          if ((tag & 7) === 2) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.delRelicList.push(reader.uint32());
            }
          } else {
            message.delRelicList.push(reader.uint32());
          }
          break;
        case 11:
          message.missionEventSync = MissionEventSync.decode(
            reader,
            reader.uint32()
          );
          break;
        case 12:
          message.basicTypeInfoList.push(
            HeroBasicTypeInfo.decode(reader, reader.uint32())
          );
          break;
        case 13:
          message.rogueItemList.push(Material.decode(reader, reader.uint32()));
          break;
        case 14:
          message.rogueModuleSync = RogueModuleSync.decode(
            reader,
            reader.uint32()
          );
          break;
        case 15:
          message.waitDelResourceList.push(
            WaitDelResource.decode(reader, reader.uint32())
          );
          break;
        case 16:
          message.totalAchievementExp = reader.uint32();
          break;
        case 17:
          if ((tag & 7) === 2) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.newItemHintList.push(reader.uint32());
            }
          } else {
            message.newItemHintList.push(reader.uint32());
          }
          break;
        case 18:
          message.groupStatusList.push(
            GroupStatus.decode(reader, reader.uint32())
          );
          break;
        case 19:
          message.sectionStatusList.push(
            SectionStatus.decode(reader, reader.uint32())
          );
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): PlayerSyncScNotify {
    return {
      basicInfo: isSet(object.basicInfo)
        ? PlayerBasicInfo.fromJSON(object.basicInfo)
        : undefined,
      avatarSync: isSet(object.avatarSync)
        ? AvatarSync.fromJSON(object.avatarSync)
        : undefined,
      equipmentList: Array.isArray(object?.equipmentList)
        ? object.equipmentList.map((e: any) => Equipment.fromJSON(e))
        : [],
      delEquipmentList: Array.isArray(object?.delEquipmentList)
        ? object.delEquipmentList.map((e: any) => Number(e))
        : [],
      materialList: Array.isArray(object?.materialList)
        ? object.materialList.map((e: any) => Material.fromJSON(e))
        : [],
      questList: Array.isArray(object?.questList)
        ? object.questList.map((e: any) => Quest.fromJSON(e))
        : [],
      missionSync: isSet(object.missionSync)
        ? MissionSync.fromJSON(object.missionSync)
        : undefined,
      basicModuleSync: isSet(object.basicModuleSync)
        ? BasicModuleSync.fromJSON(object.basicModuleSync)
        : undefined,
      relicList: Array.isArray(object?.relicList)
        ? object.relicList.map((e: any) => Relic.fromJSON(e))
        : [],
      delRelicList: Array.isArray(object?.delRelicList)
        ? object.delRelicList.map((e: any) => Number(e))
        : [],
      missionEventSync: isSet(object.missionEventSync)
        ? MissionEventSync.fromJSON(object.missionEventSync)
        : undefined,
      basicTypeInfoList: Array.isArray(object?.basicTypeInfoList)
        ? object.basicTypeInfoList.map((e: any) =>
            HeroBasicTypeInfo.fromJSON(e)
          )
        : [],
      rogueItemList: Array.isArray(object?.rogueItemList)
        ? object.rogueItemList.map((e: any) => Material.fromJSON(e))
        : [],
      rogueModuleSync: isSet(object.rogueModuleSync)
        ? RogueModuleSync.fromJSON(object.rogueModuleSync)
        : undefined,
      waitDelResourceList: Array.isArray(object?.waitDelResourceList)
        ? object.waitDelResourceList.map((e: any) =>
            WaitDelResource.fromJSON(e)
          )
        : [],
      totalAchievementExp: isSet(object.totalAchievementExp)
        ? Number(object.totalAchievementExp)
        : 0,
      newItemHintList: Array.isArray(object?.newItemHintList)
        ? object.newItemHintList.map((e: any) => Number(e))
        : [],
      groupStatusList: Array.isArray(object?.groupStatusList)
        ? object.groupStatusList.map((e: any) => GroupStatus.fromJSON(e))
        : [],
      sectionStatusList: Array.isArray(object?.sectionStatusList)
        ? object.sectionStatusList.map((e: any) => SectionStatus.fromJSON(e))
        : [],
    };
  },

  toJSON(message: PlayerSyncScNotify): unknown {
    const obj: any = {};
    message.basicInfo !== undefined &&
      (obj.basicInfo = message.basicInfo
        ? PlayerBasicInfo.toJSON(message.basicInfo)
        : undefined);
    message.avatarSync !== undefined &&
      (obj.avatarSync = message.avatarSync
        ? AvatarSync.toJSON(message.avatarSync)
        : undefined);
    if (message.equipmentList) {
      obj.equipmentList = message.equipmentList.map((e) =>
        e ? Equipment.toJSON(e) : undefined
      );
    } else {
      obj.equipmentList = [];
    }
    if (message.delEquipmentList) {
      obj.delEquipmentList = message.delEquipmentList.map((e) => Math.round(e));
    } else {
      obj.delEquipmentList = [];
    }
    if (message.materialList) {
      obj.materialList = message.materialList.map((e) =>
        e ? Material.toJSON(e) : undefined
      );
    } else {
      obj.materialList = [];
    }
    if (message.questList) {
      obj.questList = message.questList.map((e) =>
        e ? Quest.toJSON(e) : undefined
      );
    } else {
      obj.questList = [];
    }
    message.missionSync !== undefined &&
      (obj.missionSync = message.missionSync
        ? MissionSync.toJSON(message.missionSync)
        : undefined);
    message.basicModuleSync !== undefined &&
      (obj.basicModuleSync = message.basicModuleSync
        ? BasicModuleSync.toJSON(message.basicModuleSync)
        : undefined);
    if (message.relicList) {
      obj.relicList = message.relicList.map((e) =>
        e ? Relic.toJSON(e) : undefined
      );
    } else {
      obj.relicList = [];
    }
    if (message.delRelicList) {
      obj.delRelicList = message.delRelicList.map((e) => Math.round(e));
    } else {
      obj.delRelicList = [];
    }
    message.missionEventSync !== undefined &&
      (obj.missionEventSync = message.missionEventSync
        ? MissionEventSync.toJSON(message.missionEventSync)
        : undefined);
    if (message.basicTypeInfoList) {
      obj.basicTypeInfoList = message.basicTypeInfoList.map((e) =>
        e ? HeroBasicTypeInfo.toJSON(e) : undefined
      );
    } else {
      obj.basicTypeInfoList = [];
    }
    if (message.rogueItemList) {
      obj.rogueItemList = message.rogueItemList.map((e) =>
        e ? Material.toJSON(e) : undefined
      );
    } else {
      obj.rogueItemList = [];
    }
    message.rogueModuleSync !== undefined &&
      (obj.rogueModuleSync = message.rogueModuleSync
        ? RogueModuleSync.toJSON(message.rogueModuleSync)
        : undefined);
    if (message.waitDelResourceList) {
      obj.waitDelResourceList = message.waitDelResourceList.map((e) =>
        e ? WaitDelResource.toJSON(e) : undefined
      );
    } else {
      obj.waitDelResourceList = [];
    }
    message.totalAchievementExp !== undefined &&
      (obj.totalAchievementExp = Math.round(message.totalAchievementExp));
    if (message.newItemHintList) {
      obj.newItemHintList = message.newItemHintList.map((e) => Math.round(e));
    } else {
      obj.newItemHintList = [];
    }
    if (message.groupStatusList) {
      obj.groupStatusList = message.groupStatusList.map((e) =>
        e ? GroupStatus.toJSON(e) : undefined
      );
    } else {
      obj.groupStatusList = [];
    }
    if (message.sectionStatusList) {
      obj.sectionStatusList = message.sectionStatusList.map((e) =>
        e ? SectionStatus.toJSON(e) : undefined
      );
    } else {
      obj.sectionStatusList = [];
    }
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<PlayerSyncScNotify>, I>>(
    object: I
  ): PlayerSyncScNotify {
    const message = createBasePlayerSyncScNotify();
    message.basicInfo =
      object.basicInfo !== undefined && object.basicInfo !== null
        ? PlayerBasicInfo.fromPartial(object.basicInfo)
        : undefined;
    message.avatarSync =
      object.avatarSync !== undefined && object.avatarSync !== null
        ? AvatarSync.fromPartial(object.avatarSync)
        : undefined;
    message.equipmentList =
      object.equipmentList?.map((e) => Equipment.fromPartial(e)) || [];
    message.delEquipmentList = object.delEquipmentList?.map((e) => e) || [];
    message.materialList =
      object.materialList?.map((e) => Material.fromPartial(e)) || [];
    message.questList =
      object.questList?.map((e) => Quest.fromPartial(e)) || [];
    message.missionSync =
      object.missionSync !== undefined && object.missionSync !== null
        ? MissionSync.fromPartial(object.missionSync)
        : undefined;
    message.basicModuleSync =
      object.basicModuleSync !== undefined && object.basicModuleSync !== null
        ? BasicModuleSync.fromPartial(object.basicModuleSync)
        : undefined;
    message.relicList =
      object.relicList?.map((e) => Relic.fromPartial(e)) || [];
    message.delRelicList = object.delRelicList?.map((e) => e) || [];
    message.missionEventSync =
      object.missionEventSync !== undefined && object.missionEventSync !== null
        ? MissionEventSync.fromPartial(object.missionEventSync)
        : undefined;
    message.basicTypeInfoList =
      object.basicTypeInfoList?.map((e) => HeroBasicTypeInfo.fromPartial(e)) ||
      [];
    message.rogueItemList =
      object.rogueItemList?.map((e) => Material.fromPartial(e)) || [];
    message.rogueModuleSync =
      object.rogueModuleSync !== undefined && object.rogueModuleSync !== null
        ? RogueModuleSync.fromPartial(object.rogueModuleSync)
        : undefined;
    message.waitDelResourceList =
      object.waitDelResourceList?.map((e) => WaitDelResource.fromPartial(e)) ||
      [];
    message.totalAchievementExp = object.totalAchievementExp ?? 0;
    message.newItemHintList = object.newItemHintList?.map((e) => e) || [];
    message.groupStatusList =
      object.groupStatusList?.map((e) => GroupStatus.fromPartial(e)) || [];
    message.sectionStatusList =
      object.sectionStatusList?.map((e) => SectionStatus.fromPartial(e)) || [];
    return message;
  },
};

function createBaseGetNpcTakenRewardCsReq(): GetNpcTakenRewardCsReq {
  return { npcId: 0 };
}

export const GetNpcTakenRewardCsReq = {
  encode(
    message: GetNpcTakenRewardCsReq,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.npcId !== 0) {
      writer.uint32(8).uint32(message.npcId);
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): GetNpcTakenRewardCsReq {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetNpcTakenRewardCsReq();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.npcId = reader.uint32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): GetNpcTakenRewardCsReq {
    return {
      npcId: isSet(object.npcId) ? Number(object.npcId) : 0,
    };
  },

  toJSON(message: GetNpcTakenRewardCsReq): unknown {
    const obj: any = {};
    message.npcId !== undefined && (obj.npcId = Math.round(message.npcId));
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<GetNpcTakenRewardCsReq>, I>>(
    object: I
  ): GetNpcTakenRewardCsReq {
    const message = createBaseGetNpcTakenRewardCsReq();
    message.npcId = object.npcId ?? 0;
    return message;
  },
};

function createBaseGetNpcTakenRewardScRsp(): GetNpcTakenRewardScRsp {
  return { retcode: 0, npcId: 0, talkEventList: [] };
}

export const GetNpcTakenRewardScRsp = {
  encode(
    message: GetNpcTakenRewardScRsp,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.retcode !== 0) {
      writer.uint32(8).uint32(message.retcode);
    }
    if (message.npcId !== 0) {
      writer.uint32(16).uint32(message.npcId);
    }
    writer.uint32(26).fork();
    for (const v of message.talkEventList) {
      writer.uint32(v);
    }
    writer.ldelim();
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): GetNpcTakenRewardScRsp {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetNpcTakenRewardScRsp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.retcode = reader.uint32();
          break;
        case 2:
          message.npcId = reader.uint32();
          break;
        case 3:
          if ((tag & 7) === 2) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.talkEventList.push(reader.uint32());
            }
          } else {
            message.talkEventList.push(reader.uint32());
          }
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): GetNpcTakenRewardScRsp {
    return {
      retcode: isSet(object.retcode) ? Number(object.retcode) : 0,
      npcId: isSet(object.npcId) ? Number(object.npcId) : 0,
      talkEventList: Array.isArray(object?.talkEventList)
        ? object.talkEventList.map((e: any) => Number(e))
        : [],
    };
  },

  toJSON(message: GetNpcTakenRewardScRsp): unknown {
    const obj: any = {};
    message.retcode !== undefined &&
      (obj.retcode = Math.round(message.retcode));
    message.npcId !== undefined && (obj.npcId = Math.round(message.npcId));
    if (message.talkEventList) {
      obj.talkEventList = message.talkEventList.map((e) => Math.round(e));
    } else {
      obj.talkEventList = [];
    }
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<GetNpcTakenRewardScRsp>, I>>(
    object: I
  ): GetNpcTakenRewardScRsp {
    const message = createBaseGetNpcTakenRewardScRsp();
    message.retcode = object.retcode ?? 0;
    message.npcId = object.npcId ?? 0;
    message.talkEventList = object.talkEventList?.map((e) => e) || [];
    return message;
  },
};

function createBaseTakeTalkRewardCsReq(): TakeTalkRewardCsReq {
  return { talkEventId: 0, npcLocation: undefined };
}

export const TakeTalkRewardCsReq = {
  encode(
    message: TakeTalkRewardCsReq,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.talkEventId !== 0) {
      writer.uint32(8).uint32(message.talkEventId);
    }
    if (message.npcLocation !== undefined) {
      Vector.encode(message.npcLocation, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): TakeTalkRewardCsReq {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTakeTalkRewardCsReq();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.talkEventId = reader.uint32();
          break;
        case 2:
          message.npcLocation = Vector.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): TakeTalkRewardCsReq {
    return {
      talkEventId: isSet(object.talkEventId) ? Number(object.talkEventId) : 0,
      npcLocation: isSet(object.npcLocation)
        ? Vector.fromJSON(object.npcLocation)
        : undefined,
    };
  },

  toJSON(message: TakeTalkRewardCsReq): unknown {
    const obj: any = {};
    message.talkEventId !== undefined &&
      (obj.talkEventId = Math.round(message.talkEventId));
    message.npcLocation !== undefined &&
      (obj.npcLocation = message.npcLocation
        ? Vector.toJSON(message.npcLocation)
        : undefined);
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<TakeTalkRewardCsReq>, I>>(
    object: I
  ): TakeTalkRewardCsReq {
    const message = createBaseTakeTalkRewardCsReq();
    message.talkEventId = object.talkEventId ?? 0;
    message.npcLocation =
      object.npcLocation !== undefined && object.npcLocation !== null
        ? Vector.fromPartial(object.npcLocation)
        : undefined;
    return message;
  },
};

function createBaseTakeTalkRewardScRsp(): TakeTalkRewardScRsp {
  return { retcode: 0, talkEventId: 0, reward: undefined };
}

export const TakeTalkRewardScRsp = {
  encode(
    message: TakeTalkRewardScRsp,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.retcode !== 0) {
      writer.uint32(8).uint32(message.retcode);
    }
    if (message.talkEventId !== 0) {
      writer.uint32(16).uint32(message.talkEventId);
    }
    if (message.reward !== undefined) {
      ItemList.encode(message.reward, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): TakeTalkRewardScRsp {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTakeTalkRewardScRsp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.retcode = reader.uint32();
          break;
        case 2:
          message.talkEventId = reader.uint32();
          break;
        case 3:
          message.reward = ItemList.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): TakeTalkRewardScRsp {
    return {
      retcode: isSet(object.retcode) ? Number(object.retcode) : 0,
      talkEventId: isSet(object.talkEventId) ? Number(object.talkEventId) : 0,
      reward: isSet(object.reward)
        ? ItemList.fromJSON(object.reward)
        : undefined,
    };
  },

  toJSON(message: TakeTalkRewardScRsp): unknown {
    const obj: any = {};
    message.retcode !== undefined &&
      (obj.retcode = Math.round(message.retcode));
    message.talkEventId !== undefined &&
      (obj.talkEventId = Math.round(message.talkEventId));
    message.reward !== undefined &&
      (obj.reward = message.reward
        ? ItemList.toJSON(message.reward)
        : undefined);
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<TakeTalkRewardScRsp>, I>>(
    object: I
  ): TakeTalkRewardScRsp {
    const message = createBaseTakeTalkRewardScRsp();
    message.retcode = object.retcode ?? 0;
    message.talkEventId = object.talkEventId ?? 0;
    message.reward =
      object.reward !== undefined && object.reward !== null
        ? ItemList.fromPartial(object.reward)
        : undefined;
    return message;
  },
};

function createBaseGetFirstTalkNpcCsReq(): GetFirstTalkNpcCsReq {
  return { seriesIdList: [] };
}

export const GetFirstTalkNpcCsReq = {
  encode(
    message: GetFirstTalkNpcCsReq,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    writer.uint32(10).fork();
    for (const v of message.seriesIdList) {
      writer.uint32(v);
    }
    writer.ldelim();
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): GetFirstTalkNpcCsReq {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetFirstTalkNpcCsReq();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if ((tag & 7) === 2) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.seriesIdList.push(reader.uint32());
            }
          } else {
            message.seriesIdList.push(reader.uint32());
          }
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): GetFirstTalkNpcCsReq {
    return {
      seriesIdList: Array.isArray(object?.seriesIdList)
        ? object.seriesIdList.map((e: any) => Number(e))
        : [],
    };
  },

  toJSON(message: GetFirstTalkNpcCsReq): unknown {
    const obj: any = {};
    if (message.seriesIdList) {
      obj.seriesIdList = message.seriesIdList.map((e) => Math.round(e));
    } else {
      obj.seriesIdList = [];
    }
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<GetFirstTalkNpcCsReq>, I>>(
    object: I
  ): GetFirstTalkNpcCsReq {
    const message = createBaseGetFirstTalkNpcCsReq();
    message.seriesIdList = object.seriesIdList?.map((e) => e) || [];
    return message;
  },
};

function createBaseNpcMeetStatus(): NpcMeetStatus {
  return { seriesId: 0, isMeet: false };
}

export const NpcMeetStatus = {
  encode(
    message: NpcMeetStatus,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.seriesId !== 0) {
      writer.uint32(8).uint32(message.seriesId);
    }
    if (message.isMeet === true) {
      writer.uint32(16).bool(message.isMeet);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): NpcMeetStatus {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNpcMeetStatus();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.seriesId = reader.uint32();
          break;
        case 2:
          message.isMeet = reader.bool();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): NpcMeetStatus {
    return {
      seriesId: isSet(object.seriesId) ? Number(object.seriesId) : 0,
      isMeet: isSet(object.isMeet) ? Boolean(object.isMeet) : false,
    };
  },

  toJSON(message: NpcMeetStatus): unknown {
    const obj: any = {};
    message.seriesId !== undefined &&
      (obj.seriesId = Math.round(message.seriesId));
    message.isMeet !== undefined && (obj.isMeet = message.isMeet);
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<NpcMeetStatus>, I>>(
    object: I
  ): NpcMeetStatus {
    const message = createBaseNpcMeetStatus();
    message.seriesId = object.seriesId ?? 0;
    message.isMeet = object.isMeet ?? false;
    return message;
  },
};

function createBaseGetFirstTalkNpcScRsp(): GetFirstTalkNpcScRsp {
  return { retcode: 0, npcMeetStatusList: [] };
}

export const GetFirstTalkNpcScRsp = {
  encode(
    message: GetFirstTalkNpcScRsp,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.retcode !== 0) {
      writer.uint32(8).uint32(message.retcode);
    }
    for (const v of message.npcMeetStatusList) {
      NpcMeetStatus.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): GetFirstTalkNpcScRsp {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetFirstTalkNpcScRsp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.retcode = reader.uint32();
          break;
        case 2:
          message.npcMeetStatusList.push(
            NpcMeetStatus.decode(reader, reader.uint32())
          );
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): GetFirstTalkNpcScRsp {
    return {
      retcode: isSet(object.retcode) ? Number(object.retcode) : 0,
      npcMeetStatusList: Array.isArray(object?.npcMeetStatusList)
        ? object.npcMeetStatusList.map((e: any) => NpcMeetStatus.fromJSON(e))
        : [],
    };
  },

  toJSON(message: GetFirstTalkNpcScRsp): unknown {
    const obj: any = {};
    message.retcode !== undefined &&
      (obj.retcode = Math.round(message.retcode));
    if (message.npcMeetStatusList) {
      obj.npcMeetStatusList = message.npcMeetStatusList.map((e) =>
        e ? NpcMeetStatus.toJSON(e) : undefined
      );
    } else {
      obj.npcMeetStatusList = [];
    }
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<GetFirstTalkNpcScRsp>, I>>(
    object: I
  ): GetFirstTalkNpcScRsp {
    const message = createBaseGetFirstTalkNpcScRsp();
    message.retcode = object.retcode ?? 0;
    message.npcMeetStatusList =
      object.npcMeetStatusList?.map((e) => NpcMeetStatus.fromPartial(e)) || [];
    return message;
  },
};

function createBaseFinishFirstTalkNpcCsReq(): FinishFirstTalkNpcCsReq {
  return { seriesId: 0 };
}

export const FinishFirstTalkNpcCsReq = {
  encode(
    message: FinishFirstTalkNpcCsReq,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.seriesId !== 0) {
      writer.uint32(8).uint32(message.seriesId);
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): FinishFirstTalkNpcCsReq {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFinishFirstTalkNpcCsReq();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.seriesId = reader.uint32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): FinishFirstTalkNpcCsReq {
    return {
      seriesId: isSet(object.seriesId) ? Number(object.seriesId) : 0,
    };
  },

  toJSON(message: FinishFirstTalkNpcCsReq): unknown {
    const obj: any = {};
    message.seriesId !== undefined &&
      (obj.seriesId = Math.round(message.seriesId));
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<FinishFirstTalkNpcCsReq>, I>>(
    object: I
  ): FinishFirstTalkNpcCsReq {
    const message = createBaseFinishFirstTalkNpcCsReq();
    message.seriesId = object.seriesId ?? 0;
    return message;
  },
};

function createBaseFinishFirstTalkNpcScRsp(): FinishFirstTalkNpcScRsp {
  return { retcode: 0, seriesId: 0 };
}

export const FinishFirstTalkNpcScRsp = {
  encode(
    message: FinishFirstTalkNpcScRsp,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.retcode !== 0) {
      writer.uint32(8).uint32(message.retcode);
    }
    if (message.seriesId !== 0) {
      writer.uint32(16).uint32(message.seriesId);
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): FinishFirstTalkNpcScRsp {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFinishFirstTalkNpcScRsp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.retcode = reader.uint32();
          break;
        case 2:
          message.seriesId = reader.uint32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): FinishFirstTalkNpcScRsp {
    return {
      retcode: isSet(object.retcode) ? Number(object.retcode) : 0,
      seriesId: isSet(object.seriesId) ? Number(object.seriesId) : 0,
    };
  },

  toJSON(message: FinishFirstTalkNpcScRsp): unknown {
    const obj: any = {};
    message.retcode !== undefined &&
      (obj.retcode = Math.round(message.retcode));
    message.seriesId !== undefined &&
      (obj.seriesId = Math.round(message.seriesId));
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<FinishFirstTalkNpcScRsp>, I>>(
    object: I
  ): FinishFirstTalkNpcScRsp {
    const message = createBaseFinishFirstTalkNpcScRsp();
    message.retcode = object.retcode ?? 0;
    message.seriesId = object.seriesId ?? 0;
    return message;
  },
};

function createBaseTutorial(): Tutorial {
  return { id: 0, status: 0 };
}

export const Tutorial = {
  encode(
    message: Tutorial,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.id !== 0) {
      writer.uint32(8).uint32(message.id);
    }
    if (message.status !== 0) {
      writer.uint32(16).int32(message.status);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Tutorial {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTutorial();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.id = reader.uint32();
          break;
        case 2:
          message.status = reader.int32() as any;
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): Tutorial {
    return {
      id: isSet(object.id) ? Number(object.id) : 0,
      status: isSet(object.status) ? tutorialStatusFromJSON(object.status) : 0,
    };
  },

  toJSON(message: Tutorial): unknown {
    const obj: any = {};
    message.id !== undefined && (obj.id = Math.round(message.id));
    message.status !== undefined &&
      (obj.status = tutorialStatusToJSON(message.status));
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<Tutorial>, I>>(object: I): Tutorial {
    const message = createBaseTutorial();
    message.id = object.id ?? 0;
    message.status = object.status ?? 0;
    return message;
  },
};

function createBaseTutorialGuide(): TutorialGuide {
  return { id: 0, status: 0 };
}

export const TutorialGuide = {
  encode(
    message: TutorialGuide,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.id !== 0) {
      writer.uint32(8).uint32(message.id);
    }
    if (message.status !== 0) {
      writer.uint32(16).int32(message.status);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): TutorialGuide {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTutorialGuide();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.id = reader.uint32();
          break;
        case 2:
          message.status = reader.int32() as any;
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): TutorialGuide {
    return {
      id: isSet(object.id) ? Number(object.id) : 0,
      status: isSet(object.status) ? tutorialStatusFromJSON(object.status) : 0,
    };
  },

  toJSON(message: TutorialGuide): unknown {
    const obj: any = {};
    message.id !== undefined && (obj.id = Math.round(message.id));
    message.status !== undefined &&
      (obj.status = tutorialStatusToJSON(message.status));
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<TutorialGuide>, I>>(
    object: I
  ): TutorialGuide {
    const message = createBaseTutorialGuide();
    message.id = object.id ?? 0;
    message.status = object.status ?? 0;
    return message;
  },
};

function createBaseGetTutorialCsReq(): GetTutorialCsReq {
  return {};
}

export const GetTutorialCsReq = {
  encode(
    _: GetTutorialCsReq,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetTutorialCsReq {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetTutorialCsReq();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(_: any): GetTutorialCsReq {
    return {};
  },

  toJSON(_: GetTutorialCsReq): unknown {
    const obj: any = {};
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<GetTutorialCsReq>, I>>(
    _: I
  ): GetTutorialCsReq {
    const message = createBaseGetTutorialCsReq();
    return message;
  },
};

function createBaseGetTutorialScRsp(): GetTutorialScRsp {
  return { retcode: 0, tutorialList: [] };
}

export const GetTutorialScRsp = {
  encode(
    message: GetTutorialScRsp,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.retcode !== 0) {
      writer.uint32(8).uint32(message.retcode);
    }
    for (const v of message.tutorialList) {
      Tutorial.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetTutorialScRsp {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetTutorialScRsp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.retcode = reader.uint32();
          break;
        case 2:
          message.tutorialList.push(Tutorial.decode(reader, reader.uint32()));
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): GetTutorialScRsp {
    return {
      retcode: isSet(object.retcode) ? Number(object.retcode) : 0,
      tutorialList: Array.isArray(object?.tutorialList)
        ? object.tutorialList.map((e: any) => Tutorial.fromJSON(e))
        : [],
    };
  },

  toJSON(message: GetTutorialScRsp): unknown {
    const obj: any = {};
    message.retcode !== undefined &&
      (obj.retcode = Math.round(message.retcode));
    if (message.tutorialList) {
      obj.tutorialList = message.tutorialList.map((e) =>
        e ? Tutorial.toJSON(e) : undefined
      );
    } else {
      obj.tutorialList = [];
    }
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<GetTutorialScRsp>, I>>(
    object: I
  ): GetTutorialScRsp {
    const message = createBaseGetTutorialScRsp();
    message.retcode = object.retcode ?? 0;
    message.tutorialList =
      object.tutorialList?.map((e) => Tutorial.fromPartial(e)) || [];
    return message;
  },
};

function createBaseGetTutorialGuideCsReq(): GetTutorialGuideCsReq {
  return {};
}

export const GetTutorialGuideCsReq = {
  encode(
    _: GetTutorialGuideCsReq,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): GetTutorialGuideCsReq {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetTutorialGuideCsReq();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(_: any): GetTutorialGuideCsReq {
    return {};
  },

  toJSON(_: GetTutorialGuideCsReq): unknown {
    const obj: any = {};
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<GetTutorialGuideCsReq>, I>>(
    _: I
  ): GetTutorialGuideCsReq {
    const message = createBaseGetTutorialGuideCsReq();
    return message;
  },
};

function createBaseGetTutorialGuideScRsp(): GetTutorialGuideScRsp {
  return { retcode: 0, tutorialGuideList: [] };
}

export const GetTutorialGuideScRsp = {
  encode(
    message: GetTutorialGuideScRsp,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.retcode !== 0) {
      writer.uint32(8).uint32(message.retcode);
    }
    for (const v of message.tutorialGuideList) {
      TutorialGuide.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): GetTutorialGuideScRsp {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetTutorialGuideScRsp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.retcode = reader.uint32();
          break;
        case 2:
          message.tutorialGuideList.push(
            TutorialGuide.decode(reader, reader.uint32())
          );
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): GetTutorialGuideScRsp {
    return {
      retcode: isSet(object.retcode) ? Number(object.retcode) : 0,
      tutorialGuideList: Array.isArray(object?.tutorialGuideList)
        ? object.tutorialGuideList.map((e: any) => TutorialGuide.fromJSON(e))
        : [],
    };
  },

  toJSON(message: GetTutorialGuideScRsp): unknown {
    const obj: any = {};
    message.retcode !== undefined &&
      (obj.retcode = Math.round(message.retcode));
    if (message.tutorialGuideList) {
      obj.tutorialGuideList = message.tutorialGuideList.map((e) =>
        e ? TutorialGuide.toJSON(e) : undefined
      );
    } else {
      obj.tutorialGuideList = [];
    }
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<GetTutorialGuideScRsp>, I>>(
    object: I
  ): GetTutorialGuideScRsp {
    const message = createBaseGetTutorialGuideScRsp();
    message.retcode = object.retcode ?? 0;
    message.tutorialGuideList =
      object.tutorialGuideList?.map((e) => TutorialGuide.fromPartial(e)) || [];
    return message;
  },
};

function createBaseUnlockTutorialCsReq(): UnlockTutorialCsReq {
  return { tutorialId: 0 };
}

export const UnlockTutorialCsReq = {
  encode(
    message: UnlockTutorialCsReq,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.tutorialId !== 0) {
      writer.uint32(8).uint32(message.tutorialId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): UnlockTutorialCsReq {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUnlockTutorialCsReq();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.tutorialId = reader.uint32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): UnlockTutorialCsReq {
    return {
      tutorialId: isSet(object.tutorialId) ? Number(object.tutorialId) : 0,
    };
  },

  toJSON(message: UnlockTutorialCsReq): unknown {
    const obj: any = {};
    message.tutorialId !== undefined &&
      (obj.tutorialId = Math.round(message.tutorialId));
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<UnlockTutorialCsReq>, I>>(
    object: I
  ): UnlockTutorialCsReq {
    const message = createBaseUnlockTutorialCsReq();
    message.tutorialId = object.tutorialId ?? 0;
    return message;
  },
};

function createBaseUnlockTutorialScRsp(): UnlockTutorialScRsp {
  return { retcode: 0, tutorial: undefined };
}

export const UnlockTutorialScRsp = {
  encode(
    message: UnlockTutorialScRsp,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.retcode !== 0) {
      writer.uint32(8).uint32(message.retcode);
    }
    if (message.tutorial !== undefined) {
      Tutorial.encode(message.tutorial, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): UnlockTutorialScRsp {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUnlockTutorialScRsp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.retcode = reader.uint32();
          break;
        case 2:
          message.tutorial = Tutorial.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): UnlockTutorialScRsp {
    return {
      retcode: isSet(object.retcode) ? Number(object.retcode) : 0,
      tutorial: isSet(object.tutorial)
        ? Tutorial.fromJSON(object.tutorial)
        : undefined,
    };
  },

  toJSON(message: UnlockTutorialScRsp): unknown {
    const obj: any = {};
    message.retcode !== undefined &&
      (obj.retcode = Math.round(message.retcode));
    message.tutorial !== undefined &&
      (obj.tutorial = message.tutorial
        ? Tutorial.toJSON(message.tutorial)
        : undefined);
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<UnlockTutorialScRsp>, I>>(
    object: I
  ): UnlockTutorialScRsp {
    const message = createBaseUnlockTutorialScRsp();
    message.retcode = object.retcode ?? 0;
    message.tutorial =
      object.tutorial !== undefined && object.tutorial !== null
        ? Tutorial.fromPartial(object.tutorial)
        : undefined;
    return message;
  },
};

function createBaseUnlockTutorialGuideCsReq(): UnlockTutorialGuideCsReq {
  return { groupId: 0 };
}

export const UnlockTutorialGuideCsReq = {
  encode(
    message: UnlockTutorialGuideCsReq,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.groupId !== 0) {
      writer.uint32(8).uint32(message.groupId);
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): UnlockTutorialGuideCsReq {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUnlockTutorialGuideCsReq();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.groupId = reader.uint32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): UnlockTutorialGuideCsReq {
    return {
      groupId: isSet(object.groupId) ? Number(object.groupId) : 0,
    };
  },

  toJSON(message: UnlockTutorialGuideCsReq): unknown {
    const obj: any = {};
    message.groupId !== undefined &&
      (obj.groupId = Math.round(message.groupId));
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<UnlockTutorialGuideCsReq>, I>>(
    object: I
  ): UnlockTutorialGuideCsReq {
    const message = createBaseUnlockTutorialGuideCsReq();
    message.groupId = object.groupId ?? 0;
    return message;
  },
};

function createBaseUnlockTutorialGuideScRsp(): UnlockTutorialGuideScRsp {
  return { retcode: 0, tutorialGuide: undefined };
}

export const UnlockTutorialGuideScRsp = {
  encode(
    message: UnlockTutorialGuideScRsp,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.retcode !== 0) {
      writer.uint32(8).uint32(message.retcode);
    }
    if (message.tutorialGuide !== undefined) {
      TutorialGuide.encode(
        message.tutorialGuide,
        writer.uint32(18).fork()
      ).ldelim();
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): UnlockTutorialGuideScRsp {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUnlockTutorialGuideScRsp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.retcode = reader.uint32();
          break;
        case 2:
          message.tutorialGuide = TutorialGuide.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): UnlockTutorialGuideScRsp {
    return {
      retcode: isSet(object.retcode) ? Number(object.retcode) : 0,
      tutorialGuide: isSet(object.tutorialGuide)
        ? TutorialGuide.fromJSON(object.tutorialGuide)
        : undefined,
    };
  },

  toJSON(message: UnlockTutorialGuideScRsp): unknown {
    const obj: any = {};
    message.retcode !== undefined &&
      (obj.retcode = Math.round(message.retcode));
    message.tutorialGuide !== undefined &&
      (obj.tutorialGuide = message.tutorialGuide
        ? TutorialGuide.toJSON(message.tutorialGuide)
        : undefined);
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<UnlockTutorialGuideScRsp>, I>>(
    object: I
  ): UnlockTutorialGuideScRsp {
    const message = createBaseUnlockTutorialGuideScRsp();
    message.retcode = object.retcode ?? 0;
    message.tutorialGuide =
      object.tutorialGuide !== undefined && object.tutorialGuide !== null
        ? TutorialGuide.fromPartial(object.tutorialGuide)
        : undefined;
    return message;
  },
};

function createBaseFinishTutorialCsReq(): FinishTutorialCsReq {
  return { tutorialId: 0 };
}

export const FinishTutorialCsReq = {
  encode(
    message: FinishTutorialCsReq,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.tutorialId !== 0) {
      writer.uint32(8).uint32(message.tutorialId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): FinishTutorialCsReq {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFinishTutorialCsReq();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.tutorialId = reader.uint32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): FinishTutorialCsReq {
    return {
      tutorialId: isSet(object.tutorialId) ? Number(object.tutorialId) : 0,
    };
  },

  toJSON(message: FinishTutorialCsReq): unknown {
    const obj: any = {};
    message.tutorialId !== undefined &&
      (obj.tutorialId = Math.round(message.tutorialId));
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<FinishTutorialCsReq>, I>>(
    object: I
  ): FinishTutorialCsReq {
    const message = createBaseFinishTutorialCsReq();
    message.tutorialId = object.tutorialId ?? 0;
    return message;
  },
};

function createBaseFinishTutorialScRsp(): FinishTutorialScRsp {
  return { retcode: 0, tutorial: undefined };
}

export const FinishTutorialScRsp = {
  encode(
    message: FinishTutorialScRsp,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.retcode !== 0) {
      writer.uint32(8).uint32(message.retcode);
    }
    if (message.tutorial !== undefined) {
      Tutorial.encode(message.tutorial, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): FinishTutorialScRsp {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFinishTutorialScRsp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.retcode = reader.uint32();
          break;
        case 2:
          message.tutorial = Tutorial.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): FinishTutorialScRsp {
    return {
      retcode: isSet(object.retcode) ? Number(object.retcode) : 0,
      tutorial: isSet(object.tutorial)
        ? Tutorial.fromJSON(object.tutorial)
        : undefined,
    };
  },

  toJSON(message: FinishTutorialScRsp): unknown {
    const obj: any = {};
    message.retcode !== undefined &&
      (obj.retcode = Math.round(message.retcode));
    message.tutorial !== undefined &&
      (obj.tutorial = message.tutorial
        ? Tutorial.toJSON(message.tutorial)
        : undefined);
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<FinishTutorialScRsp>, I>>(
    object: I
  ): FinishTutorialScRsp {
    const message = createBaseFinishTutorialScRsp();
    message.retcode = object.retcode ?? 0;
    message.tutorial =
      object.tutorial !== undefined && object.tutorial !== null
        ? Tutorial.fromPartial(object.tutorial)
        : undefined;
    return message;
  },
};

function createBaseFinishTutorialGuideCsReq(): FinishTutorialGuideCsReq {
  return { groupId: 0 };
}

export const FinishTutorialGuideCsReq = {
  encode(
    message: FinishTutorialGuideCsReq,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.groupId !== 0) {
      writer.uint32(8).uint32(message.groupId);
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): FinishTutorialGuideCsReq {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFinishTutorialGuideCsReq();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.groupId = reader.uint32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): FinishTutorialGuideCsReq {
    return {
      groupId: isSet(object.groupId) ? Number(object.groupId) : 0,
    };
  },

  toJSON(message: FinishTutorialGuideCsReq): unknown {
    const obj: any = {};
    message.groupId !== undefined &&
      (obj.groupId = Math.round(message.groupId));
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<FinishTutorialGuideCsReq>, I>>(
    object: I
  ): FinishTutorialGuideCsReq {
    const message = createBaseFinishTutorialGuideCsReq();
    message.groupId = object.groupId ?? 0;
    return message;
  },
};

function createBaseFinishTutorialGuideScRsp(): FinishTutorialGuideScRsp {
  return { retcode: 0, tutorialGuide: undefined, reward: undefined };
}

export const FinishTutorialGuideScRsp = {
  encode(
    message: FinishTutorialGuideScRsp,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.retcode !== 0) {
      writer.uint32(8).uint32(message.retcode);
    }
    if (message.tutorialGuide !== undefined) {
      TutorialGuide.encode(
        message.tutorialGuide,
        writer.uint32(18).fork()
      ).ldelim();
    }
    if (message.reward !== undefined) {
      ItemList.encode(message.reward, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): FinishTutorialGuideScRsp {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFinishTutorialGuideScRsp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.retcode = reader.uint32();
          break;
        case 2:
          message.tutorialGuide = TutorialGuide.decode(reader, reader.uint32());
          break;
        case 3:
          message.reward = ItemList.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): FinishTutorialGuideScRsp {
    return {
      retcode: isSet(object.retcode) ? Number(object.retcode) : 0,
      tutorialGuide: isSet(object.tutorialGuide)
        ? TutorialGuide.fromJSON(object.tutorialGuide)
        : undefined,
      reward: isSet(object.reward)
        ? ItemList.fromJSON(object.reward)
        : undefined,
    };
  },

  toJSON(message: FinishTutorialGuideScRsp): unknown {
    const obj: any = {};
    message.retcode !== undefined &&
      (obj.retcode = Math.round(message.retcode));
    message.tutorialGuide !== undefined &&
      (obj.tutorialGuide = message.tutorialGuide
        ? TutorialGuide.toJSON(message.tutorialGuide)
        : undefined);
    message.reward !== undefined &&
      (obj.reward = message.reward
        ? ItemList.toJSON(message.reward)
        : undefined);
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<FinishTutorialGuideScRsp>, I>>(
    object: I
  ): FinishTutorialGuideScRsp {
    const message = createBaseFinishTutorialGuideScRsp();
    message.retcode = object.retcode ?? 0;
    message.tutorialGuide =
      object.tutorialGuide !== undefined && object.tutorialGuide !== null
        ? TutorialGuide.fromPartial(object.tutorialGuide)
        : undefined;
    message.reward =
      object.reward !== undefined && object.reward !== null
        ? ItemList.fromPartial(object.reward)
        : undefined;
    return message;
  },
};

function createBaseWaypoint(): Waypoint {
  return { id: 0, finishTimes: 0, isNew: false };
}

export const Waypoint = {
  encode(
    message: Waypoint,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.id !== 0) {
      writer.uint32(8).uint32(message.id);
    }
    if (message.finishTimes !== 0) {
      writer.uint32(16).uint32(message.finishTimes);
    }
    if (message.isNew === true) {
      writer.uint32(24).bool(message.isNew);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Waypoint {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWaypoint();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.id = reader.uint32();
          break;
        case 2:
          message.finishTimes = reader.uint32();
          break;
        case 3:
          message.isNew = reader.bool();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): Waypoint {
    return {
      id: isSet(object.id) ? Number(object.id) : 0,
      finishTimes: isSet(object.finishTimes) ? Number(object.finishTimes) : 0,
      isNew: isSet(object.isNew) ? Boolean(object.isNew) : false,
    };
  },

  toJSON(message: Waypoint): unknown {
    const obj: any = {};
    message.id !== undefined && (obj.id = Math.round(message.id));
    message.finishTimes !== undefined &&
      (obj.finishTimes = Math.round(message.finishTimes));
    message.isNew !== undefined && (obj.isNew = message.isNew);
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<Waypoint>, I>>(object: I): Waypoint {
    const message = createBaseWaypoint();
    message.id = object.id ?? 0;
    message.finishTimes = object.finishTimes ?? 0;
    message.isNew = object.isNew ?? false;
    return message;
  },
};

function createBaseChapterBrief(): ChapterBrief {
  return { id: 0, finishChallengeNum: 0, takenRewardIdList: [], isNew: false };
}

export const ChapterBrief = {
  encode(
    message: ChapterBrief,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.id !== 0) {
      writer.uint32(8).uint32(message.id);
    }
    if (message.finishChallengeNum !== 0) {
      writer.uint32(16).uint32(message.finishChallengeNum);
    }
    writer.uint32(26).fork();
    for (const v of message.takenRewardIdList) {
      writer.uint32(v);
    }
    writer.ldelim();
    if (message.isNew === true) {
      writer.uint32(32).bool(message.isNew);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ChapterBrief {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseChapterBrief();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.id = reader.uint32();
          break;
        case 2:
          message.finishChallengeNum = reader.uint32();
          break;
        case 3:
          if ((tag & 7) === 2) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.takenRewardIdList.push(reader.uint32());
            }
          } else {
            message.takenRewardIdList.push(reader.uint32());
          }
          break;
        case 4:
          message.isNew = reader.bool();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): ChapterBrief {
    return {
      id: isSet(object.id) ? Number(object.id) : 0,
      finishChallengeNum: isSet(object.finishChallengeNum)
        ? Number(object.finishChallengeNum)
        : 0,
      takenRewardIdList: Array.isArray(object?.takenRewardIdList)
        ? object.takenRewardIdList.map((e: any) => Number(e))
        : [],
      isNew: isSet(object.isNew) ? Boolean(object.isNew) : false,
    };
  },

  toJSON(message: ChapterBrief): unknown {
    const obj: any = {};
    message.id !== undefined && (obj.id = Math.round(message.id));
    message.finishChallengeNum !== undefined &&
      (obj.finishChallengeNum = Math.round(message.finishChallengeNum));
    if (message.takenRewardIdList) {
      obj.takenRewardIdList = message.takenRewardIdList.map((e) =>
        Math.round(e)
      );
    } else {
      obj.takenRewardIdList = [];
    }
    message.isNew !== undefined && (obj.isNew = message.isNew);
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<ChapterBrief>, I>>(
    object: I
  ): ChapterBrief {
    const message = createBaseChapterBrief();
    message.id = object.id ?? 0;
    message.finishChallengeNum = object.finishChallengeNum ?? 0;
    message.takenRewardIdList = object.takenRewardIdList?.map((e) => e) || [];
    message.isNew = object.isNew ?? false;
    return message;
  },
};

function createBaseChapter(): Chapter {
  return { briefInfo: undefined, waypointList: [] };
}

export const Chapter = {
  encode(
    message: Chapter,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.briefInfo !== undefined) {
      ChapterBrief.encode(message.briefInfo, writer.uint32(10).fork()).ldelim();
    }
    for (const v of message.waypointList) {
      Waypoint.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Chapter {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseChapter();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.briefInfo = ChapterBrief.decode(reader, reader.uint32());
          break;
        case 2:
          message.waypointList.push(Waypoint.decode(reader, reader.uint32()));
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): Chapter {
    return {
      briefInfo: isSet(object.briefInfo)
        ? ChapterBrief.fromJSON(object.briefInfo)
        : undefined,
      waypointList: Array.isArray(object?.waypointList)
        ? object.waypointList.map((e: any) => Waypoint.fromJSON(e))
        : [],
    };
  },

  toJSON(message: Chapter): unknown {
    const obj: any = {};
    message.briefInfo !== undefined &&
      (obj.briefInfo = message.briefInfo
        ? ChapterBrief.toJSON(message.briefInfo)
        : undefined);
    if (message.waypointList) {
      obj.waypointList = message.waypointList.map((e) =>
        e ? Waypoint.toJSON(e) : undefined
      );
    } else {
      obj.waypointList = [];
    }
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<Chapter>, I>>(object: I): Chapter {
    const message = createBaseChapter();
    message.briefInfo =
      object.briefInfo !== undefined && object.briefInfo !== null
        ? ChapterBrief.fromPartial(object.briefInfo)
        : undefined;
    message.waypointList =
      object.waypointList?.map((e) => Waypoint.fromPartial(e)) || [];
    return message;
  },
};

function createBaseGetWaypointCsReq(): GetWaypointCsReq {
  return { chapterId: 0 };
}

export const GetWaypointCsReq = {
  encode(
    message: GetWaypointCsReq,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.chapterId !== 0) {
      writer.uint32(8).uint32(message.chapterId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetWaypointCsReq {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetWaypointCsReq();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.chapterId = reader.uint32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): GetWaypointCsReq {
    return {
      chapterId: isSet(object.chapterId) ? Number(object.chapterId) : 0,
    };
  },

  toJSON(message: GetWaypointCsReq): unknown {
    const obj: any = {};
    message.chapterId !== undefined &&
      (obj.chapterId = Math.round(message.chapterId));
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<GetWaypointCsReq>, I>>(
    object: I
  ): GetWaypointCsReq {
    const message = createBaseGetWaypointCsReq();
    message.chapterId = object.chapterId ?? 0;
    return message;
  },
};

function createBaseGetWaypointScRsp(): GetWaypointScRsp {
  return { retcode: 0, chapter: undefined, curWaypointId: 0 };
}

export const GetWaypointScRsp = {
  encode(
    message: GetWaypointScRsp,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.retcode !== 0) {
      writer.uint32(8).uint32(message.retcode);
    }
    if (message.chapter !== undefined) {
      Chapter.encode(message.chapter, writer.uint32(18).fork()).ldelim();
    }
    if (message.curWaypointId !== 0) {
      writer.uint32(24).uint32(message.curWaypointId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetWaypointScRsp {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetWaypointScRsp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.retcode = reader.uint32();
          break;
        case 2:
          message.chapter = Chapter.decode(reader, reader.uint32());
          break;
        case 3:
          message.curWaypointId = reader.uint32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): GetWaypointScRsp {
    return {
      retcode: isSet(object.retcode) ? Number(object.retcode) : 0,
      chapter: isSet(object.chapter)
        ? Chapter.fromJSON(object.chapter)
        : undefined,
      curWaypointId: isSet(object.curWaypointId)
        ? Number(object.curWaypointId)
        : 0,
    };
  },

  toJSON(message: GetWaypointScRsp): unknown {
    const obj: any = {};
    message.retcode !== undefined &&
      (obj.retcode = Math.round(message.retcode));
    message.chapter !== undefined &&
      (obj.chapter = message.chapter
        ? Chapter.toJSON(message.chapter)
        : undefined);
    message.curWaypointId !== undefined &&
      (obj.curWaypointId = Math.round(message.curWaypointId));
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<GetWaypointScRsp>, I>>(
    object: I
  ): GetWaypointScRsp {
    const message = createBaseGetWaypointScRsp();
    message.retcode = object.retcode ?? 0;
    message.chapter =
      object.chapter !== undefined && object.chapter !== null
        ? Chapter.fromPartial(object.chapter)
        : undefined;
    message.curWaypointId = object.curWaypointId ?? 0;
    return message;
  },
};

function createBaseSetCurWaypointCsReq(): SetCurWaypointCsReq {
  return { waypointId: 0 };
}

export const SetCurWaypointCsReq = {
  encode(
    message: SetCurWaypointCsReq,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.waypointId !== 0) {
      writer.uint32(8).uint32(message.waypointId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SetCurWaypointCsReq {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSetCurWaypointCsReq();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.waypointId = reader.uint32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): SetCurWaypointCsReq {
    return {
      waypointId: isSet(object.waypointId) ? Number(object.waypointId) : 0,
    };
  },

  toJSON(message: SetCurWaypointCsReq): unknown {
    const obj: any = {};
    message.waypointId !== undefined &&
      (obj.waypointId = Math.round(message.waypointId));
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<SetCurWaypointCsReq>, I>>(
    object: I
  ): SetCurWaypointCsReq {
    const message = createBaseSetCurWaypointCsReq();
    message.waypointId = object.waypointId ?? 0;
    return message;
  },
};

function createBaseSetCurWaypointScRsp(): SetCurWaypointScRsp {
  return { retcode: 0, curWaypointId: 0 };
}

export const SetCurWaypointScRsp = {
  encode(
    message: SetCurWaypointScRsp,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.retcode !== 0) {
      writer.uint32(8).uint32(message.retcode);
    }
    if (message.curWaypointId !== 0) {
      writer.uint32(16).uint32(message.curWaypointId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SetCurWaypointScRsp {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSetCurWaypointScRsp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.retcode = reader.uint32();
          break;
        case 2:
          message.curWaypointId = reader.uint32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): SetCurWaypointScRsp {
    return {
      retcode: isSet(object.retcode) ? Number(object.retcode) : 0,
      curWaypointId: isSet(object.curWaypointId)
        ? Number(object.curWaypointId)
        : 0,
    };
  },

  toJSON(message: SetCurWaypointScRsp): unknown {
    const obj: any = {};
    message.retcode !== undefined &&
      (obj.retcode = Math.round(message.retcode));
    message.curWaypointId !== undefined &&
      (obj.curWaypointId = Math.round(message.curWaypointId));
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<SetCurWaypointScRsp>, I>>(
    object: I
  ): SetCurWaypointScRsp {
    const message = createBaseSetCurWaypointScRsp();
    message.retcode = object.retcode ?? 0;
    message.curWaypointId = object.curWaypointId ?? 0;
    return message;
  },
};

function createBaseGetChapterCsReq(): GetChapterCsReq {
  return {};
}

export const GetChapterCsReq = {
  encode(
    _: GetChapterCsReq,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetChapterCsReq {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetChapterCsReq();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(_: any): GetChapterCsReq {
    return {};
  },

  toJSON(_: GetChapterCsReq): unknown {
    const obj: any = {};
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<GetChapterCsReq>, I>>(
    _: I
  ): GetChapterCsReq {
    const message = createBaseGetChapterCsReq();
    return message;
  },
};

function createBaseGetChapterScRsp(): GetChapterScRsp {
  return { retcode: 0, chapterList: [], curWaypointId: 0 };
}

export const GetChapterScRsp = {
  encode(
    message: GetChapterScRsp,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.retcode !== 0) {
      writer.uint32(8).uint32(message.retcode);
    }
    for (const v of message.chapterList) {
      ChapterBrief.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    if (message.curWaypointId !== 0) {
      writer.uint32(24).uint32(message.curWaypointId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetChapterScRsp {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetChapterScRsp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.retcode = reader.uint32();
          break;
        case 2:
          message.chapterList.push(
            ChapterBrief.decode(reader, reader.uint32())
          );
          break;
        case 3:
          message.curWaypointId = reader.uint32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): GetChapterScRsp {
    return {
      retcode: isSet(object.retcode) ? Number(object.retcode) : 0,
      chapterList: Array.isArray(object?.chapterList)
        ? object.chapterList.map((e: any) => ChapterBrief.fromJSON(e))
        : [],
      curWaypointId: isSet(object.curWaypointId)
        ? Number(object.curWaypointId)
        : 0,
    };
  },

  toJSON(message: GetChapterScRsp): unknown {
    const obj: any = {};
    message.retcode !== undefined &&
      (obj.retcode = Math.round(message.retcode));
    if (message.chapterList) {
      obj.chapterList = message.chapterList.map((e) =>
        e ? ChapterBrief.toJSON(e) : undefined
      );
    } else {
      obj.chapterList = [];
    }
    message.curWaypointId !== undefined &&
      (obj.curWaypointId = Math.round(message.curWaypointId));
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<GetChapterScRsp>, I>>(
    object: I
  ): GetChapterScRsp {
    const message = createBaseGetChapterScRsp();
    message.retcode = object.retcode ?? 0;
    message.chapterList =
      object.chapterList?.map((e) => ChapterBrief.fromPartial(e)) || [];
    message.curWaypointId = object.curWaypointId ?? 0;
    return message;
  },
};

function createBaseWaypointShowNewCsNotify(): WaypointShowNewCsNotify {
  return { waypointId: 0, chapterId: 0 };
}

export const WaypointShowNewCsNotify = {
  encode(
    message: WaypointShowNewCsNotify,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.waypointId !== 0) {
      writer.uint32(8).uint32(message.waypointId);
    }
    if (message.chapterId !== 0) {
      writer.uint32(16).uint32(message.chapterId);
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): WaypointShowNewCsNotify {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWaypointShowNewCsNotify();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.waypointId = reader.uint32();
          break;
        case 2:
          message.chapterId = reader.uint32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): WaypointShowNewCsNotify {
    return {
      waypointId: isSet(object.waypointId) ? Number(object.waypointId) : 0,
      chapterId: isSet(object.chapterId) ? Number(object.chapterId) : 0,
    };
  },

  toJSON(message: WaypointShowNewCsNotify): unknown {
    const obj: any = {};
    message.waypointId !== undefined &&
      (obj.waypointId = Math.round(message.waypointId));
    message.chapterId !== undefined &&
      (obj.chapterId = Math.round(message.chapterId));
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<WaypointShowNewCsNotify>, I>>(
    object: I
  ): WaypointShowNewCsNotify {
    const message = createBaseWaypointShowNewCsNotify();
    message.waypointId = object.waypointId ?? 0;
    message.chapterId = object.chapterId ?? 0;
    return message;
  },
};

function createBaseTakeChapterRewardCsReq(): TakeChapterRewardCsReq {
  return { chapterId: 0, chapterRewardId: 0 };
}

export const TakeChapterRewardCsReq = {
  encode(
    message: TakeChapterRewardCsReq,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.chapterId !== 0) {
      writer.uint32(8).uint32(message.chapterId);
    }
    if (message.chapterRewardId !== 0) {
      writer.uint32(16).uint32(message.chapterRewardId);
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): TakeChapterRewardCsReq {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTakeChapterRewardCsReq();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.chapterId = reader.uint32();
          break;
        case 2:
          message.chapterRewardId = reader.uint32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): TakeChapterRewardCsReq {
    return {
      chapterId: isSet(object.chapterId) ? Number(object.chapterId) : 0,
      chapterRewardId: isSet(object.chapterRewardId)
        ? Number(object.chapterRewardId)
        : 0,
    };
  },

  toJSON(message: TakeChapterRewardCsReq): unknown {
    const obj: any = {};
    message.chapterId !== undefined &&
      (obj.chapterId = Math.round(message.chapterId));
    message.chapterRewardId !== undefined &&
      (obj.chapterRewardId = Math.round(message.chapterRewardId));
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<TakeChapterRewardCsReq>, I>>(
    object: I
  ): TakeChapterRewardCsReq {
    const message = createBaseTakeChapterRewardCsReq();
    message.chapterId = object.chapterId ?? 0;
    message.chapterRewardId = object.chapterRewardId ?? 0;
    return message;
  },
};

function createBaseTakeChapterRewardScRsp(): TakeChapterRewardScRsp {
  return { retcode: 0, chapterId: 0, chapterRewardId: 0 };
}

export const TakeChapterRewardScRsp = {
  encode(
    message: TakeChapterRewardScRsp,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.retcode !== 0) {
      writer.uint32(8).uint32(message.retcode);
    }
    if (message.chapterId !== 0) {
      writer.uint32(16).uint32(message.chapterId);
    }
    if (message.chapterRewardId !== 0) {
      writer.uint32(24).uint32(message.chapterRewardId);
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number
  ): TakeChapterRewardScRsp {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTakeChapterRewardScRsp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.retcode = reader.uint32();
          break;
        case 2:
          message.chapterId = reader.uint32();
          break;
        case 3:
          message.chapterRewardId = reader.uint32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): TakeChapterRewardScRsp {
    return {
      retcode: isSet(object.retcode) ? Number(object.retcode) : 0,
      chapterId: isSet(object.chapterId) ? Number(object.chapterId) : 0,
      chapterRewardId: isSet(object.chapterRewardId)
        ? Number(object.chapterRewardId)
        : 0,
    };
  },

  toJSON(message: TakeChapterRewardScRsp): unknown {
    const obj: any = {};
    message.retcode !== undefined &&
      (obj.retcode = Math.round(message.retcode));
    message.chapterId !== undefined &&
      (obj.chapterId = Math.round(message.chapterId));
    message.chapterRewardId !== undefined &&
      (obj.chapterRewardId = Math.round(message.chapterRewardId));
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<TakeChapterRewardScRsp>, I>>(
    object: I
  ): TakeChapterRewardScRsp {
    const message = createBaseTakeChapterRewardScRsp();
    message.retcode = object.retcode ?? 0;
    message.chapterId = object.chapterId ?? 0;
    message.chapterRewardId = object.chapterRewardId ?? 0;
    return message;
  },
};

function createBasePacketHead(): PacketHead {
  return {
    packetId: 0,
    signType: 0,
    sign: 0,
    userId: 0,
    srcAddr: 0,
    dstAddr: 0,
    dispatchType: 0,
    serverType: 0,
    dispatchKey: 0,
    userSessionId: 0,
    id: 0,
    coroutineId: 0,
    hopCnt: 0,
  };
}

export const PacketHead = {
  encode(
    message: PacketHead,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.packetId !== 0) {
      writer.uint32(8).uint32(message.packetId);
    }
    if (message.signType !== 0) {
      writer.uint32(16).uint32(message.signType);
    }
    if (message.sign !== 0) {
      writer.uint32(24).uint32(message.sign);
    }
    if (message.userId !== 0) {
      writer.uint32(32).uint32(message.userId);
    }
    if (message.srcAddr !== 0) {
      writer.uint32(40).uint32(message.srcAddr);
    }
    if (message.dstAddr !== 0) {
      writer.uint32(48).uint32(message.dstAddr);
    }
    if (message.dispatchType !== 0) {
      writer.uint32(56).uint32(message.dispatchType);
    }
    if (message.serverType !== 0) {
      writer.uint32(64).uint32(message.serverType);
    }
    if (message.dispatchKey !== 0) {
      writer.uint32(72).uint32(message.dispatchKey);
    }
    if (message.userSessionId !== 0) {
      writer.uint32(80).uint32(message.userSessionId);
    }
    if (message.id !== 0) {
      writer.uint32(88).uint32(message.id);
    }
    if (message.coroutineId !== 0) {
      writer.uint32(96).uint32(message.coroutineId);
    }
    if (message.hopCnt !== 0) {
      writer.uint32(104).uint32(message.hopCnt);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): PacketHead {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePacketHead();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.packetId = reader.uint32();
          break;
        case 2:
          message.signType = reader.uint32();
          break;
        case 3:
          message.sign = reader.uint32();
          break;
        case 4:
          message.userId = reader.uint32();
          break;
        case 5:
          message.srcAddr = reader.uint32();
          break;
        case 6:
          message.dstAddr = reader.uint32();
          break;
        case 7:
          message.dispatchType = reader.uint32();
          break;
        case 8:
          message.serverType = reader.uint32();
          break;
        case 9:
          message.dispatchKey = reader.uint32();
          break;
        case 10:
          message.userSessionId = reader.uint32();
          break;
        case 11:
          message.id = reader.uint32();
          break;
        case 12:
          message.coroutineId = reader.uint32();
          break;
        case 13:
          message.hopCnt = reader.uint32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },

  fromJSON(object: any): PacketHead {
    return {
      packetId: isSet(object.packetId) ? Number(object.packetId) : 0,
      signType: isSet(object.signType) ? Number(object.signType) : 0,
      sign: isSet(object.sign) ? Number(object.sign) : 0,
      userId: isSet(object.userId) ? Number(object.userId) : 0,
      srcAddr: isSet(object.srcAddr) ? Number(object.srcAddr) : 0,
      dstAddr: isSet(object.dstAddr) ? Number(object.dstAddr) : 0,
      dispatchType: isSet(object.dispatchType)
        ? Number(object.dispatchType)
        : 0,
      serverType: isSet(object.serverType) ? Number(object.serverType) : 0,
      dispatchKey: isSet(object.dispatchKey) ? Number(object.dispatchKey) : 0,
      userSessionId: isSet(object.userSessionId)
        ? Number(object.userSessionId)
        : 0,
      id: isSet(object.id) ? Number(object.id) : 0,
      coroutineId: isSet(object.coroutineId) ? Number(object.coroutineId) : 0,
      hopCnt: isSet(object.hopCnt) ? Number(object.hopCnt) : 0,
    };
  },

  toJSON(message: PacketHead): unknown {
    const obj: any = {};
    message.packetId !== undefined &&
      (obj.packetId = Math.round(message.packetId));
    message.signType !== undefined &&
      (obj.signType = Math.round(message.signType));
    message.sign !== undefined && (obj.sign = Math.round(message.sign));
    message.userId !== undefined && (obj.userId = Math.round(message.userId));
    message.srcAddr !== undefined &&
      (obj.srcAddr = Math.round(message.srcAddr));
    message.dstAddr !== undefined &&
      (obj.dstAddr = Math.round(message.dstAddr));
    message.dispatchType !== undefined &&
      (obj.dispatchType = Math.round(message.dispatchType));
    message.serverType !== undefined &&
      (obj.serverType = Math.round(message.serverType));
    message.dispatchKey !== undefined &&
      (obj.dispatchKey = Math.round(message.dispatchKey));
    message.userSessionId !== undefined &&
      (obj.userSessionId = Math.round(message.userSessionId));
    message.id !== undefined && (obj.id = Math.round(message.id));
    message.coroutineId !== undefined &&
      (obj.coroutineId = Math.round(message.coroutineId));
    message.hopCnt !== undefined && (obj.hopCnt = Math.round(message.hopCnt));
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<PacketHead>, I>>(
    object: I
  ): PacketHead {
    const message = createBasePacketHead();
    message.packetId = object.packetId ?? 0;
    message.signType = object.signType ?? 0;
    message.sign = object.sign ?? 0;
    message.userId = object.userId ?? 0;
    message.srcAddr = object.srcAddr ?? 0;
    message.dstAddr = object.dstAddr ?? 0;
    message.dispatchType = object.dispatchType ?? 0;
    message.serverType = object.serverType ?? 0;
    message.dispatchKey = object.dispatchKey ?? 0;
    message.userSessionId = object.userSessionId ?? 0;
    message.id = object.id ?? 0;
    message.coroutineId = object.coroutineId ?? 0;
    message.hopCnt = object.hopCnt ?? 0;
    return message;
  },
};

declare var self: any | undefined;
declare var window: any | undefined;
declare var global: any | undefined;
var globalThis: any = (() => {
  if (typeof globalThis !== "undefined") return globalThis;
  if (typeof self !== "undefined") return self;
  if (typeof window !== "undefined") return window;
  if (typeof global !== "undefined") return global;
  throw "Unable to locate global object";
})();

const atob: (b64: string) => string =
  globalThis.atob ||
  ((b64) => globalThis.Buffer.from(b64, "base64").toString("binary"));
function bytesFromBase64(b64: string): Uint8Array {
  const bin = atob(b64);
  const arr = new Uint8Array(bin.length);
  for (let i = 0; i < bin.length; ++i) {
    arr[i] = bin.charCodeAt(i);
  }
  return arr;
}

const btoa: (bin: string) => string =
  globalThis.btoa ||
  ((bin) => globalThis.Buffer.from(bin, "binary").toString("base64"));
function base64FromBytes(arr: Uint8Array): string {
  const bin: string[] = [];
  arr.forEach((byte) => {
    bin.push(String.fromCharCode(byte));
  });
  return btoa(bin.join(""));
}

type Builtin =
  | Date
  | Function
  | Uint8Array
  | string
  | number
  | boolean
  | undefined;

export type DeepPartial<T> = T extends Builtin
  ? T
  : T extends Array<infer U>
  ? Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U>
  ? ReadonlyArray<DeepPartial<U>>
  : T extends {}
  ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin
  ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & Record<
        Exclude<keyof I, KeysOfUnion<P>>,
        never
      >;

function longToNumber(long: Long): number {
  if (long.gt(Number.MAX_SAFE_INTEGER)) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  return long.toNumber();
}

if (_m0.util.Long !== Long) {
  _m0.util.Long = Long as any;
  _m0.configure();
}

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}
